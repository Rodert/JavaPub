---
title: 2025面试Go真题第一场
icon: lightbulb
author: Wang Shiyu
date: 2025-02-24
category:
  - 面试
  - go
tag:
  - 面试
  - go
---

前几天参加了一场面试，GoLang 后端工程师，他们直接给了我 10 道题，我留了一个截图。

![image-20250224133316933](https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202502241333053.png)

在看答案之前，你可以先简单做一下，下面我会对每个题目做一个说明。



@[toc]

### 1、golang map 是否并发安全?

Go 语言中的原生 `map` 并不是并发安全的。在多 goroutine 并发读写同一个 `map` 时，可能会导致数据竞争（race condition），从而引发程序崩溃。

可以用 `sync.Map`

Go标准库中的 `sync.Map` 是一个并发安全的map实现。它内部通过读写分离的策略来减少锁争用，适用于读多写少的场景。例如：

```go
var m sync.Map
m.Store("key", 42) // 存储键值对
value, ok := m.Load("key") // 获取值
m.Delete("key") // 删除键值对
```


### 2、协程泄漏的原因可能是什么？

在 Go 语言中，协程泄漏（Goroutine Leak）是指启动的协程无法正常退出，持续占用资源，最终可能导致程序崩溃或系统资源耗尽。

例如：

协程中存在无限循环，且没有退出条件。多个协程之间存在死锁，导致无法正常退出。总的来说就是协程没有释放、不受控制。


### 3、关于channel操作正确的可能是?

- 从已关闭的 channel 接收数据：是可以的。
- 向已关闭的 channel 发送数据：会导致运行时错误。
- 关闭已关闭的 channel：会导致运行时错误。


### 4、Golang字符串转成byte数组，会发生内存拷贝吗？

不会。GoLang 底层字符串就是用 byte 数组存储的。


### 5、请说一说Golang 的 GC可以怎么触发的?

自动触发：堆内存达到阈值、时间周期触发、系统监控触发。

手动触发：调用 `runtime.GC()` 。

### 6、Channel是同步的还是异步的 ?

无缓冲通道：同步。

```go
ch := make(chan int) // 创建一个无缓冲通道
```

有缓冲通道：异步。

```go
ch := make(chan int, 2) // 创建一个缓冲大小为2的通道
```


### 7、defer在return返回前还是返回后执行?

在函数真正返回给调用者之前执行。


### 8、什么情况下可能会发生内存逃逸 ?

在Go语言中，内存逃逸（Memory Escape）是指变量被分配到堆上，而不是栈上。这通常发生在Go编译器无法确定变量是否会在函数外部被引用时。以下是一些可能导致内存逃逸的常见场景：


1. 返回局部变量的指针

如果函数返回了局部变量的指针，该变量会被分配到堆上，因为其生命周期需要超出函数的作用域。

```go
func createPointer() *int {
    x := 42
    return &x // x逃逸到堆上
}
```

2. 闭包引用局部变量

如果闭包引用了局部变量，这些变量可能会被分配到堆上。

```go
func main() {
    f := func() int {
        x := 10
        return x
    }
    fmt.Println(f()) // f会导致x逃逸到堆上
}
```

还有多种情况，这个有一定难度，我会再单开一篇继续讲解。


### 9、Golang中有哪些方式可以安全读写共享变量?

- 使用互斥锁（sync.Mutex）
- 使用读写锁（sync.RWMutex）
- 使用原子操作（sync/atomic）
- 使用通道（channel）
- 使用sync.Map进行并发访问


### 10、Golang协程为什么比线程轻量?

- 调度开销更小，协程的切换由Go运行时管理，上下文切换的开销非常小，通常只需要几十纳秒。
- 协程的内存占用，Go协程：栈空间的初始大小非常小（通常为2KB），并且会根据需要动态扩展。这种动态栈分配机制使得协程的内存占用非常低。
- 协程的轻量级结构：Go协程的内部结构简单，主要包含协程状态、栈指针等信息，而操作系统线程需要维护更多的内核资源。
- Go运行时通过多路复用（Multiplexing）的方式将协程映射到少量的操作系统线程上，从而实现高效的并发执行。多路复用机制、高并发能力。
- 阻塞处理：协程阻塞时，运行时会自动切换到其他协程，充分利用CPU。
- Go协程：协程的创建和销毁由Go运行时管理，开销极小。创建和销毁协程的成本非常低，因为它们不需要操作系统内核的介入。



