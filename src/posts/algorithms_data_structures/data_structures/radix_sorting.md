---
title: 基数排序就是这么容易
icon: lightbulb
author: Wang Shiyu
date: 2022-04-21
category:
  - 数据结构
  - 排序
tag:
  - 数据结构
  - 排序
---



## 前言


> 欢迎关注公众号，白嫖原创PDF，也可以催更，微信搜：JavaPub

[toc]

## 1.基数排序
### 1.1.对比

> 前面讲了计数排序、桶排序，那么它们有什么不同

**基数排序 vs 计数排序 vs 桶排序**

这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

- 基数排序：根据键值的每位数字来分配桶；
- 计数排序：每个桶只存储单一键值；
- 桶排序：每个桶存储一定范围的数值；

### 1.2.基数排序

`百度百科：`

> 基数排序（radix sort）属于 “分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些 “桶” 中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为 **O (nlog(r)m)**，其中 `r` 为所采取的基数，而 `m` 为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。

### 1.3.特点

- **时间复杂度**为 **O (nlog(r)m)**，其中 `r` 为所采取的基数，而 `m` 为堆数。

- **基数排序法**是属于**稳定性**的排序。

## 2.原理
### 2.1.实现原理

基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机(Tabulation Machine)上的贡献。它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。

### 2.2.步骤

> `LSD` 基数排序动图演示



![](https://static01.imgkr.com/temp/bf8fc13b22d144c0857387baab7eb42f.gif)





> 下面步骤介绍布局虽然不好看，但是非常有助于理解。


- 第一步

以 `LSD` 为例，假设原来有一串数值如下所示：

`73, 22, 93, 43, 55, 14, 28, 65, 39, 81`

首先根据个位数的数值，在走访数值时将它们分配至编号 0 到 9 的桶子中：
```
0
1 81
2 22
3 73 93 43
4 14
5 55 65
6
7
8 28
9 39
```
- 第二步

接下来将这些桶子中的数值重新串接起来，成为以下的数列：

`81, 22, 73, 93, 43, 14, 55, 65, 28, 39`

接着再进行一次分配，这次是根据十位数来分配：
```
0
1 14
2 22 28
3 39
4 43
5 55
6 65
7 73
8 81
9 93
```
- 第三步

接下来将这些桶子中的数值重新串接起来，成为以下的数列：

`14, 22, 28, 39, 43, 55, 65, 73, 81, 93`

这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。


> LSD 的基数排序适用于位数小的数列，如果位数多的话，使用 MSD 的效率会比较好。MSD 的方式与 LSD 相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。


## 3.代码
### 3.1.Java 版

> 代码基于 Java 语言

```java
package com.rodert.springbootes.test;

import java.util.Arrays;

/**
 * @author JavaPub rodert
 * @date 2020/6/28 20:46
 * @description
 */
public class RadixSort {

    public static void sort(int[] number, int d) //d表示最大的数有多少位
    {
        int k = 0;
        int n = 1;
        int m = 1; //控制键值排序依据在哪一位
        int[][] temp = new int[10][number.length]; //数组的第一维表示可能的余数0-9
        int[] order = new int[10]; //数组order[i]用来表示该位是i的数的个数
        while (m <= d) {
            for (int value : number) {
                int lsd = ((value / n) % 10);
                temp[lsd][order[lsd]] = value;
                order[lsd]++;
            }
            for (int i = 0; i < 10; i++) {
                if (order[i] != 0)
                    for (int j = 0; j < order[i]; j++) {
                        number[k] = temp[i][j];
                        k++;
                    }
                order[i] = 0;
            }
            n *= 10;
            k = 0;
            m++;
        }
    }

    public static void main(String[] args) {
        int[] data = {73, 22, 93, 43, 55, 14, 28, 65, 39, 81, 33, 100};
        RadixSort.sort(data, 3);
        System.out.println(Arrays.toString(data));
    }
}
```



返回结果：
> [14, 22, 28, 33, 39, 43, 55, 65, 73, 81, 93, 100]

```

> 声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。

> 本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。
> 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub

> 有任何问题都可以来谈谈 ！
