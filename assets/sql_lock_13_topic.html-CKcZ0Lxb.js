import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,e as l}from"./app-yODpLvS5.js";const n={},e=l(`<blockquote><p>数据库13问，谁能顶得住 |</p></blockquote><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>过完这个节，就要进入金银季，准备了 13 道数据库锁面试题，一定用得上。</p><p>锁的问题归更到底就是资源竞争导致的，而并发场景一定会发生资源竞争，所以锁的问题，也是并发场景下必问的问题。理解好锁的原理，在编程中提升设计能力也非常重要。</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271854966.png" alt="汇总xmind" tabindex="0" loading="lazy"><figcaption>汇总xmind</figcaption></figure><ul><li>作者：</li><li>感谢每一个支持： <a href="https://github.com/Rodert/JavaPub" target="_blank" rel="noopener noreferrer">github</a></li></ul><hr><h3 id="_1-为什么要在数据库中加锁" tabindex="-1"><a class="header-anchor" href="#_1-为什么要在数据库中加锁"><span>1. 为什么要在数据库中加锁</span></a></h3><blockquote><p>就像我们生活中，每天出门都要给房子上锁，这时有人来拜访看到已上锁，就知道家里没人。</p></blockquote><p>我们的系统绝大多不是单机系统，都会从在资源的竞争（并发控制）和数据一致性的场景，比如：俩个人同时买一个商品、但是商品只剩下一件，这时就需要锁来保证谁拥有这件商品。锁是保证数据库事务四个特性，原子性、一致性、隔离性和持久性（ACID）的关键性技术之一。</p><p>无锁的情况下就可能出现，如脏读、不可重复读和幻读等。</p><h3 id="_2-innodb-中有哪些锁" tabindex="-1"><a class="header-anchor" href="#_2-innodb-中有哪些锁"><span>2. InnoDB 中有哪些锁</span></a></h3><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271849204.png" alt="image-20240527184946810" tabindex="0" loading="lazy"><figcaption>image-20240527184946810</figcaption></figure><h4 id="_2-1-共享锁-排它锁" tabindex="-1"><a class="header-anchor" href="#_2-1-共享锁-排它锁"><span>2.1 共享锁/排它锁</span></a></h4><p>共享锁（S锁）和排它锁（X锁）是最基础的锁类型，用于操作对数据的读取和写入。</p><p>通过名字，我们也可以看出这两个锁的作用。当事务要读取一条记录时，先获取该记录的S锁；当事务要改动一条记录时，先获取该记录的X锁。</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271527069.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>通过这个图可以知道，什么情况下可以获得 S 锁和 X 锁。可以看到，只有都是共享锁时，才可以同时在一行记录加锁。</p><p><strong>例子：</strong></p><p>加共享锁，共享锁允许其他事务读取这些行，但不允许其他事务修改或删除这些行，直到当前事务结束。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> ... LOCK </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">IN</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> SHARE MODE; 加共享锁</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">---</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> LOCK </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">IN</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> SHARE MODE;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>加排他锁，相当于是独占记录。当一个事务对某行数据加上排他锁后，其他事务既不能读取也不能修改这些数据，直到持有排他锁的事务结束。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> ... </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">FOR</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; 加排他锁</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">---</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> condition </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">FOR</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 执行一些更新操作</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> column </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> condition;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-2-行锁-临键锁" tabindex="-1"><a class="header-anchor" href="#_2-2-行锁-临键锁"><span>2.2 行锁/临键锁</span></a></h4><p><strong>行锁</strong></p><p>行锁通常在执行涉及单个行的操作时自动应用，例如 SELECT 语句中的 FOR UPDATE 子句，这会为查询结果中的每行添加排他锁。也就是上面说到的例子。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 在此事务中，id为1的行将被锁定，其他事务不能修改或读取这行</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>临键锁</strong></p><p>临键锁结合了记录锁和间隙锁，用于行级锁定和范围查询，防止幻读。我们一般无法判断是行锁还是临键锁，都是行锁的形式，由存储引擎在执行查询时自动管理决定的。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">BETWEEN</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 这将锁定id在1到10之间的所有行，以及可能的下一个键值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-3-意向锁" tabindex="-1"><a class="header-anchor" href="#_2-3-意向锁"><span>2.3 意向锁</span></a></h4><p>意向锁是针对多粒度锁定协议的系统，比如行粒度锁、表粒度锁。当一个事务打算在某个细粒度上请求锁（共享锁|排他锁），它会首先在更粗力度上设置意向锁。</p><p><strong>意向共识锁 - 简称 IS</strong></p><p><strong>意向排他锁 - 简称 IX</strong></p><p>例子：如果一个事务要对一张表加排他锁，它会先在表级别加上意向排他锁，然后对表中的特定行加排他锁。</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271837190.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="_2-4-间隙锁-插入意向锁" tabindex="-1"><a class="header-anchor" href="#_2-4-间隙锁-插入意向锁"><span>2.4 间隙锁/插入意向锁</span></a></h4><p>间隙锁和插入意向锁针对实现了多版本并发控制（MVCC）的系统中，如 MySQL 的 InnoDB 存储引擎。</p><p><strong>间隙锁（Gap Locks）：</strong></p><p>间隙锁是一种行锁，它锁定一个范围内的间隙，但不锁定该范围内的任何具体行。间隙锁主要用于防止其他事务在这个间隙中插入新的行，从而维护数据的顺序性和一致性。 间隙锁通常在执行范围查询并加上共享或排他锁时自动应用。例如，如果一个事务执行了 <code>SELECT ... WHERE index_column BETWEEN x AND y LOCK IN SHARE MODE</code> ，InnoDB 会在索引列 x 和 y 之间的间隙上设置间隙锁，防止其他事务在这个范围内插入新行。</p><p>示例：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">BETWEEN</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> LOCK </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">IN</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> SHARE MODE;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 在id为10到20的范围内设置间隙锁</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>插入意向锁（Insert Intention Locks）：</strong></p><p>插入意向锁是一种特殊的间隙锁，它表明一个事务有意向在某个间隙中插入新行。 当一个事务想要在一个已经被其他事务加上间隙锁的范围内插入新行时，它会首先在该范围内设置一个插入意向锁。</p><p>插入意向锁允许多个事务保留在特定间隙中插入新行的意图，而不直接与间隙锁冲突。这样，当间隙锁被释放时，持有插入意向锁的事务可以继续执行插入操作。</p><p>示例：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 假设另一个事务已经在id为10到20的范围内设置了间隙锁</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 15</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 这将设置一个插入意向锁，表明事务有意向在id为10到20的范围内插入新行</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-5-自增锁" tabindex="-1"><a class="header-anchor" href="#_2-5-自增锁"><span>2.5 自增锁</span></a></h4><p>自增锁（Auto-Increment Locks，简称：AI Locks）是MySQL数据库中InnoDB存储引擎特有的一种锁机制，它与自增字段（AUTO_INCREMENT）相关联。<code>AUTO_INCREMENT</code> 你一定不陌生，我们在建表时多数情况都会让主键 id 自增来生成唯一序列。</p><p>当一个表中包含自增字段时，InnoDB 会使用自增锁来确保在并发环境下，自增字段生成的值是唯一的，并且连续的。</p><p>示例：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">INSERT INTO</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> table_name (auto_increment_column, other_columns) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">VALUES</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;value1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- InnoDB分配自增值并锁定它</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 自增锁在事务提交时释放</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，<code>auto_increment_column</code> 是一个自增字段。当事务提交时，InnoDB 会分配一个新的自增值给插入的行，并在事务提交时释放自增锁。</p><h4 id="_2-6-外键锁" tabindex="-1"><a class="header-anchor" href="#_2-6-外键锁"><span>2.6 外键锁</span></a></h4><blockquote><p>外键（Foreign Key）是一种数据库完整性约束，它用于维护两个表之间的链接，并确保引用的数据的完整性。</p></blockquote><p>外键锁顾名思义就是针对外键的。外键锁并不是一个标准的锁类型，而是指与外键约束相关的锁定行为，这些行为确保在执行涉及外键的插入或更新操作时，数据库的完整性不被破坏。</p><p>外键锁这个术语并不是用来描述一种特定的锁类型，而是用来描述与外键约束相关的锁定行为。数据库系统会自动处理这些锁定，以确保数据的完整性和一致性。</p><h4 id="_2-7-表锁-页锁" tabindex="-1"><a class="header-anchor" href="#_2-7-表锁-页锁"><span>2.7 表锁/页锁</span></a></h4><p>表锁和页锁是两种不同粒度的锁，</p><p><strong>表锁（Table Locks）</strong></p><p>表锁是锁定整个表的锁，这意味着在锁定期间，没有其他事务可以对这张表进行读写操作。表锁通常用于批量操作，如全表扫描或全表更新，以及在不需要频繁锁定和解锁单个行的场景中。</p><p>特点：</p><ul><li>粒度较大：表锁影响整个表的所有数据，因此粒度较大。</li><li>冲突较少：由于锁定了整个表，减少了锁冲突的可能性，但在高并发环境下可能导致其他事务长时间等待。</li><li>使用场景：适用于全表操作，如全表备份或全表删除。</li></ul><p>示例：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">LOCK TABLES table_name WRITE;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 在此期间，其他事务不能访问table_name</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">UNLOCK</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> TABLES;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>页锁（Page Locks）</strong></p><p>页锁是锁定数据库中的一个“页”的锁。在许多数据库系统中，数据是按页存储的，每页包含一定数量的行。页锁允许多个事务同时访问不同的页，从而提供比表锁更细粒度的并发控制。</p><p>特点：</p><ul><li>粒度较小：页锁锁定的是数据页，而不是整个表，因此粒度较小。</li><li>并发性更好：允许多个事务并发访问不同的数据页，提高了并发性能。</li><li>使用场景：适用于需要较高并发性能的场景，尤其是在大型表上进行部分数据的读写操作。</li></ul><p>注意：页锁通常由数据库管理系统自动管理，不需要用户显式操作。例如，在InnoDB存储引擎中，虽然页锁不是用户可以直接控制的锁类型，但InnoDB会根据需要自动在页级别上应用锁。</p><blockquote><p>总结： 粒度：行锁 &lt; 页锁 &lt; 表锁（从细到粗）。</p></blockquote><h3 id="_3-什么是死锁" tabindex="-1"><a class="header-anchor" href="#_3-什么是死锁"><span>3. 什么是死锁</span></a></h3><p>死锁是在事务数据库中会发生的一种特殊现象，多个事务在执行过程中，相互等待对方持有的资源，导致这些事务都无法继续执行。简单来说，就是两个或多个事务陷入了一个循环等待的状态，每个事务都在等待其他事务释放资源。</p><p>比如这个蛇和青蛙互不放手。</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271658523.jpeg" alt="来源网络-互不放手" tabindex="0" loading="lazy"><figcaption>来源网络-互不放手</figcaption></figure><p>死锁通常由以下四种情况同时出现时引起：</p><ol><li><strong>互斥条件</strong>（Mutual Exclusion）： <ul><li>指某些资源（如数据库中的记录）一次只能被一个事务占用。</li></ul></li><li><strong>持有和等待条件</strong>（Hold and Wait）： <ul><li>指一个事务至少持有一个资源，并在等待获取其他事务持有的资源。</li></ul></li><li><strong>不可剥夺条件</strong>（No Preemption）： <ul><li>指已经分配给一个事务的资源，在事务使用完毕之前，不能被强行剥夺。</li></ul></li><li><strong>循环等待条件</strong>（Circular Wait）： <ul><li>指事务之间形成了一个闭环，每个事务都在等待下一个事务所持有的资源。</li></ul></li></ol><h3 id="_4-行锁、表锁、页面锁有什么区别" tabindex="-1"><a class="header-anchor" href="#_4-行锁、表锁、页面锁有什么区别"><span>4. 行锁、表锁、页面锁有什么区别</span></a></h3><p>从每种锁的锁粒度、并发性、冲突和使用场景几个角度来区分。</p><h3 id="行锁-row-locks" tabindex="-1"><a class="header-anchor" href="#行锁-row-locks"><span>行锁（Row Locks）</span></a></h3><ul><li><strong>锁粒度</strong>：行锁是锁定表中的单行或多行。</li><li><strong>并发性</strong>：行锁允许多个事务同时访问表中的不同行，从而提供较高的并发性。</li><li><strong>冲突</strong>：行锁可能导致更多的锁冲突，因为它们需要在更细的粒度上管理锁。</li><li><strong>使用场景</strong>：适用于需要高并发读写操作的场景，尤其是在表中只有少数行会被访问时。</li><li><strong>示例</strong>：在InnoDB存储引擎中，使用<code>SELECT ... FOR UPDATE</code>可以显式地对行加排他锁。</li></ul><h3 id="表锁-table-locks" tabindex="-1"><a class="header-anchor" href="#表锁-table-locks"><span>表锁（Table Locks）</span></a></h3><ul><li><strong>锁粒度</strong>：表锁是锁定整个表。</li><li><strong>并发性</strong>：表锁期间，其他事务不能对表进行任何读写操作，直到锁被释放，因此并发性较低。</li><li><strong>冲突</strong>：由于锁定了整个表，减少了锁冲突的可能性，但可能导致其他事务长时间等待。</li><li><strong>使用场景</strong>：适用于需要对整个表执行批量操作的场景，如全表备份或全表删除。</li><li><strong>示例</strong>：在MySQL中，可以使用<code>LOCK TABLES</code>和<code>UNLOCK TABLES</code>语句显式地对表加锁和解锁。</li></ul><h3 id="页锁-page-locks" tabindex="-1"><a class="header-anchor" href="#页锁-page-locks"><span>页锁（Page Locks）</span></a></h3><ul><li><strong>锁粒度</strong>：页锁是锁定数据库中的一个数据页，每个页包含多行数据。</li><li><strong>并发性</strong>：页锁允许多个事务同时访问不同的数据页，提高了并发性。</li><li><strong>冲突</strong>：相比于行锁，页锁可能导致较少的锁冲突，但仍然存在一定的冲突可能。</li><li><strong>使用场景</strong>：适用于需要较高并发性能的场景，尤其是在大型表上进行部分数据的读写操作。</li><li><strong>示例</strong>：页锁通常由数据库管理系统自动管理，不需要用户显式操作。例如，在PostgreSQL中，页锁可以用于控制对表中特定数据页的访问。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li><strong>粒度</strong>：行锁 &lt; 页锁 &lt; 表锁（从细到粗）。</li><li><strong>并发性</strong>：行锁提供最高的并发性，页锁次之，表锁最低。</li><li><strong>冲突</strong>：行锁可能导致最多的锁冲突，页锁和表锁的冲突较少。</li><li><strong>使用场景</strong>：行锁适用于高并发读写，表锁适用于全表操作，页锁适用于需要较高并发的场景。</li></ul><p>区分选择不同的锁，正确使用锁类型对于优化数据库性能、确保数据一致性至关重要。</p><h3 id="_5-乐观锁和悲观锁有什么区别-它们什么场景会用" tabindex="-1"><a class="header-anchor" href="#_5-乐观锁和悲观锁有什么区别-它们什么场景会用"><span>5. 乐观锁和悲观锁有什么区别，它们什么场景会用</span></a></h3><h3 id="乐观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁"><span>乐观锁</span></a></h3><p>乐观锁基于这样的假设：多个事务在同一时间对同一数据对象进行操作的可能性很小，因此它允许多个事务同时进行，仅在事务提交时检查是否有其他事务对数据进行了修改。</p><p><strong>特点</strong>：</p><ul><li><strong>无锁</strong>：乐观锁通常不使用数据库的锁定机制，而是通过其他方式（如时间戳、版本号）来确保数据一致性。</li><li><strong>性能</strong>：在冲突较少的情况下，乐观锁可以提供更好的性能，因为它允许高并发。</li><li><strong>冲突检测</strong>：在事务提交时检测冲突，如果检测到冲突，事务将被回滚。</li></ul><p><strong>实现方式</strong>：</p><ul><li><strong>版本号</strong>：在数据表中添加一个版本号字段或时间戳字段。事务开始时记录版本号，提交时检查版本号是否发生变化，如果变化了，则表示有冲突。</li><li><strong>时间戳</strong>：使用时间戳来控制事务的顺序，如果检测到时间戳冲突，则回滚事务。</li></ul><p><strong>适用场景</strong>：</p><ul><li><strong>写冲突较少</strong>：适用于写操作不频繁或者写冲突可能性较低的场景。</li><li><strong>读多写少</strong>：适用于读操作远多于写操作的环境。</li><li><strong>高并发</strong>：需要支持高并发访问的系统。</li></ul><h3 id="悲观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁"><span>悲观锁</span></a></h3><p>悲观锁基于这样的假设：多个事务对同一数据对象的并发操作会产生冲突，因此它在事务开始时就对数据对象加锁，直到事务结束才释放锁。</p><p><strong>特点</strong>：</p><ul><li><strong>锁定</strong>：悲观锁通过数据库的锁定机制来确保数据一致性，如行锁或表锁。</li><li><strong>性能</strong>：在高冲突环境下，悲观锁可能导致更多的等待和锁竞争，从而影响性能。</li><li><strong>预防冲突</strong>：通过锁定机制预防冲突，而不是检测冲突。</li></ul><p><strong>实现方式</strong>：</p><ul><li><strong>显式锁定</strong>：使用数据库的锁定命令（如<code>SELECT ... FOR UPDATE</code>）来显式地锁定需要的资源。</li><li><strong>隐式锁定</strong>：通过数据库事务的隔离级别隐式地实现锁定。</li></ul><p><strong>适用场景</strong>：</p><ul><li><strong>写冲突较多</strong>：适用于写操作频繁或者写冲突可能性较高的场景。</li><li><strong>写多读少</strong>：适用于写操作多于读操作的环境。</li><li><strong>数据一致性要求高</strong>：需要严格保证数据一致性的场合。</li></ul><h3 id="_6-select-for-update-加了行锁还是表锁" tabindex="-1"><a class="header-anchor" href="#_6-select-for-update-加了行锁还是表锁"><span>6. select...for update 加了行锁还是表锁</span></a></h3><p>行锁。</p><p>这个在上面的例子中有提到过，这个 SQL 会锁定查询到的行，行锁的粒度更小、可以提高并发性。</p><p><strong>示例</strong>：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> column_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;some_value&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 在此事务中，column_name 等于 &#39;some_value&#39; 的行将被加上排他锁</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，只有 <code>column_name</code> 等于 <code>&#39;some_value&#39;</code> 的行会被锁定，其他行仍然可以被其他事务访问。</p><h3 id="_7-如何通过-sql-手动给-mysql-的某个表加锁" tabindex="-1"><a class="header-anchor" href="#_7-如何通过-sql-手动给-mysql-的某个表加锁"><span>7. 如何通过 SQL 手动给 MySQL 的某个表加锁</span></a></h3><p>手动加锁也就是显示的加表锁。</p><p>MySQL提供了<code>LOCK TABLES</code>语句来显式地锁定一个或多个表。这可以用来阻止其他会话访问这些表。</p><p>加写锁（排他锁）示例：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">LOCK TABLES table_name WRITE;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>加读锁（共享锁）示例：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">LOCK TABLES table_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">READ</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>锁定多个表的示例：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">复制</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">LOCK TABLES table1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">READ</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, table2 WRITE;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_8-高并发场景下-如何修改同一条数据" tabindex="-1"><a class="header-anchor" href="#_8-高并发场景下-如何修改同一条数据"><span>8. 高并发场景下，如何修改同一条数据</span></a></h3><p>这个要根据业务场景来选择锁。比如读多写少场景下，可以使用乐观锁，写冲突较多时可以使用悲观锁。</p><p>例子：</p><ol><li><p><strong>使用乐观锁</strong>： 乐观锁适用于写冲突较少的场景。通过在数据表中添加一个版本号或时间戳字段来实现。每次更新数据时，检查版本号或时间戳是否与读取时的值相同，如果相同，则进行更新并增加版本号或更新时间戳；如果不同，则放弃更新，提示用户冲突发生。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> version_column, data_column </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 检查并更新</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> data_column </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;new_value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, version_column </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> version_column </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> version_column </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> read_version;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>使用悲观锁</strong>： 悲观锁适用于写冲突较多的场景。通过在事务开始时锁定需要修改的数据行，直到事务结束才释放锁。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">复制</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 进行更新操作</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> data_column </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;new_value&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="_9-mysql-中的锁升级是什么" tabindex="-1"><a class="header-anchor" href="#_9-mysql-中的锁升级是什么"><span>9. MySQL 中的锁升级是什么</span></a></h3><p>锁升级指细粒度锁升级为粗粒度锁，如行锁升级为表锁。锁升级通常发生在一下情况：</p><ol><li><strong>锁竞争</strong>： 当一个事务持有多个行锁，并且这些行锁的数量超过了系统预设的阈值时，数据库系统可能会将这些行锁升级为表锁，以减少系统开销和提高性能。</li><li><strong>锁定的行数</strong>： 如果锁定的行数占表中行数的很大一部分，数据库系统可能会认为整个表都被锁定了，因此会升级为表锁。</li><li><strong>锁定的页数</strong>： 类似地，如果锁定的页（数据库中数据的存储单位）数量占表中总页数的很大一部分，也可能触发锁升级。</li><li><strong>系统配置</strong>： MySQL的配置参数（如<code>innodb_table_locks</code>）会影响是否启用表锁以及何时进行锁升级。</li></ol><p>锁升级的优点包括：</p><ul><li><strong>减少系统开销</strong>：管理大量行锁的开销可能很大，升级为表锁可以简化锁管理。</li><li><strong>提高性能</strong>：在某些情况下，锁升级可以减少死锁的可能性，并提高系统的整体性能。</li></ul><p>锁升级的缺点包括：</p><ul><li><strong>降低并发性</strong>：表锁是一种粗粒度的锁，会阻止其他事务访问整个表，从而降低并发性。</li><li><strong>增加等待时间</strong>：其他事务可能需要等待表锁释放，增加了它们的等待时间。</li></ul><blockquote><p>锁升级是数据库系统自动进行的，不需要用户干预。</p></blockquote><h3 id="_10-mysql-rr-的隔离级别下加锁规则" tabindex="-1"><a class="header-anchor" href="#_10-mysql-rr-的隔离级别下加锁规则"><span>10. MySql RR 的隔离级别下加锁规则</span></a></h3><blockquote><p>重点</p></blockquote><p>在MySQL的可重复读（Repeatable Read，简称RR）隔离级别下，InnoDB存储引擎采用了一系列加锁规则来保证事务的隔离性。</p><ol><li><strong>行锁</strong>： <ul><li>对于索引项的查询，如果能够定位到具体的索引记录，无论是主键索引还是二级索引，InnoDB会在这些具体的索引项上加上行锁（Record Lock）。</li></ul></li><li><strong>间隙锁</strong>： <ul><li>如果查询条件的结果为空，即没有命中任何索引，那么在RR隔离级别下，InnoDB会在相关索引的间隙上加上间隙锁（Gap Lock）。</li></ul></li><li><strong>Next-Key Lock</strong>： <ul><li>对于范围查询，InnoDB会使用Next-Key Lock，它是行锁和间隙锁的组合，用于锁定一个区间内的所有行以及区间的边界值。</li></ul></li><li><strong>快照读与当前读</strong>： <ul><li>在RR隔离级别下，普通的SELECT语句是快照读（Snapshot Read），不加锁；但是当使用<code>SELECT ... FOR UPDATE</code>或<code>SELECT ... LOCK IN SHARE MODE</code>时，会变成当前读（Current Read），并加上相应的行锁或共享锁。</li></ul></li><li><strong>幻读</strong>： <ul><li>RR隔离级别旨在防止幻读现象，即在一个事务中，两次读同一个范围的时候，第二次读到之前不存在的行。为了防止幻读，InnoDB会在查询涉及的范围上加上足够的间隙锁。</li></ul></li><li><strong>锁升级</strong>： <ul><li>在RR隔离级别下，如果锁定的行数过多，InnoDB可能会将行锁升级为表锁，尽管这种行为在默认配置下不常见。</li></ul></li><li><strong>自增锁</strong>： <ul><li>对于自增字段，InnoDB可能会使用自增锁（Auto-Increment Locks）来保证自增值的唯一性和连续性。</li></ul></li><li><strong>意向锁</strong>： <ul><li>在多粒度锁定协议中，InnoDB使用意向锁（Intention Locks），如意向共享锁（Intention Shared Locks）和意向排他锁（Intention Exclusive Locks），以表明事务将在更细粒度上请求锁。</li></ul></li><li><strong>锁的兼容性</strong>： <ul><li>共享锁（S锁）之间是兼容的，但排他锁（X锁）与任何其他类型的锁都不兼容。</li></ul></li></ol><p>这些加锁规则共同作用，以确保在RR隔离级别下，事务可以看到一致的快照数据，并防止其他事务的干扰，直到事务完成。</p><h3 id="_11-如何使用分布式锁" tabindex="-1"><a class="header-anchor" href="#_11-如何使用分布式锁"><span>11. 如何使用分布式锁</span></a></h3><p>实现分布式锁有以下几种方式：</p><h4 id="_11-1-基于唯一索引实现" tabindex="-1"><a class="header-anchor" href="#_11-1-基于唯一索引实现"><span>11.1. 基于唯一索引实现</span></a></h4><p>这种方法通过尝试向一个表中插入具有唯一索引的记录来实现锁的获取。如果插入成功，则认为获取了锁；如果插入失败（由于唯一键冲突），则认为获取锁失败。</p><p><strong>创建锁表</strong>：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> \`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">t_lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">\` (</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  \`lock_key\`</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> varchar</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> COMMENT </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;锁的标识&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  PRIMARY KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">\`lock_key\`</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) ENGINE</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">InnoDB </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">DEFAULT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> CHARSET</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">utf8mb4 COMMENT</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;分布式锁&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>获取锁</strong>：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">insert ignore into</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> t_lock(lock_key) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;my_lock_key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用<code>insert ignore</code>来避免违反唯一约束时产生的错误，如果返回值大于0，则认为成功获取了锁。</p><p><strong>释放锁</strong>：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">delete</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> t_lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> lock_key </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;my_lock_key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当操作完成时，删除记录以释放锁。</p><h4 id="_11-2-基于排他锁-select-for-update-实现" tabindex="-1"><a class="header-anchor" href="#_11-2-基于排他锁-select-for-update-实现"><span>11.2. 基于排他锁（<code>SELECT ... FOR UPDATE</code>）实现</span></a></h4><p>这种方法通过在<code>SELECT</code>语句后增加<code>FOR UPDATE</code>来获取排他锁，确保某条记录在事务中被锁定，其他事务无法再获取到相同的排他锁。</p><p><strong>获取锁</strong>：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> some_table </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> some_column </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;some_value&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样就会在满足条件的行上加上排他锁。</p><p><strong>释放锁</strong>： 排他锁会在事务结束时释放，无论是通过<code>COMMIT</code>提交事务还是通过<code>ROLLBACK</code>回滚事务。</p><h4 id="_11-3-基于乐观锁" tabindex="-1"><a class="header-anchor" href="#_11-3-基于乐观锁"><span>11.3. 基于乐观锁</span></a></h4><p>乐观锁通常通过在表中添加一个版本号或时间戳字段来实现。每次更新记录时，检查版本号或时间戳是否与读取时的值相同，如果相同则进行更新，否则放弃更新。</p><p><strong>获取锁</strong>： 使用普通的<code>SELECT</code>语句读取数据及版本号。</p><p><strong>更新操作</strong>：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> some_table </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> column1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> value1, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">version</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> version</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> some_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">AND</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> version</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> some_version;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>只有当版本号匹配时才更新，并增加版本号。</p><p><strong>释放锁</strong>： 乐观锁通常不需要显式释放，因为它不依赖于数据库的锁定机制。</p><h3 id="_12-如何检测死锁" tabindex="-1"><a class="header-anchor" href="#_12-如何检测死锁"><span>12. 如何检测死锁</span></a></h3><p>大多数数据库都自带死锁检测机制，内置的死锁检测器会在事务等待资源时自动检测死锁。例如：</p><ul><li><p><strong>MySQL</strong>：可以使用<code>INFORMATION_SCHEMA</code>数据库中的<code>INNODB_LOCK_WAITS</code>表来查看死锁信息。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> FROM</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> INFORMATION_SCHEMA</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">INNODB_LOCK_WAITS</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个表展示了哪些事务被锁定，以及哪些事务持有其他事务正在等待的锁。</p></li></ul><h3 id="_13-你遇到过死锁吗-你怎么处理的" tabindex="-1"><a class="header-anchor" href="#_13-你遇到过死锁吗-你怎么处理的"><span>13. 你遇到过死锁吗，你怎么处理的</span></a></h3><p><strong>解决死锁</strong>： 数据库管理系统通常有机制来检测和解决死锁：</p><ul><li><strong>死锁检测</strong>：系统定期检查事务的执行状态，以识别是否存在死锁。</li><li><strong>超时</strong>：事务在等待资源超过一定时间后超时，系统自动回滚事务。</li><li><strong>回滚</strong>：检测到死锁后，系统可能会选择一个或多个事务进行回滚，释放它们持有的资源，从而打破死锁状态。</li><li><strong>锁升级</strong>：在某些情况下，系统可能会尝试将锁从更细的粒度升级到更粗的粒度，以减少死锁的可能性。</li></ul><p>这四种是解决死锁的办法，接下来实操如何发现处理死锁。</p><ol><li>监控死锁</li></ol><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">show engine innodb </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">status</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271825084.png" alt="image-20240527182546406" tabindex="0" loading="lazy"><figcaption>image-20240527182546406</figcaption></figure><p>这里返回了包含详细信息的输出，包括死锁检测到的信息。</p><ol start="2"><li>解决死锁</li></ol><ul><li>回滚事务</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">ROLLBACK</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>杀死引起死锁的进程</li></ul><p>找到引起死锁的进程 ID，使用 kill 杀死该进程。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SHOW PROCESSLIST;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">KILL</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">process_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,179),t=[e];function h(k,p){return a(),s("div",null,t)}const g=i(n,[["render",h],["__file","sql_lock_13_topic.html.vue"]]),o=JSON.parse('{"path":"/posts/database/mysql/sql_lock_13_topic.html","title":"数据库13问，谁能顶得住","lang":"zh-CN","frontmatter":{"title":"数据库13问，谁能顶得住","icon":"file","author":"Ms.Wang","date":"2024-06-12T00:00:00.000Z","sticky":true,"star":false,"category":["mysql"],"tag":["mysql","数据库锁"],"description":"数据库13问，谁能顶得住 | 前言 过完这个节，就要进入金银季，准备了 13 道数据库锁面试题，一定用得上。 锁的问题归更到底就是资源竞争导致的，而并发场景一定会发生资源竞争，所以锁的问题，也是并发场景下必问的问题。理解好锁的原理，在编程中提升设计能力也非常重要。 汇总xmind汇总xmind 作者： 感谢每一个支持： github 1. 为什么要在数...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/posts/database/mysql/sql_lock_13_topic.html"}],["meta",{"property":"og:site_name","content":"JavaPub"}],["meta",{"property":"og:title","content":"数据库13问，谁能顶得住"}],["meta",{"property":"og:description","content":"数据库13问，谁能顶得住 | 前言 过完这个节，就要进入金银季，准备了 13 道数据库锁面试题，一定用得上。 锁的问题归更到底就是资源竞争导致的，而并发场景一定会发生资源竞争，所以锁的问题，也是并发场景下必问的问题。理解好锁的原理，在编程中提升设计能力也非常重要。 汇总xmind汇总xmind 作者： 感谢每一个支持： github 1. 为什么要在数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271854966.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-03T14:35:52.000Z"}],["meta",{"property":"article:author","content":"Ms.Wang"}],["meta",{"property":"article:tag","content":"mysql"}],["meta",{"property":"article:tag","content":"数据库锁"}],["meta",{"property":"article:published_time","content":"2024-06-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-03T14:35:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据库13问，谁能顶得住\\",\\"image\\":[\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271854966.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271849204.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271527069.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271837190.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271658523.jpeg\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271825084.png\\"],\\"datePublished\\":\\"2024-06-12T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-03T14:35:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ms.Wang\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[{"level":3,"title":"1. 为什么要在数据库中加锁","slug":"_1-为什么要在数据库中加锁","link":"#_1-为什么要在数据库中加锁","children":[]},{"level":3,"title":"2. InnoDB 中有哪些锁","slug":"_2-innodb-中有哪些锁","link":"#_2-innodb-中有哪些锁","children":[]},{"level":3,"title":"3. 什么是死锁","slug":"_3-什么是死锁","link":"#_3-什么是死锁","children":[]},{"level":3,"title":"4. 行锁、表锁、页面锁有什么区别","slug":"_4-行锁、表锁、页面锁有什么区别","link":"#_4-行锁、表锁、页面锁有什么区别","children":[]},{"level":3,"title":"行锁（Row Locks）","slug":"行锁-row-locks","link":"#行锁-row-locks","children":[]},{"level":3,"title":"表锁（Table Locks）","slug":"表锁-table-locks","link":"#表锁-table-locks","children":[]},{"level":3,"title":"页锁（Page Locks）","slug":"页锁-page-locks","link":"#页锁-page-locks","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":3,"title":"5. 乐观锁和悲观锁有什么区别，它们什么场景会用","slug":"_5-乐观锁和悲观锁有什么区别-它们什么场景会用","link":"#_5-乐观锁和悲观锁有什么区别-它们什么场景会用","children":[]},{"level":3,"title":"乐观锁","slug":"乐观锁","link":"#乐观锁","children":[]},{"level":3,"title":"悲观锁","slug":"悲观锁","link":"#悲观锁","children":[]},{"level":3,"title":"6. select...for update 加了行锁还是表锁","slug":"_6-select-for-update-加了行锁还是表锁","link":"#_6-select-for-update-加了行锁还是表锁","children":[]},{"level":3,"title":"7. 如何通过 SQL 手动给 MySQL 的某个表加锁","slug":"_7-如何通过-sql-手动给-mysql-的某个表加锁","link":"#_7-如何通过-sql-手动给-mysql-的某个表加锁","children":[]},{"level":3,"title":"8. 高并发场景下，如何修改同一条数据","slug":"_8-高并发场景下-如何修改同一条数据","link":"#_8-高并发场景下-如何修改同一条数据","children":[]},{"level":3,"title":"9. MySQL 中的锁升级是什么","slug":"_9-mysql-中的锁升级是什么","link":"#_9-mysql-中的锁升级是什么","children":[]},{"level":3,"title":"10. MySql RR 的隔离级别下加锁规则","slug":"_10-mysql-rr-的隔离级别下加锁规则","link":"#_10-mysql-rr-的隔离级别下加锁规则","children":[]},{"level":3,"title":"11. 如何使用分布式锁","slug":"_11-如何使用分布式锁","link":"#_11-如何使用分布式锁","children":[]},{"level":3,"title":"12. 如何检测死锁","slug":"_12-如何检测死锁","link":"#_12-如何检测死锁","children":[]},{"level":3,"title":"13. 你遇到过死锁吗，你怎么处理的","slug":"_13-你遇到过死锁吗-你怎么处理的","link":"#_13-你遇到过死锁吗-你怎么处理的","children":[]}]}],"git":{"createdTime":1717658350000,"updatedTime":1720017352000,"contributors":[{"name":"wangshiyu","email":"iswangshiyu@foxmail.com","commits":1}]},"readingTime":{"minutes":20.78,"words":6234},"filePathRelative":"posts/database/mysql/sql_lock_13_topic.md","localizedDate":"2024年6月12日","excerpt":"<blockquote>\\n<p>数据库13问，谁能顶得住 |</p>\\n</blockquote>\\n<h2>前言</h2>\\n<p>过完这个节，就要进入金银季，准备了 13 道数据库锁面试题，一定用得上。</p>\\n<p>锁的问题归更到底就是资源竞争导致的，而并发场景一定会发生资源竞争，所以锁的问题，也是并发场景下必问的问题。理解好锁的原理，在编程中提升设计能力也非常重要。</p>\\n<figure><img src=\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202405271854966.png\\" alt=\\"汇总xmind\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>汇总xmind</figcaption></figure>","autoDesc":true}');export{g as comp,o as data};
