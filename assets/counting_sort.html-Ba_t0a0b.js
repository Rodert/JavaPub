import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,e as n}from"./app-D3ONNahh.js";const t={},l=n(`<p>[toc]</p><h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h1><blockquote><p>声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。</p></blockquote><blockquote><p>本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub</p></blockquote><blockquote><p>有任何问题都可以来谈谈 ！</p></blockquote><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091843.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p><strong>计数排序</strong>是比较容易的排序算法，但是对数量级较小的整数排序很实用。</p></blockquote><h1 id="_1-计数排序-counting-sort" tabindex="-1"><a class="header-anchor" href="#_1-计数排序-counting-sort"><span>1.计数排序(Counting Sort)</span></a></h1><h2 id="_1-1-计数排序-counting-sort" tabindex="-1"><a class="header-anchor" href="#_1-1-计数排序-counting-sort"><span>1.1.计数排序(Counting Sort)</span></a></h2><blockquote><p>计数排序是一个<strong>非基于比较</strong>的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对<strong>一定范围</strong>内的<strong>整数排序</strong>时，它的复杂度为 <code>Ο(n+k)</code>（其中k是整数的范围），<strong>快于任何比较排序算法</strong>。当然这是一种牺牲空间换取时间的做法，而且当 <code>O(k)&gt;O(n*log(n))</code> 的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n*log(n)), 如 <a href="https://mp.weixin.qq.com/s/VM9R4Y3uvFcmRuvmoWxLdw" target="_blank" rel="noopener noreferrer">归并排序</a>，<a href="https://mp.weixin.qq.com/s/ajLmV6eVAFsV9El0aD_PjA" target="_blank" rel="noopener noreferrer">堆排序</a>）</p></blockquote><p><em>例如</em>：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><ul><li>计数排序是一个简单的排序算法，看下边原理很容易理解。</li></ul><h1 id="_2-原理" tabindex="-1"><a class="header-anchor" href="#_2-原理"><span>2.原理</span></a></h1><h2 id="_2-1-步骤" tabindex="-1"><a class="header-anchor" href="#_2-1-步骤"><span>2.1.步骤</span></a></h2><ul><li>算法的步骤如下：</li></ul><ol><li>找出待排序的数组中最大和最小的元素</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ol><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091452.gif" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><p>如果有疑问，看下边一个例子</p></blockquote><h2 id="_2-2-实例题目" tabindex="-1"><a class="header-anchor" href="#_2-2-实例题目"><span>2.2.实例题目</span></a></h2><blockquote><p>题目：数组里有20个随机数，取值范围为从0到10，要求用最快的速度把这20个整数从小到大进行排序。</p></blockquote><p>无论是<a href="">归并排序</a>，<a href="">冒泡排序</a>还是<a href="">快速排序</a>等等，都是基于元素之间的<strong>比较</strong>来进行排序的。但是有一种特殊的排序算法叫<strong>计数排序</strong>，这种排序算法不是基于元素比较，而是利用 <code>数组下标</code> 来确定元素的正确位置。</p><p>通过<strong>计数排序</strong>特性分析题目，我们知道整数的取值范围是从0到10，那么这些整数的值肯定是在0到10这11个数里面。于是我们可以建立一个长度为11的数组，数组下标从0到10，元素初始值全为0，如下所示：</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091510.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>先假设20个随机整数的值是： <code>9, 3, 5, 4, 9, 1, 2, 7, 8，1，3, 6, 5, 3, 4, 0, 10, 9, 7, 9</code></p><ul><li>让我们先遍历这个无序的随机数组，每一个整数按照其值对号入座，对应数组下标的元素进行 <code>加1</code> 操作。</li></ul><p>比如第一个整数是 9，那么数组下标为 9 的元素加 1：</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091517.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>第二个整数是3，那么数组下标为 3 的元素加 1：</li></ul><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091523.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>继续遍历数列并修改数组......</li></ul><p>最终，数列遍历完毕时，数组的状态如下：</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091530.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>数组中的每一个值，代表了数列中对应整数的出现次数。</p><p>有了这个统计结果，排序就很简单了，直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次：</p><p><code>0, 1, 1, 2, 3, 3, 3, 4, 4, 5, 5, 6, 7, 7, 8, 9, 9, 9, 9, 10</code></p><p>这就是计数排序的基本过程，它<strong>适用于一定范围的整数排序。在取值范围不是很大的情况下，它的性能在某些情况甚至快过那些O(nlogn)的排序，例如快速排序、归并排序。</strong></p><h1 id="_3-代码" tabindex="-1"><a class="header-anchor" href="#_3-代码"><span>3.代码</span></a></h1><h2 id="_3-1-代码" tabindex="-1"><a class="header-anchor" href="#_3-1-代码"><span>3.1.代码</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> sortJavaPub</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> [] array </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">	//1.得到数列的最大值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> max </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> array[</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> array</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (array[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> max)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">			max </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> array[i]</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">	//2.根据数列的最大值确定统计数组的长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">[] coutArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">[max </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">	//3.遍历数列，填充统计数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> array</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">		coutArray[array[i]]</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">	//4.遍历统计数组，输出结果</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">[] sortedArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">array</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> coutArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">		for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> coutArray[i]</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> j</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">			sortedArray[index</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">	System</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Arrays</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(sortedArray));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回结果：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>[1, 2, 3, 4, 5]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h1 id="_4-扩展阅读" tabindex="-1"><a class="header-anchor" href="#_4-扩展阅读"><span>4.扩展阅读</span></a></h1><h2 id="_4-1-局限性" tabindex="-1"><a class="header-anchor" href="#_4-1-局限性"><span>4.1.局限性</span></a></h2><p><strong>1. 当数列最大最小值差距过大时，并不适用于计数排序</strong></p><p>比如给定20个随机整数，范围在0到1亿之间，此时如果使用计数排序的话，就需要创建长度为1亿的数组，不但严重浪费了空间，而且时间复杂度也随之升高。</p><p><strong>2. 当数列元素不是整数时，并不适用于计数排序</strong></p><p>如果数列中的元素都是小数，比如3.1415，或是0.00000001这样子，则无法创建对应的统计数组，这样显然无法进行计数排序。</p>`,47),h=[l];function e(p,k){return a(),s("div",null,h)}const o=i(t,[["render",e],["__file","counting_sort.html.vue"]]),g=JSON.parse('{"path":"/posts/algorithms_data_structures/data_structures/counting_sort.html","title":"计数排序就是这么容易","lang":"zh-CN","frontmatter":{"title":"计数排序就是这么容易","icon":"lightbulb","author":"Wang Shiyu","date":"2022-04-21T00:00:00.000Z","category":["数据结构","排序"],"tag":["数据结构","排序"],"description":"[toc] 前言 声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。 本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub 有任何问题都可以来谈谈 ！ 计数排序是比较容易的排序算法，但是对数量级较小的整数排序很实用。 1.计数排序(Count...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/posts/algorithms_data_structures/data_structures/counting_sort.html"}],["meta",{"property":"og:site_name","content":"JavaPub"}],["meta",{"property":"og:title","content":"计数排序就是这么容易"}],["meta",{"property":"og:description","content":"[toc] 前言 声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。 本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub 有任何问题都可以来谈谈 ！ 计数排序是比较容易的排序算法，但是对数量级较小的整数排序很实用。 1.计数排序(Count..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091843.jpeg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-06T13:42:36.000Z"}],["meta",{"property":"article:author","content":"Wang Shiyu"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:tag","content":"排序"}],["meta",{"property":"article:published_time","content":"2022-04-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-06T13:42:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"计数排序就是这么容易\\",\\"image\\":[\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091843.jpeg\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091452.gif\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091510.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091517.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091523.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091530.png\\"],\\"datePublished\\":\\"2022-04-21T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-06T13:42:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Wang Shiyu\\"}]}"]]},"headers":[{"level":2,"title":"1.1.计数排序(Counting Sort)","slug":"_1-1-计数排序-counting-sort","link":"#_1-1-计数排序-counting-sort","children":[]},{"level":2,"title":"2.1.步骤","slug":"_2-1-步骤","link":"#_2-1-步骤","children":[]},{"level":2,"title":"2.2.实例题目","slug":"_2-2-实例题目","link":"#_2-2-实例题目","children":[]},{"level":2,"title":"3.1.代码","slug":"_3-1-代码","link":"#_3-1-代码","children":[]},{"level":2,"title":"4.1.局限性","slug":"_4-1-局限性","link":"#_4-1-局限性","children":[]}],"git":{"createdTime":1718348642000,"updatedTime":1720273356000,"contributors":[{"name":"wangshiyu","email":"iswangshiyu@foxmail.com","commits":2}]},"readingTime":{"minutes":4.83,"words":1448},"filePathRelative":"posts/algorithms_data_structures/data_structures/counting_sort.md","localizedDate":"2022年4月21日","excerpt":"<p>[toc]</p>\\n<h1>前言</h1>\\n<blockquote>\\n<p>声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。</p>\\n</blockquote>\\n<blockquote>\\n<p>本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。\\n欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub</p>\\n</blockquote>\\n<blockquote>\\n<p>有任何问题都可以来谈谈 ！</p>\\n</blockquote>\\n<figure><img src=\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-091843.jpeg\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>","autoDesc":true}');export{o as comp,g as data};
