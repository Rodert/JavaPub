import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,a as i,b as l,w as n,d as s,e,r as p,o as k}from"./app-DLoSqUOP.js";const r={},d=i("p",null,[i("strong",null,[s("我是 javapub，一名 "),i("code",null,"Markdown"),s(" 程序员从👨‍💻，八股文种子选手。")])],-1),o=i("ul",null,[i("li",null,[i("strong",null,"Serial 收集器"),s(":最基本的收集器,对内存进行复制然后清理,效率low。只使用一个线程,会停顿其他线程,不适用服务器环境。")]),i("li",null,[i("strong",null,"Parallel 收集器"),s(":多个线程并行回收,效率高于Serial,适用于微服务等。")]),i("li",null,[i("strong",null,"CMS 收集器"),s(":并发标记清除,效率高,并发回收,但会产生碎片。适用于对响应时间有要求的场景。")]),i("li",null,[i("strong",null,"G1 收集器"),s(":JDK9默认,基于region分代回收,效率高且不产生碎片。适用于大内存的机器。")])],-1),g=e(`<ol><li><strong>初始标记</strong>:标记GC Roots能直接关联的对象,速度快,主要为了第2步做准备。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 代码示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> markFromRoots</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // classify objects and put them into correct lists</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> strongRefs) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        G1CollectedHeap</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">addToMarked</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(obj);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>并发标记</strong>:从GC Roots开始对堆中对象进行并发标记,jia部分STW(stop-the-world)</li><li><strong>最终标记</strong>:修正并发标记期间并发修改导致的错误标记,需要STW。</li><li><strong>筛选回收</strong>:根据标记结果筛选回收区域,回收垃圾对象,需要STW。</li><li><strong>并发清理</strong>:与用户线程一起工作,对标记和筛选阶段差异化技术产生的垃圾链进行清理。</li></ol><p>以上就是G1收集器的整个工作流程,相比CMS无碎片和高效,适用于大内存服务器。</p>`,4),c=e(`<ol><li>如果一个对象仅被强引用变量引用,并且这个强引用变量为 null,则该对象为垃圾。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 对象example引用为null,则该对象为垃圾</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> example </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">example </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>如果一个对象被强引用的变量引用,并且这个强引用变量所在的方法已经弹出栈,则该对象为垃圾。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 方法退出后,obj为垃圾</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>如果一个对象仅被软引用、弱引用或虚引用变量引用,则在垃圾回收时这些变量会被清除,该对象为垃圾。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 使用WeakReference例子 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">WeakReference</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> weakExample </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> WeakReference</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">())</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 如果没有其他引用指向Example对象,则该对象可被回收</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>如果两个对象彼此引用,但没有任何一个对象被外部强引用,则这两个对象之间形成的循环引用链为垃圾。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// A和B相互引用,构成循环,都为垃圾</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(b)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">B</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(a)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),u=i("ol",null,[i("li",null,"垃圾的判断:通过引用计数算法判断对象是否可达。如被引用变量置null、超出作用域、软引用被清理等,则判断为垃圾。"),i("li",null,"垃圾的回收:通过垃圾收集器进行自动回收,如Serial、Parallel、CMS、G1等收集器。使用分代回收、标记-清除、复制算法等进行回收。"),i("li",null,[s("垃圾回收的时机:当堆中垃圾对象达到一定比例或内存不足时,会触发垃圾回收。也可以手动触发"),i("code",null,"System.gc()"),s("。")]),i("li",null,"垃圾回收的步骤:1标记阶段标记垃圾 2清除阶段删除垃圾 3整理阶段压缩空间"),i("li",null,"如何优化:尽量减少垃圾产生,使用软引用或弱引用存放易变对象,及时回收资源等方式优化。")],-1),y=i("p",null,"以上就是 Java 垃圾回收机制的主要内容,希望能对你有所帮助!有任何问题都可以继续问我。",-1),v=e(`<ol><li>JVM内存结构分为:堆内存、虚拟机栈、方法区、本地方法栈、程序计数器等。堆内存存储对象实例,垃圾回收的主要区域就是堆内存。</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">//</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> JVM内存结构图示</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">   +--------------------+</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">      方法区</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">        |</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">   +--------------------+</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">     程序计数器</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">      |</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">   +--------------------+</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        JVM栈</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">        |</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">   +--------------------+</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">                     |</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">     堆内存</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">           |</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">                     |</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">   +--------------------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>堆内存中又分为几个区域,主要有两个:新生代和老年代。新生代用于存储新创建的对象,老年代中存放老化对象。</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">   +--------------------+</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">     方法区</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">        |</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">   +--------------------+</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">     程序计数器</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">      |</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">   +--------------------+</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        JVM栈</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">        |</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">   +--------------------+</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">  新生代</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">            |</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">                     |</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">     堆内存</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">           |</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">                     |</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">   老年代</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">             |</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">   +--------------------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><p>垃圾收集器会根据这些内存区域中的对象进行回收,比如新生代使用Copying算法,老年代使用Mark-Sweep算法。</p></li><li><p>情景举例:</p></li></ol><ul><li>对象在Eden出生,经过第一次Minor GC后未死亡进入Survivor,多次MinorGC后仍存活进入老年代。</li><li>老年代空间不足触发Major GC,回收部分垃圾对象。</li><li>老年代的对象通过晋升至永久代,如果永久代填满,会抛出<code>OOM</code>异常。</li></ul>`,6),B=e('<figure><img src="https://ghproxy.com/https://raw.githubusercontent.com/Rodert/javapub_oss/main/other/16.jpg?raw=true" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注<strong>公众号JavaPub</strong>追更！</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F06%2F20240606-225632.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>🎁目录合集：</p><p>Gitee：<code>https://gitee.com/rodert/JavaPub</code></p><p>GitHub：<code>https://github.com/Rodert/JavaPub</code></p><p><a href="http://javapub.net.cn" target="_blank" rel="noopener noreferrer">http://javapub.net.cn</a></p>',7);function b(m,F){const a=p("font");return k(),h("div",null,[d,i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:n(()=>[s("面试官")]),_:1}),s("： 小伙子,跟我聊聊垃圾回收机制吧。什么是垃圾?怎么回收?")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:n(()=>[s("候选人：")]),_:1})]),s(" 好的面试官,来吧!垃圾就是那些不再被程序使用的对象。Java 通过自动的垃圾回收机制回收这些垃圾对象所占的内存。")]),i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:n(()=>[s("面试官")]),_:1}),s("： 那Java垃圾收集器都有哪些?各有什么优缺点?")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:n(()=>[s("候选人：")]),_:1})]),s(" Java 提供了几种垃圾收集器:")]),o,i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:n(()=>[s("面试官")]),_:1}),s("： 讲讲G1垃圾收集器的工作流程。")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:n(()=>[s("候选人：")]),_:1})]),s(" G1垃圾收集器的工作流程如下:")]),g,i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:n(()=>[s("面试官")]),_:1}),s("： 那说说 Java 对象如何判断为“垃圾”?")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:n(()=>[s("候选人：")]),_:1})]),s(" Java 对象通过引用计数算法判断是否为垃圾:")]),c,i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:n(()=>[s("面试官")]),_:1}),s("： 帮我总结下 Java 垃圾回收的机制?")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:n(()=>[s("候选人：")]),_:1})]),s(" 可以这么总结 Java 垃圾回收机制:")]),u,y,i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:n(()=>[s("面试官")]),_:1}),s("： 那谈谈你了解的JVM内存结构和垃圾回收之间的关系?")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:n(()=>[s("候选人：")]),_:1})]),s(" JVM内存结构与垃圾回收有密切关系:")]),v,i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:n(()=>[s("面试官")]),_:1}),s("： 嗯！啊。")])]),B])}const C=t(r,[["render",b],["__file","16.lajihuishoujizhi.html.vue"]]),f=JSON.parse('{"path":"/posts/special/1v1/16.lajihuishoujizhi.html","title":"垃圾回收机制","lang":"zh-CN","frontmatter":{"title":"垃圾回收机制","icon":"laptop-code","category":["《面试1v1》"],"description":"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。 ： 小伙子,跟我聊聊垃圾回收机制吧。什么是垃圾?怎么回收? 好的面试官,来吧!垃圾就是那些不再被程序使用的对象。Java 通过自动的垃圾回收机制回收这些垃圾对象所占的内存。 ： 那Java垃圾收集器都有哪些?各有什么优缺点? Java 提供了几种垃圾收集器: Seria...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/posts/special/1v1/16.lajihuishoujizhi.html"}],["meta",{"property":"og:site_name","content":"JavaPub"}],["meta",{"property":"og:title","content":"垃圾回收机制"}],["meta",{"property":"og:description","content":"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。 ： 小伙子,跟我聊聊垃圾回收机制吧。什么是垃圾?怎么回收? 好的面试官,来吧!垃圾就是那些不再被程序使用的对象。Java 通过自动的垃圾回收机制回收这些垃圾对象所占的内存。 ： 那Java垃圾收集器都有哪些?各有什么优缺点? Java 提供了几种垃圾收集器: Seria..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://ghproxy.com/https://raw.githubusercontent.com/Rodert/javapub_oss/main/other/16.jpg?raw=true"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-03T14:35:52.000Z"}],["meta",{"property":"article:author","content":"Mr.Wang"}],["meta",{"property":"article:modified_time","content":"2024-07-03T14:35:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"垃圾回收机制\\",\\"image\\":[\\"https://ghproxy.com/https://raw.githubusercontent.com/Rodert/javapub_oss/main/other/16.jpg?raw=true\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F06%2F20240606-225632.png\\"],\\"dateModified\\":\\"2024-07-03T14:35:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Wang\\",\\"url\\":\\"https://javapub.net.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1717568495000,"updatedTime":1720017352000,"contributors":[{"name":"wangshiyu","email":"iswangshiyu@foxmail.com","commits":1}]},"readingTime":{"minutes":5.21,"words":1564},"filePathRelative":"posts/special/1v1/16.lajihuishoujizhi.md","localizedDate":"2024年6月5日","excerpt":"<p><strong>我是 javapub，一名 <code>Markdown</code> 程序员从👨‍💻，八股文种子选手。</strong></p>\\n<p><strong>： 小伙子,跟我聊聊垃圾回收机制吧。什么是垃圾?怎么回收?</strong></p>\\n<p><strong></strong> 好的面试官,来吧!垃圾就是那些不再被程序使用的对象。Java 通过自动的垃圾回收机制回收这些垃圾对象所占的内存。</p>\\n<p><strong>： 那Java垃圾收集器都有哪些?各有什么优缺点?</strong></p>\\n<p><strong></strong> Java 提供了几种垃圾收集器:</p>","autoDesc":true}');export{C as comp,f as data};
