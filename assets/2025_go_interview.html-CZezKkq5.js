import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,e}from"./app-BuoHmt6k.js";const n={},l=e(`<p>前几天参加了一场面试，GoLang 后端工程师，他们直接给了我 10 道题，我留了一个截图。</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202502241333053.png" alt="image-20250224133316933" tabindex="0" loading="lazy"><figcaption>image-20250224133316933</figcaption></figure><p>在看答案之前，你可以先简单做一下，下面我会对每个题目做一个说明。</p><p>@[toc]</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202502241442866.png" alt="image-20250224144221700" tabindex="0" loading="lazy"><figcaption>image-20250224144221700</figcaption></figure><h3 id="_1、golang-map-是否并发安全" tabindex="-1"><a class="header-anchor" href="#_1、golang-map-是否并发安全"><span>1、golang map 是否并发安全?</span></a></h3><p>Go 语言中的原生 <code>map</code> 并不是并发安全的。在多 goroutine 并发读写同一个 <code>map</code> 时，可能会导致数据竞争（race condition），从而引发程序崩溃。</p><p>可以用 <code>sync.Map</code></p><p>Go标准库中的 <code>sync.Map</code> 是一个并发安全的map实现。它内部通过读写分离的策略来减少锁争用，适用于读多写少的场景。例如：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> m</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> sync</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Map</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Store</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 存储键值对</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">ok</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> m</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Load</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 获取值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Delete</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 删除键值对</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、协程泄漏的原因可能是什么" tabindex="-1"><a class="header-anchor" href="#_2、协程泄漏的原因可能是什么"><span>2、协程泄漏的原因可能是什么？</span></a></h3><p>在 Go 语言中，协程泄漏（Goroutine Leak）是指启动的协程无法正常退出，持续占用资源，最终可能导致程序崩溃或系统资源耗尽。</p><p>例如：</p><p>协程中存在无限循环，且没有退出条件。多个协程之间存在死锁，导致无法正常退出。总的来说就是协程没有释放、不受控制。</p><h3 id="_3、关于channel操作正确的可能是" tabindex="-1"><a class="header-anchor" href="#_3、关于channel操作正确的可能是"><span>3、关于channel操作正确的可能是?</span></a></h3><ul><li>从已关闭的 channel 接收数据：是可以的。</li><li>向已关闭的 channel 发送数据：会导致运行时错误。</li><li>关闭已关闭的 channel：会导致运行时错误。</li></ul><h3 id="_4、golang字符串转成byte数组-会发生内存拷贝吗" tabindex="-1"><a class="header-anchor" href="#_4、golang字符串转成byte数组-会发生内存拷贝吗"><span>4、Golang字符串转成byte数组，会发生内存拷贝吗？</span></a></h3><p>不会。GoLang 底层字符串就是用 byte 数组存储的。</p><h3 id="_5、请说一说golang-的-gc可以怎么触发的" tabindex="-1"><a class="header-anchor" href="#_5、请说一说golang-的-gc可以怎么触发的"><span>5、请说一说Golang 的 GC可以怎么触发的?</span></a></h3><p>自动触发：堆内存达到阈值、时间周期触发、系统监控触发。</p><p>手动触发：调用 <code>runtime.GC()</code> 。</p><h3 id="_6、channel是同步的还是异步的" tabindex="-1"><a class="header-anchor" href="#_6、channel是同步的还是异步的"><span>6、Channel是同步的还是异步的 ?</span></a></h3><p>无缓冲通道：同步。</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">ch</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> make</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">chan</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 创建一个无缓冲通道</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>有缓冲通道：异步。</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">ch</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> make</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">chan</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 创建一个缓冲大小为2的通道</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_7、defer在return返回前还是返回后执行" tabindex="-1"><a class="header-anchor" href="#_7、defer在return返回前还是返回后执行"><span>7、defer在return返回前还是返回后执行?</span></a></h3><p>在函数真正返回给调用者之前执行。</p><h3 id="_8、什么情况下可能会发生内存逃逸" tabindex="-1"><a class="header-anchor" href="#_8、什么情况下可能会发生内存逃逸"><span>8、什么情况下可能会发生内存逃逸 ?</span></a></h3><p>在Go语言中，内存逃逸（Memory Escape）是指变量被分配到堆上，而不是栈上。这通常发生在Go编译器无法确定变量是否会在函数外部被引用时。以下是一些可能导致内存逃逸的常见场景：</p><ol><li>返回局部变量的指针</li></ol><p>如果函数返回了局部变量的指针，该变量会被分配到堆上，因为其生命周期需要超出函数的作用域。</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> createPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    x</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 42</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">x</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> // x逃逸到堆上</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>闭包引用局部变量</li></ol><p>如果闭包引用了局部变量，这些变量可能会被分配到堆上。</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    f</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        x</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 10</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    fmt</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// f会导致x逃逸到堆上</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有多种情况，这个有一定难度，我会再单开一篇继续讲解。</p><h3 id="_9、golang中有哪些方式可以安全读写共享变量" tabindex="-1"><a class="header-anchor" href="#_9、golang中有哪些方式可以安全读写共享变量"><span>9、Golang中有哪些方式可以安全读写共享变量?</span></a></h3><ul><li>使用互斥锁（sync.Mutex）</li><li>使用读写锁（sync.RWMutex）</li><li>使用原子操作（sync/atomic）</li><li>使用通道（channel）</li><li>使用sync.Map进行并发访问</li></ul><h3 id="_10、golang协程为什么比线程轻量" tabindex="-1"><a class="header-anchor" href="#_10、golang协程为什么比线程轻量"><span>10、Golang协程为什么比线程轻量?</span></a></h3><ul><li>调度开销更小，协程的切换由Go运行时管理，上下文切换的开销非常小，通常只需要几十纳秒。</li><li>协程的内存占用，Go协程：栈空间的初始大小非常小（通常为2KB），并且会根据需要动态扩展。这种动态栈分配机制使得协程的内存占用非常低。</li><li>协程的轻量级结构：Go协程的内部结构简单，主要包含协程状态、栈指针等信息，而操作系统线程需要维护更多的内核资源。</li><li>Go运行时通过多路复用（Multiplexing）的方式将协程映射到少量的操作系统线程上，从而实现高效的并发执行。多路复用机制、高并发能力。</li><li>阻塞处理：协程阻塞时，运行时会自动切换到其他协程，充分利用CPU。</li><li>Go协程：协程的创建和销毁由Go运行时管理，开销极小。创建和销毁协程的成本非常低，因为它们不需要操作系统内核的介入。</li></ul><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">离线版PDF下载：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">链接:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> https://pan.baidu.com/s/1zsffbsHj5CRC9whL7W-9aw?pwd=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">6666</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 提取码:</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 6666</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,43),t=[l];function h(p,k){return a(),s("div",null,t)}const g=i(n,[["render",h],["__file","2025_go_interview.html.vue"]]),o=JSON.parse('{"path":"/posts/special/interview/2025_go_interview.html","title":"2025面试Go真题第一场","lang":"zh-CN","frontmatter":{"title":"2025面试Go真题第一场","icon":"lightbulb","author":"Wang Shiyu","date":"2025-02-24T00:00:00.000Z","category":["面试","go"],"tag":["面试","go"],"description":"前几天参加了一场面试，GoLang 后端工程师，他们直接给了我 10 道题，我留了一个截图。 image-20250224133316933image-20250224133316933 在看答案之前，你可以先简单做一下，下面我会对每个题目做一个说明。 @[toc] image-20250224144221700image-20250224144221...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/posts/special/interview/2025_go_interview.html"}],["meta",{"property":"og:site_name","content":"JavaPub"}],["meta",{"property":"og:title","content":"2025面试Go真题第一场"}],["meta",{"property":"og:description","content":"前几天参加了一场面试，GoLang 后端工程师，他们直接给了我 10 道题，我留了一个截图。 image-20250224133316933image-20250224133316933 在看答案之前，你可以先简单做一下，下面我会对每个题目做一个说明。 @[toc] image-20250224144221700image-20250224144221..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202502241333053.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-24T06:42:44.000Z"}],["meta",{"property":"article:author","content":"Wang Shiyu"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"go"}],["meta",{"property":"article:published_time","content":"2025-02-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-24T06:42:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2025面试Go真题第一场\\",\\"image\\":[\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202502241333053.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202502241442866.png\\"],\\"datePublished\\":\\"2025-02-24T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-24T06:42:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Wang Shiyu\\"}]}"]]},"headers":[{"level":3,"title":"1、golang map 是否并发安全?","slug":"_1、golang-map-是否并发安全","link":"#_1、golang-map-是否并发安全","children":[]},{"level":3,"title":"2、协程泄漏的原因可能是什么？","slug":"_2、协程泄漏的原因可能是什么","link":"#_2、协程泄漏的原因可能是什么","children":[]},{"level":3,"title":"3、关于channel操作正确的可能是?","slug":"_3、关于channel操作正确的可能是","link":"#_3、关于channel操作正确的可能是","children":[]},{"level":3,"title":"4、Golang字符串转成byte数组，会发生内存拷贝吗？","slug":"_4、golang字符串转成byte数组-会发生内存拷贝吗","link":"#_4、golang字符串转成byte数组-会发生内存拷贝吗","children":[]},{"level":3,"title":"5、请说一说Golang 的 GC可以怎么触发的?","slug":"_5、请说一说golang-的-gc可以怎么触发的","link":"#_5、请说一说golang-的-gc可以怎么触发的","children":[]},{"level":3,"title":"6、Channel是同步的还是异步的 ?","slug":"_6、channel是同步的还是异步的","link":"#_6、channel是同步的还是异步的","children":[]},{"level":3,"title":"7、defer在return返回前还是返回后执行?","slug":"_7、defer在return返回前还是返回后执行","link":"#_7、defer在return返回前还是返回后执行","children":[]},{"level":3,"title":"8、什么情况下可能会发生内存逃逸 ?","slug":"_8、什么情况下可能会发生内存逃逸","link":"#_8、什么情况下可能会发生内存逃逸","children":[]},{"level":3,"title":"9、Golang中有哪些方式可以安全读写共享变量?","slug":"_9、golang中有哪些方式可以安全读写共享变量","link":"#_9、golang中有哪些方式可以安全读写共享变量","children":[]},{"level":3,"title":"10、Golang协程为什么比线程轻量?","slug":"_10、golang协程为什么比线程轻量","link":"#_10、golang协程为什么比线程轻量","children":[]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]}],"git":{"createdTime":1740377800000,"updatedTime":1740379364000,"contributors":[{"name":"javapub","email":"iswangshiyu@foxmail.com","commits":2}]},"readingTime":{"minutes":3.92,"words":1175},"filePathRelative":"posts/special/interview/2025_go_interview.md","localizedDate":"2025年2月24日","excerpt":"<p>前几天参加了一场面试，GoLang 后端工程师，他们直接给了我 10 道题，我留了一个截图。</p>\\n<figure><img src=\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/202502241333053.png\\" alt=\\"image-20250224133316933\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>image-20250224133316933</figcaption></figure>\\n<p>在看答案之前，你可以先简单做一下，下面我会对每个题目做一个说明。</p>","autoDesc":true}');export{g as comp,o as data};
