import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,f as s,a,e as n,o as r}from"./app-B3AYoYF_.js";const l={},t=a("p",null,"Docker",-1),p=n(`<p>10道不得不会的 Docker 面试题</p><p>我是JavaPub，专注于面试、副业，技术人的成长记录。</p><p>以下是 Docker 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>JavaPub</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p><p>评论区见</p><p>@[toc]</p><h1 id="docker" tabindex="-1"><a class="header-anchor" href="#docker"><span>Docker</span></a></h1><p>以下是一些docker的基础面试题，下一篇docker进阶面试题。本系列《最少必要面试题》</p><h3 id="_1-什么是-docker-容器" tabindex="-1"><a class="header-anchor" href="#_1-什么是-docker-容器"><span>1. 什么是 Docker 容器？</span></a></h3><p>Docker 是一种流行的开源软件平台，可简化创建、管理、运行和分发应用程序的过程。它使用容器来打包应用程序及其依赖项。我们也可以将容器视为 Docker 镜像的运行时实例。</p><h3 id="_2-docker-和虚拟机有什么不同" tabindex="-1"><a class="header-anchor" href="#_2-docker-和虚拟机有什么不同"><span>2. Docker 和虚拟机有什么不同？</span></a></h3><p>Docker 是轻量级的沙盒，在其中运行的只是应用，虚拟机里面还有额外的系统。</p><h3 id="_3-什么是-dockerfile" tabindex="-1"><a class="header-anchor" href="#_3-什么是-dockerfile"><span>3. 什么是 DockerFile？</span></a></h3><p>Dockerfile 是一个文本文件，其中包含我们需要运行以构建 Docker 镜像的所有命令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。Docker 使用 Dockerfile 中的指令自动构建镜像。我们可以 <code>docker build</code> 用来创建按顺序执行多个命令行指令的自动构建。</p><p><strong>一些最常用的指令如下：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">FROM</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> ：使用</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> FROM</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 为后续的指令建立基础映像。在所有有效的</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> Dockerfile</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 中，</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> FROM</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 是第一条指令。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">LABEL：</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> LABEL</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 指令用于组织项目映像，模块，许可等。在自动化布署方面</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> LABEL</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 也有很大用途。在</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> LABEL</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 中指定一组键值对，可用于程序化配置或布署</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> Docker</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">RUN：</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> RUN</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 指令可在映像当前层执行任何命令并创建一个新层，用于在映像层中添加功能层，也许最来的层会依赖它。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">CMD：</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 使用</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> CMD</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 指令为执行的容器提供默认值。在</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> Dockerfile</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 文件中，若添加多个</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> CMD</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 指令，只有最后的</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> CMD</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 指令运行。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-使用docker-compose时如何保证容器a先于容器b运行" tabindex="-1"><a class="header-anchor" href="#_4-使用docker-compose时如何保证容器a先于容器b运行"><span>4. 使用Docker Compose时如何保证容器A先于容器B运行？</span></a></h3><blockquote><p>Docker Compose 是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。Compose 通过一个配置文件来管理多个Docker容器。简单理解：Docker Compose 是docker的管理工具。</p></blockquote><p>Docker Compose 在继续下一个容器之前不会等待容器准备就绪。为了控制我们的执行顺序，我们可以使用“<strong>取决于</strong>”条件，<code>depends_on</code> 。这是在 docker-compose.yml 文件中使用的示例</p><div class="language-yml line-numbers-mode" data-highlighter="shiki" data-ext="yml" data-title="yml" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;2.4&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">services</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;"> backend</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">   build</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">.</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    # 构建自定义镜像</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">   depends_on</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">     - </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">db</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;"> db</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">   image</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">mysql</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用 <code>docker-compose up</code> 命令将按照我们指定的依赖顺序启动和运行服务。</p><h3 id="_5-一个完整的docker由哪些部分组成" tabindex="-1"><a class="header-anchor" href="#_5-一个完整的docker由哪些部分组成"><span>5. 一个完整的Docker由哪些部分组成?</span></a></h3><ul><li>DockerClient 客户端</li><li>Docker Daemon 守护进程</li><li>Docker Image 镜像</li><li>DockerContainer 容器</li></ul><h3 id="_6-docker常用命令" tabindex="-1"><a class="header-anchor" href="#_6-docker常用命令"><span>6. docker常用命令</span></a></h3><blockquote><p>命令建议在本地安装做一个实操，记忆会更深刻。 也可以克隆基于docker的俩万（springboot+vue）项目练手，提供视频+完善文档。地址：<a href="https://gitee.com/rodert/liawan-vue" target="_blank" rel="noopener noreferrer">https://gitee.com/rodert/liawan-vue</a></p></blockquote><ol><li>查看本地主机的所用镜像：\`docker images\`\`</li><li>搜索镜像：\`docker search mysql\`\`</li><li>下载镜像：<code>docker pull mysql</code>，没写 tag 就默认下载最新的 lastest</li><li>下载指定版本的镜像：\`docker pull mysql:5.7\`\`</li><li>删除镜像：\`docker rmi -f 镜像id 镜像id 镜像id\`\`</li></ol><h3 id="_7-描述-docker-容器的生命周期。" tabindex="-1"><a class="header-anchor" href="#_7-描述-docker-容器的生命周期。"><span>7. 描述 Docker 容器的生命周期。</span></a></h3><p>Docker 容器经历以下阶段：</p><ul><li>创建容器</li><li>运行容器</li><li>暂停容器（可选）</li><li>取消暂停容器（可选）</li><li>启动容器</li><li>停止容器</li><li>重启容器</li><li>杀死容器</li><li>销毁容器</li></ul><h3 id="_8-docker容器之间怎么隔离" tabindex="-1"><a class="header-anchor" href="#_8-docker容器之间怎么隔离"><span>8. docker容器之间怎么隔离?</span></a></h3><blockquote><p>这是一道涉猎很广泛的题目，理解性阅读。</p></blockquote><p>Linux中的PID、IPC、网络等资源是全局的，而Linux的NameSpace机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰。</p><p>​​**Namespace实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容​​。**对于宿主机来说，这些被“隔离”了的进程跟其他进程并没有区别。</p><p>虽然有了NameSpace技术可以实现资源隔离，但进程还是可以不受控的访问系统资源，比如CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker采用control groups技术(也就是cgroup)，有了cgroup就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些CPU上运行等等。</p><p>有了这两项技术，容器看起来就真的像是独立的操作系统了。</p><blockquote><p>强烈建议大家实操，才能更好的理解docker。</p></blockquote><p>低谷蓄力</p><p><strong>《最少必要面试题》</strong></p><p><a href="https://mp.weixin.qq.com/s/3Nviyml0cvnX_HHkZ5DjWg" target="_blank" rel="noopener noreferrer">10道不得不会的Java基础面试题</a></p><p><a href="https://mp.weixin.qq.com/s/ug3LBR4MfM1C5uVFJaPWLQ" target="_blank" rel="noopener noreferrer">10道不得不会的Java容器面试题</a></p><p><a href="https://mp.weixin.qq.com/s/h2tTwDVqL15rCI6rftgn9A" target="_blank" rel="noopener noreferrer">10道不得不会的Java并发基础面试题</a></p><p><a href="https://mp.weixin.qq.com/s/59Tif95LGi8BTJXu47zi6g" target="_blank" rel="noopener noreferrer">10道不得不会的JavaEE面试题</a></p><p><a href="https://mp.weixin.qq.com/s/hvsaD1NlzpR0LpP-GmbU_A" target="_blank" rel="noopener noreferrer">10道不得不会的JVM面试题</a></p><p><a href="https://mp.weixin.qq.com/s/yVPwCoSQ-8OYvhw8bH0PtA" target="_blank" rel="noopener noreferrer">10道不得不会的MySQL基础面试题</a></p><p><a href="https://mp.weixin.qq.com/s/lVFwy765hQ2FvIYBHyw0yA" target="_blank" rel="noopener noreferrer">10道不得不会的MyBatis面试题</a></p><p><a href="https://mp.weixin.qq.com/s/lrHsLZANxHxd_FWTCdMNJw" target="_blank" rel="noopener noreferrer">10道不得不会的Spring面试题</a></p><p><a href="https://mp.weixin.qq.com/s/-oYKVXBaQwzyzp7ffqH7gw" target="_blank" rel="noopener noreferrer">10道不得不会的SpringBoot面试题</a></p><p><a href="https://mp.weixin.qq.com/s/z3D37HqeTUmwrdheUL_Efw" target="_blank" rel="noopener noreferrer">10道不得不会的ElasticSearch面试题</a></p><p><a href="https://mp.weixin.qq.com/s/_Pq2VgxRA4yw1j_eCfEiLg" target="_blank" rel="noopener noreferrer">10道不得不会的Redis面试题</a></p><p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Kafka面试题</a></p><p><a href="https://mp.weixin.qq.com/s/ym0-x6okFi0CgF8RcxeLFA" target="_blank" rel="noopener noreferrer">10道不得不会的Zookeeper面试题</a></p><p><a href="https://mp.weixin.qq.com/s/DTC3gZNHm3Rlf_GK7twlkQ" target="_blank" rel="noopener noreferrer">10道不得不会的Docker面试题</a></p><p><a href="">10道不得不会的缓存面试题</a></p>`,52);function o(k,h){return r(),i("div",null,[t,s(" more "),p])}const g=e(l,[["render",o],["__file","docker-interview-must.html.vue"]]),m=JSON.parse('{"path":"/posts/special/havato/docker-interview-must.html","title":"10道不得不会的 Docker 面试题","lang":"zh-CN","frontmatter":{"index":true,"icon":"page","title":"10道不得不会的 Docker 面试题","author":"Wang Shiyu","date":"2022-06-19T00:00:00.000Z","category":["最少必要面试题"],"tag":["docker","面试题"],"description":"Docker","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/posts/special/havato/docker-interview-must.html"}],["meta",{"property":"og:site_name","content":"JavaPub"}],["meta",{"property":"og:title","content":"10道不得不会的 Docker 面试题"}],["meta",{"property":"og:description","content":"Docker"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-03T14:35:52.000Z"}],["meta",{"property":"article:author","content":"Wang Shiyu"}],["meta",{"property":"article:tag","content":"docker"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:published_time","content":"2022-06-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-03T14:35:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"10道不得不会的 Docker 面试题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-06-19T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-03T14:35:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Wang Shiyu\\"}]}"]]},"headers":[{"level":3,"title":"1. 什么是 Docker 容器？","slug":"_1-什么是-docker-容器","link":"#_1-什么是-docker-容器","children":[]},{"level":3,"title":"2. Docker 和虚拟机有什么不同？","slug":"_2-docker-和虚拟机有什么不同","link":"#_2-docker-和虚拟机有什么不同","children":[]},{"level":3,"title":"3. 什么是 DockerFile？","slug":"_3-什么是-dockerfile","link":"#_3-什么是-dockerfile","children":[]},{"level":3,"title":"4. 使用Docker Compose时如何保证容器A先于容器B运行？","slug":"_4-使用docker-compose时如何保证容器a先于容器b运行","link":"#_4-使用docker-compose时如何保证容器a先于容器b运行","children":[]},{"level":3,"title":"5. 一个完整的Docker由哪些部分组成?","slug":"_5-一个完整的docker由哪些部分组成","link":"#_5-一个完整的docker由哪些部分组成","children":[]},{"level":3,"title":"6. docker常用命令","slug":"_6-docker常用命令","link":"#_6-docker常用命令","children":[]},{"level":3,"title":"7. 描述 Docker 容器的生命周期。","slug":"_7-描述-docker-容器的生命周期。","link":"#_7-描述-docker-容器的生命周期。","children":[]},{"level":3,"title":"8. docker容器之间怎么隔离?","slug":"_8-docker容器之间怎么隔离","link":"#_8-docker容器之间怎么隔离","children":[]}],"git":{"createdTime":1717582746000,"updatedTime":1720017352000,"contributors":[{"name":"wangshiyu","email":"iswangshiyu@foxmail.com","commits":1}]},"readingTime":{"minutes":5.36,"words":1608},"filePathRelative":"posts/special/havato/docker-interview-must.md","localizedDate":"2022年6月19日","excerpt":"<p>Docker</p>\\n","autoDesc":true}');export{g as comp,m as data};
