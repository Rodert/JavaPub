import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,f as n,a as s,e as l,o as e}from"./app-BjojdNjp.js";const t={},h=s("h2",{id:"rodert单排学习redis进阶【青铜】",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#rodert单排学习redis进阶【青铜】"},[s("span",null,"rodert单排学习redis进阶【青铜】")])],-1),p=l(`<p>redis之青铜</p><p><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-094232.png" alt="在这里插入图片描述" loading="lazy"> @[toc]</p><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><blockquote><p>声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。</p></blockquote><blockquote><p>本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub</p></blockquote><blockquote><p>有任何问题都可以来谈谈 ！</p></blockquote><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-094234.jpeg" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><p>本篇继续学习 Redis ,上一篇 <a href="https://mp.weixin.qq.com/s?__biz=MzUzNDUyOTY0Nw==&amp;mid=2247484011&amp;idx=1&amp;sn=1ffdb758a552db1934f41b1c4496bb36&amp;chksm=fa92116bcde5987da7db79b41b86add44bddc574cdbd33bd622b7f6a21662c652331ed9e4173&amp;scene=126&amp;sessionid=1592125292&amp;key=2e8f81eda3e54fad9074a8b209275cc64f9c5dd28066961b7be2f518b92c55507968ed1b6278d887e87fd9f464f4b4899c8cf651adda04616c16f3c11e97de5ebdc827c9144e99e8b08451af86234894&amp;ascene=1&amp;uin=MTk1NDc4MzM2Mg%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AWHTYrB4gjJmGEbHtri6R6w%3D&amp;pass_ticket=leo%2BHfJ0BW2bC82%2BQSYAPob7M1DzxC09JpT%2BAvOxTmnKdJp6Basn7bAq9v%2Fv3xN%2B" target="_blank" rel="noopener noreferrer">rodert单排学习redis入门【黑铁】</a> 对 Redis **<span color="#159957">安装</span><strong>和</strong><span color="#159957">常用数据</span>**结构做了梳理，如果没看可以先回去看完再继续本篇~</p><p>上一篇都是对一些 redis 基本数据类型 api 的讲解，本篇是数据类型底层实现，主要内容有：</p><ul><li>为什么使用Redis</li><li>Redis数据结构解析</li><li>SDS简单动态字符串</li><li>哈希表</li><li>跳跃表</li><li>整数集合</li><li>压缩列表</li><li>Redis中数据结构的对象</li><li>...</li></ul><h2 id="_1-再谈redis" tabindex="-1"><a class="header-anchor" href="#_1-再谈redis"><span>1.再谈Redis</span></a></h2><p>Redis 是什么？官话来说就是：</p><blockquote><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p></blockquote><p>Redis 是一个开源的、<strong>基于内存</strong>的<strong>数据结构存储器</strong>，可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。</p><p>如果想尝试 Redis 命令又懒得安装，可以使用这个 <a href="http://try.redis.io/" target="_blank" rel="noopener noreferrer">http://try.redis.io/</a> 网站。</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-094237.jpeg" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><h2 id="_2-为什么要用redis" tabindex="-1"><a class="header-anchor" href="#_2-为什么要用redis"><span>2.为什么要用Redis</span></a></h2><p>上一篇咱们有一定了解</p><p>Redis 是**<span color="#159957">基于内存</span>**，常用作缓存的一种技术，并且 Redis 存储的方式是以 <strong><span color="#c00">key-value</span></strong> 形式。</p><p>那我们为什么不用 Java Map？</p><ul><li>Java Map是**<span color="#c00">本地缓存</span>**的，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</li><li>JVM内存太大容易挂掉，还有各种**<span color="#c00">过期机制、存储结构</span>**需要自己手动来写</li><li>Redis 会定期把缓存保存到硬盘，重启恢复数据，丰富的数据结构，缓存机制等实用功能。</li></ul><h2 id="_3-为什么要使用缓存" tabindex="-1"><a class="header-anchor" href="#_3-为什么要使用缓存"><span>3.为什么要使用缓存？</span></a></h2><p>高并发，高可用这是现在互联网经常提到的一个词。在程序出现大量请求是就会出现**<span color="#c00">性能问题</span><strong>，一般性能问题第一道就是</strong><span color="#c00">数据库扛不住了</span>**，数据库的读写会有磁盘操作，而磁盘的速度相对内存来说慢很多。</p><p>所有我们在中间加一道缓存：</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093006.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><h2 id="_4-redis数据结构" tabindex="-1"><a class="header-anchor" href="#_4-redis数据结构"><span>4.Redis数据结构</span></a></h2><h3 id="_4-1-sds简单动态字符串" tabindex="-1"><a class="header-anchor" href="#_4-1-sds简单动态字符串"><span>4.1.SDS简单动态字符串</span></a></h3><h4 id="_4-1-1-sds简单动态字符串" tabindex="-1"><a class="header-anchor" href="#_4-1-1-sds简单动态字符串"><span>4.1.1.SDS简单动态字符串</span></a></h4><p>Redis 是由C语言编写的。</p><p>我们现在知道 Redis 所有键都是字符串，值有字符串（string）、散列（hash）、列表（list）、集合（set）和有序集合（sorted set）这五种类型的键的底层实现数据结构。</p><blockquote><p>Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。</p></blockquote><p>Redis 使用 <code>sds.h/sdshdr</code> 结构表示一个 SDS 值：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">struct sdshdr {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 记录 buf 数组中已使用字节的数量</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 等于 SDS 所保存字符串的长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 记录 buf 数组中未使用字节的数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> free</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 字节数组，用于保存字符串</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    char</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> buf[]</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093016.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><p>上图是 SDS 示例，以空字符结尾 <code>&#39;\\0&#39;</code>。遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数。</p><p>举个例子， 如果我们有一个指向图 2-1 所示 SDS 的指针 s ， 那么我们可以直接使用 stdio.h/printf 函数， 通过执行以下语句：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">%s</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">buf</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>来打印出 SDS 保存的字符串值 &quot;Redis&quot; ， 而无须为 SDS 编写专门的打印函数。</p><h4 id="_4-1-2-sds简单动态字符串好处" tabindex="-1"><a class="header-anchor" href="#_4-1-2-sds简单动态字符串好处"><span>4.1.2.SDS简单动态字符串好处</span></a></h4><ol><li><p>sdshdr数据结构中用len属性记录了字符串的长度。那么获取字符串的长度时，<strong><span color="#c00">时间复杂度</span><strong>只需要 <code>O(1)</code>。</strong><span color="#159957">常数复杂度获取字符串长度</span></strong>。</p></li><li><p>SDS不会发生溢出的问题，如果修改SDS时，空间不足。先会扩展空间，再进行修改！(<strong><span color="#c00">内部实现了动态扩展机制</span></strong>)。<strong><span color="#159957">杜绝缓冲区溢出</span></strong>。</p></li><li><p>SDS可以**<span color="#c00">减少内存分配的次数</span><strong>(空间预分配机制)。在扩展空间时，除了分配修改时所必要的空间，还会分配额外的空闲空间(free 属性)。</strong><span color="#159957">减少修改字符串长度时所需的内存重分配次数</span>**。</p></li><li><p>SDS是**<span color="#c00">二进制安全</span>**的，SDS 以二进制的方式来处理SDS存放在buf数组里的数据。</p></li><li><p>可以使用一部分 <code>&lt;string.h&gt;</code> 库中的函数。<strong><span color="#159957">兼容部分 C 字符串函数</span></strong>。</p></li></ol><h3 id="_4-2-redis-链表和链表节点" tabindex="-1"><a class="header-anchor" href="#_4-2-redis-链表和链表节点"><span>4.2.Redis 链表和链表节点</span></a></h3><blockquote><p>Java 学习者对链表应该都很熟悉，链表是 Java 中一种典型且常用的数据构。</p></blockquote><p>每个**<span color="#c00">链表节点</span>**使用一个 <code>adlist.h/listNode</code> 结构来表示：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">typedef struct listNode {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 前置节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    struct listNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">prev</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 后置节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    struct listNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 节点的值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">} listNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用listNode是可以组成链表了，Redis中**<span color="#159957">使用list结构来持有链表</span>**：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">typedef struct list {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 表头节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    listNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 表尾节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    listNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">tail</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 链表所包含的节点数量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    unsigned </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 节点值复制函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">dup)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">ptr)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 节点值释放函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    void</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">free)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">ptr)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 节点值对比函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">match)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">ptr</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">key)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">} list</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由一个 <code>list</code> 结构和三个 <code>listNode</code> 结构组成的链表：</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093024.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><h4 id="_4-2-2-redis-链表重点" tabindex="-1"><a class="header-anchor" href="#_4-2-2-redis-链表重点"><span>4.2.2.Redis 链表重点</span></a></h4><ul><li>链表被广泛用于实现 Redis 的各种功能， 比如<strong>列表键， 发布与订阅， 慢查询， 监视器</strong>， 等等。</li><li>每个链表节点由一个 <code>listNode</code> 结构来表示， 每个节点都有一个指向<strong>前置节点</strong>和<strong>后置节点</strong>的指针， 所以 Redis 的链表实现是<strong>双端链表</strong>。</li><li>每个链表使用一个 <code>list</code> 结构来表示，这个结构带有<strong>表头节点指针</strong>、<strong>表尾节点指针</strong>、以及<strong>链表长度</strong>等信息。</li><li>因为链表表头节点的<strong>前置节点</strong>和<strong>表尾节点</strong>的后置节点都指向 NULL ， 所以 Redis 的链表实现是<strong>无环链表</strong>。</li><li>通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。</li></ul><h3 id="_4-3-redis-字典" tabindex="-1"><a class="header-anchor" href="#_4-3-redis-字典"><span>4.3.Redis 字典</span></a></h3><h4 id="_4-3-1-哈希表" tabindex="-1"><a class="header-anchor" href="#_4-3-1-哈希表"><span>4.3.1.哈希表</span></a></h4><blockquote><p>字典是 Redis 中的一个概念，Redis 的字典使用哈希表作为底层实现。 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。</p></blockquote><p><strong>空哈希表</strong> Redis 字典所使用的哈希表由 <code>dict.h/dictht</code> 结构定义：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> dictht {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 哈希表数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    dictEntry </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">**</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">table;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 哈希表大小</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> size;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 哈希表大小掩码，用于计算索引值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 总是等于 size - 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> sizemask;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 该哈希表已有节点的数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> used;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} dictht;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093059.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><p><strong>哈希表节点</strong> 哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> dictEntry {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 键</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">key;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    union</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">val; </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        uint64_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> u64;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //uint64_t整数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        int64_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> s64;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //int64_t整数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    } v;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 指向下个哈希表节点，形成链表</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> dictEntry </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">next;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} dictEntry;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093102.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><blockquote><p>有没有注意到，上图有个冲突，俩个键在同一个节点，这就是 Redis <strong>解决键冲突</strong> ，Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p></blockquote><p><strong>字典</strong> Redis 中的字典由 dict.h/dict 结构表示：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> dict {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 类型特定函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    dictType </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">type;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 私有数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">privdata;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 哈希表</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    dictht </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;">ht</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // rehash 索引</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 当 rehash 不在进行时，值为 -1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> rehashidx;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> /* rehashing not in progress if rehashidx == -1 */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} dict;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">------------------</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">分割线</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">---------------------------</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> dictType {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 计算哈希值的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">hashFunction)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">key);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 复制键的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">keyDup)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">privdata, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">key);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 复制值的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">valDup)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">privdata, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">obj);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 对比键的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">keyCompare)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">privdata, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">key1, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">key2);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 销毁键的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">keyDestructor)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">privdata, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">key);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 销毁值的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">valDestructor)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">privdata, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">obj);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} dictType;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 <strong>dictht</strong> 哈希表， 一般情况下， 字典只使用 <strong>ht[0]</strong> 哈希表， <strong>ht[1]</strong> 哈希表只会在对 <strong>ht[0]</strong> 哈希表进行 <strong>rehash</strong> 时使用。</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093106.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><h4 id="_4-3-2-redis-rehash-重新散列" tabindex="-1"><a class="header-anchor" href="#_4-3-2-redis-rehash-重新散列"><span>4.3.2.Redis rehash(重新散列)</span></a></h4><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的**<span color="#159957">负载因子</span>**（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p><blockquote><p>在对哈希表进行扩展或者收缩操作时，reash 过程并不是一次性地完成的，而是**<span color="#159957">渐进式</span>**地完成的。</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>以下是哈希表渐进式 rehash 的详细步骤：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</span></span>
<span class="line"><span>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</span></span>
<span class="line"><span>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。</span></span>
<span class="line"><span>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-3-3-重点" tabindex="-1"><a class="header-anchor" href="#_4-3-3-重点"><span>4.3.3.重点</span></a></h4><ul><li>字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。</li><li>Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 <code>rehash</code> 时使用。</li><li>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</li><li>哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。</li><li>在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 <code>rehash</code> 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。</li></ul><h3 id="_4-4-跳跃表" tabindex="-1"><a class="header-anchor" href="#_4-4-跳跃表"><span>4.4.跳跃表</span></a></h3><h4 id="_4-4-1-跳跃表" tabindex="-1"><a class="header-anchor" href="#_4-4-1-跳跃表"><span>4.4.1.跳跃表</span></a></h4><p>Redis 的跳跃表由 <code>redis.h/zskiplistNode</code> 和 <code>redis.h/zskiplist</code> 两个结构定义， 其中 <code>zskiplistNode</code> 结构用于表示跳跃表节点， 而 <code>zskiplist</code> 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向**<span color="#159957">表头节点和表尾节点</span>**的指针， 等等。</p><p><strong>跳跃表节点</strong></p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> zskiplistNode {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 后退指针</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> zskiplistNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">backward;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 分值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    double</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> score;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 成员对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    robj </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">obj;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 层</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> zskiplistLevel {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 前进指针</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> zskiplistNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">forward;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 跨度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> span;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    } level</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} zskiplistNode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>zskiplistNode 不同层高节点</li></ul><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093110.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><blockquote><p>跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， <strong><span color="#159957">层的数量越多</span></strong>， 访问其他节点的**<span color="#159957">速度就越快</span>**。</p></blockquote><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093113.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><blockquote><p>看到这里，如果还有疑惑，不理解什么是跳跃表，传送一篇不错的跳跃表介绍文章：https://www.cnblogs.com/hunternet/p/11248192.html</p></blockquote><h4 id="_4-4-2-重点" tabindex="-1"><a class="header-anchor" href="#_4-4-2-重点"><span>4.4.2.重点</span></a></h4><ol><li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。</li><li>Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成， 其中 zskiplist 用于保存**<span color="#159957">跳跃表信息</span><strong>（比如表头节点、表尾节点、长度）， 而 zskiplistNode 则用于表示</strong><span color="#159957">跳跃表节点</span>**。</li><li>每个跳跃表节点的层高都是 <strong><span color="#159957">1 至 32</span></strong> 之间的**<span color="#159957">随机数</span>**。</li><li>在同一个跳跃表中， 多个节点可以包含**<span color="#159957">相同的分值</span><strong>， 但每个节点的</strong><span color="#159957">成员对象必须是唯一</span>**的。</li><li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li></ol><h3 id="_4-5-整数集合" tabindex="-1"><a class="header-anchor" href="#_4-5-整数集合"><span>4.5.整数集合</span></a></h3><ul><li><strong>整数集合</strong>是**<span color="#159957">集合键(set)</span>**的底层实现之一。</li><li>整数集合的底层实现为**<span color="#159957">数组</span><strong>， 这个数组以</strong><span color="#159957">有序、无重复</span><strong>的方式保存集合元素，在有需要时， 程序会根据</strong><span color="#159957">新添加元素</span>**的类型， <strong><span color="#159957">改变这个数组的类型</span></strong>。</li><li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地<strong>节约了内存</strong>。</li><li>整数集合**<span color="#159957">只支持升级</span>**操作， 不支持降级操作。</li></ul><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 的整数值， 并且保证集合中不会出现**<span color="#159957">重复元素</span>**。</p><p>数据结构：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> intset {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 编码方式</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> encoding;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 集合包含的元素数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> length;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 保存元素的数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    int8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> contents</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} intset;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093117.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><h3 id="_4-6-压缩列表" tabindex="-1"><a class="header-anchor" href="#_4-6-压缩列表"><span>4.6.压缩列表</span></a></h3><h4 id="_4-6-1-前言" tabindex="-1"><a class="header-anchor" href="#_4-6-1-前言"><span>4.6.1.前言</span></a></h4><blockquote><p>同整数集合一样压缩列表也不是基础数据结构，而是 <strong>Redis</strong> 自己设计的一种数据存储结构。它有点儿类似数组，通过一片**<span color="#159957">连续的内存空间</span>**，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。</p></blockquote><p>我们知道，数组要求每个元素大大小相同，如果要存储长度不同的字符串，那就需要用**<span color="#159957">最大长度</span>**的字符串大小作为元素的大小。以最大长度为标准，就会浪费一部分存储空间。</p><p>数组的优势占用一片**<span color="#159957">连续的空间</span>**可以很好的利用CPU缓存访问数据。如果我们想要保留这种优势，又想节省存储空间我们可以对数组进行压缩。</p><p>那就需要给每个节点增加一个 <code>lenght</code> 的属性。</p><h4 id="_4-6-2-redis-压缩列表" tabindex="-1"><a class="header-anchor" href="#_4-6-2-redis-压缩列表"><span>4.6.2.Redis 压缩列表</span></a></h4><p><em>压缩列表(zip1ist)是 Redis 列表和 Redis 哈希的底层实现之一。</em></p><ul><li><p>当一个列表只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表的底层实现。</p></li><li><p>当一个哈希只包含少量键值对,比且每个键值对的键和值要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做哈希的底层实现。</p></li></ul><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093120.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><blockquote><p>参考：https://www.cnblogs.com/hunternet/p/11306690.html</p></blockquote><ol><li>表是Redis为节约内存自己设计的一种顺序型数据结构。</li><li>表被用作列表键和哈希键的底层实现之一。</li><li>压缩列表可以包含多个节点,每个节点可以保存一个字节数组或者整数值。</li><li>添加新节点到压缩列表,或者从压缩列表中删除节点,可能会引发连锁更新操作,但这种操作出现的几率并不高。</li></ol><h3 id="_4-7-redis的对象" tabindex="-1"><a class="header-anchor" href="#_4-7-redis的对象"><span>4.7.Redis的对象</span></a></h3><h4 id="_4-7-1-redis的对象" tabindex="-1"><a class="header-anchor" href="#_4-7-1-redis的对象"><span>4.7.1.Redis的对象</span></a></h4><p>Redis 中当我们创建一个键值对时，我们至少会创建俩个对象，一个用作键(键对象)，一个用作值(值对象)。</p><ul><li>Redis 对象结构</li></ul><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> redisObject {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> type:</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 编码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> encoding:</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 指向底层实现数据结构的指针</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ptr;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} robj;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>Redis 内存回收</strong></li></ul><blockquote><p>值得一提的是 redis 内存回收，因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个**<span color="#159957">引用计数</span><strong>（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行</strong><span color="#159957">内存回收</span>**。每个对象的引用计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录：</p></blockquote><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> redisObject {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 引用计数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> refcount;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} robj;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>Redis 对象共享</strong></li></ul><blockquote><p>举个例子， 假设键 A 创建了一个包含整数值 100 的字符串对象作为值对象，如果这时键 B 也要创建一个同样保存了整数值 100 的字符串对象作为值对象。</p></blockquote><p>在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：</p><ol><li>将数据库键的值指针指向一个现有的值对象；</li><li>将被共享的值对象的引用计数增一。</li></ol><p><code>目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</code></p><ul><li><strong>Redis 对象的空转时长</strong></li></ul><blockquote><p>除了前面介绍过的 <strong><span color="#159957">type 、 encoding 、 ptr 和 refcount</span></strong> 四个属性之外， redisObject 结构包含的最后一个属性为 <strong><span color="#159957">lru</span></strong> 属性， 该属性记录了对象最后一次被命令程序访问的时间：</p></blockquote><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> redisObject {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> lru:</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} robj;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-7-2-重点" tabindex="-1"><a class="header-anchor" href="#_4-7-2-重点"><span>4.7.2.重点</span></a></h4><blockquote><p>内存回收和对象的空转时长涉及到 Redis 配置文件(内存的算法 volatile-lru、allkeys-lru等其他知识点)，后面单独一篇详细讲解。</p></blockquote><ul><li>Redis 数据库中的每个键值对的键和值都是一个对象。</li><li>Redis 共有字**<span color="#159957">符串、列表、哈希、集合、有序集合</span>**五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。</li><li>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</li><li>Redis 的对象系统带有引用计数实现的**<span color="#159957">内存回收机制</span>**， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。</li><li>Redis 会共享值为 0 到 9999 的字符串对象。</li><li>对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的**<span color="#159957">空转时间</span>**。</li></ul>`,119);function d(r,k){return e(),a("div",null,[h,n(" more "),p])}const g=i(t,[["render",d],["__file","learn_redis_02.html.vue"]]),v=JSON.parse('{"path":"/posts/database/redis/learn_redis_02.html","title":"rodert单排学习redis进阶【青铜】","lang":"zh-CN","frontmatter":{"title":"rodert单排学习redis进阶【青铜】","icon":"lightbulb","category":["redis"],"tag":["redis","单排学习redis"],"description":"rodert单排学习redis进阶【青铜】","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/posts/database/redis/learn_redis_02.html"}],["meta",{"property":"og:site_name","content":"JavaPub"}],["meta",{"property":"og:title","content":"rodert单排学习redis进阶【青铜】"}],["meta",{"property":"og:description","content":"rodert单排学习redis进阶【青铜】"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-094232.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-03T14:35:52.000Z"}],["meta",{"property":"article:author","content":"Mr.Wang"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:tag","content":"单排学习redis"}],["meta",{"property":"article:modified_time","content":"2024-07-03T14:35:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"rodert单排学习redis进阶【青铜】\\",\\"image\\":[\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-094232.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-094234.jpeg\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-094237.jpeg\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093006.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093016.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093024.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093059.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093102.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093106.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093110.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093113.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093117.png\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F15%2F20240615-093120.png\\"],\\"dateModified\\":\\"2024-07-03T14:35:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Wang\\",\\"url\\":\\"https://javapub.net.cn\\"}]}"]]},"headers":[{"level":2,"title":"rodert单排学习redis进阶【青铜】","slug":"rodert单排学习redis进阶【青铜】","link":"#rodert单排学习redis进阶【青铜】","children":[]},{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"1.再谈Redis","slug":"_1-再谈redis","link":"#_1-再谈redis","children":[]},{"level":2,"title":"2.为什么要用Redis","slug":"_2-为什么要用redis","link":"#_2-为什么要用redis","children":[]},{"level":2,"title":"3.为什么要使用缓存？","slug":"_3-为什么要使用缓存","link":"#_3-为什么要使用缓存","children":[]},{"level":2,"title":"4.Redis数据结构","slug":"_4-redis数据结构","link":"#_4-redis数据结构","children":[{"level":3,"title":"4.1.SDS简单动态字符串","slug":"_4-1-sds简单动态字符串","link":"#_4-1-sds简单动态字符串","children":[]},{"level":3,"title":"4.2.Redis 链表和链表节点","slug":"_4-2-redis-链表和链表节点","link":"#_4-2-redis-链表和链表节点","children":[]},{"level":3,"title":"4.3.Redis 字典","slug":"_4-3-redis-字典","link":"#_4-3-redis-字典","children":[]},{"level":3,"title":"4.4.跳跃表","slug":"_4-4-跳跃表","link":"#_4-4-跳跃表","children":[]},{"level":3,"title":"4.5.整数集合","slug":"_4-5-整数集合","link":"#_4-5-整数集合","children":[]},{"level":3,"title":"4.6.压缩列表","slug":"_4-6-压缩列表","link":"#_4-6-压缩列表","children":[]},{"level":3,"title":"4.7.Redis的对象","slug":"_4-7-redis的对象","link":"#_4-7-redis的对象","children":[]}]}],"git":{"createdTime":1718350679000,"updatedTime":1720017352000,"contributors":[{"name":"wangshiyu","email":"iswangshiyu@foxmail.com","commits":1}]},"readingTime":{"minutes":17.51,"words":5252},"filePathRelative":"posts/database/redis/learn_redis_02.md","localizedDate":"2024年6月14日","excerpt":"<h2>rodert单排学习redis进阶【青铜】</h2>\\n","autoDesc":true}');export{g as comp,v as data};
