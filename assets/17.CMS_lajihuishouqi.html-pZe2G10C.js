import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as i,b as t,w as a,d as s,e,r,o as p}from"./app-BuoHmt6k.js";const h={},d=i("p",null,[i("strong",null,[s("我是 javapub，一名 "),i("code",null,"Markdown"),s(" 程序员从👨‍💻，八股文种子选手。")])],-1),c=e(`<ol><li><strong>初始标记</strong>:只标记GC Roots能直接关联的对象,速度快,与用户线程共享运行,不需要Stop The World。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 初始标记代码示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> initialMark</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> strongRefs) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        CMSCollector</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">mark</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(obj);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>并发标记</strong>:从GC Roots开始递归的标记对象图,与用户线程一起工作,需要部分STW阶段。</li><li><strong>最终标记</strong>:修正在并发标记期间并发修改导致的错误标记,需要STW。</li><li><strong>并发清除</strong>:与用户线程一起工作,清除被标记的对象,不需要STW。</li><li><strong>并发重置</strong>:与用户线程一起工作,为下一次GC做准备,不需要STW。</li></ol>`,3),u=i("ul",null,[i("li",null,"并发标记阶段与用户线程一起运行,在标记过程中对象图可能被修改,会产生”脏标记“。需要最终标记修正。"),i("li",null,"最终标记阶段需要Stop The World,去修正并发标记期间的”脏标记“,确保正确的标记对象。"),i("li",null,"如果没有最终标记阶段,并发标记的”脏标记“会导致非垃圾对象被清除,或者垃圾对象未被清除。"),i("li",null,"所以,最终标记阶段是CMS算法关键,它通过STW去修正并发阶段的错误”脏标记“,使得CMS并发标记清除算法成为可能。")],-1),k=i("ol",null,[i("li",null,"会产生大量空间碎片,空间利用率低。"),i("li",null,"标记和清除过程需要占用CPU资源,并发时会对程序性能产生一定影响。"),i("li",null,"并发执行时,需要处理一致性问题,会加大开发难度。"),i("li",null,"只适用于老年代回收,新生代仍需其他收集器配合。"),i("li",null,"浮动垃圾可能带来更长的GC停顿时间,不适用于需要极低停顿的场景。")],-1),g=i("p",null,"所以,CMS 是一款比较经典的低停顿收集器,但也存在一定的缺陷, v在JDK9后G1成为了更好的选择。但CMS算法本身的思想仍然值得我们学习。",-1),C=e(`<ol><li>在并发标记阶段,需与用户程序同时运行,无法移动对象。</li><li>在并发清除阶段,直接清除标记的垃圾对象,留下空隙。</li><li>这些空隙会产生空间碎片,并不连续,但空间可能不足以分配较大对象。</li><li>空间利用率降低,达不到理想状态,需要更频繁的Major GC来整理空间。 我们可以从JVM源码中看到CMSCollector在清除对象后直接造成碎片:</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//CMSCollector.java</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> sweep </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">phase</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> markedObjects) { </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        freeMemory</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(obj)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> // 直接清除,产生碎片</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为解决这个问题,CMS做了一些努力:</p><ol><li>采用Free-list维护小块空闲空间, satisfiy小对象分配。</li><li>对象晋升到老年代时预留一定空间减少碎片。</li><li>空间报警触发Minor GC和Full GC,做空间整合。</li><li>可配置启动Incremental CMS模式,进入并发清理阶段做连续空间整理。</li></ol><p>但由于算法的限制,CMS仍无法完全解决碎片空间问题,这也是它被G1等收集器替代的原因之一。</p>`,5),m=i("ol",null,[i("li",null,"将清理过程分为并发和STW两个阶段,大大减少停顿。"),i("li",null,"通过最终标记修正并发阶段的”脏标记“,使得并发标记成为可能。"),i("li",null,"采用Free-list和预留空间等手段减轻空间碎片问题。"),i("li",null,"根据空间利用率与GC时间的平衡,选择满足需求的收集频率。")],-1),v=i("p",null,"这些思想为我们设计低停顿、高效的GC算法提供了参考,CMS也因此成为Java垃圾收集史上的里程碑。所以,尽管它有缺陷,但它的算法思想和理念仍十分值得我们学习。",-1),b=e('<figure><img src="https://ghproxy.com/https://raw.githubusercontent.com/Rodert/javapub_oss/main/other/17.jpg?raw=true" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注<strong>公众号JavaPub</strong>追更！</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F06%2F20240606-225632.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>🎁目录合集：</p><p>Gitee：<code>https://gitee.com/rodert/JavaPub</code></p><p>GitHub：<code>https://github.com/Rodert/JavaPub</code></p><p><a href="http://javapub.net.cn" target="_blank" rel="noopener noreferrer">http://javapub.net.cn</a></p>',7);function y(f,M){const l=r("font");return p(),o("div",null,[d,i("p",null,[i("strong",null,[t(l,{color:"blue"},{default:a(()=>[s("面试官")]),_:1}),s("： 小伙子,CMS 垃圾收集器跟我讲讲?")])]),i("p",null,[i("strong",null,[t(l,{color:"red"},{default:a(()=>[s("候选人：")]),_:1})]),s(" CMS全称Concurrent Mark Sweep,是一种并发标记清除算法。它并发执行与用户程序,减少垃圾收集时程序暂停的时间。")]),i("p",null,[i("strong",null,[t(l,{color:"blue"},{default:a(()=>[s("面试官")]),_:1}),s("： 说白了,CMS就是为了减少卡顿吧?")])]),i("p",null,[i("strong",null,[t(l,{color:"red"},{default:a(()=>[s("候选人：")]),_:1})]),s(" 是的,CMS 的核心目标就是达到并发收集、减少停顿。它的工作流程如下:")]),c,i("p",null,[i("strong",null,[t(l,{color:"blue"},{default:a(()=>[s("面试官")]),_:1}),s("： 说说并发标记和最终标记的区别?")])]),i("p",null,[i("strong",null,[t(l,{color:"red"},{default:a(()=>[s("候选人：")]),_:1})])]),u,i("p",null,[i("strong",null,[t(l,{color:"blue"},{default:a(()=>[s("面试官")]),_:1}),s("： CMS 收集器的优缺点分别是什么?")])]),i("p",null,[i("strong",null,[t(l,{color:"red"},{default:a(()=>[s("候选人：")]),_:1})]),s(" CMS 收集器的主要优点是并发收集、低停顿,适用于对响应时间有要求的场景。 但是CMS也有一些缺点:")]),k,g,i("p",null,[i("strong",null,[t(l,{color:"blue"},{default:a(()=>[s("面试官")]),_:1}),s("： 说说CMS 收集器的“碎片化”问题?")])]),i("p",null,[i("strong",null,[t(l,{color:"red"},{default:a(()=>[s("候选人：")]),_:1})]),s(" CMS 是一种标记-清除算法,它会产生大量空间碎片,空间利用率低是一个缺点。这是因为:")]),C,i("p",null,[i("strong",null,[t(l,{color:"blue"},{default:a(()=>[s("面试官")]),_:1}),s("： 谢谢详细的解释!CMS 收集器虽然有缺陷,但它的并发标记清除思想影响了后续的垃圾回收算法。")])]),i("p",null,[i("strong",null,[t(l,{color:"red"},{default:a(()=>[s("候选人：")]),_:1})]),s(" 是的,CMS 收集器提出了并发收集和低停顿的理念,其中的并发标记清除算法也为之后G1等收集器奠定了基础。它的关键思想值得我们学习:")]),m,v,i("p",null,[i("strong",null,[t(l,{color:"blue"},{default:a(()=>[s("面试官")]),_:1}),s("： 很好,你对CMS收集器的理解已经相当透彻!希望你在日后继续深入学习其他垃圾收集算法。")])]),i("p",null,[i("strong",null,[t(l,{color:"red"},{default:a(()=>[s("候选人：")]),_:1})]),s(" 非常感谢您的夸奖和建议!我会继续努力学习和研究垃圾收集theory与实践,包括G1、ZGC、Epsilon等算法与案例。谢谢您的提问,让我有机会深入梳理CMS以及Java垃圾收集机制,收获颇丰!")]),i("p",null,[i("strong",null,[t(l,{color:"blue"},{default:a(()=>[s("面试官")]),_:1}),s("： 看来有点东西，你先等一下！")])]),b])}const E=n(h,[["render",y],["__file","17.CMS_lajihuishouqi.html.vue"]]),j=JSON.parse('{"path":"/posts/special/1v1/17.CMS_lajihuishouqi.html","title":"CMS垃圾回收器","lang":"zh-CN","frontmatter":{"title":"CMS垃圾回收器","icon":"laptop-code","category":["《面试1v1》"],"description":"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。 ： 小伙子,CMS 垃圾收集器跟我讲讲? CMS全称Concurrent Mark Sweep,是一种并发标记清除算法。它并发执行与用户程序,减少垃圾收集时程序暂停的时间。 ： 说白了,CMS就是为了减少卡顿吧? 是的,CMS 的核心目标就是达到并发收集、减少停顿。它的...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/posts/special/1v1/17.CMS_lajihuishouqi.html"}],["meta",{"property":"og:site_name","content":"JavaPub"}],["meta",{"property":"og:title","content":"CMS垃圾回收器"}],["meta",{"property":"og:description","content":"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。 ： 小伙子,CMS 垃圾收集器跟我讲讲? CMS全称Concurrent Mark Sweep,是一种并发标记清除算法。它并发执行与用户程序,减少垃圾收集时程序暂停的时间。 ： 说白了,CMS就是为了减少卡顿吧? 是的,CMS 的核心目标就是达到并发收集、减少停顿。它的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://ghproxy.com/https://raw.githubusercontent.com/Rodert/javapub_oss/main/other/17.jpg?raw=true"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-03T14:35:52.000Z"}],["meta",{"property":"article:author","content":"Mr.Wang"}],["meta",{"property":"article:modified_time","content":"2024-07-03T14:35:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CMS垃圾回收器\\",\\"image\\":[\\"https://ghproxy.com/https://raw.githubusercontent.com/Rodert/javapub_oss/main/other/17.jpg?raw=true\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F06%2F20240606-225632.png\\"],\\"dateModified\\":\\"2024-07-03T14:35:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Wang\\",\\"url\\":\\"https://javapub.net.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1717568495000,"updatedTime":1720017352000,"contributors":[{"name":"wangshiyu","email":"iswangshiyu@foxmail.com","commits":1}]},"readingTime":{"minutes":5.35,"words":1605},"filePathRelative":"posts/special/1v1/17.CMS_lajihuishouqi.md","localizedDate":"2024年6月5日","excerpt":"<p><strong>我是 javapub，一名 <code>Markdown</code> 程序员从👨‍💻，八股文种子选手。</strong></p>\\n<p><strong>： 小伙子,CMS 垃圾收集器跟我讲讲?</strong></p>\\n<p><strong></strong> CMS全称Concurrent Mark Sweep,是一种并发标记清除算法。它并发执行与用户程序,减少垃圾收集时程序暂停的时间。</p>\\n<p><strong>： 说白了,CMS就是为了减少卡顿吧?</strong></p>\\n<p><strong></strong> 是的,CMS 的核心目标就是达到并发收集、减少停顿。它的工作流程如下:</p>","autoDesc":true}');export{E as comp,j as data};
