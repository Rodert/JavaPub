import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,e as n}from"./app-C2Z-6ncV.js";const l={},e=n(`<h1 id="cas-和自旋锁" tabindex="-1"><a class="header-anchor" href="#cas-和自旋锁"><span>CAS 和自旋锁</span></a></h1><h2 id="cas-compare-and-swap" tabindex="-1"><a class="header-anchor" href="#cas-compare-and-swap"><span>CAS (Compare-And-Swap)</span></a></h2><p>CAS 是一种原子操作，全称为&quot;比较并交换&quot;(Compare-And-Swap)。它是实现无锁数据结构和算法的基础，也是许多并发框架的核心机制。</p><h3 id="cas-的基本原理" tabindex="-1"><a class="header-anchor" href="#cas-的基本原理"><span>CAS 的基本原理</span></a></h3><p>CAS 操作包含三个操作数：</p><ul><li><strong>内存位置 V</strong>：需要读写的内存位置</li><li><strong>预期值 A</strong>：预期内存位置 V 中存储的值</li><li><strong>新值 B</strong>：如果 V 中的值等于 A，则将 V 的值更新为 B</li></ul><p>CAS 的伪代码表示：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> compareAndSwap</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(V</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> B) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (V </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> A) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        V </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CAS 操作是原子的，意味着它在执行期间不会被中断，要么完全执行成功，要么完全不执行。</p><h3 id="cas-在-java-中的应用" tabindex="-1"><a class="header-anchor" href="#cas-在-java-中的应用"><span>CAS 在 Java 中的应用</span></a></h3><p>在 Java 中，<code>java.util.concurrent.atomic</code> 包提供了一系列基于 CAS 操作的原子类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">AtomicInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> AtomicInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 原子地将当前值增加1，并返回更新后的值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> updatedValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> counter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">incrementAndGet</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 原子地比较当前值是否等于期望值，如果是则更新为新值并返回true</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> success </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> counter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">compareAndSet</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(updatedValue, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="cas-的优缺点" tabindex="-1"><a class="header-anchor" href="#cas-的优缺点"><span>CAS 的优缺点</span></a></h3><p><strong>优点：</strong></p><ol><li><strong>无锁</strong>：不需要加锁解锁操作，减少了线程上下文切换和调度的开销</li><li><strong>高效</strong>：在竞争不激烈的情况下，性能远高于互斥锁</li><li><strong>适合实现原子操作</strong>：尤其适合简单变量的原子更新</li></ol><p><strong>缺点：</strong></p><ol><li><strong>ABA 问题</strong>：如果一个值从 A 变成 B 再变回 A，CAS 检查时会认为它没有被修改过</li><li><strong>循环时间长开销大</strong>：如果 CAS 失败，通常会不断重试，可能会消耗较多的 CPU 资源</li><li><strong>只能保证单个变量的原子性</strong>：无法保证多个变量的原子性操作</li></ol><h3 id="aba-问题解决方案" tabindex="-1"><a class="header-anchor" href="#aba-问题解决方案"><span>ABA 问题解决方案</span></a></h3><p>ABA 问题可以通过引入版本号或时间戳来解决：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 使用 AtomicStampedReference 解决 ABA 问题</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">AtomicStampedReference</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> reference </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> AtomicStampedReference</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 获取当前值和版本号</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> stamp </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> reference</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getStamp</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> reference</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getReference</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// CAS 操作时同时检查值和版本号</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">reference</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">compareAndSet</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(value, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">101</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, stamp, stamp </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="自旋锁-spin-lock" tabindex="-1"><a class="header-anchor" href="#自旋锁-spin-lock"><span>自旋锁 (Spin Lock)</span></a></h2><p>自旋锁是一种基于忙等待（busy waiting）的锁机制，线程在请求获取锁时，如果锁已被其他线程持有，会一直循环检查锁是否可用，而不是被阻塞或进入睡眠状态。</p><h3 id="自旋锁的基本原理" tabindex="-1"><a class="header-anchor" href="#自旋锁的基本原理"><span>自旋锁的基本原理</span></a></h3><p>自旋锁的基本实现通常基于 CAS 操作：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> SimpleSpinLock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> AtomicReference</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> owner </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> AtomicReference</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> currentThread</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 如果锁已被获取，则自旋等待</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">owner</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">compareAndSet</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, currentThread)) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">            // 自旋等待</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> currentThread</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        owner</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">compareAndSet</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(currentThread, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自旋锁的类型" tabindex="-1"><a class="header-anchor" href="#自旋锁的类型"><span>自旋锁的类型</span></a></h3><ol><li><strong>简单自旋锁</strong>：基本的自旋实现，如上述代码所示</li><li><strong>TicketLock</strong>：采用类似排队叫号的机制，避免线程饥饿</li><li><strong>CLH 锁</strong>：基于链表的公平自旋锁，减少了空间复杂度</li><li><strong>MCS 锁</strong>：也是基于链表的公平自旋锁，但每个线程自旋在本地变量上，降低了缓存一致性协议开销</li></ol><h3 id="自旋锁的适用场景" tabindex="-1"><a class="header-anchor" href="#自旋锁的适用场景"><span>自旋锁的适用场景</span></a></h3><p>自旋锁适用于以下场景：</p><ol><li><strong>锁持有时间短</strong>：如果锁被持有的时间很短，自旋等待可能比线程阻塞和唤醒更高效</li><li><strong>处理器资源丰富</strong>：在多核处理器上，一个线程的自旋不会影响其他线程的执行</li><li><strong>实时性要求高</strong>：避免线程调度带来的延迟</li></ol><h3 id="自旋锁的优缺点" tabindex="-1"><a class="header-anchor" href="#自旋锁的优缺点"><span>自旋锁的优缺点</span></a></h3><p><strong>优点：</strong></p><ol><li><strong>避免上下文切换</strong>：线程不会被挂起，减少了线程调度的开销</li><li><strong>响应更快</strong>：在锁被持有时间短的情况下，自旋等待可以更快地获取锁</li></ol><p><strong>缺点：</strong></p><ol><li><strong>CPU 资源消耗</strong>：自旋会消耗处理器时间，如果锁被长时间持有，会造成资源浪费</li><li><strong>不公平</strong>：基本的自旋锁可能导致某些线程长时间无法获取锁（饥饿问题）</li><li><strong>优化困难</strong>：难以确定最佳的自旋次数</li></ol><h3 id="java-中的自旋锁应用" tabindex="-1"><a class="header-anchor" href="#java-中的自旋锁应用"><span>Java 中的自旋锁应用</span></a></h3><p>在 Java 中，显式的自旋锁很少直接使用，但 JVM 中的锁实现（如 synchronized）在内部可能使用自旋优化：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// synchronized 在轻量级锁状态可能使用自旋优化</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (lock) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 临界区代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 也可以使用 ReentrantLock</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 临界区代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="适应性自旋锁" tabindex="-1"><a class="header-anchor" href="#适应性自旋锁"><span>适应性自旋锁</span></a></h3><p>Java 的 HotSpot VM 使用&quot;适应性自旋锁&quot;，它会根据前一次自旋的效果动态调整自旋的时间：</p><ul><li>如果前几次自旋获取到了锁，会增加自旋次数</li><li>如果自旋很少成功，则会减少自旋次数，甚至不自旋</li></ul><h2 id="cas-与自旋锁的关系" tabindex="-1"><a class="header-anchor" href="#cas-与自旋锁的关系"><span>CAS 与自旋锁的关系</span></a></h2><p>CAS 是自旋锁实现的基础，自旋锁通常使用 CAS 操作来实现无锁的同步机制。两者关系如下：</p><ol><li>CAS 是一种底层原子操作，自旋锁是一种基于 CAS 的同步机制</li><li>自旋锁通常在 CAS 失败时进行自旋重试</li><li>两者都属于乐观并发控制的范畴，相比传统的悲观锁定，在低竞争情况下性能更好</li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>CAS 和自旋锁在现代并发编程中扮演着重要角色：</p><ul><li><strong>CAS</strong> 提供了无锁的原子操作能力，是实现高性能并发算法的基础</li><li><strong>自旋锁</strong> 通过忙等待而非线程阻塞提供了低延迟的同步机制，适用于锁竞争不激烈且锁持有时间短的场景</li></ul><p>理解这两种机制对于设计和实现高性能并发系统非常重要，但同时也需要注意它们的局限性和适用场景。</p>`,48),t=[e];function h(k,p){return a(),s("div",null,t)}const c=i(l,[["render",h],["__file","cas.html.vue"]]),g=JSON.parse('{"path":"/posts/algorithms_data_structures/algorithms/cas.html","title":"cas和自旋锁","lang":"zh-CN","frontmatter":{"title":"cas和自旋锁","icon":"lightbulb","author":"Wang Shiyu","date":"2025-03-31T00:00:00.000Z","category":["算法"],"tag":["算法","cas","自旋锁"],"description":"CAS 和自旋锁 CAS (Compare-And-Swap) CAS 是一种原子操作，全称为\\"比较并交换\\"(Compare-And-Swap)。它是实现无锁数据结构和算法的基础，也是许多并发框架的核心机制。 CAS 的基本原理 CAS 操作包含三个操作数： 内存位置 V：需要读写的内存位置 预期值 A：预期内存位置 V 中存储的值 新值 B：如果 V...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/JavaPub/posts/algorithms_data_structures/algorithms/cas.html"}],["meta",{"property":"og:site_name","content":"JavaPub"}],["meta",{"property":"og:title","content":"cas和自旋锁"}],["meta",{"property":"og:description","content":"CAS 和自旋锁 CAS (Compare-And-Swap) CAS 是一种原子操作，全称为\\"比较并交换\\"(Compare-And-Swap)。它是实现无锁数据结构和算法的基础，也是许多并发框架的核心机制。 CAS 的基本原理 CAS 操作包含三个操作数： 内存位置 V：需要读写的内存位置 预期值 A：预期内存位置 V 中存储的值 新值 B：如果 V..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T08:07:59.000Z"}],["meta",{"property":"article:author","content":"Wang Shiyu"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:tag","content":"cas"}],["meta",{"property":"article:tag","content":"自旋锁"}],["meta",{"property":"article:published_time","content":"2025-03-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T08:07:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"cas和自旋锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-31T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T08:07:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Wang Shiyu\\"}]}"]]},"headers":[{"level":2,"title":"CAS (Compare-And-Swap)","slug":"cas-compare-and-swap","link":"#cas-compare-and-swap","children":[{"level":3,"title":"CAS 的基本原理","slug":"cas-的基本原理","link":"#cas-的基本原理","children":[]},{"level":3,"title":"CAS 在 Java 中的应用","slug":"cas-在-java-中的应用","link":"#cas-在-java-中的应用","children":[]},{"level":3,"title":"CAS 的优缺点","slug":"cas-的优缺点","link":"#cas-的优缺点","children":[]},{"level":3,"title":"ABA 问题解决方案","slug":"aba-问题解决方案","link":"#aba-问题解决方案","children":[]}]},{"level":2,"title":"自旋锁 (Spin Lock)","slug":"自旋锁-spin-lock","link":"#自旋锁-spin-lock","children":[{"level":3,"title":"自旋锁的基本原理","slug":"自旋锁的基本原理","link":"#自旋锁的基本原理","children":[]},{"level":3,"title":"自旋锁的类型","slug":"自旋锁的类型","link":"#自旋锁的类型","children":[]},{"level":3,"title":"自旋锁的适用场景","slug":"自旋锁的适用场景","link":"#自旋锁的适用场景","children":[]},{"level":3,"title":"自旋锁的优缺点","slug":"自旋锁的优缺点","link":"#自旋锁的优缺点","children":[]},{"level":3,"title":"Java 中的自旋锁应用","slug":"java-中的自旋锁应用","link":"#java-中的自旋锁应用","children":[]},{"level":3,"title":"适应性自旋锁","slug":"适应性自旋锁","link":"#适应性自旋锁","children":[]}]},{"level":2,"title":"CAS 与自旋锁的关系","slug":"cas-与自旋锁的关系","link":"#cas-与自旋锁的关系","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1743408479000,"updatedTime":1743408479000,"contributors":[{"name":"javapub","email":"iswangshiyu@foxmail.com","commits":1}]},"readingTime":{"minutes":4.89,"words":1466},"filePathRelative":"posts/algorithms_data_structures/algorithms/cas.md","localizedDate":"2025年3月31日","excerpt":"\\n<h2>CAS (Compare-And-Swap)</h2>\\n<p>CAS 是一种原子操作，全称为\\"比较并交换\\"(Compare-And-Swap)。它是实现无锁数据结构和算法的基础，也是许多并发框架的核心机制。</p>\\n<h3>CAS 的基本原理</h3>\\n<p>CAS 操作包含三个操作数：</p>\\n<ul>\\n<li><strong>内存位置 V</strong>：需要读写的内存位置</li>\\n<li><strong>预期值 A</strong>：预期内存位置 V 中存储的值</li>\\n<li><strong>新值 B</strong>：如果 V 中的值等于 A，则将 V 的值更新为 B</li>\\n</ul>","autoDesc":true}');export{c as comp,g as data};
