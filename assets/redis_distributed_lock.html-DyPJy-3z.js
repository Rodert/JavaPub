import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as s,e as t}from"./app-Cg7wluTA.js";const a={},n=t(`<p>参考： https://juejin.cn/post/7178327462869205051#heading-1</p><h2 id="redis分布式锁要注意哪几点-离bug远一点" tabindex="-1"><a class="header-anchor" href="#redis分布式锁要注意哪几点-离bug远一点"><span>Redis分布式锁要注意哪几点...离BUG远一点</span></a></h2><p>当前开发中，为了避免应用出现单点故障，大多数应用都会部署多个节点。分布式应用部署，就会涉及到状态同步的场景，比如 <code>session</code> 共享，单点抢占式任务执行、秒杀抢购等等。比如我最近开发中需要一个邮件验证码发送服务，这个邮件服务是一个死循环，持续轮训表里有没有需要发送验证码的邮箱地址，保证实时性的同时，并且不可以重复发送。</p><p>这时，分布式锁就成为一个必要、且简单的解决方案。这里基于 Redis 特性和分布式场景来分析会遇到哪些关键点。</p><p><strong>前言</strong> 众所周知，redis 是单线程应用，就算是 v6 版本也是网络并发、键值读写依然是单线程。</p><ol><li>原子操作（setnx + expire）</li></ol><p>说到分布式锁，很多人一定会想到 <code>setnx + expire</code> 命令， <code>setnx</code> 用来抢占锁（不存在就创建、存在就不做任何操作），抢到后再设置<strong>过期时间</strong>。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 抢占锁</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">jedis</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">setnx</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key_lock, value)</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 设置过期时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    jedis</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">expire</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key_lock, expiration_time);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // TODO Something</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个代码有很明显的问题，当程序执行完 <code>setnx</code> 后出现异常宕机，这是后这个锁就永久无法释放了。造成的后果是：需要拿到这个锁来获取执行任务权限的应用都停止了。</p><ol start="2"><li></li></ol><p>原文： <a href="https://javapub.net.cn/posts/database/redis/" target="_blank" rel="noopener noreferrer">https://javapub.net.cn/posts/database/redis/</a></p>`,11),r=[n];function l(p,d){return s(),i("div",null,r)}const c=e(a,[["render",l],["__file","redis_distributed_lock.html.vue"]]),k=JSON.parse('{"path":"/posts/database/redis/redis_distributed_lock.html","title":"Redis分布式锁要点注意","lang":"zh-CN","frontmatter":{"title":"Redis分布式锁要点注意","icon":"lightbulb","category":["redis","分布式","锁"],"tag":["redis","分布式","锁","lock"],"description":"参考： https://juejin.cn/post/7178327462869205051#heading-1 Redis分布式锁要注意哪几点...离BUG远一点 当前开发中，为了避免应用出现单点故障，大多数应用都会部署多个节点。分布式应用部署，就会涉及到状态同步的场景，比如 session 共享，单点抢占式任务执行、秒杀抢购等等。比如我最近开发中需...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/posts/database/redis/redis_distributed_lock.html"}],["meta",{"property":"og:site_name","content":"JavaPub"}],["meta",{"property":"og:title","content":"Redis分布式锁要点注意"}],["meta",{"property":"og:description","content":"参考： https://juejin.cn/post/7178327462869205051#heading-1 Redis分布式锁要注意哪几点...离BUG远一点 当前开发中，为了避免应用出现单点故障，大多数应用都会部署多个节点。分布式应用部署，就会涉及到状态同步的场景，比如 session 共享，单点抢占式任务执行、秒杀抢购等等。比如我最近开发中需..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-17T11:18:31.000Z"}],["meta",{"property":"article:author","content":"Mr.Wang"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:tag","content":"分布式"}],["meta",{"property":"article:tag","content":"锁"}],["meta",{"property":"article:tag","content":"lock"}],["meta",{"property":"article:modified_time","content":"2024-07-17T11:18:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis分布式锁要点注意\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-17T11:18:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Wang\\",\\"url\\":\\"https://javapub.net.cn\\"}]}"]]},"headers":[{"level":2,"title":"Redis分布式锁要注意哪几点...离BUG远一点","slug":"redis分布式锁要注意哪几点-离bug远一点","link":"#redis分布式锁要注意哪几点-离bug远一点","children":[]}],"git":{"createdTime":1721215111000,"updatedTime":1721215111000,"contributors":[{"name":"wangshiyu","email":"iswangshiyu@foxmail.com","commits":1}]},"readingTime":{"minutes":1.41,"words":422},"filePathRelative":"posts/database/redis/redis_distributed_lock.md","localizedDate":"2024年7月17日","excerpt":"<p>参考： https://juejin.cn/post/7178327462869205051#heading-1</p>\\n<h2>Redis分布式锁要注意哪几点...离BUG远一点</h2>\\n<p>当前开发中，为了避免应用出现单点故障，大多数应用都会部署多个节点。分布式应用部署，就会涉及到状态同步的场景，比如 <code>session</code> 共享，单点抢占式任务执行、秒杀抢购等等。比如我最近开发中需要一个邮件验证码发送服务，这个邮件服务是一个死循环，持续轮训表里有没有需要发送验证码的邮箱地址，保证实时性的同时，并且不可以重复发送。</p>\\n<p>这时，分布式锁就成为一个必要、且简单的解决方案。这里基于 Redis 特性和分布式场景来分析会遇到哪些关键点。</p>","autoDesc":true}');export{c as comp,k as data};
