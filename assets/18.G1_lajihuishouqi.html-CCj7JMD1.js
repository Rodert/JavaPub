import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as i,b as l,w as e,d as s,e as n,r as h,o as p}from"./app-Bu5key1w.js";const o={},d=i("p",null,[i("strong",null,[s("我是 javapub，一名 "),i("code",null,"Markdown"),s(" 程序员从👨‍💻，八股文种子选手。")])],-1),k=n(`<ol><li>并发和增量式回收:不像CMS要全部STW,G1可以渐进式回收,不停顿太久。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// G1CollectedHeap.java</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> collectGarbage</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">G1ConcurrentMark</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> mark) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    initial</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">mark</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> // STW</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    remark</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">     // Concurrent </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    cleanup</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // STW</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    concurrent</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">cleanup</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // Concurrent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>分代回收:不需要一次全堆回收,可以分代增量回收,选择性回收新生代和老年代。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> collectGarbage</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> collectOnlyYongGen) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (collectOnlyYongGen) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        collectYoungGenGarbage</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // only YongGen</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        collectGarbage</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> // YongGen and Old Gen</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>空间整合:通过Remembered Sets实现空间整合,解决碎片问题。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// G1RemSet.java</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> addToRememberedSets</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">HeapRegion</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> HeapRegion</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> to) { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    from</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">addRememberedSetEntry</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(to);</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>预测分析:通过限定垃圾产生速率,动态调整回收频率与时间,实现高吞吐量。</li></ol>`,7),g=i("ol",null,[i("li",null,"Remembered Sets:记录不同Region之间的引用关系,用于判定垃圾。由于G1采用分代和分片回收,需要记录新生代和老年代以及各个Region之间的引用链,这就是Remembered Sets要做的工作。"),i("li",null,"Card Tables:由Remembered Sets维护的引用链过于精细,代价太大。所以,G1引入Card Tables,按照内存块做了分段,如果一个分段里至少有一个对象被老年代引用,则标记整个分段为”脏“。在回收时只处理”脏“的分段,提高效率。"),i("li",null,"它们的工作可以简述为:Remembered Sets记录精细的引用信息,Card Tables进行概括性标记,在GC时结合使用,达到高精度且高性能的铁子回收效果。"),i("li",null,"可以看到,Remembered Sets和Card Tables是G1高效率回收的关键,它们让G1不需要像CMS那样全堆回收,可以有选择性地、增量式地进行分代、分片的回收,极大的提高了工作效率。")],-1),c=n(`<ol><li><strong>初始标记</strong>:标记GC Roots能直接关联的对象,需要Stop The World。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> initialMark</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> strongRefs) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        G1CollectedHeap</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">mark</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(obj);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>并发标记</strong>:从GC Roots开始对堆中对象进行并发标记,需要部分STW。</li><li><strong>最终标记</strong>:修正并发标记期间的错误标记,需要STW。</li><li><strong>筛选回收</strong>:根据标记和Card Table结果筛选回收区域,回收垃圾,需要STW。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 筛选待回收区域</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> selectGarbageCollectionCandidates</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">    Region</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">[] filtered </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> filterRegions</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    garbageCollect</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(filtered)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li><strong>并发清理</strong>:与用户线程一起工作,对标记和筛选阶段误差产生的垃圾链进行清理。</li><li><strong>并发重置</strong>:与用户线程一起工作,为下次GC做准备。</li></ol><p>这一过程实际上和CMS非常相似,同为“标记-清除”算法。但G1在并发标记的基础上,通过Remembered Sets和Card Tables实现了分代回收和空间整合,这也是它能达到高性能的关键。</p>`,6),u=i("ol",null,[i("li",null,"G1继承了“标记-清除”算法的思想,但已远非传统意义上的“标记-清除”。"),i("li",null,"G1引入了Remembered Sets和Card Tables,实现了细致且高效的分代、分片增量回收,这是它的重要创新点。"),i("li",null,"所以,G1是在“标记-清除”思想上做出重大改进、发展和优化而成的一种高性能垃圾收集器,将它简单归类为“标记-清除”算法已忽略其最关键的优点。"),i("li",null,"G1与CMS一脉相承,但已大大超越,其性能和效率甚至与“复制”算法接近,堪称一代新高。 所以,更准确的说法应是:G1继承了标记-清除模型,但在算法和实现上都已经有了重大创新,超越了传统标记-清除算法,达到一种混合模型与新高度,是一款高性能、高效率的收集器。")],-1),m=n("<ol><li><strong>Region</strong>:将整个堆内存分割成多个大小相等的Region,作为回收和管理的基本单元。</li><li><strong>Humongous Object</strong>:对超大对象特殊处理,让其占用连续的Region。</li><li><strong>Remembered Sets</strong>:记录不同Region之间的引用关系,但过于精细,通过Card Tables进行优化。</li><li><strong>Card Tables</strong>:按Region进行内存分块,标记”脏“的Region,在GC时优先处理。</li><li><strong>Coloreo Grey Lists</strong>:通过颜色标记法管理标记过程,避免重复标记对象。</li><li><strong>回收率与吞吐量预测</strong>:通过统计与分析,动态预测并调整回收率与吞吐量,实现自动调优。</li><li><strong>增量式并发回收</strong>:通过分代和分片回收,以及STW与并发相结合,实现渐进式回收与低停顿。</li><li><strong>空闲区整理</strong>:通过回收产生的空闲区的合并整理,解决空间碎片问题。</li><li><strong>Safepoint</strong>:在STW阶段,用于保证用户线程的一致性快照。但开销大,所以尽量减少STW次数。</li></ol><p>这些都是G1高性能与低停顿的关键 support,对其设计与实现有深入理解,可以更好运用G1收集器。当然,本回答只能简要提及,实际上G1的设计极为复杂精巧,需要深入研读源码和官方文档方能全面理解。</p>",2),y=n('<figure><img src="https://ghproxy.com/https://raw.githubusercontent.com/Rodert/javapub_oss/main/other/18.jpg?raw=true" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注<strong>公众号JavaPub</strong>追更！</p><figure><img src="https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F06%2F20240606-225632.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>🎁目录合集：</p><p>Gitee：<code>https://gitee.com/rodert/JavaPub</code></p><p>GitHub：<code>https://github.com/Rodert/JavaPub</code></p><p><a href="http://javapub.net.cn" target="_blank" rel="noopener noreferrer">http://javapub.net.cn</a></p>',7);function b(v,E){const a=h("font");return p(),r("div",null,[d,i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:e(()=>[s("面试官")]),_:1}),s("： G1垃圾收集器?听说很牛逼的样子!")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:e(()=>[s("候选人：")]),_:1})]),s(" 是的,G1是JDK9默认的垃圾收集器,代替了CMS收集器。它的目标是达到更高的吞吐量和更短的GC停顿时间。")]),i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:e(()=>[s("面试官")]),_:1}),s("： 听你一说,我就不高兴了!G1到底好在哪儿?")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:e(()=>[s("候选人：")]),_:1})]),s(" G1具有以下优点:")]),k,i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:e(()=>[s("面试官")]),_:1}),s("： 垃圾收集里最让我头疼的就是“Remembered Sets”和“卡片表”,解释一下?")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:e(()=>[s("候选人：")]),_:1})]),s(" Remembered Sets和Card Tables都是G1用来管理堆和处理垃圾回收的重要数据结构。")]),g,i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:e(()=>[s("面试官")]),_:1}),s("： 原来如此,G1之所以马力十足,关键还是它发明的这套“铁子”数据结构,聪明!")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:e(()=>[s("候选人：")]),_:1})]),s(" 谢谢面试官的赞赏和提议!我会继续努力学习,如果有机会能参与。")]),i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:e(()=>[s("面试官")]),_:1}),s("： 说说G1的垃圾回收过程?")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:e(()=>[s("候选人：")]),_:1})]),s(" G1的垃圾回收过程可以分为以下几个主要阶段:")]),c,i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:e(()=>[s("面试官")]),_:1}),s("： 说G1是“标记-清除”,是不是太武断了?它用的不正是你刚才提到的那套铁子数据结构吗?")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:e(()=>[s("候选人：")]),_:1})]),s(" 您说的对,我的表述确实有失妥当。更准确的来说:")]),u,i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:e(()=>[s("面试官")]),_:1}),s("： 对,你的理解已经趋于准确和清晰。能看出G1的创新之处,并不简单归类,这说明你对收集器的认知已逐步深入。")])]),i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:e(()=>[s("面试官")]),_:1}),s("： G1收集器的设计与实现还有哪些关键点需要关注?")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:e(()=>[s("候选人：")]),_:1})]),s(" 除了我们讨论过的Remembered Sets和Card Tables外,G1的设计与实现还有其他一些关键点:")]),m,i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:e(()=>[s("面试官")]),_:1}),s("： Wonderful! 你对G1的理解已经相当深入全面,提到的这些关键点imovativ析得很透彻。G1的设计确实非常复杂精巧,能达到如此水平的理解,看来你在这方面下了不少功夫!")])]),i("p",null,[i("strong",null,[l(a,{color:"red"},{default:e(()=>[s("候选人：")]),_:1})]),s(" 非常感谢您的赞赏!我会持之以恒,继续深入学习G1与其他垃圾收集器的设计与实现。事实上,想全面深入理解G1还需要我继续努力,它的设计之巧妙令人颇感佩服与惊叹,这也使得我在研究这个课题上收获颇丰。谢谢您的提问,让我有机会梳理和总结这些关键点,这对我加深理解G1有很大帮助。我亟需在实践中不断磨练这些理论知识,并且对更多案例和细节有所了解,这需要我继续学习和努力。")]),i("p",null,[i("strong",null,[l(a,{color:"blue"},{default:e(()=>[s("面试官")]),_:1}),s("： 开心能听到你如此谦逊好学的态度。")])]),y])}const G=t(o,[["render",b],["__file","18.G1_lajihuishouqi.html.vue"]]),F=JSON.parse('{"path":"/posts/special/1v1/18.G1_lajihuishouqi.html","title":"G1垃圾回收器","lang":"zh-CN","frontmatter":{"title":"G1垃圾回收器","icon":"laptop-code","category":["《面试1v1》"],"description":"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。 ： G1垃圾收集器?听说很牛逼的样子! 是的,G1是JDK9默认的垃圾收集器,代替了CMS收集器。它的目标是达到更高的吞吐量和更短的GC停顿时间。 ： 听你一说,我就不高兴了!G1到底好在哪儿? G1具有以下优点: 并发和增量式回收:不像CMS要全部STW,G1可以渐进...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/posts/special/1v1/18.G1_lajihuishouqi.html"}],["meta",{"property":"og:site_name","content":"JavaPub"}],["meta",{"property":"og:title","content":"G1垃圾回收器"}],["meta",{"property":"og:description","content":"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。 ： G1垃圾收集器?听说很牛逼的样子! 是的,G1是JDK9默认的垃圾收集器,代替了CMS收集器。它的目标是达到更高的吞吐量和更短的GC停顿时间。 ： 听你一说,我就不高兴了!G1到底好在哪儿? G1具有以下优点: 并发和增量式回收:不像CMS要全部STW,G1可以渐进..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://ghproxy.com/https://raw.githubusercontent.com/Rodert/javapub_oss/main/other/18.jpg?raw=true"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-03T14:35:52.000Z"}],["meta",{"property":"article:author","content":"Mr.Wang"}],["meta",{"property":"article:modified_time","content":"2024-07-03T14:35:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"G1垃圾回收器\\",\\"image\\":[\\"https://ghproxy.com/https://raw.githubusercontent.com/Rodert/javapub_oss/main/other/18.jpg?raw=true\\",\\"https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F06%2F06%2F20240606-225632.png\\"],\\"dateModified\\":\\"2024-07-03T14:35:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Wang\\",\\"url\\":\\"https://javapub.net.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1717568495000,"updatedTime":1720017352000,"contributors":[{"name":"wangshiyu","email":"iswangshiyu@foxmail.com","commits":1}]},"readingTime":{"minutes":7.02,"words":2107},"filePathRelative":"posts/special/1v1/18.G1_lajihuishouqi.md","localizedDate":"2024年6月5日","excerpt":"<p><strong>我是 javapub，一名 <code>Markdown</code> 程序员从👨‍💻，八股文种子选手。</strong></p>\\n<p><strong>： G1垃圾收集器?听说很牛逼的样子!</strong></p>\\n<p><strong></strong> 是的,G1是JDK9默认的垃圾收集器,代替了CMS收集器。它的目标是达到更高的吞吐量和更短的GC停顿时间。</p>\\n<p><strong>： 听你一说,我就不高兴了!G1到底好在哪儿?</strong></p>\\n<p><strong></strong> G1具有以下优点:</p>\\n<ol>\\n<li>并发和增量式回收:不像CMS要全部STW,G1可以渐进式回收,不停顿太久。</li>\\n</ol>","autoDesc":true}');export{G as comp,F as data};
