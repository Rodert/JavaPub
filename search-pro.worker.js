const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":1448,\"nextId\":1448,\"documentIds\":{\"0\":\"0\",\"1\":\"0#网站信息\",\"2\":\"0#关于站长\",\"3\":\"0#公众号\",\"4\":\"0#搜索引擎收录直达\",\"5\":\"1\",\"6\":\"1#介绍\",\"7\":\"2\",\"8\":\"2@0\",\"9\":\"3\",\"10\":\"4\",\"11\":\"4@0\",\"12\":\"5\",\"13\":\"5@0\",\"14\":\"6\",\"15\":\"6#功能亮点\",\"16\":\"6#bar\",\"17\":\"6#foo\",\"18\":\"7\",\"19\":\"7@0\",\"20\":\"8\",\"21\":\"8@0\",\"22\":\"8@1\",\"23\":\"9\",\"24\":\"9@0\",\"25\":\"9@1\",\"26\":\"10\",\"27\":\"10#markdown-介绍\",\"28\":\"10#markdown-配置\",\"29\":\"10#markdown-扩展\",\"30\":\"10#vuepress-扩展\",\"31\":\"10#主题扩展\",\"32\":\"10#选项卡\",\"33\":\"10#脚注\",\"34\":\"10#导入文件\",\"35\":\"10#tex-语法\",\"36\":\"10#任务列表\",\"37\":\"10#图片增强\",\"38\":\"10#上下角标\",\"39\":\"10#组件\",\"40\":\"10@0\",\"41\":\"10@1\",\"42\":\"11\",\"43\":\"11#页面标题\",\"44\":\"11#页面信息\",\"45\":\"11#页面内容\",\"46\":\"11#组件\",\"47\":\"11@0\",\"48\":\"11@1\",\"49\":\"12\",\"50\":\"14\",\"51\":\"14@0\",\"52\":\"15\",\"53\":\"15#介绍\",\"54\":\"15#详情\",\"55\":\"16\",\"56\":\"16#二级\",\"57\":\"16#三级\",\"58\":\"17\",\"59\":\"17#介绍\",\"60\":\"17#详情\",\"61\":\"18\",\"62\":\"18#二级\",\"63\":\"18#三级\",\"64\":\"19\",\"65\":\"20\",\"66\":\"21\",\"67\":\"21@0\",\"68\":\"22\",\"69\":\"22@0\",\"70\":\"23\",\"71\":\"24\",\"72\":\"24@0\",\"73\":\"24@1\",\"74\":\"25\",\"75\":\"26\",\"76\":\"27\",\"77\":\"27#为什么使用单例模式\",\"78\":\"27#实现\",\"79\":\"27#预加载\",\"80\":\"27#懒加载\",\"81\":\"27#java\",\"82\":\"27#懒加载-线程安全\",\"83\":\"27#sychronized\",\"84\":\"27#sychronized-volatile\",\"85\":\"27@0\",\"86\":\"27@1\",\"87\":\"28\",\"88\":\"29\",\"89\":\"30\",\"90\":\"30#面试官-这些命令大学生都会\",\"91\":\"30#文件操作\",\"92\":\"31\",\"93\":\"31#awk\",\"94\":\"31#常用命令大全\",\"95\":\"32\",\"96\":\"33\",\"97\":\"33#问题1-可以把文章下载到本地吗-还想发到个人博客上去\",\"98\":\"33#问题2-我有个朋友是初学者-可以学吗-要怎么开始学\",\"99\":\"34\",\"100\":\"34#在准备面试\",\"101\":\"34#在学习\",\"102\":\"34@1\",\"103\":\"35\",\"104\":\"36\",\"105\":\"37\",\"106\":\"38\",\"107\":\"39\",\"108\":\"39#快速搭建-prometheus-grafana-保姆级教程\",\"109\":\"39#前言\",\"110\":\"39#prometheus-的四种类型\",\"111\":\"40\",\"112\":\"41\",\"113\":\"41#使用场景\",\"114\":\"41#搭建-etcd\",\"115\":\"41#与-etcd-交互\",\"116\":\"41#集群\",\"117\":\"41@0\",\"118\":\"41@1\",\"119\":\"42\",\"120\":\"42#rodert教你学ffmpeg实战这一篇就够了\",\"121\":\"42#前言\",\"122\":\"42#_1-简介\",\"123\":\"42#_2-安装\",\"124\":\"42#_2-1-windows安装\",\"125\":\"42#_2-2-linux安装\",\"126\":\"42#_3-命令行操使用\",\"127\":\"42#_3-1-简单说明\",\"128\":\"42#_3-2-视频剪切\",\"129\":\"42#_3-2-1-掐头去尾\",\"130\":\"42#_3-2-2\",\"131\":\"42#_3-3-视频格式转换\",\"132\":\"42#_3-4-提取音频\",\"133\":\"42#_3-5-提取音频\",\"134\":\"42#_3-6-码率控制\",\"135\":\"42#_3-7-视频编码格式转换\",\"136\":\"42#_3-8-只提取视频es数据\",\"137\":\"42#_3-9-过滤器的使用\",\"138\":\"42#_3-9-1-将输入的1920x1080缩小到960x540输出\",\"139\":\"42#_3-9-2-视频添加logo\",\"140\":\"42#_3-9-3-去掉视频的logo\",\"141\":\"42#_3-10-抓取视频的一些帧-存为jpeg图片\",\"142\":\"42#_3-11-查询操作\",\"143\":\"42#_3-11-1-查询视频总帧数\",\"144\":\"42#_3-11-2-查询ffmpeg软件信息\",\"145\":\"42#_3-12-录制\",\"146\":\"42#_3-13-直播相关\",\"147\":\"43\",\"148\":\"44\",\"149\":\"44#rodert教你学zookeeper-实战这一篇就够了\",\"150\":\"44#前言\",\"151\":\"44#_1-什么是zookeeper\",\"152\":\"44#_1-2-zookeeper简介\",\"153\":\"44#_1-3-为什么要用zookeeper\",\"154\":\"44#_2-zookeeper介绍\",\"155\":\"44#_3-zookeeper整体架构\",\"156\":\"44#_4-快速入门-quick-start\",\"157\":\"44#_4-1-安装\",\"158\":\"44#_4-2-启动\",\"159\":\"44#_4-3-查询\",\"160\":\"44#_5-常用指令\",\"161\":\"44#_6-应用场景\",\"162\":\"44#场景一-配置文件\",\"163\":\"44#场景二-分布式锁\",\"164\":\"44#场景三-分布式队列\",\"165\":\"44#场景四-负载均衡\",\"166\":\"44#_7-选举机制\",\"167\":\"44#_8-三大功能\",\"168\":\"45\",\"169\":\"46\",\"170\":\"46@0\",\"171\":\"46@1\",\"172\":\"47\",\"173\":\"47@0\",\"174\":\"47@1\",\"175\":\"48\",\"176\":\"48#_1-接口名称清晰、明确\",\"177\":\"48#_2-接口路径规整\",\"178\":\"48#_3-请求方式规范\",\"179\":\"48#_4-接口详细说明\",\"180\":\"48#_5-编写接口请求示例\",\"181\":\"48#_6-引入接口版本管理\",\"182\":\"48#_7-维护接口文档版本更新\",\"183\":\"48#_8-明确请求头有哪些\",\"184\":\"48#_9-接口安全\",\"185\":\"48#_10-接口测试\",\"186\":\"48#_11-定义错误码\",\"187\":\"48@0\",\"188\":\"48@1\",\"189\":\"49\",\"190\":\"49#前言\",\"191\":\"49#选择合适的日志等级\",\"192\":\"49#要打印函数的入参、出参\",\"193\":\"49#打印日志对象要做判空处理-避免阻断流程\",\"194\":\"49#不要使用日志系统的-log4j、logback-要使用-slf4j\",\"195\":\"49#对低级别的日志输出-必须进行日志级别开关判断\",\"196\":\"49#不要用e-printstacktrace-打印日志\",\"197\":\"49#打印全部的异常信息-方便定位问题\",\"198\":\"49#不要打印重复日志\",\"199\":\"49#日志尽量使用英文\",\"200\":\"49#核心业务逻辑-在每个分支首行都打印日志\",\"201\":\"49#不要打印无意义的日志-不携带上下文、日志链路-id\",\"202\":\"49@0\",\"203\":\"49@1\",\"204\":\"50\",\"205\":\"51\",\"206\":\"51@0\",\"207\":\"51@1\",\"208\":\"52\",\"209\":\"53\",\"210\":\"54\",\"211\":\"54#编程指南的优势\",\"212\":\"54#付费加入\",\"213\":\"55\",\"214\":\"56\",\"215\":\"56@0\",\"216\":\"56@1\",\"217\":\"57\",\"218\":\"57#视频\",\"219\":\"57#我做过的项目\",\"220\":\"57@0\",\"221\":\"57@1\",\"222\":\"58\",\"223\":\"58#介绍\",\"224\":\"59\",\"225\":\"60\",\"226\":\"60#历史图片\",\"227\":\"60@0\",\"228\":\"60@1\",\"229\":\"61\",\"230\":\"61@0\",\"231\":\"61@1\",\"232\":\"62\",\"233\":\"62@0\",\"234\":\"62@1\",\"235\":\"63\",\"236\":\"63@0\",\"237\":\"63@1\",\"238\":\"64\",\"239\":\"64@0\",\"240\":\"64@1\",\"241\":\"65\",\"242\":\"65@0\",\"243\":\"65@1\",\"244\":\"66\",\"245\":\"66#认识-ollama\",\"246\":\"66#搭建\",\"247\":\"66#linux-为例\",\"248\":\"66#测试\",\"249\":\"66#调用llama3试用\",\"250\":\"66#前言\",\"251\":\"66#搭建-1\",\"252\":\"66#附录\",\"253\":\"66@0\",\"254\":\"66@1\",\"255\":\"67\",\"256\":\"67@0\",\"257\":\"67@1\",\"258\":\"68\",\"259\":\"68@0\",\"260\":\"68@1\",\"261\":\"69\",\"262\":\"69#写在前面\",\"263\":\"69#_1、b树\",\"264\":\"69#_2、b-树\",\"265\":\"69#b树\",\"266\":\"69#b树深入\",\"267\":\"69#b-树的查找\",\"268\":\"69#b-树\",\"269\":\"69#b-树概述\",\"270\":\"69#b-树和b-树的区别\",\"271\":\"69#拓展-mysql为什么使用b-tree-b-tree-存储知识\",\"272\":\"69#存储数据最小单元\",\"273\":\"69#主存存取原理\",\"274\":\"69#磁盘存取原理\",\"275\":\"69#总结\",\"276\":\"69@0\",\"277\":\"70\",\"278\":\"70#数据结构和算法的基本概念\",\"279\":\"70#数据、数据元素、数据逻辑结构、数据存储结构、数据类型、抽象数据类型等\",\"280\":\"70#算法、算法设计的要求、算法效率的度量、算法存储空间的需求等\",\"281\":\"70#线性数据结构\",\"282\":\"70#栈、队列和线性表的定义和基本概念\",\"283\":\"70#栈、队列和线性表的实现-包括顺序和链式存储结构\",\"284\":\"70#线性表\",\"285\":\"70#顺序存储实现-例如arraylist\",\"286\":\"70#链式存储实现-linkedlist-双向链表\",\"287\":\"70#队列\",\"288\":\"70#顺序队列\",\"289\":\"70#链式队列\",\"290\":\"70#栈的实现\",\"291\":\"70#顺序栈\",\"292\":\"70#链式栈\",\"293\":\"70#栈、队列和线性表的应用\",\"294\":\"70#基础排序\",\"295\":\"70#排序的概念和分类\",\"296\":\"70#直接插入排序、希尔排序和基数排序\",\"297\":\"70#哈希表\",\"298\":\"70#哈希表的构造\",\"299\":\"70#哈希表的实现\",\"300\":\"70#递归\",\"301\":\"70#递归函数的执行过程\",\"302\":\"70#折半查找、归并排序和快速排序\",\"303\":\"70#广义表的定义、存储与实现\",\"304\":\"70#二叉树\",\"305\":\"70#二叉树的定义及其主要特征\",\"306\":\"70#二叉树的实现-包括顺序和链式存储\",\"307\":\"70#二叉树的遍历\",\"308\":\"70#堆和堆排序\",\"309\":\"70#二叉排序树\",\"310\":\"70#二叉平衡树\",\"311\":\"70#树和森林\",\"312\":\"70#树的定义以及树的存储结构-包括双亲、双亲孩子和孩子兄弟表示法\",\"313\":\"70#树和森林与二叉树的转换\",\"314\":\"70#数和森林的遍历\",\"315\":\"70#并查集\",\"316\":\"70#b-树及其基本操作-b-树的基本概念\",\"317\":\"70#图\",\"318\":\"70#图的定义和基本概念\",\"319\":\"70#图的实现-包括数组-邻接矩阵-和领接表表示法\",\"320\":\"70#图的遍历\",\"321\":\"70#图的典型应用\",\"322\":\"70#最小生成树\",\"323\":\"70#最短路径\",\"324\":\"70#拓扑排序\",\"325\":\"70#关键路径\",\"326\":\"70@0\",\"327\":\"70@1\",\"328\":\"71\",\"329\":\"71#javapub说\",\"330\":\"71#关于布隆过滤器\",\"331\":\"71#_1-1-基础介绍\",\"332\":\"71#_1-1-1-百度百科\",\"333\":\"71#_1-1-2-原理介绍\",\"334\":\"71#_1-1-3-布隆过滤器的属性\",\"335\":\"71#_1-2-数学推导\",\"336\":\"71#_1-3-哈希\",\"337\":\"71#_2-1-java版\",\"338\":\"71#_3-1-进阶一-参数定义\",\"339\":\"71#_3-1-1-介绍\",\"340\":\"71#_3-1-2-java实现\",\"341\":\"71#_3-2-进阶二-redis版\",\"342\":\"71#_3-2-1-介绍\",\"343\":\"71#_3-2-2-java代码\",\"344\":\"71@0\",\"345\":\"71@1\",\"346\":\"72\",\"347\":\"72#前言\",\"348\":\"72#_1-桶排序-bucket-sort\",\"349\":\"72#_2-原理\",\"350\":\"72#_2-1-关键\",\"351\":\"72#_2-2-算法过程\",\"352\":\"72#_3-代码\",\"353\":\"72#_4-扩展阅读\",\"354\":\"72@0\",\"355\":\"72@1\",\"356\":\"73\",\"357\":\"73#_1-1-计数排序-counting-sort\",\"358\":\"73#_2-1-步骤\",\"359\":\"73#_2-2-实例题目\",\"360\":\"73#_3-1-代码\",\"361\":\"73#_4-1-局限性\",\"362\":\"73@0\",\"363\":\"73@1\",\"364\":\"74\",\"365\":\"74@0\",\"366\":\"74@1\",\"367\":\"75\",\"368\":\"75#前言\",\"369\":\"75#_1-基数排序\",\"370\":\"75#_1-1-对比\",\"371\":\"75#_1-2-基数排序\",\"372\":\"75#_1-3-特点\",\"373\":\"75#_2-原理\",\"374\":\"75#_2-1-实现原理\",\"375\":\"75#_2-2-步骤\",\"376\":\"75#_3-代码\",\"377\":\"75#_3-1-java-版\",\"378\":\"75@0\",\"379\":\"75@1\",\"380\":\"76\",\"381\":\"76#前言\",\"382\":\"76#id生成器\",\"383\":\"76#数据库自增\",\"384\":\"76#分布式id生成器\",\"385\":\"76#方案一-uuid\",\"386\":\"76#方案二-snowflake-雪花算法\",\"387\":\"76#算法介绍\",\"388\":\"76#源码\",\"389\":\"76@0\",\"390\":\"76@1\",\"391\":\"77\",\"392\":\"77@0\",\"393\":\"77@1\",\"394\":\"78\",\"395\":\"78@0\",\"396\":\"78@1\",\"397\":\"79\",\"398\":\"79#自我介绍\",\"399\":\"79#elasticsearch-springboot-介绍\",\"400\":\"79#elasticsearch\",\"401\":\"79#springboot\",\"402\":\"79#环境介绍\",\"403\":\"79#服务器环境\",\"404\":\"79#linux安装jdk\",\"405\":\"79#linux安装es-方法和要点\",\"406\":\"79#es集群、初步配置和使用\",\"407\":\"79#启动\",\"408\":\"79#安装使用可视化工具插件head-cerebro\",\"409\":\"79@0\",\"410\":\"79@1\",\"411\":\"80\",\"412\":\"80#ik分词器插件安装\",\"413\":\"80#拼音分词器插件安装\",\"414\":\"80#更多扩展词库\",\"415\":\"80#elasticsearch核心概念-相关术语解析\",\"416\":\"80#cluster\",\"417\":\"80#node\",\"418\":\"80#index\",\"419\":\"80#type\",\"420\":\"80#document\",\"421\":\"80#shard\",\"422\":\"80#replica\",\"423\":\"80#理解倒排索引\",\"424\":\"80#倒排索引相关术语\",\"425\":\"80#简单倒排索引实例\",\"426\":\"80@0\",\"427\":\"80@1\",\"428\":\"81\",\"429\":\"81#什么是-mapping\",\"430\":\"81#maping设置\",\"431\":\"81#dynamic-动态mapping\",\"432\":\"81#index\",\"433\":\"81#index-options\",\"434\":\"81#null-value\",\"435\":\"81#all\",\"436\":\"81#copy-to\",\"437\":\"81#分词器analyzer和arch-analyzer\",\"438\":\"81#构建mapping方式\",\"439\":\"81#类型自动识别\",\"440\":\"81#映射参数\",\"441\":\"81#字段数据类型\",\"442\":\"81#核心类型\",\"443\":\"81#字符串类型\",\"444\":\"81#数字类型\",\"445\":\"81#日期类型\",\"446\":\"81#布尔类型\",\"447\":\"81#二进制类型\",\"448\":\"81#范围类型\",\"449\":\"81#复杂类型\",\"450\":\"81#对象类型\",\"451\":\"81#嵌套类型\",\"452\":\"81#地理类型\",\"453\":\"81#经纬度类型\",\"454\":\"81#地理区域类型\",\"455\":\"81#特殊类型\",\"456\":\"81#ip-类型\",\"457\":\"81#join类型\",\"458\":\"81@0\",\"459\":\"81@1\",\"460\":\"82\",\"461\":\"82#集群\",\"462\":\"82#检查集群状态\",\"463\":\"82#检查节点状态\",\"464\":\"82#查询全部索引\",\"465\":\"82#索引\",\"466\":\"82#创建索引\",\"467\":\"82#删除索引\",\"468\":\"82#查询索引\",\"469\":\"82#数据操作\",\"470\":\"82#插入数据\",\"471\":\"82#单条插入\",\"472\":\"82#批量插入\",\"473\":\"82#删除\",\"474\":\"82#更新\",\"475\":\"82#搜索\",\"476\":\"82@0\",\"477\":\"82@1\",\"478\":\"83\",\"479\":\"83@0\",\"480\":\"83@1\",\"481\":\"84\",\"482\":\"84#前言\",\"483\":\"84#空投到底是什么\",\"484\":\"84#空投什么\",\"485\":\"84#空投合约代码\",\"486\":\"84#空投步骤\",\"487\":\"84#代码解析\",\"488\":\"84#代码详解\",\"489\":\"84@0\",\"490\":\"84@1\",\"491\":\"85\",\"492\":\"86\",\"493\":\"86#前言\",\"494\":\"86#_1-索引是什么\",\"495\":\"86#_2-mysql索引有哪些类型\",\"496\":\"86#_3-主键索引和唯一索引有什么区别\",\"497\":\"86#_4-什么是聚簇索引和非聚簇索引-它们在innodb存储引擎中是如何工作的\",\"498\":\"86#_5-复合索引和单列索引有何区别\",\"499\":\"86#_6-hash-索引和-b-树索引区别是什么-如何选择\",\"500\":\"86#_7-索引是否越多越好-为什么\",\"501\":\"86#_8-索引什么时候会失效\",\"502\":\"86#_9-哪些情况下适合建立索引\",\"503\":\"86#_10-为什么要用-b-树-而不用二叉树\",\"504\":\"86#_11-什么是回表-如何减少回表\",\"505\":\"86#_12-能否解释什么是位图索引-以及它在mysql中的使用场景\",\"506\":\"86#_13-如何查看mysql表中已有的索引\",\"507\":\"86#_14-如何在mysql中创建全文索引-并说明全文索引的使用场景\",\"508\":\"86#_15-当表中的数据量非常大时-如何有效地维护和管理索引-以确保查询性能\",\"509\":\"86#_16-假设你有一个包含大量数据的表-并且经常需要根据某个字段进行排序。你应如何优化这个字段的索引以提高排序操作的性能\",\"510\":\"86#_17-如何优化索引\",\"511\":\"86#_18-请谈谈你对-mysql-索引碎片化的理解-并说明如何检测和修复索引碎片化。\",\"512\":\"86@0\",\"513\":\"86@1\",\"514\":\"87\",\"515\":\"87#分表分库解决思路\",\"516\":\"87#垂直分表\",\"517\":\"87#垂直分库\",\"518\":\"87#水平分库\",\"519\":\"87#水平分表\",\"520\":\"87#总结\",\"521\":\"87#后记\",\"522\":\"87#序言\",\"523\":\"87#适合阅读人群\",\"524\":\"87#阅读建议\",\"525\":\"88\",\"526\":\"88#_1-应尽量避免在-where-子句中对字段进行-null-值判断-否则将导致引擎放弃使用索引而进行全表扫描-如\",\"527\":\"88#_2-应尽量避免在-where-子句中使用-或-操作符-否则将引擎放弃使用索引而进行全表扫描。\",\"528\":\"88#_3-应尽量避免在-where-子句中使用-or-来连接条件-否则将导致引擎放弃使用索引而进行全表扫描-如\",\"529\":\"88#_4-in-和-not-in-也要慎用-否则会导致全表扫描-如\",\"530\":\"88#_5-下面的查询也将导致全表扫描\",\"531\":\"88#_6-应尽量避免在-where-子句中对字段进行表达式操作-这将导致引擎放弃使用索引而进行全表扫描。如\",\"532\":\"88#_7-应尽量避免在where子句中对字段进行函数操作-这将导致引擎放弃使用索引而进行全表扫描。如\",\"533\":\"88#_8-不要在-where-子句中的-左边进行函数、算术运算或其他表达式运算-否则系统将可能无法正确使用索引。\",\"534\":\"88#_9-在使用索引字段作为条件时-如果该索引是复合索引-那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引-否则该索引将不会被使用-并且应尽可能的让字段顺序与索引顺序相一致。\",\"535\":\"88#_10-很多时候用-exists-代替-in-是一个好的选择\",\"536\":\"88#_11-并不是所有索引对查询都有效-sql-是根据表中数据来进行查询优化的-当索引列有大量数据重复时-sql-查询可能不会去利用索引。\",\"537\":\"88#_12-索引并不是越多越好-索引固然可以提高相应的-select-的效率-但同时也降低了-insert-及-update-的效率\",\"538\":\"88#_13-尽量使用数字型字段-若只含数值信息的字段尽量不要设计为字符型-这会降低查询和连接的性能-并会增加存储开销。\",\"539\":\"88#_14-尽可能的使用-varchar-代替-char-因为首先变长字段存储空间小-可以节省存储空间-其次对于查询来说-在一个相对较小的字段内搜索效率显然要高些。\",\"540\":\"88#_15-任何地方都不要使用-select-from-t-用具体的字段列表代替-不要返回用不到的任何字段。\",\"541\":\"88#_16-避免频繁创建和删除临时表-以减少系统表资源的消耗。\",\"542\":\"88#_17-在新建临时表时-如果一次性插入数据量很大-那么可以使用-select-into-代替-create-table-避免造成大量-log-以提高速度-如果数据量不大-为了缓和系统表的资源-应先create-table-然后insert。\",\"543\":\"88#_18-如果使用到了临时表-在存储过程的最后务必将所有的临时表显式删除-先-truncate-table-然后-drop-table-这样可以避免系统表的较长时间锁定。\",\"544\":\"88#_19-尽量避免使用游标-因为游标的效率较差-如果游标操作的数据超过1万行-那么就应该考虑改写。\",\"545\":\"88#_20-使用基于游标的方法或临时表方法之前-应先寻找基于集的解决方案来解决问题-基于集的方法通常更有效。\",\"546\":\"88#_21-与临时表一样-游标并不是不可使用。对小型数据集使用-fast-forward-游标通常要优于其他逐行处理方法-尤其是在必须引用几个表才能获得所需的数据时。\",\"547\":\"88#_22-尽量避免大事务操作-提高系统并发能力。\",\"548\":\"88#_23-尽量避免向客户端返回大数据量-若数据量过大-应该考虑相应需求是否合理。\",\"549\":\"88@0\",\"550\":\"88@1\",\"551\":\"89\",\"552\":\"89#前言\",\"553\":\"89#_1-为什么要在数据库中加锁\",\"554\":\"89#_2-innodb-中有哪些锁\",\"555\":\"89#_2-1-共享锁-排它锁\",\"556\":\"89#_2-2-行锁-临键锁\",\"557\":\"89#_2-3-意向锁\",\"558\":\"89#_2-4-间隙锁-插入意向锁\",\"559\":\"89#_2-5-自增锁\",\"560\":\"89#_2-6-外键锁\",\"561\":\"89#_2-7-表锁-页锁\",\"562\":\"89#_3-什么是死锁\",\"563\":\"89#_4-行锁、表锁、页面锁有什么区别\",\"564\":\"89#行锁-row-locks\",\"565\":\"89#表锁-table-locks\",\"566\":\"89#页锁-page-locks\",\"567\":\"89#总结\",\"568\":\"89#_5-乐观锁和悲观锁有什么区别-它们什么场景会用\",\"569\":\"89#乐观锁\",\"570\":\"89#悲观锁\",\"571\":\"89#_6-select-for-update-加了行锁还是表锁\",\"572\":\"89#_7-如何通过-sql-手动给-mysql-的某个表加锁\",\"573\":\"89#_8-高并发场景下-如何修改同一条数据\",\"574\":\"89#_9-mysql-中的锁升级是什么\",\"575\":\"89#_10-mysql-rr-的隔离级别下加锁规则\",\"576\":\"89#_11-如何使用分布式锁\",\"577\":\"89#_11-1-基于唯一索引实现\",\"578\":\"89#_11-2-基于排他锁-select-for-update-实现\",\"579\":\"89#_11-3-基于乐观锁\",\"580\":\"89#_12-如何检测死锁\",\"581\":\"89#_13-你遇到过死锁吗-你怎么处理的\",\"582\":\"89@0\",\"583\":\"89@1\",\"584\":\"90\",\"585\":\"91\",\"586\":\"91#rodert单排学习redis入门【黑铁】\",\"587\":\"91#前言\",\"588\":\"91#_1-nosql-not-only-sql\",\"589\":\"91#_2-redis入门\",\"590\":\"91#_3-redis特性\",\"591\":\"91#_3-1-性能\",\"592\":\"91#_3-2-特性\",\"593\":\"91#_3-3-优势\",\"594\":\"91#_4-redis使用场景\",\"595\":\"91#_5-安装\",\"596\":\"91#_5-1-单机安装\",\"597\":\"91#_5-1-1-windows下\",\"598\":\"91#_5-1-2-linux下\",\"599\":\"91#_6-五类数据结构\",\"600\":\"91#_6-0-说明\",\"601\":\"91#_6-1-介绍\",\"602\":\"91#_6-2-redis-keys\",\"603\":\"91#_6-2-字符串-strings\",\"604\":\"91#_6-3-列表-lists\",\"605\":\"91#_6-4-哈希-hash\",\"606\":\"91#_6-5-集合-set\",\"607\":\"91#_6-6-有序集合-sorted-set\",\"608\":\"91#_7-redis常用\",\"609\":\"91@0\",\"610\":\"91@1\",\"611\":\"92\",\"612\":\"92#rodert单排学习redis进阶【青铜】\",\"613\":\"92#前言\",\"614\":\"92#_1-再谈redis\",\"615\":\"92#_2-为什么要用redis\",\"616\":\"92#_3-为什么要使用缓存\",\"617\":\"92#_4-redis数据结构\",\"618\":\"92#_4-1-sds简单动态字符串\",\"619\":\"92#_4-1-1-sds简单动态字符串\",\"620\":\"92#_4-1-2-sds简单动态字符串好处\",\"621\":\"92#_4-2-redis-链表和链表节点\",\"622\":\"92#_4-2-2-redis-链表重点\",\"623\":\"92#_4-3-redis-字典\",\"624\":\"92#_4-3-1-哈希表\",\"625\":\"92#_4-3-2-redis-rehash-重新散列\",\"626\":\"92#_4-3-3-重点\",\"627\":\"92#_4-4-跳跃表\",\"628\":\"92#_4-4-1-跳跃表\",\"629\":\"92#_4-4-2-重点\",\"630\":\"92#_4-5-整数集合\",\"631\":\"92#_4-6-压缩列表\",\"632\":\"92#_4-6-1-前言\",\"633\":\"92#_4-6-2-redis-压缩列表\",\"634\":\"92#_4-7-redis的对象\",\"635\":\"92#_4-7-1-redis的对象\",\"636\":\"92#_4-7-2-重点\",\"637\":\"92@0\",\"638\":\"92@1\",\"639\":\"93\",\"640\":\"93#rodert单排学习redis进阶【白银一】\",\"641\":\"93#前言\",\"642\":\"93#_1-redis-客户端\",\"643\":\"93#_1-1-redis-desktop-manager\",\"644\":\"93#_2-redis-连接池\",\"645\":\"93#_2-2-0-连接池\",\"646\":\"93#_2-1-redis-连接池\",\"647\":\"93#_2-1-1-前言引入\",\"648\":\"93#_2-1-2-redis-连接池\",\"649\":\"93@0\",\"650\":\"93@1\",\"651\":\"94\",\"652\":\"94#redis基本类型使用场景都懂了\",\"653\":\"94#string\",\"654\":\"94#hash\",\"655\":\"94#list\",\"656\":\"94#set\",\"657\":\"94#sortedset\",\"658\":\"94#bitmap\",\"659\":\"94#hyperloglog\",\"660\":\"94#geo\",\"661\":\"94@0\",\"662\":\"94@1\",\"663\":\"95\",\"664\":\"95#redis分布式锁要注意哪几点-离bug远一点\",\"665\":\"95@0\",\"666\":\"95@1\",\"667\":\"96\",\"668\":\"96#基于-centos7-的-redis-安装\",\"669\":\"96#前言\",\"670\":\"96#安装教程\",\"671\":\"96#_1-下载\",\"672\":\"96#_2-安装\",\"673\":\"96#_3-修改配置\",\"674\":\"96#_4-启动\",\"675\":\"96#_5-访问测试\",\"676\":\"96@0\",\"677\":\"96@1\",\"678\":\"97\",\"679\":\"97@0\",\"680\":\"97@1\",\"681\":\"98\",\"682\":\"98#前言\",\"683\":\"98#说明\",\"684\":\"98#代码讲解\",\"685\":\"98#切面注解日志\",\"686\":\"98#_1-新建接口\",\"687\":\"98#_2-引入依赖\",\"688\":\"98#_3-注解\",\"689\":\"98#_4-aop切点类\",\"690\":\"98#测试\",\"691\":\"98@0\",\"692\":\"99\",\"693\":\"99@0\",\"694\":\"100\",\"695\":\"100@0\",\"696\":\"100@1\",\"697\":\"101\",\"698\":\"101#rodert教你学maven-实战这一篇就够了\",\"699\":\"101#_2-1-maven的功能\",\"700\":\"101#_2-2-为什么使用maven\",\"701\":\"101#_3-1-安装\",\"702\":\"101#_3-2-配置\",\"703\":\"101#_5-1-命令行构建java项目\",\"704\":\"101#_5-2-使用命令行创建web项目\",\"705\":\"101#_5-3-构建maven项目命令的使用\",\"706\":\"101#_8-1-依赖范围\",\"707\":\"101#_8-2-传递性依赖\",\"708\":\"101#_8-3-可选依赖\",\"709\":\"101#_8-4-依赖冲突\",\"710\":\"101#_8-4-排除依赖\",\"711\":\"101#_9-1-maven生命周期\",\"712\":\"101#_9-2-clean生命周期\",\"713\":\"101#_9-3-default生命周期\",\"714\":\"101#_9-4-site生命周期\",\"715\":\"101#_11-1-maven继承\",\"716\":\"101#_11-2-聚合\",\"717\":\"101@0\",\"718\":\"101@1\",\"719\":\"102\",\"720\":\"102@0\",\"721\":\"102@1\",\"722\":\"103\",\"723\":\"103#_1-场景\",\"724\":\"103#_2-mybatis-xml\",\"725\":\"103#_2-1-打印sql\",\"726\":\"103#_2-2-数据库结构\",\"727\":\"103#_3-实例二\",\"728\":\"103#_4-重点\",\"729\":\"103@0\",\"730\":\"104\",\"731\":\"104#rodert教你学mybatis-实战这一篇就够了\",\"732\":\"104#前言\",\"733\":\"104#_1-什么是mybatis之jdbc攻城狮\",\"734\":\"104#_1-1-使用idea构建maven工程\",\"735\":\"104#_1-2-引入mysql依赖包\",\"736\":\"104#_1-3-准备数据\",\"737\":\"104#_1-4-jdbc代码回顾\",\"738\":\"104#_1-5-jdbc缺点分析\",\"739\":\"104#_4-mybatis介绍\",\"740\":\"104#_3-mybatis整体架构\",\"741\":\"104#_4-快速入门-quick-start\",\"742\":\"104#_4-1-引入依赖-pom-xml\",\"743\":\"104#_4-2-全局配置文件-mybatis-config-xml\",\"744\":\"104#_4-3-配置map-xml-mymapper-xml\",\"745\":\"104#_4-4-修改全局配置文件-mybatis-config-xml\",\"746\":\"104#_4-5-构建sqlsessionfactory-mybatistest-java\",\"747\":\"104#_4-6-打开sqlsession回话-并执行sql-mybatistest-xml\",\"748\":\"104#_4-7-目录结构\",\"749\":\"104#_5-分析\",\"750\":\"104#_5-1-日志\",\"751\":\"104#_5-2-mybatis使用步骤总结\",\"752\":\"104#_6-完整增删查改操作-curd\",\"753\":\"104#_6-1-创建userdao-java接口\",\"754\":\"104#_6-2-创建userdaoimpl-java\",\"755\":\"104#_6-3-编写userdao对应mapper-userdaomapper-xml\",\"756\":\"104#_6-4-添加userdao测试用例\",\"757\":\"104#_6-5-编写userdao的测试用例\",\"758\":\"104#_6-6-目录结构\",\"759\":\"104#_6-7-解决数据库字段名和实体类属性名不一致的问题\",\"760\":\"104#_7-动态代理mapper实现类\",\"761\":\"104#_7-1-思考上述crud中的问题\",\"762\":\"104#_7-2-使用动态代理改造crud\",\"763\":\"104#_7-3-完整的例子\",\"764\":\"104#_7-4-动态代理总结\",\"765\":\"104#_8-mybatis-config-xml详解\",\"766\":\"104#_8-1-properties属性读取外部资源\",\"767\":\"104#_8-2-settings设置\",\"768\":\"104#_8-3-typealiases-别名\",\"769\":\"104#_8-4-typehandlers-类处理器\",\"770\":\"104#_8-5-plugins-插件-拦截器\",\"771\":\"104#_8-6-environments-环境\",\"772\":\"104#_8-7-mappers\",\"773\":\"104#_9-mapper-xml文件详解\",\"774\":\"104#_9-1-crud标签\",\"775\":\"104#_9-1-1-select\",\"776\":\"104#_9-1-2-insert\",\"777\":\"104#_9-1-3-update\",\"778\":\"104#_9-1-4-delete\",\"779\":\"104#_9-2-和\",\"780\":\"104#_9-3-面试题-、-区别\",\"781\":\"104#_9-4-resultmap\",\"782\":\"104#_9-5-sql片段\",\"783\":\"104#_10-动态sql\",\"784\":\"104#_10-1-if\",\"785\":\"104#_10-2-choose-when-otherwise\",\"786\":\"104#_10-3-where-和set\",\"787\":\"104#_10-4-foreach\",\"788\":\"104#_11-缓存\",\"789\":\"104#_11-1-一级缓存\",\"790\":\"104#_11-2-二级缓存\",\"791\":\"104#_12-高级查询\",\"792\":\"104#_12-1-表关系说明\",\"793\":\"104#_12-2-一对一查询\",\"794\":\"104#_12-3-一对多查询\",\"795\":\"104#_12-4-多对多查询\",\"796\":\"104#_12-5-resultmap的继承\",\"797\":\"104#_12-6-高级查询的整理\",\"798\":\"104#_13-延迟加载\",\"799\":\"104#_14-如果sql语句中出现-的解决方案\",\"800\":\"104#_14-1-使用xml中的字符实体\",\"801\":\"104#_14-2-使用-cdata\",\"802\":\"104@0\",\"803\":\"104@1\",\"804\":\"105\",\"805\":\"105@0\",\"806\":\"105@1\",\"807\":\"106\",\"808\":\"106#开发环境\",\"809\":\"106#目录\",\"810\":\"106#环境搭建\",\"811\":\"106#新建项目\",\"812\":\"106#导入依赖\",\"813\":\"106#编码\",\"814\":\"106#配置文件\",\"815\":\"106#spring-dao-xml\",\"816\":\"106#jdbc-properties\",\"817\":\"106#mybatis-config-xml\",\"818\":\"106#spring-service-xml\",\"819\":\"106#spring-web-xml\",\"820\":\"106#web-xml\",\"821\":\"106#日志\",\"822\":\"106#配置说明\",\"823\":\"106#ssm实例-图书管理系统\",\"824\":\"106#sql\",\"825\":\"106#实体\",\"826\":\"106#dao接口\",\"827\":\"106#dao接口xml\",\"828\":\"106#dao接口测试\",\"829\":\"106#业务层-结果集封装\",\"830\":\"106#service-业务接口代码\",\"831\":\"106#web层\",\"832\":\"106#运行项目\",\"833\":\"106@0\",\"834\":\"107\",\"835\":\"108\",\"836\":\"108#三种快速创建springboot项目的方式\",\"837\":\"108#在线创建\",\"838\":\"108#intellij-idea-创建\",\"839\":\"108#maven-创建\",\"840\":\"108#基本项目结构\",\"841\":\"108@0\",\"842\":\"108@1\",\"843\":\"109\",\"844\":\"109#你了解pomxml吗\",\"845\":\"109@0\",\"846\":\"109@1\",\"847\":\"110\",\"848\":\"110#新建项目\",\"849\":\"110#创建接口\",\"850\":\"110#maven-打包-springboot-项目\",\"851\":\"110#文件准备\",\"852\":\"110#linux下docker安装\",\"853\":\"110#异常\",\"854\":\"110#打包构建docker镜像\",\"855\":\"110#运行\",\"856\":\"110#查看日志\",\"857\":\"110@0\",\"858\":\"110@1\",\"859\":\"111\",\"860\":\"111#视频教程\",\"861\":\"111#插件安装\",\"862\":\"111#导入依赖\",\"863\":\"111#新建数据库\",\"864\":\"111#修改配置\",\"865\":\"111#定义流程文件\",\"866\":\"111#测试\",\"867\":\"111#截图\",\"868\":\"111@0\",\"869\":\"111@1\",\"870\":\"112\",\"871\":\"112#springboot生成二维码的正确姿势-附视频-附源码\",\"872\":\"112#前言\",\"873\":\"112#初始化-springboot-项目\",\"874\":\"112#引入依赖\",\"875\":\"112#编码\",\"876\":\"112#编写工具类\",\"877\":\"112#生成二维码\",\"878\":\"112#资源共享\",\"879\":\"112@0\",\"880\":\"112@1\",\"881\":\"113\",\"882\":\"113#简介\",\"883\":\"113#prometheus\",\"884\":\"113#grafana\",\"885\":\"113#springboot工程初始化\",\"886\":\"113#环境安装\",\"887\":\"113#prometheus安装\",\"888\":\"113#grafana安装\",\"889\":\"113#整合\",\"890\":\"113@0\",\"891\":\"113@1\",\"892\":\"114\",\"893\":\"115\",\"894\":\"116\",\"895\":\"116#python-安装-cv2-已解决\",\"896\":\"116#_1-传统方式1\",\"897\":\"116#_2-第一阶段-终极办法01\",\"898\":\"116#_3-第二阶段-终极办法02\",\"899\":\"116#附加\",\"900\":\"116@0\",\"901\":\"116@1\",\"902\":\"117\",\"903\":\"118\",\"904\":\"118#参考资料\",\"905\":\"119\",\"906\":\"120\",\"907\":\"120#前言\",\"908\":\"120#快速搭建\",\"909\":\"120#安装工具\",\"910\":\"120#初始化\",\"911\":\"120#写文档\",\"912\":\"120#本地预览\",\"913\":\"120#部署-github\",\"914\":\"121\",\"915\":\"121#案例1\",\"916\":\"121#案例2-git-stash\",\"917\":\"121#案例3-git-cherry-pick\",\"918\":\"121#案例4-git-reset\",\"919\":\"121#案例5-git-fetch\",\"920\":\"122\",\"921\":\"122@0\",\"922\":\"123\",\"923\":\"123@0\",\"924\":\"124\",\"925\":\"124@0\",\"926\":\"125\",\"927\":\"125@0\",\"928\":\"126\",\"929\":\"126@0\",\"930\":\"127\",\"931\":\"127@0\",\"932\":\"128\",\"933\":\"128@0\",\"934\":\"129\",\"935\":\"129@0\",\"936\":\"130\",\"937\":\"130@0\",\"938\":\"131\",\"939\":\"131@0\",\"940\":\"132\",\"941\":\"132@0\",\"942\":\"133\",\"943\":\"133@0\",\"944\":\"134\",\"945\":\"134@0\",\"946\":\"135\",\"947\":\"135@0\",\"948\":\"136\",\"949\":\"136@0\",\"950\":\"137\",\"951\":\"137@0\",\"952\":\"138\",\"953\":\"138@0\",\"954\":\"139\",\"955\":\"139@0\",\"956\":\"140\",\"957\":\"140@0\",\"958\":\"141\",\"959\":\"141@0\",\"960\":\"142\",\"961\":\"142@0\",\"962\":\"143\",\"963\":\"143@0\",\"964\":\"144\",\"965\":\"144@0\",\"966\":\"145\",\"967\":\"145@0\",\"968\":\"146\",\"969\":\"146@0\",\"970\":\"147\",\"971\":\"147@0\",\"972\":\"148\",\"973\":\"148@0\",\"974\":\"149\",\"975\":\"149@0\",\"976\":\"150\",\"977\":\"150@0\",\"978\":\"151\",\"979\":\"151@0\",\"980\":\"152\",\"981\":\"152@0\",\"982\":\"153\",\"983\":\"153@0\",\"984\":\"154\",\"985\":\"154@0\",\"986\":\"155\",\"987\":\"155@0\",\"988\":\"156\",\"989\":\"156@0\",\"990\":\"157\",\"991\":\"157@0\",\"992\":\"158\",\"993\":\"158@0\",\"994\":\"159\",\"995\":\"159@0\",\"996\":\"160\",\"997\":\"160@0\",\"998\":\"161\",\"999\":\"161@0\",\"1000\":\"162\",\"1001\":\"162@0\",\"1002\":\"163\",\"1003\":\"163@0\",\"1004\":\"164\",\"1005\":\"164@0\",\"1006\":\"165\",\"1007\":\"165@0\",\"1008\":\"166\",\"1009\":\"166@0\",\"1010\":\"167\",\"1011\":\"167@0\",\"1012\":\"168\",\"1013\":\"168@0\",\"1014\":\"169\",\"1015\":\"169@0\",\"1016\":\"170\",\"1017\":\"170@0\",\"1018\":\"171\",\"1019\":\"171@0\",\"1020\":\"172\",\"1021\":\"172@0\",\"1022\":\"173\",\"1023\":\"173#参考底层指令\",\"1024\":\"173@0\",\"1025\":\"174\",\"1026\":\"175\",\"1027\":\"175#_1-什么是-http\",\"1028\":\"175@0\",\"1029\":\"175@1\",\"1030\":\"176\",\"1031\":\"176#_1-什么是netty\",\"1032\":\"176#为什么要用-netty-呢-说一下自己的看法。\",\"1033\":\"176#netty-应用场景了解么\",\"1034\":\"176#netty-核心组件有哪些-分别有什么作用\",\"1035\":\"176#-1\",\"1036\":\"176#-2\",\"1037\":\"176@0\",\"1038\":\"176@1\",\"1039\":\"177\",\"1040\":\"177@0\",\"1041\":\"178\",\"1042\":\"178#_1-什么是缓存\",\"1043\":\"178#_2-为什么要用缓存\",\"1044\":\"178#_3-请说说有哪些缓存算法-是否能手写一下-lru-代码的实现\",\"1045\":\"178#_4-常见的常见的缓存工具和框架有哪些\",\"1046\":\"178#_5-用了缓存之后-有哪些常见问题\",\"1047\":\"178#_6-如何处理缓存穿透的问题\",\"1048\":\"178#_7-如何处理缓存雪崩的问题\",\"1049\":\"178#_8-如何处理缓存击穿的问题\",\"1050\":\"178#_9-缓存和-db-的一致性如何保证\",\"1051\":\"178#_10-什么是缓存预热-如何实现缓存预热\",\"1052\":\"178#拓展-缓存数据的淘汰策略有哪些\",\"1053\":\"178#推荐阅读\",\"1054\":\"178@0\",\"1055\":\"178@1\",\"1056\":\"179\",\"1057\":\"179#_1-什么是-docker-容器\",\"1058\":\"179#_2-docker-和虚拟机有什么不同\",\"1059\":\"179#_3-什么是-dockerfile\",\"1060\":\"179#_4-使用docker-compose时如何保证容器a先于容器b运行\",\"1061\":\"179#_5-一个完整的docker由哪些部分组成\",\"1062\":\"179#_6-docker常用命令\",\"1063\":\"179#_7-描述-docker-容器的生命周期。\",\"1064\":\"179#_8-docker容器之间怎么隔离\",\"1065\":\"179@0\",\"1066\":\"179@1\",\"1067\":\"180\",\"1068\":\"180#_1-说说你们公司-es-的集群架构-索引数据大小-分片有多少-以及一些调优手段-。\",\"1069\":\"180#_2-elasticsearch-的倒排索引是什么\",\"1070\":\"180#_3-elasticsearch-是如何实现-master-选举的\",\"1071\":\"180#_4-描述一下-elasticsearch-索引文档的过程\",\"1072\":\"180#_5-详细描述一下-elasticsearch-搜索的过程\",\"1073\":\"180#_6-elasticsearch-在部署时-对-linux-的设置有哪些优化方法\",\"1074\":\"180#_7-elasticsearch-中的节点-比如共-20-个-其中的-10-个选了一个-master-另外-10-个选了另一个-master-怎么办\",\"1075\":\"180#_8-客户端在和集群连接时-如何选择特定的节点执行请求的\",\"1076\":\"180#_9-详细描述一下-elasticsearch-更新和删除文档的过程。\",\"1077\":\"180#_10-elasticsearch-对于大数据量-上亿量级-的聚合如何实现\",\"1078\":\"180#_11-在并发情况下-elasticsearch-如果保证读写一致\",\"1079\":\"180#_11-介绍一下你们的个性化搜索方案\",\"1080\":\"180#推荐阅读\",\"1081\":\"180@0\",\"1082\":\"180@1\",\"1083\":\"181\",\"1084\":\"181#_1-instanceof-关键字的作用\",\"1085\":\"181#_2-java自动装箱和拆箱\",\"1086\":\"181#_3-重载和重写区别\",\"1087\":\"181#_4-equals与-区别\",\"1088\":\"181#_5-谈谈nio和bio区别\",\"1089\":\"181#_6-string、stringbuffer、stringbuilder-的区别是什么\",\"1090\":\"181#_7-泛型是什么-有什么特点\",\"1091\":\"181#_8-final-有哪些用法\",\"1092\":\"181#_9-说一下java注解\",\"1093\":\"181#_10-java创建对象有几种方式\",\"1094\":\"181#推荐阅读\",\"1095\":\"181@0\",\"1096\":\"181@1\",\"1097\":\"182\",\"1098\":\"182#_1-start-方法和run-方法的区别\",\"1099\":\"182#_2-volatile关键字的作用\",\"1100\":\"182#_3-sleep方法和wait方法有什么区别\",\"1101\":\"182#_4-如何停止一个正在运行的线程\",\"1102\":\"182#_5-java如何实现多线程之间的通讯和协作-如何在两个线程间共享数据\",\"1103\":\"182#_6-什么是threadlocal\",\"1104\":\"182#_7-java-中-countdownlatch-和-cyclicbarrier-有什么不同\",\"1105\":\"182#_8-如何避免死锁\",\"1106\":\"182#_9-java-中-synchronized-和-reentrantlock-有什么不同\",\"1107\":\"182#_10-有三个线程-t1-t2-t3-怎么确保它们按顺序执行\",\"1108\":\"182#推荐阅读\",\"1109\":\"182@0\",\"1110\":\"182@1\",\"1111\":\"183\",\"1112\":\"183#_1-请说一下java容器集合的分类-各自的继承结构\",\"1113\":\"183#_2-collection-和-collections-有什么区别\",\"1114\":\"183#_3-list、set、map-之间的区别是什么\",\"1115\":\"183#_4-hashmap-和-hashtable-有什么区别\",\"1116\":\"183#_5-说一下-hashmap-的实现原理\",\"1117\":\"183#_6-谈谈-arraylist-和-linkedlist-的区别\",\"1118\":\"183#_7-谈谈arraylist和vector的区别\",\"1119\":\"183#_8-请谈一谈-java-集合中的-fail-fast-和-fail-safe-机制\",\"1120\":\"183#_9-hashmap是怎样确定key存放在数组的哪个位置的-jdk1-8\",\"1121\":\"183#_9-1-追问-为什么计算key的hash时要把hashcode的高16位与低16位进行异或-变式-为什么不直接用key的hashcode\",\"1122\":\"183#_10-为什么要把链表转为红黑树-阈值为什么是8\",\"1123\":\"183#拓展题-为什么-hashmap-数组的长度是2的幂次方\",\"1124\":\"183@0\",\"1125\":\"183@1\",\"1126\":\"184\",\"1127\":\"184#_1-jsp-有哪些内置对象-作用分别是什么\",\"1128\":\"184#_2-介绍一下-servlet-生命周期\",\"1129\":\"184#_3-servlet和jsp的区别和联系\",\"1130\":\"184#_4-jsp的执行过程\",\"1131\":\"184#_5-session和cookie的区别和联系-说明在自己项目中如何使用\",\"1132\":\"184#_6-转发和重定向的联系和区别\",\"1133\":\"184#_7-拦截器和过滤器的区别\",\"1134\":\"184#_8-三次握手和四次挥手\",\"1135\":\"184#_9-tcp和udp的区别\",\"1136\":\"184#_10-如何解决跨域问题\",\"1137\":\"184#_11-什么是-csrf-攻击-如何防御csrf-攻击\",\"1138\":\"184#_12-http1-0和http1-1和http2-0的区别\",\"1139\":\"184@0\",\"1140\":\"184@1\",\"1141\":\"185\",\"1142\":\"185#_1-说一说jvm的主要组成部分\",\"1143\":\"185#_2-说一下-jvm-的作用\",\"1144\":\"185#_3-说一下堆栈的区别\",\"1145\":\"185#_4-java内存泄漏\",\"1146\":\"185#_5-jvm-有哪些垃圾回收算法\",\"1147\":\"185#_6-说一下-jvm-有哪些垃圾回收器\",\"1148\":\"185#_7-说一下类加载的执行过程\",\"1149\":\"185#_8-什么是双亲委派模型-为什么要使用双亲委派模型\",\"1150\":\"185#_9-cms垃圾清理的过程\",\"1151\":\"185#_10-常用的-jvm-调优的参数都有哪些\",\"1152\":\"185#系列文章\",\"1153\":\"185@0\",\"1154\":\"185@1\",\"1155\":\"186\",\"1156\":\"186#术语0-kafka中的isr、ar又代表什么-isr的伸缩又指什么\",\"1157\":\"186#术语0-kafka中的hw、leo、lso、lw等分别代表什么\",\"1158\":\"186#_1-kafka-是什么-有什么作用\",\"1159\":\"186#_2-kafka-的架构是怎么样的\",\"1160\":\"186#_3-kafka-replicas是怎么管理的\",\"1161\":\"186#_4-如何确定当前能读到哪一条消息\",\"1162\":\"186#_5-发送消息的分区策略有哪些\",\"1163\":\"186#_6-kafka-的可靠性是怎么保证的\",\"1164\":\"186#_7-分区再分配是做什么的-解决了什么问题\",\"1165\":\"186#_8-kafka-partition-副本-leader-是怎么选举的\",\"1166\":\"186#_9-分区数越多越好吗-吞吐量就会越高吗\",\"1167\":\"186#_10-kafka-为什么这么快\",\"1168\":\"186#《最少必要面试题》\",\"1169\":\"186@0\",\"1170\":\"186@1\",\"1171\":\"187\",\"1172\":\"187#_1-什么是mybatis\",\"1173\":\"187#_2-mybatis的优点\",\"1174\":\"187#_3-和-的区别是什么\",\"1175\":\"187#_4-一个-xml-映射文件-都会写一个-dao-接口与之对应-这个-dao-接口的工作原理是什么\",\"1176\":\"187#_5-如何获取自动生成的-主-键值\",\"1177\":\"187#_6-mybatis-动态-sql-有什么用-有哪些动态-sql-执行原理\",\"1178\":\"187#_7-什么是mybatis的一级、二级缓存\",\"1179\":\"187#_8-mybatis的工作原理\",\"1180\":\"187#_9-什么是mybatis的接口绑定-有哪些实现方式\",\"1181\":\"187#_10-mybatis的分页原理\",\"1182\":\"187@0\",\"1183\":\"187@1\",\"1184\":\"188\",\"1185\":\"188#_1-mysql有哪几种log\",\"1186\":\"188#_2-mysql的复制原理以及流程\",\"1187\":\"188#_3-事物的4种隔离级别\",\"1188\":\"188#_4-相关概念\",\"1189\":\"188#_5-mysql数据库几个基本的索引类型\",\"1190\":\"188#_6-drop、delete与truncate的区\",\"1191\":\"188#_7-数据库的乐观锁和悲观锁是什么\",\"1192\":\"188#_8-sql优化方式\",\"1193\":\"188#_9-从锁的类别上分mysql都有哪些锁呢\",\"1194\":\"188#推荐阅读\",\"1195\":\"188@0\",\"1196\":\"188@1\",\"1197\":\"189\",\"1198\":\"189#_1-redis是什么\",\"1199\":\"189#_2-你在哪些场景使用redis\",\"1200\":\"189#_3-为什么redis是单线程的\",\"1201\":\"189#_4-redis持久化有几种方式\",\"1202\":\"189#_5-什么是缓存穿透-怎么解决\",\"1203\":\"189#_6-什么是缓存雪崩\",\"1204\":\"189#_7-redis使用上如何做内存优化\",\"1205\":\"189#_8-你们redis使用哪种部署方式\",\"1206\":\"189#_9-redis实现分布式锁要注意什么\",\"1207\":\"189#推荐阅读\",\"1208\":\"189@0\",\"1209\":\"189@1\",\"1210\":\"190\",\"1211\":\"190#_1-什么是-spring-框架-spring-框架有哪些主要模块\",\"1212\":\"190#_2-spring-ioc、aop举例说明\",\"1213\":\"190#_3-什么是控制反转-ioc-什么是依赖注入-di\",\"1214\":\"190#_4-描述一下-spring-bean-的生命周期\",\"1215\":\"190#_5-spring-bean-的作用域之间有什么区别\",\"1216\":\"190#_6-spring中都应用了哪些设计模式\",\"1217\":\"190#_7-spring-aop里面的几个名词的概念\",\"1218\":\"190#_8-beanfactory和applicationcontext有什么区别\",\"1219\":\"190#_9-spring如何解决循环依赖问题\",\"1220\":\"190#_10-spring事务的实现方式和实现原理\",\"1221\":\"190@0\",\"1222\":\"190@1\",\"1223\":\"191\",\"1224\":\"191#_1-为什么要用-spring-boot\",\"1225\":\"191#_2-spring-boot-有哪些优点\",\"1226\":\"191#_3-spring-boot-核心配置文件是什么\",\"1227\":\"191#_4-spring-boot的核心注解是什么-由那些注解组成\",\"1228\":\"191#_5-说一下springboot的自动装配原理\",\"1229\":\"191#_6-springboot、spring-mvc和spring有什么区别\",\"1230\":\"191#_7-springboot启动时都做了什么\",\"1231\":\"191#_8-springboot-中的监视器是什么\",\"1232\":\"191#_9-springboot-中的starter到底是什么\",\"1233\":\"191#_10-微服务中如何实现-session-共享\",\"1234\":\"191@0\",\"1235\":\"191@1\",\"1236\":\"192\",\"1237\":\"192#_1-什么是-zookeeper\",\"1238\":\"192#_2-zk-的节点类型\",\"1239\":\"192#_3-zookeeper-下-server-工作状态有哪些\",\"1240\":\"192#_4-zookeeper是cp还是ap\",\"1241\":\"192#_5-说几个-zookeeper-常用的命令。\",\"1242\":\"192#_6-介绍一下zab协议\",\"1243\":\"192#_7-zab-和-paxos-算法的联系与区别\",\"1244\":\"192#_8-zookeeper-的典型应用场景\",\"1245\":\"192#_9-chroot特性\",\"1246\":\"192#拓展\",\"1247\":\"192@0\",\"1248\":\"192@1\",\"1249\":\"193\",\"1250\":\"193#缓存\",\"1251\":\"193#_1-什么是缓存\",\"1252\":\"193#_2-为什么要用缓存\",\"1253\":\"193#_3-请说说有哪些缓存算法-是否能手写一下-lru-代码的实现\",\"1254\":\"193#_4-常见的常见的缓存工具和框架有哪些\",\"1255\":\"193#_5-用了缓存之后-有哪些常见问题\",\"1256\":\"193#_6-如何处理缓存穿透的问题\",\"1257\":\"193#_7-如何处理缓存雪崩的问题\",\"1258\":\"193#_8-如何处理缓存击穿的问题\",\"1259\":\"193#_9-缓存和-db-的一致性如何保证\",\"1260\":\"193#_10-什么是缓存预热-如何实现缓存预热\",\"1261\":\"193#拓展-缓存数据的淘汰策略有哪些\",\"1262\":\"193#docker\",\"1263\":\"193#_1-什么是-docker-容器\",\"1264\":\"193#_2-docker-和虚拟机有什么不同\",\"1265\":\"193#_3-什么是-dockerfile\",\"1266\":\"193#_4-使用docker-compose时如何保证容器a先于容器b运行\",\"1267\":\"193#_5-一个完整的docker由哪些部分组成\",\"1268\":\"193#_6-docker常用命令\",\"1269\":\"193#_7-描述-docker-容器的生命周期。\",\"1270\":\"193#_8-docker容器之间怎么隔离\",\"1271\":\"193#elasticsearch\",\"1272\":\"193#_1-说说你们公司-es-的集群架构-索引数据大小-分片有多少-以及一些调优手段-。\",\"1273\":\"193#_2-elasticsearch-的倒排索引是什么\",\"1274\":\"193#_3-elasticsearch-是如何实现-master-选举的\",\"1275\":\"193#_5-描述一下-elasticsearch-索引文档的过程\",\"1276\":\"193#_4-详细描述一下-elasticsearch-搜索的过程\",\"1277\":\"193#_5-elasticsearch-在部署时-对-linux-的设置有哪些优化方法\",\"1278\":\"193#_6-elasticsearch-中的节点-比如共-20-个-其中的-10-个选了一个-master-另外-10-个选了另一个-master-怎么办\",\"1279\":\"193#_7-客户端在和集群连接时-如何选择特定的节点执行请求的\",\"1280\":\"193#_8-详细描述一下-elasticsearch-更新和删除文档的过程。\",\"1281\":\"193#_9-elasticsearch-对于大数据量-上亿量级-的聚合如何实现\",\"1282\":\"193#_10-在并发情况下-elasticsearch-如果保证读写一致\",\"1283\":\"193#_11-介绍一下你们的个性化搜索方案\",\"1284\":\"193#java基础\",\"1285\":\"193#_1-instanceof-关键字的作用\",\"1286\":\"193#_2-java自动装箱和拆箱\",\"1287\":\"193#_3-重载和重写区别\",\"1288\":\"193#_4-equals与-区别\",\"1289\":\"193#_5-谈谈nio和bio区别\",\"1290\":\"193#_6-string、stringbuffer、stringbuilder-的区别是什么\",\"1291\":\"193#_7-泛型是什么-有什么特点\",\"1292\":\"193#_8-final-有哪些用法\",\"1293\":\"193#_9-说一下java注解\",\"1294\":\"193#_10-java创建对象有几种方式\",\"1295\":\"193#java并发\",\"1296\":\"193#_1-start-方法和run-方法的区别\",\"1297\":\"193#_2-volatile关键字的作用\",\"1298\":\"193#_3-sleep方法和wait方法有什么区别\",\"1299\":\"193#_4-如何停止一个正在运行的线程\",\"1300\":\"193#_5-java如何实现多线程之间的通讯和协作-如何在两个线程间共享数据\",\"1301\":\"193#_6-什么是threadlocal\",\"1302\":\"193#_7-java-中-countdownlatch-和-cyclicbarrier-有什么不同\",\"1303\":\"193#_8-如何避免死锁\",\"1304\":\"193#_9-java-中-synchronized-和-reentrantlock-有什么不同\",\"1305\":\"193#_10-有三个线程-t1-t2-t3-怎么确保它们按顺序执行\",\"1306\":\"193#java-容器\",\"1307\":\"193#_1-请说一下java容器集合的分类-各自的继承结构\",\"1308\":\"193#_2-collection-和-collections-有什么区别\",\"1309\":\"193#_3-list、set、map-之间的区别是什么\",\"1310\":\"193#_4-hashmap-和-hashtable-有什么区别\",\"1311\":\"193#_5-说一下-hashmap-的实现原理\",\"1312\":\"193#_6-谈谈-arraylist-和-linkedlist-的区别\",\"1313\":\"193#_7-谈谈arraylist和vector的区别\",\"1314\":\"193#_8-请谈一谈-java-集合中的-fail-fast-和-fail-safe-机制\",\"1315\":\"193#_9-hashmap是怎样确定key存放在数组的哪个位置的-jdk1-8\",\"1316\":\"193#_9-1-追问-为什么计算key的hash时要把hashcode的高16位与低16位进行异或-变式-为什么不直接用key的hashcode\",\"1317\":\"193#_10-为什么要把链表转为红黑树-阈值为什么是8\",\"1318\":\"193#拓展题-为什么-hashmap-数组的长度是2的幂次方\",\"1319\":\"193#javaee\",\"1320\":\"193#_1-jsp-有哪些内置对象-作用分别是什么\",\"1321\":\"193#_2-介绍一下-servlet-生命周期\",\"1322\":\"193#_3-servlet和jsp的区别和联系\",\"1323\":\"193#_4-jsp的执行过程\",\"1324\":\"193#_5-session和cookie的区别和联系-说明在自己项目中如何使用\",\"1325\":\"193#_6-转发和重定向的联系和区别\",\"1326\":\"193#_7-拦截器和过滤器的区别\",\"1327\":\"193#_8-三次握手和四次挥手\",\"1328\":\"193#_9-tcp和udp的区别\",\"1329\":\"193#_10-如何解决跨域问题\",\"1330\":\"193#_11-什么是-csrf-攻击-如何防御csrf-攻击\",\"1331\":\"193#_12-http1-0和http1-1和http2-0的区别\",\"1332\":\"193#jvm\",\"1333\":\"193#_1-说一说jvm的主要组成部分\",\"1334\":\"193#_2-说一下-jvm-的作用\",\"1335\":\"193#_3-说一下堆栈的区别\",\"1336\":\"193#_4-java内存泄漏\",\"1337\":\"193#_5-jvm-有哪些垃圾回收算法\",\"1338\":\"193#_6-说一下-jvm-有哪些垃圾回收器\",\"1339\":\"193#_7-说一下类加载的执行过程\",\"1340\":\"193#_8-什么是双亲委派模型-为什么要使用双亲委派模型\",\"1341\":\"193#_9-cms垃圾清理的过程\",\"1342\":\"193#_10-常用的-jvm-调优的参数都有哪些\",\"1343\":\"193#kafka\",\"1344\":\"193#术语0-kafka中的isr、ar又代表什么-isr的伸缩又指什么\",\"1345\":\"193#术语0-kafka中的hw、leo、lso、lw等分别代表什么\",\"1346\":\"193#_1-kafka-是什么-有什么作用\",\"1347\":\"193#_2-kafka-的架构是怎么样的\",\"1348\":\"193#_3-kafka-replicas是怎么管理的\",\"1349\":\"193#_4-如何确定当前能读到哪一条消息\",\"1350\":\"193#_5-发送消息的分区策略有哪些\",\"1351\":\"193#_6-kafka-的可靠性是怎么保证的\",\"1352\":\"193#_7-分区再分配是做什么的-解决了什么问题\",\"1353\":\"193#_8-kafka-partition-副本-leader-是怎么选举的\",\"1354\":\"193#_9-分区数越多越好吗-吞吐量就会越高吗\",\"1355\":\"193#_10-kafka-为什么这么快\",\"1356\":\"193#mybatis\",\"1357\":\"193#_1-什么是mybatis\",\"1358\":\"193#_2-mybatis的优点\",\"1359\":\"193#_3-和-的区别是什么\",\"1360\":\"193#_4-一个-xml-映射文件-都会写一个-dao-接口与之对应-这个-dao-接口的工作原理是什么\",\"1361\":\"193#_5-如何获取自动生成的-主-键值\",\"1362\":\"193#_6-mybatis-动态-sql-有什么用-有哪些动态-sql-执行原理\",\"1363\":\"193#_7-什么是mybatis的一级、二级缓存\",\"1364\":\"193#_8-mybatis的工作原理\",\"1365\":\"193#_9-什么是mybatis的接口绑定-有哪些实现方式\",\"1366\":\"193#_10-mybatis的分页原理\",\"1367\":\"193#mysql\",\"1368\":\"193#_1-mysql有哪几种log\",\"1369\":\"193#_2-mysql的复制原理以及流程\",\"1370\":\"193#_3-事物的4种隔离级别\",\"1371\":\"193#_4-相关概念\",\"1372\":\"193#_5-mysql数据库几个基本的索引类型\",\"1373\":\"193#_6-drop、delete与truncate的区\",\"1374\":\"193#_7-数据库的乐观锁和悲观锁是什么\",\"1375\":\"193#_8-sql优化方式\",\"1376\":\"193#_9-从锁的类别上分mysql都有哪些锁呢\",\"1377\":\"193#redis\",\"1378\":\"193#_1-redis是什么\",\"1379\":\"193#_2-你在哪些场景使用redis\",\"1380\":\"193#_3-为什么redis是单线程的\",\"1381\":\"193#_4-redis持久化有几种方式\",\"1382\":\"193#_5-什么是缓存穿透-怎么解决\",\"1383\":\"193#_6-什么是缓存雪崩\",\"1384\":\"193#_7-redis使用上如何做内存优化\",\"1385\":\"193#_8-你们redis使用哪种部署方式\",\"1386\":\"193#_9-redis实现分布式锁要注意什么\",\"1387\":\"193#spring\",\"1388\":\"193#_1-什么是-spring-框架-spring-框架有哪些主要模块\",\"1389\":\"193#_2-spring-ioc、aop举例说明\",\"1390\":\"193#_3-什么是控制反转-ioc-什么是依赖注入-di\",\"1391\":\"193#_4-描述一下-spring-bean-的生命周期\",\"1392\":\"193#_5-spring-bean-的作用域之间有什么区别\",\"1393\":\"193#_6-spring中都应用了哪些设计模式\",\"1394\":\"193#_7-spring-aop里面的几个名词的概念\",\"1395\":\"193#_8-beanfactory和applicationcontext有什么区别\",\"1396\":\"193#_9-spring如何解决循环依赖问题\",\"1397\":\"193#_10-spring事务的实现方式和实现原理\",\"1398\":\"193#springboot\",\"1399\":\"193#_1-为什么要用-spring-boot\",\"1400\":\"193#_2-spring-boot-有哪些优点\",\"1401\":\"193#_3-spring-boot-核心配置文件是什么\",\"1402\":\"193#_4-spring-boot的核心注解是什么-由那些注解组成\",\"1403\":\"193#_5-说一下springboot的自动装配原理\",\"1404\":\"193#_6-springboot、spring-mvc和spring有什么区别\",\"1405\":\"193#_7-springboot启动时都做了什么\",\"1406\":\"193#_8-springboot-中的监视器是什么\",\"1407\":\"193#_9-springboot-中的starter到底是什么\",\"1408\":\"193#_10-微服务中如何实现-session-共享\",\"1409\":\"193#zookeeper\",\"1410\":\"193#_1-什么是-zookeeper\",\"1411\":\"193#_2-zk-的节点类型\",\"1412\":\"193#_3-zookeeper-下-server-工作状态有哪些\",\"1413\":\"193#_4-zookeeper是cp还是ap\",\"1414\":\"193#_5-说几个-zookeeper-常用的命令。\",\"1415\":\"193#_6-介绍一下zab协议\",\"1416\":\"193#_7-zab-和-paxos-算法的联系与区别\",\"1417\":\"193#_8-zookeeper-的典型应用场景\",\"1418\":\"193#_9-chroot特性\",\"1419\":\"193#拓展\",\"1420\":\"193@0\",\"1421\":\"194\",\"1422\":\"195\",\"1423\":\"195@0\",\"1424\":\"195@1\",\"1425\":\"196\",\"1426\":\"196#《新闻搜索elasticsearch》\",\"1427\":\"196@0\",\"1428\":\"196@1\",\"1429\":\"197\",\"1430\":\"198\",\"1431\":\"198#《用户中心》\",\"1432\":\"198@0\",\"1433\":\"198@1\",\"1434\":\"199\",\"1435\":\"199#《用户中心》\",\"1436\":\"199@0\",\"1437\":\"199@1\",\"1438\":\"200\",\"1439\":\"200#《用户中心》\",\"1440\":\"200@0\",\"1441\":\"200@1\",\"1442\":\"201\",\"1443\":\"201#《用户中心》\",\"1444\":\"201#环境\",\"1445\":\"201@0\",\"1446\":\"201@1\",\"1447\":\"202\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,20],\"2\":[1,17],\"3\":[1,7],\"4\":[1,23],\"5\":[1],\"6\":[1,12],\"7\":[1,3],\"8\":[null,null,1],\"9\":[1,3],\"10\":[1,9],\"11\":[null,null,1],\"12\":[1],\"13\":[null,null,1],\"14\":[1],\"15\":[1],\"16\":[1,2],\"17\":[1,2],\"18\":[1],\"19\":[null,null,1],\"20\":[1,18],\"21\":[null,null,1],\"22\":[null,null,1],\"23\":[1,20],\"24\":[null,null,1],\"25\":[null,null,1],\"26\":[2,10],\"27\":[2,8],\"28\":[2,12],\"29\":[2,11],\"30\":[2,10],\"31\":[1,10],\"32\":[1,1],\"33\":[1,2],\"34\":[1,1],\"35\":[2,25],\"36\":[1,5],\"37\":[1,2],\"38\":[1,3],\"39\":[1],\"40\":[null,null,1],\"41\":[null,null,1],\"42\":[1,3],\"43\":[1,19],\"44\":[1,20],\"45\":[1,12],\"46\":[1,13],\"47\":[null,null,1],\"48\":[null,null,2],\"49\":[1,36],\"50\":[1],\"51\":[null,null,1],\"52\":[2],\"53\":[1,4],\"54\":[1,2],\"55\":[1,2],\"56\":[1],\"57\":[1],\"58\":[2],\"59\":[1,4],\"60\":[1,2],\"61\":[1,2],\"62\":[1],\"63\":[1],\"64\":[1,3],\"65\":[1],\"66\":[1],\"67\":[null,null,1],\"68\":[1,1],\"69\":[null,null,1],\"70\":[1],\"71\":[1,10],\"72\":[null,null,2],\"73\":[null,null,2],\"74\":[1],\"75\":[1],\"76\":[2,21],\"77\":[1,20],\"78\":[1,11],\"79\":[1,22],\"80\":[1,27],\"81\":[1],\"82\":[1,17],\"83\":[1,26],\"84\":[3,33],\"85\":[null,null,1],\"86\":[null,null,1],\"87\":[1],\"88\":[1],\"89\":[1],\"90\":[2,81],\"91\":[1,37],\"92\":[1],\"93\":[1],\"94\":[1,171],\"95\":[1],\"96\":[1,2],\"97\":[4,12],\"98\":[5,26],\"99\":[1],\"100\":[1,23],\"101\":[1,14],\"102\":[null,null,1],\"103\":[1],\"104\":[2,36],\"105\":[1],\"106\":[2,593],\"107\":[1],\"108\":[3,5],\"109\":[1,61],\"110\":[2,6],\"111\":[1],\"112\":[1,58],\"113\":[1,3],\"114\":[2,17],\"115\":[3,12],\"116\":[1,22],\"117\":[null,null,2],\"118\":[null,null,2],\"119\":[1],\"120\":[1,2],\"121\":[1,10],\"122\":[2,36],\"123\":[2],\"124\":[3],\"125\":[2,47],\"126\":[2],\"127\":[3,40],\"128\":[3],\"129\":[4,18],\"130\":[3],\"131\":[2,11],\"132\":[3,16],\"133\":[3,9],\"134\":[3,71],\"135\":[3,27],\"136\":[3,25],\"137\":[3],\"138\":[4,17],\"139\":[4,19],\"140\":[3,33],\"141\":[4,57],\"142\":[3],\"143\":[4,44],\"144\":[4,32],\"145\":[3,85],\"146\":[3,34],\"147\":[1,9],\"148\":[2],\"149\":[2,2],\"150\":[1,20],\"151\":[2],\"152\":[3,94],\"153\":[3,64],\"154\":[2,27],\"155\":[2,1],\"156\":[5],\"157\":[3,85],\"158\":[3,31],\"159\":[3,68],\"160\":[2,2],\"161\":[2],\"162\":[2,9],\"163\":[2,7],\"164\":[2,6],\"165\":[2,13],\"166\":[2,136],\"167\":[2,3],\"168\":[1],\"169\":[1],\"170\":[null,null,1],\"171\":[null,null,1],\"172\":[3,10],\"173\":[null,null,1],\"174\":[null,null,1],\"175\":[1,21],\"176\":[3,10],\"177\":[2,34],\"178\":[2,36],\"179\":[2,12],\"180\":[2,11],\"181\":[2,24],\"182\":[2,21],\"183\":[2,36],\"184\":[2,8],\"185\":[2,7],\"186\":[2,18],\"187\":[null,null,2],\"188\":[null,null,2],\"189\":[2,2],\"190\":[1,16],\"191\":[1,26],\"192\":[2,38],\"193\":[2,24],\"194\":[5,22],\"195\":[2,46],\"196\":[3,28],\"197\":[2,17],\"198\":[1,26],\"199\":[1,8],\"200\":[2,28],\"201\":[5,35],\"202\":[null,null,2],\"203\":[null,null,2],\"204\":[1,2],\"205\":[1,8],\"206\":[null,null,1],\"207\":[null,null,1],\"208\":[1],\"209\":[1,22],\"210\":[1,3],\"211\":[1,27],\"212\":[1,33],\"213\":[1],\"214\":[1,5],\"215\":[null,null,2],\"216\":[null,null,2],\"217\":[1,14],\"218\":[1,2],\"219\":[1,6],\"220\":[null,null,2],\"221\":[null,null,1],\"222\":[1],\"223\":[1,17],\"224\":[1],\"225\":[1,38],\"226\":[1,5],\"227\":[null,null,1],\"228\":[null,null,1],\"229\":[1],\"230\":[null,null,2],\"231\":[null,null,2],\"232\":[1,18],\"233\":[null,null,2],\"234\":[null,null,3],\"235\":[2],\"236\":[null,null,3],\"237\":[null,null,3],\"238\":[2,11],\"239\":[null,null,2],\"240\":[null,null,3],\"241\":[1,8],\"242\":[null,null,2],\"243\":[null,null,2],\"244\":[1,11],\"245\":[2,9],\"246\":[1,6],\"247\":[2,15],\"248\":[1,11],\"249\":[1,21],\"250\":[1,2],\"251\":[1,79],\"252\":[1,24],\"253\":[null,null,2],\"254\":[null,null,4],\"255\":[1],\"256\":[null,null,1],\"257\":[null,null,1],\"258\":[1],\"259\":[null,null,1],\"260\":[null,null,1],\"261\":[1,2],\"262\":[1,12],\"263\":[2,44],\"264\":[2,24],\"265\":[1,12],\"266\":[1,165],\"267\":[2,60],\"268\":[2],\"269\":[1,24],\"270\":[2,116],\"271\":[5,25],\"272\":[1,27],\"273\":[1,35],\"274\":[1,87],\"275\":[1,13],\"276\":[null,null,2],\"277\":[1,5],\"278\":[1],\"279\":[6],\"280\":[4],\"281\":[1],\"282\":[2,46],\"283\":[3],\"284\":[1,77],\"285\":[3,106],\"286\":[4,122],\"287\":[1,21],\"288\":[1,131],\"289\":[1,102],\"290\":[1],\"291\":[1],\"292\":[1],\"293\":[2],\"294\":[1],\"295\":[1],\"296\":[2],\"297\":[1],\"298\":[1],\"299\":[1],\"300\":[1],\"301\":[1],\"302\":[2],\"303\":[2],\"304\":[1],\"305\":[1],\"306\":[2],\"307\":[1],\"308\":[1],\"309\":[1],\"310\":[1],\"311\":[1],\"312\":[3],\"313\":[1],\"314\":[1],\"315\":[1],\"316\":[3],\"317\":[1],\"318\":[1],\"319\":[4],\"320\":[1],\"321\":[1],\"322\":[1],\"323\":[1],\"324\":[1],\"325\":[1],\"326\":[null,null,1],\"327\":[null,null,1],\"328\":[3,20],\"329\":[1,28],\"330\":[1,21],\"331\":[2],\"332\":[2,10],\"333\":[3,38],\"334\":[3,14],\"335\":[3,4],\"336\":[3,15],\"337\":[3,88],\"338\":[5],\"339\":[3,85],\"340\":[4,25],\"341\":[5],\"342\":[4,30],\"343\":[3,16],\"344\":[null,null,1],\"345\":[null,null,2],\"346\":[1,3],\"347\":[1,29],\"348\":[5,62],\"349\":[2],\"350\":[3,19],\"351\":[2,25],\"352\":[2,109],\"353\":[2,79],\"354\":[null,null,2],\"355\":[null,null,2],\"356\":[1,19],\"357\":[5,32],\"358\":[3,16],\"359\":[2,62],\"360\":[3,43],\"361\":[3,19],\"362\":[null,null,2],\"363\":[null,null,2],\"364\":[1,194],\"365\":[null,null,2],\"366\":[null,null,2],\"367\":[1],\"368\":[1,7],\"369\":[2],\"370\":[2,12],\"371\":[3,31],\"372\":[3,11],\"373\":[2],\"374\":[3,25],\"375\":[2,58],\"376\":[2],\"377\":[4,98],\"378\":[null,null,2],\"379\":[null,null,2],\"380\":[2,4],\"381\":[1,8],\"382\":[1,18],\"383\":[1,33],\"384\":[1],\"385\":[2,41],\"386\":[4,7],\"387\":[1,128],\"388\":[1,245],\"389\":[null,null,2],\"390\":[null,null,1],\"391\":[1],\"392\":[null,null,2],\"393\":[null,null,2],\"394\":[5,68],\"395\":[null,null,2],\"396\":[null,null,2],\"397\":[5,20],\"398\":[1,2],\"399\":[3],\"400\":[1,47],\"401\":[1,30],\"402\":[1,8],\"403\":[1,24],\"404\":[1,5],\"405\":[2,17],\"406\":[2,67],\"407\":[2,9],\"408\":[2,31],\"409\":[null,null,2],\"410\":[null,null,2],\"411\":[5,53],\"412\":[1,38],\"413\":[1,36],\"414\":[1,12],\"415\":[2],\"416\":[1,7],\"417\":[1,7],\"418\":[1,9],\"419\":[1,26],\"420\":[1,21],\"421\":[1,10],\"422\":[1,30],\"423\":[1,1],\"424\":[1,32],\"425\":[1,58],\"426\":[null,null,2],\"427\":[null,null,2],\"428\":[5,25],\"429\":[3,39],\"430\":[1],\"431\":[3,48],\"432\":[1,24],\"433\":[2,27],\"434\":[2,41],\"435\":[2,14],\"436\":[2,87],\"437\":[2,21],\"438\":[1,24],\"439\":[1,54],\"440\":[1,154],\"441\":[1,10],\"442\":[1,9],\"443\":[1,39],\"444\":[1,23],\"445\":[1,19],\"446\":[1,12],\"447\":[1,11],\"448\":[1,10],\"449\":[1,5],\"450\":[1,26],\"451\":[1,46],\"452\":[1,3],\"453\":[1,9],\"454\":[1,13],\"455\":[1,10],\"456\":[2,15],\"457\":[1,59],\"458\":[null,null,2],\"459\":[null,null,2],\"460\":[5,28],\"461\":[1],\"462\":[1,8],\"463\":[1],\"464\":[1],\"465\":[1],\"466\":[1],\"467\":[1],\"468\":[1],\"469\":[1],\"470\":[1],\"471\":[1],\"472\":[1],\"473\":[1],\"474\":[1],\"475\":[1],\"476\":[null,null,2],\"477\":[null,null,2],\"478\":[1,1],\"479\":[null,null,3],\"480\":[null,null,3],\"481\":[1,12],\"482\":[1,1],\"483\":[1,17],\"484\":[2,9],\"485\":[1,7],\"486\":[1,13],\"487\":[1,55],\"488\":[1,93],\"489\":[null,null,4],\"490\":[null,null,4],\"491\":[1],\"492\":[2,5],\"493\":[1,13],\"494\":[2,9],\"495\":[2,65],\"496\":[2,11],\"497\":[4,16],\"498\":[3,31],\"499\":[7,78],\"500\":[4,23],\"501\":[3,94],\"502\":[3,58],\"503\":[6,61],\"504\":[4,54],\"505\":[4,41],\"506\":[3,44],\"507\":[4,45],\"508\":[5,31],\"509\":[5,18],\"510\":[2,36],\"511\":[6,77],\"512\":[null,null,1],\"513\":[null,null,2],\"514\":[1],\"515\":[1,51],\"516\":[1,43],\"517\":[1,31],\"518\":[1,24],\"519\":[1,13],\"520\":[1,50],\"521\":[1,9],\"522\":[1,4],\"523\":[1,5],\"524\":[1,30],\"525\":[2,47],\"526\":[9,90],\"527\":[7,34],\"528\":[9,21],\"529\":[8,16],\"530\":[3,15],\"531\":[7,10],\"532\":[5,15],\"533\":[9],\"534\":[7],\"535\":[7,14],\"536\":[7,13],\"537\":[10,12],\"538\":[6,3],\"539\":[10],\"540\":[8,3],\"541\":[4,15],\"542\":[17,13],\"543\":[10],\"544\":[6],\"545\":[5],\"546\":[9,7],\"547\":[4],\"548\":[5,14],\"549\":[null,null,1],\"550\":[null,null,2],\"551\":[2,3],\"552\":[1,16],\"553\":[2,22],\"554\":[3,2],\"555\":[4,55],\"556\":[3,36],\"557\":[3,16],\"558\":[4,66],\"559\":[3,44],\"560\":[3,16],\"561\":[4,62],\"562\":[2,34],\"563\":[4,4],\"564\":[4,17],\"565\":[4,20],\"566\":[4,20],\"567\":[1,21],\"568\":[3],\"569\":[1,37],\"570\":[1,32],\"571\":[5,30],\"572\":[6,20],\"573\":[3,45],\"574\":[3,43],\"575\":[4,81],\"576\":[2,2],\"577\":[3,47],\"578\":[4,20],\"579\":[3,27],\"580\":[2,17],\"581\":[3,41],\"582\":[null,null,1],\"583\":[null,null,2],\"584\":[1],\"585\":[3],\"586\":[3,10],\"587\":[1,36],\"588\":[6,10],\"589\":[2,101],\"590\":[2],\"591\":[3,33],\"592\":[3,22],\"593\":[2,26],\"594\":[2,103],\"595\":[2],\"596\":[3],\"597\":[3,61],\"598\":[4,20],\"599\":[2],\"600\":[3,6],\"601\":[3,57],\"602\":[4,48],\"603\":[5,98],\"604\":[5,126],\"605\":[5,89],\"606\":[5,88],\"607\":[5,119],\"608\":[2,16],\"609\":[null,null,1],\"610\":[null,null,2],\"611\":[3],\"612\":[3,3],\"613\":[1,41],\"614\":[2,35],\"615\":[2,31],\"616\":[3,9],\"617\":[2],\"618\":[3],\"619\":[3,74],\"620\":[4,35],\"621\":[4,45],\"622\":[4,25],\"623\":[4],\"624\":[4,114],\"625\":[7,53],\"626\":[3,24],\"627\":[2],\"628\":[3,59],\"629\":[3,32],\"630\":[3,43],\"631\":[3],\"632\":[4,28],\"633\":[5,32],\"634\":[3],\"635\":[4,79],\"636\":[4,35],\"637\":[null,null,1],\"638\":[null,null,2],\"639\":[3],\"640\":[3,9],\"641\":[1,14],\"642\":[3],\"643\":[4,24],\"644\":[3],\"645\":[3,26],\"646\":[4],\"647\":[3,19],\"648\":[4,169],\"649\":[null,null,1],\"650\":[null,null,2],\"651\":[1],\"652\":[1,27],\"653\":[1,17],\"654\":[1,32],\"655\":[1,41],\"656\":[1,40],\"657\":[1,33],\"658\":[1,88],\"659\":[1,71],\"660\":[1,49],\"661\":[null,null,1],\"662\":[null,null,1],\"663\":[1,8],\"664\":[2,67],\"665\":[null,null,3],\"666\":[null,null,4],\"667\":[1],\"668\":[5,10],\"669\":[1,4],\"670\":[1],\"671\":[2,7],\"672\":[2,12],\"673\":[2,12],\"674\":[2,6],\"675\":[2,13],\"676\":[null,null,1],\"677\":[null,null,1],\"678\":[1],\"679\":[null,null,1],\"680\":[null,null,1],\"681\":[3,13],\"682\":[1,4],\"683\":[1,7],\"684\":[1,1],\"685\":[1],\"686\":[2,7],\"687\":[2,13],\"688\":[2,62],\"689\":[2,161],\"690\":[1,22],\"691\":[null,null,4],\"692\":[1,227],\"693\":[null,null,2],\"694\":[1],\"695\":[null,null,2],\"696\":[null,null,2],\"697\":[2],\"698\":[2,73],\"699\":[3,16],\"700\":[2,13],\"701\":[3,44],\"702\":[3,57],\"703\":[3,41],\"704\":[3,36],\"705\":[3,96],\"706\":[3,49],\"707\":[3,13],\"708\":[3,41],\"709\":[3,62],\"710\":[3,42],\"711\":[3,33],\"712\":[3,29],\"713\":[3,47],\"714\":[3,25],\"715\":[3,113],\"716\":[3,22],\"717\":[null,null,2],\"718\":[null,null,2],\"719\":[1],\"720\":[null,null,2],\"721\":[null,null,2],\"722\":[3,9],\"723\":[2,17],\"724\":[3,69],\"725\":[3,26],\"726\":[2,49],\"727\":[2,67],\"728\":[2,15],\"729\":[null,null,2],\"730\":[2],\"731\":[2,2],\"732\":[1,20],\"733\":[2],\"734\":[2],\"735\":[3,13],\"736\":[3,54],\"737\":[3,82],\"738\":[3,5],\"739\":[2,10],\"740\":[2,1],\"741\":[5],\"742\":[6,12],\"743\":[7,73],\"744\":[6,52],\"745\":[6,71],\"746\":[6,19],\"747\":[7,101],\"748\":[3,1],\"749\":[2],\"750\":[3],\"751\":[3,21],\"752\":[4],\"753\":[4,30],\"754\":[4,41],\"755\":[6,106],\"756\":[3,18],\"757\":[3,84],\"758\":[2,1],\"759\":[3,69],\"760\":[2],\"761\":[3,20],\"762\":[3,56],\"763\":[3,239],\"764\":[3,9],\"765\":[4,5],\"766\":[3,73],\"767\":[3,11],\"768\":[5,38],\"769\":[5,11],\"770\":[5,83],\"771\":[5,15],\"772\":[3,77],\"773\":[3],\"774\":[3],\"775\":[3,15],\"776\":[4,19],\"777\":[4,9],\"778\":[4,11],\"779\":[4,100],\"780\":[5,30],\"781\":[3,4],\"782\":[3,77],\"783\":[2,5],\"784\":[3,53],\"785\":[5,71],\"786\":[4,106],\"787\":[3,78],\"788\":[2],\"789\":[3,128],\"790\":[3,138],\"791\":[2],\"792\":[3,39],\"793\":[3,107],\"794\":[3,100],\"795\":[3,147],\"796\":[3,1],\"797\":[3,39],\"798\":[2,1],\"799\":[4],\"800\":[3,66],\"801\":[3,38],\"802\":[null,null,2],\"803\":[null,null,2],\"804\":[1],\"805\":[null,null,2],\"806\":[null,null,2],\"807\":[1,21],\"808\":[1,9],\"809\":[1,8],\"810\":[1],\"811\":[1,10],\"812\":[1,188],\"813\":[1],\"814\":[1],\"815\":[3,128],\"816\":[2,19],\"817\":[3,48],\"818\":[3,74],\"819\":[3,105],\"820\":[2,84],\"821\":[1,60],\"822\":[1,5],\"823\":[2],\"824\":[1,104],\"825\":[1,58],\"826\":[1,74],\"827\":[1,112],\"828\":[1,110],\"829\":[2,133],\"830\":[2,206],\"831\":[1,154],\"832\":[1,99],\"833\":[null,null,3],\"834\":[1],\"835\":[1],\"836\":[1,10],\"837\":[1,46],\"838\":[3,37],\"839\":[2,41],\"840\":[1,2],\"841\":[null,null,2],\"842\":[null,null,2],\"843\":[2],\"844\":[1,222],\"845\":[null,null,2],\"846\":[null,null,2],\"847\":[4,3],\"848\":[1],\"849\":[1,52],\"850\":[4,27],\"851\":[1,5],\"852\":[1,66],\"853\":[1,3],\"854\":[1,19],\"855\":[1,12],\"856\":[1,25],\"857\":[null,null,4],\"858\":[null,null,4],\"859\":[4,2],\"860\":[1,8],\"861\":[1,4],\"862\":[1,31],\"863\":[1,3],\"864\":[1,61],\"865\":[1,186],\"866\":[1,24],\"867\":[1,8],\"868\":[null,null,3],\"869\":[null,null,3],\"870\":[4],\"871\":[4,24],\"872\":[1,12],\"873\":[3,4],\"874\":[1,17],\"875\":[1],\"876\":[1,81],\"877\":[1,3],\"878\":[1,13],\"879\":[null,null,2],\"880\":[null,null,3],\"881\":[4,10],\"882\":[1],\"883\":[1,32],\"884\":[1,18],\"885\":[1,69],\"886\":[1,6],\"887\":[1,93],\"888\":[1,18],\"889\":[1,25],\"890\":[null,null,3],\"891\":[null,null,3],\"892\":[1],\"893\":[1],\"894\":[1],\"895\":[4,9],\"896\":[2,24],\"897\":[3,9],\"898\":[3,31],\"899\":[1,14],\"900\":[null,null,1],\"901\":[null,null,2],\"902\":[1],\"903\":[1,8],\"904\":[1,14],\"905\":[1],\"906\":[2,40],\"907\":[1,5],\"908\":[1],\"909\":[1,10],\"910\":[1,11],\"911\":[1,22],\"912\":[1,17],\"913\":[2,70],\"914\":[1,4],\"915\":[1,21],\"916\":[4,124],\"917\":[5,111],\"918\":[4,52],\"919\":[4,39],\"920\":[1,55],\"921\":[null,null,2],\"922\":[1,386],\"923\":[null,null,2],\"924\":[1,209],\"925\":[null,null,2],\"926\":[1,106],\"927\":[null,null,2],\"928\":[1,202],\"929\":[null,null,2],\"930\":[1,151],\"931\":[null,null,2],\"932\":[1,216],\"933\":[null,null,2],\"934\":[1,274],\"935\":[null,null,2],\"936\":[1,218],\"937\":[null,null,2],\"938\":[1,186],\"939\":[null,null,2],\"940\":[1,276],\"941\":[null,null,2],\"942\":[1,127],\"943\":[null,null,2],\"944\":[1,261],\"945\":[null,null,2],\"946\":[1,184],\"947\":[null,null,2],\"948\":[1,209],\"949\":[null,null,2],\"950\":[1,356],\"951\":[null,null,2],\"952\":[1,273],\"953\":[null,null,2],\"954\":[1,183],\"955\":[null,null,2],\"956\":[1,171],\"957\":[null,null,2],\"958\":[1,227],\"959\":[null,null,2],\"960\":[1,123],\"961\":[null,null,2],\"962\":[1,158],\"963\":[null,null,2],\"964\":[1,145],\"965\":[null,null,2],\"966\":[1,308],\"967\":[null,null,2],\"968\":[1,92],\"969\":[null,null,2],\"970\":[1,109],\"971\":[null,null,2],\"972\":[1,85],\"973\":[null,null,2],\"974\":[1,85],\"975\":[null,null,2],\"976\":[1,81],\"977\":[null,null,2],\"978\":[1,95],\"979\":[null,null,2],\"980\":[1,94],\"981\":[null,null,2],\"982\":[1,133],\"983\":[null,null,2],\"984\":[1,130],\"985\":[null,null,2],\"986\":[1,101],\"987\":[null,null,2],\"988\":[1,196],\"989\":[null,null,2],\"990\":[1,158],\"991\":[null,null,2],\"992\":[1,110],\"993\":[null,null,2],\"994\":[1,100],\"995\":[null,null,2],\"996\":[1,100],\"997\":[null,null,2],\"998\":[1,107],\"999\":[null,null,2],\"1000\":[1,78],\"1001\":[null,null,2],\"1002\":[1,124],\"1003\":[null,null,2],\"1004\":[1,117],\"1005\":[null,null,2],\"1006\":[1,101],\"1007\":[null,null,2],\"1008\":[1,162],\"1009\":[null,null,2],\"1010\":[1,124],\"1011\":[null,null,2],\"1012\":[1,91],\"1013\":[null,null,2],\"1014\":[2],\"1015\":[null,null,2],\"1016\":[1,155],\"1017\":[null,null,2],\"1018\":[1,230],\"1019\":[null,null,2],\"1020\":[1,219],\"1021\":[null,null,2],\"1022\":[1,214],\"1023\":[2,233],\"1024\":[null,null,2],\"1025\":[2],\"1026\":[3,20],\"1027\":[4,44],\"1028\":[null,null,1],\"1029\":[null,null,2],\"1030\":[3,44],\"1031\":[3,14],\"1032\":[5,42],\"1033\":[3,50],\"1034\":[4,43],\"1035\":[1],\"1036\":[1,15],\"1037\":[null,null,1],\"1038\":[null,null,2],\"1039\":[2,4],\"1040\":[null,null,2],\"1041\":[1,22],\"1042\":[3,34],\"1043\":[3,32],\"1044\":[6,85],\"1045\":[3,18],\"1046\":[4,14],\"1047\":[2,69],\"1048\":[2,77],\"1049\":[2,81],\"1050\":[5,85],\"1051\":[4,29],\"1052\":[3,20],\"1053\":[2,15],\"1054\":[null,null,1],\"1055\":[null,null,2],\"1056\":[3,20],\"1057\":[5,9],\"1058\":[4,5],\"1059\":[4,41],\"1060\":[4,36],\"1061\":[3,9],\"1062\":[2,35],\"1063\":[5,12],\"1064\":[3,56],\"1065\":[null,null,1],\"1066\":[null,null,2],\"1067\":[1,16],\"1068\":[8,78],\"1069\":[3,12],\"1070\":[5,38],\"1071\":[4,118],\"1072\":[5,151],\"1073\":[6,41],\"1074\":[14,18],\"1075\":[4,8],\"1076\":[5,30],\"1077\":[6,66],\"1078\":[5,44],\"1079\":[3,14],\"1080\":[2,16],\"1081\":[null,null,1],\"1082\":[null,null,2],\"1083\":[1,12],\"1084\":[3,56],\"1085\":[2,135],\"1086\":[2,63],\"1087\":[2,73],\"1088\":[2,111],\"1089\":[6,16],\"1090\":[3,42],\"1091\":[3,56],\"1092\":[2,230],\"1093\":[2,60],\"1094\":[2,16],\"1095\":[null,null,1],\"1096\":[null,null,2],\"1097\":[1,11],\"1098\":[4,14],\"1099\":[2,81],\"1100\":[2,107],\"1101\":[3,126],\"1102\":[4,30],\"1103\":[3,19],\"1104\":[8,132],\"1105\":[3,158],\"1106\":[8,43],\"1107\":[7,94],\"1108\":[2,16],\"1109\":[null,null,1],\"1110\":[null,null,2],\"1111\":[1,13],\"1112\":[3,24],\"1113\":[6,17],\"1114\":[6,7],\"1115\":[6,32],\"1116\":[5,33],\"1117\":[6,30],\"1118\":[2,18],\"1119\":[9,60],\"1120\":[4,10],\"1121\":[7,9],\"1122\":[4,36],\"1123\":[5,45],\"1124\":[null,null,1],\"1125\":[null,null,2],\"1126\":[3,22],\"1127\":[5,22],\"1128\":[4,71],\"1129\":[2,28],\"1130\":[2,24],\"1131\":[4,41],\"1132\":[3,15],\"1133\":[2,56],\"1134\":[2,14],\"1135\":[2,10],\"1136\":[3,38],\"1137\":[5,23],\"1138\":[5,36],\"1139\":[null,null,1],\"1140\":[null,null,2],\"1141\":[1,16],\"1142\":[2,55],\"1143\":[5,27],\"1144\":[3,43],\"1145\":[2,20],\"1146\":[4,24],\"1147\":[5],\"1148\":[3,16],\"1149\":[4,27],\"1150\":[2,45],\"1151\":[5,34],\"1152\":[1,16],\"1153\":[null,null,1],\"1154\":[null,null,2],\"1155\":[3,21],\"1156\":[4,27],\"1157\":[6,28],\"1158\":[5,33],\"1159\":[4,95],\"1160\":[4,29],\"1161\":[3,37],\"1162\":[3,41],\"1163\":[4,65],\"1164\":[4,38],\"1165\":[7,67],\"1166\":[4,93],\"1167\":[4,74],\"1168\":[2,16],\"1169\":[null,null,1],\"1170\":[null,null,2],\"1171\":[3,18],\"1172\":[2,16],\"1173\":[2,10],\"1174\":[4,36],\"1175\":[10,45],\"1176\":[5,76],\"1177\":[8,85],\"1178\":[4,49],\"1179\":[2,67],\"1180\":[4,25],\"1181\":[2,50],\"1182\":[null,null,1],\"1183\":[null,null,2],\"1184\":[1,21],\"1185\":[2,29],\"1186\":[2,19],\"1187\":[2,27],\"1188\":[2,43],\"1189\":[2,4],\"1190\":[3,27],\"1191\":[3,77],\"1192\":[2,47],\"1193\":[3,26],\"1194\":[2,17],\"1195\":[null,null,1],\"1196\":[null,null,2],\"1197\":[1,12],\"1198\":[3,21],\"1199\":[2,30],\"1200\":[3,8],\"1201\":[3,28],\"1202\":[4,19],\"1203\":[3,32],\"1204\":[3,43],\"1205\":[3,67],\"1206\":[3,23],\"1207\":[2,16],\"1208\":[null,null,1],\"1209\":[null,null,2],\"1210\":[1,17],\"1211\":[6,38],\"1212\":[4,173],\"1213\":[6,22],\"1214\":[6,59],\"1215\":[5,24],\"1216\":[2,135],\"1217\":[3,83],\"1218\":[3,58],\"1219\":[3,82],\"1220\":[3,119],\"1221\":[null,null,1],\"1222\":[null,null,2],\"1223\":[3,18],\"1224\":[5,11],\"1225\":[5,26],\"1226\":[5,24],\"1227\":[5,12],\"1228\":[2,33],\"1229\":[5,14],\"1230\":[3,16],\"1231\":[4,12],\"1232\":[4,55],\"1233\":[5,46],\"1234\":[null,null,1],\"1235\":[null,null,2],\"1236\":[3,18],\"1237\":[3,25],\"1238\":[3,39],\"1239\":[6,33],\"1240\":[3,20],\"1241\":[5,8],\"1242\":[3,23],\"1243\":[6,54],\"1244\":[3,82],\"1245\":[2,20],\"1246\":[1,29],\"1247\":[null,null,1],\"1248\":[null,null,2],\"1249\":[3,11],\"1250\":[1],\"1251\":[3,34],\"1252\":[3,32],\"1253\":[6,85],\"1254\":[3,18],\"1255\":[4,14],\"1256\":[2,69],\"1257\":[2,77],\"1258\":[2,81],\"1259\":[5,85],\"1260\":[4,29],\"1261\":[3,20],\"1262\":[1],\"1263\":[5,9],\"1264\":[4,5],\"1265\":[4,41],\"1266\":[4,36],\"1267\":[3,9],\"1268\":[2,35],\"1269\":[5,12],\"1270\":[3,39],\"1271\":[1],\"1272\":[8,78],\"1273\":[3,12],\"1274\":[5,38],\"1275\":[4,119],\"1276\":[5,153],\"1277\":[6,41],\"1278\":[14,18],\"1279\":[4,8],\"1280\":[5,30],\"1281\":[6,66],\"1282\":[5,44],\"1283\":[3,14],\"1284\":[1],\"1285\":[3,56],\"1286\":[2,135],\"1287\":[2,63],\"1288\":[2,73],\"1289\":[2,111],\"1290\":[6,16],\"1291\":[3,42],\"1292\":[3,56],\"1293\":[2,230],\"1294\":[2,56],\"1295\":[1],\"1296\":[4,14],\"1297\":[2,81],\"1298\":[2,107],\"1299\":[3,126],\"1300\":[4,30],\"1301\":[3,19],\"1302\":[8,132],\"1303\":[3,158],\"1304\":[8,43],\"1305\":[7,91],\"1306\":[2],\"1307\":[3,24],\"1308\":[6,17],\"1309\":[6,7],\"1310\":[6,32],\"1311\":[5,33],\"1312\":[6,30],\"1313\":[2,18],\"1314\":[9,60],\"1315\":[4,10],\"1316\":[7,9],\"1317\":[4,36],\"1318\":[5,28],\"1319\":[1],\"1320\":[5,22],\"1321\":[4,71],\"1322\":[2,28],\"1323\":[2,24],\"1324\":[4,41],\"1325\":[3,15],\"1326\":[2,56],\"1327\":[2,14],\"1328\":[2,10],\"1329\":[3,38],\"1330\":[5,23],\"1331\":[5,19],\"1332\":[1],\"1333\":[2,56],\"1334\":[5,27],\"1335\":[3,43],\"1336\":[2,20],\"1337\":[4,24],\"1338\":[5,1],\"1339\":[3,17],\"1340\":[4,27],\"1341\":[2,46],\"1342\":[5,31],\"1343\":[1,5],\"1344\":[4,27],\"1345\":[6,28],\"1346\":[5,33],\"1347\":[4,95],\"1348\":[4,29],\"1349\":[3,37],\"1350\":[3,41],\"1351\":[4,65],\"1352\":[4,38],\"1353\":[7,67],\"1354\":[4,93],\"1355\":[4,74],\"1356\":[1],\"1357\":[2,16],\"1358\":[2,10],\"1359\":[4,36],\"1360\":[10,45],\"1361\":[5,76],\"1362\":[8,85],\"1363\":[4,49],\"1364\":[2,67],\"1365\":[4,25],\"1366\":[2,33],\"1367\":[1,10],\"1368\":[2,29],\"1369\":[2,19],\"1370\":[2,27],\"1371\":[2,43],\"1372\":[2,4],\"1373\":[3,27],\"1374\":[3,77],\"1375\":[2,47],\"1376\":[3,26],\"1377\":[1],\"1378\":[3,21],\"1379\":[2,30],\"1380\":[3,8],\"1381\":[3,28],\"1382\":[4,19],\"1383\":[3,32],\"1384\":[3,44],\"1385\":[3,67],\"1386\":[3,23],\"1387\":[1],\"1388\":[6,38],\"1389\":[4,173],\"1390\":[6,22],\"1391\":[6,59],\"1392\":[5,24],\"1393\":[2,135],\"1394\":[3,83],\"1395\":[3,58],\"1396\":[3,82],\"1397\":[3,103],\"1398\":[1],\"1399\":[5,11],\"1400\":[5,26],\"1401\":[5,24],\"1402\":[5,12],\"1403\":[2,33],\"1404\":[5,14],\"1405\":[3,16],\"1406\":[4,12],\"1407\":[4,55],\"1408\":[5,29],\"1409\":[1],\"1410\":[3,25],\"1411\":[3,39],\"1412\":[6,33],\"1413\":[3,20],\"1414\":[5,8],\"1415\":[3,23],\"1416\":[6,54],\"1417\":[3,82],\"1418\":[2,20],\"1419\":[1,15],\"1420\":[null,null,2],\"1421\":[1],\"1422\":[3,6],\"1423\":[null,null,3],\"1424\":[null,null,3],\"1425\":[3],\"1426\":[2,2],\"1427\":[null,null,3],\"1428\":[null,null,3],\"1429\":[3,28],\"1430\":[1,1],\"1431\":[2,174],\"1432\":[null,null,3],\"1433\":[null,null,2],\"1434\":[3],\"1435\":[2,2],\"1436\":[null,null,3],\"1437\":[null,null,2],\"1438\":[3,4],\"1439\":[2,103],\"1440\":[null,null,3],\"1441\":[null,null,2],\"1442\":[2,5],\"1443\":[2,26],\"1444\":[1,184],\"1445\":[null,null,3],\"1446\":[null,null,5],\"1447\":[1,3]},\"averageFieldLength\":[2.4958517097023822,40.100160604262705,0.9972358690097336],\"storedFields\":{\"0\":{\"h\":\"项目主页\"},\"1\":{\"h\":\"网站信息\",\"t\":[\"JavaPub 官方网站，优质原创资源会在这里归档，计划运营到 2050 年，期待你的陪伴。目前所有内容都由站长个人维护、并在逐步完善中，如果你有兴趣欢迎参与进来。\",\"如果觉得有用，可以前往代码仓库点个免费的 start (求星星✨)。传送门： GitHub | Gitee\",\"实战项目\",\"常见问题\"]},\"2\":{\"h\":\"关于站长\",\"t\":[\"linktr | 个人站点 | 微信公众号 | 微博 | 语雀 | 知乎 | GitHub | 掘金 | CSDN | 腾讯云开发者社区 | 哔哩哔哩 | 阿里云栖社区 | 西瓜视频 | 微博\",\"作者信息\",\"作者照片\",\"联系站长\"]},\"3\":{\"h\":\"公众号\",\"t\":[\"所有的内容会公众号第一时间更新，其他平台也会同步。此外，通过公众号可以获得站长联系方式。\",\"JavaPub官方公众号\",\"Visitor Count\"]},\"4\":{\"h\":\"搜索引擎收录直达\",\"t\":[\"收录\",\"地址\",\"谷歌收录\",\"https://www.google.com.hk/search?q=javapub\",\"百度收录\",\"https://www.baidu.com/s?wd=javapub\",\"必应收录\",\"https://www4.bing.com/search?q=javapub\",\"360收录\",\"https://www.so.com/s?q=javapub\",\"搜狗收录\",\"https://www.sogou.com/web?query=javapub\"]},\"5\":{\"h\":\"档案主页\"},\"6\":{\"h\":\"介绍\",\"t\":[\"这是一个档案主页的案例。\",\"要使用此布局，你应该在页面 Frontmatter 中设置 home: true 和 portfolio: true。\",\"相关配置文档请见 档案主页。\"]},\"7\":{\"h\":\"Java\",\"t\":[\"《阿里巴巴开发手册（黄山版）》\"]},\"8\":{\"c\":[\"java\"]},\"9\":{\"h\":\"技术书籍\",\"t\":[\"知识是人类进步的阶梯，永远是。\"]},\"10\":{\"h\":\"成长\",\"t\":[\"《提问的智慧》\",\"《比特币：一个虚幻而真实的金融世界》\",\"《一个创业程序员的35岁人生人生总结》\",\"《华尔街之狼》\",\"《华商崛起》\",\"《天才源自刻意练习：通向成功的高效学习法》\"]},\"11\":{\"c\":[\"成长\"]},\"12\":{\"h\":\"数据库\"},\"13\":{\"c\":[\"数据库\"]},\"14\":{\"h\":\"指南\"},\"15\":{\"h\":\"功能亮点\"},\"16\":{\"h\":\"Bar\",\"t\":[\"baz\",\"...\"]},\"17\":{\"h\":\"Foo\",\"t\":[\"ray\",\"...\"]},\"18\":{\"h\":\"主要功能与配置演示\"},\"19\":{\"c\":[\"使用指南\"]},\"20\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"21\":{\"c\":[\"使用指南\"]},\"22\":{\"c\":[\"禁用\"]},\"23\":{\"h\":\"布局\",\"t\":[\"布局包括:\",\"导航栏\",\"侧边栏\",\"页脚\",\"同时每个页面包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"主题也带有以下元素:\",\"夜间模式按钮\",\"返回顶部按钮\",\"打印按钮\",\"你可以在主题选项和页面的 frontmatter 中自定义它们。\"]},\"24\":{\"c\":[\"指南\"]},\"25\":{\"c\":[\"布局\"]},\"26\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你需要创建并编写 Markdown，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"27\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"28\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"Frontmatter\",\"Frontmatter 是 VuePress 中很重要的一个概念，请阅读 Frontmatter 介绍 了解详情。\"]},\"29\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"30\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"31\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"32\":{\"h\":\"选项卡\",\"t\":[\"查看详情\"]},\"33\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注^first.\",\"查看详情\"]},\"34\":{\"h\":\"导入文件\",\"t\":[\"查看详情\"]},\"35\":{\"h\":\"TeX 语法\",\"t\":[\"$$ \\\\frac {\\\\partial^r} {\\\\partial \\\\omega^r} \\\\left(\\\\frac {y^{\\\\omega}} {\\\\omega}\\\\right) = \\\\left(\\\\frac {y^{\\\\omega}} {\\\\omega}\\\\right) \\\\left{(\\\\log y)^r + \\\\sum_{i=1}^r \\\\frac {(-1)^i r \\\\cdots (r-i+1) (\\\\log y)^{r-i}} {\\\\omega^i} \\\\right} $$\",\"查看详情\"]},\"36\":{\"h\":\"任务列表\",\"t\":[\" 计划 1\",\" 计划 2\",\"查看详情\"]},\"37\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小。\",\"查看详情\"]},\"38\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"39\":{\"h\":\"组件\"},\"40\":{\"c\":[\"使用指南\"]},\"41\":{\"c\":[\"Markdown\"]},\"42\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"43\":{\"h\":\"页面标题\",\"t\":[\"The first H1 title in Markdown will be regarded as page title.\",\"Markdown 中的第一个 H1 标题会被视为页面标题。\",\"你可以在 Markdown 的 Frontmatter 中设置页面标题。\",\"--- title: 页面标题 ---\"]},\"44\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"45\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"图片引入\",\"你可以将图片和 Markdown 文件放置在一起使用相对路径进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\"]},\"46\":{\"h\":\"组件\",\"t\":[\"每个 Markdown 页面都会被转换为一个 Vue 组件，这意味着你可以在 Markdown 中使用 Vue 语法：\",\"{{ 1 + 1 }}\",\"{{ i }}\",\"你也可以创建并引入你自己的组件。\"]},\"47\":{\"c\":[\"使用指南\"]},\"48\":{\"c\":[\"页面配置\",\"使用指南\"]},\"49\":{\"h\":\"编程指南\",\"t\":[\"🔔提示\",\"面试专题： 在准备面试的朋友可以优先阅读面试专栏 最少必要面试题\",\"知识星球： 星球内提供一对一交流/简历修改/实战项目直播教学等专属求职指南，毕竟合不合适也可以先体验 3 天。欢迎加入 JavaPub知识星球\",\"求个 Star：如果 JavaPub 的内容对你有所帮助，请点一个免费的 Star，这是对我最大的鼓励。传送门： GitHub | Gitee。\",\"转载说明： 所有文章非特别说明都为 JavaPub 原创，转载请在文章头部注明出处。抄袭不会长久，合作才有未来。还有这样做违FA，费时费力，不如加上三五好友加入 编程指南知识星球 分享高昂分成。\"]},\"50\":{\"h\":\"关于网站\"},\"51\":{\"c\":[\"网站信息\"]},\"52\":{\"h\":\"Bar 功能\"},\"53\":{\"h\":\"介绍\",\"t\":[\"我们支持 bar 功能，...\"]},\"54\":{\"h\":\"详情\",\"t\":[\"baz\",\"...\"]},\"55\":{\"h\":\"Baz\",\"t\":[\"功能详情...\"]},\"56\":{\"h\":\"二级\"},\"57\":{\"h\":\"三级\"},\"58\":{\"h\":\"Foo 功能\"},\"59\":{\"h\":\"介绍\",\"t\":[\"我们支持 foo 功能，...\"]},\"60\":{\"h\":\"详情\",\"t\":[\"ray\",\"...\"]},\"61\":{\"h\":\"Ray\",\"t\":[\"功能详情...\"]},\"62\":{\"h\":\"二级\"},\"63\":{\"h\":\"三级\"},\"64\":{\"h\":\"人工智能\",\"t\":[\"AI 绘画、智能聊天\"]},\"65\":{\"h\":\"算法与数据结构\"},\"66\":{\"h\":\"大数据\"},\"67\":{\"c\":[\"大数据\"]},\"68\":{\"h\":\"区块链\",\"t\":[\"技术和业务角度看区块链\"]},\"69\":{\"c\":[\"区块链\"]},\"70\":{\"h\":\"Bug修复手册\"},\"71\":{\"h\":\"记一次redis线上问题\",\"t\":[\"原文： https://mp.weixin.qq.com/s/blf1a6cP-oJQ9FmnpU_ocw\"]},\"72\":{\"c\":[\"redis\",\"bugfix\"]},\"73\":{\"c\":[\"redis\",\"bugfix\"]},\"74\":{\"h\":\"数据库\"},\"75\":{\"h\":\"设计模式\"},\"76\":{\"h\":\"单例模式-生产环境用法\",\"t\":[\"大家好，我是JavaPub！\",\"最近各大互联网公司都传出裁员消息，各个自媒体更是跟风传着各种小道消息，好像寒冬马上要侵蚀整个IT行业。我认为作为提高生产力的技术，永远都会走在发展的最前沿。作为一个技术人，打铁还要自身硬。\",\"1. 当被问到你知道哪些设计模式？ 2. 你在代码使用了那些设计模式？ 3. 你是怎么怎么使用的？\",\"在这里插入图片描述\",\"单例模式是最常见的设计模式之一\",\"相信没有一个攻城狮不懂单例模式，本篇介绍如何在生产环境使用单例模式\",\"[toc]\"]},\"77\":{\"h\":\"为什么使用单例模式\",\"t\":[\"对于软件系统的某些类，它可能是全局使用，无需频繁创建销毁。例如创建、销毁代价比较大的数据库连接，会浪费大量资源。\",\"单例最有代表就是我们耳熟能详的 windows 任务管理器，无论我们创建多少次，总是打开一个窗口。1. 如果打开多个重复的窗口，那就是对资源的浪费，资源是宝贵的。2. 多个窗口还要保证一致性，否则谁也不知道谁对谁错。\",\" 所以，就有个单例模式的用武之地\"]},\"78\":{\"h\":\"实现\",\"t\":[\"定义：确保一个类只有一个实例，并提供一个全局访问点。 \",\"单例模式又可以分为预加载和懒加载。当然我们在生产环境中一般使用较多的是 线程安全+懒加载。下文会提及单例的演变过程，你可以直接看最后一个案例，快速掌握生产环境中实战要点。JavaPub为金九银十助力，淦\"]},\"79\":{\"h\":\"预加载\",\"t\":[\"package com.javapub.schema; /** * 预加载 单例模式 * JavaPub */ public class PreloadSingleton { public static PreloadSingleton instance = new PreloadSingleton(); // 其他的类无法实例化单例类的对象 private PreloadSingleton() { } public static PreloadSingleton getInstance() { return instance; } }\",\"上面这种写法可以保证线程安全。\",\"但是对象还没有使用时就被创建，很明显这种写法会造成资源浪费。\"]},\"80\":{\"h\":\"懒加载\",\"t\":[\"package com.javapub.schema; /** * 懒加载 单例模式 * JavaPub */ public class LazyLoadingSingleton { private static LazyLoadingSingleton instance = null; private LazyLoadingSingleton() { } public static LazyLoadingSingleton getInstance() { if (instance == null) { instance = new LazyLoadingSingleton(); } return instance; } }\",\"懒加载显然是不能保证线程安全的，在Java实例化对象会分为三步，JVM为了提高程序执行性能，会对没有依赖关系的代码进行重排序。\",\"初始化内存空间\",\"初始化对象\",\"设置instance实例指向刚分配的内存空间\"]},\"81\":{\"h\":\"Java\"},\"82\":{\"h\":\"懒加载+线程安全\",\"t\":[\"synchronized 关键字是我们处理线程安全的一个利器，加载 getInstace() 函数可以保证线程安全。但是，如果要经常的调用 getInstance() 方法，不管有没有初始化实例，都会唤醒和阻塞线程。为了避免线程的上下文切换消耗大量时间，如果对象已经实例化了，我们没有必要再使用 synchronized 加锁，直接返回对象。经过如上分析\"]},\"83\":{\"h\":\"Sychronized\",\"t\":[\"如上分析，我们把锁加在 if (instance == null) 里面，保证instance未实例化的时候才加锁\",\"package com.javapub.schema; /** * 单例模式 线程安全 * JavaPub */ public class SychronizedSingleton { private static SychronizedSingleton instance = null; private SychronizedSingleton() { } public static synchronized SychronizedSingleton getInstance() { if (instance == null) { synchronized (SychronizedSingleton.class) { if (instance == null) { instance = new SychronizedSingleton(); } } } return instance; } }\"]},\"84\":{\"h\":\"Sychronized + Volatile\",\"t\":[\"上面我们了解过，Java 在 new 一个对象是无法保证顺序性的。因此我们需要另一个关键字Volatile保证对象实例化过程中的顺序性。\",\"package com.javapub.schema; /** * 单例模式 线程安全 synchronized volatile * JavaPub */ public class Singleton { private static volatile Singleton instance = null; private Singleton() { } public static synchronized Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } }\",\"网络讲解设计模式的文章有很多，但是真正在生产环境中怎么用确一直不被大多数人掌握，所以最近想更新一个系列文章，专门针对设计模式在生产环境怎么用，让更多攻城狮在极客之路提供一点点思路。---\"]},\"85\":{\"c\":[\"单例模式\"]},\"86\":{\"c\":[\"单例模式\"]},\"87\":{\"h\":\"Java\"},\"88\":{\"h\":\"Linux\"},\"89\":{\"h\":\"大学生都会的Linux命令\"},\"90\":{\"h\":\"面试官：这些命令大学生都会\",\"t\":[\"大家好，我是 JavaPub。\",\"最近有些同学在后台问我，面试总是会遇到被问 Linux 命令的问题，自己就面试个后端开发岗位，怎么这么难呢？\",\"image-20231216131924099\",\"其实 Linux 命令，对于一个后端开发来说，并不是很难，只是我们平时很少使用而已。\",\"但是，我们平时开发，用到的 Linux 命令，其实也就那么几个，比如：\",\"文件操作：ls、cd、pwd、mkdir、touch、cp、mv、rm\",\"文件查看：cat、more、less、head、tail\",\"文件压缩：tar、gzip、zip\",\"文件权限：chmod、chown\",\"文件搜索：find、grep\",\"网络操作：ping、ifconfig、netstat\",\"进程操作：ps、kill、top\",\"系统操作：date、df、du、free、top\",\"有没有发现上面的命令大多都是对文件的操作。linux 有句话叫做：一切皆文件 Everything is a file。\",\"image-20231216131826484\",\"...\",\"接下来给大家演示一些文件的操作。有的同学说，我没有 Linux 服务器，没关系，我之前给大家推荐了一个可以免费使用 Linux 的在线网站、跟着下面视频一学就会。当然，大家也可以在自己的电脑上安装虚拟机来操作。\",\"play-with-docker在线linux操作视频\"]},\"91\":{\"h\":\"文件操作\",\"t\":[\"ls\",\"ls 命令用于显示指定工作目录下之内容（列出当前目录下的文件和目录）。\",\"cd\",\"当要进入某个目录时。\",\"image-20231216124523478\",\"pwd\",\"pwd 命令用于显示工作目录。\",\"image-20231216124628242\",\"mkdir\",\"mkdir 命令用于创建目录。当你要给自己的项目分层，比如 Javapub-docs 放文档、javapub-img 放图片。\",\"image-20231216124857718\",\"touch\",\"touch 是用来创建文件的命令。\",\"image-20231216125205177\",\"cp\",\"cp 命令用于复制文件或目录。这个命令很有用，比如把我们上传到服务器的代码复制到需要运行的目录下。\",\"image-20231216130058600\",\"mv\",\"mv 命令用于移动文件或目录。\",\"image-20231216130625976\",\"rm\",\"rm 命令用于删除文件或目录。\",\"image-20231216125353767\",\"下期继续。。。\"]},\"92\":{\"h\":\"大学生都会的Linux命令V2\"},\"93\":{\"h\":\"awk\"},\"94\":{\"h\":\"常用命令大全\",\"t\":[\"工作中最常用shell指令\",\"ps aux | grep \\\"tomcat\\\" 查找运行的进程\",\"find / -name java* 全部查找（java*）文件\",\"cat -n name-file | grep \\\"java\\\" 查找文件（java）所在行\",\"cat -n name-file | tail -n +92 | head -n 20 查看文件92行前后20行\",\":set nu 显示行号\",\":n 跳转到指定行号\",\"7，tail -n 20 filename 显示后20行数据\",\"8,sudo -u bsafe bash 切换basfe帐户\",\"9，cat textJson_20190216.log | awk -F '\\\\t' '{print $NF}' > result.log 去除文件中字符\\\"\\\\t\\\" 方法二：#awk -F \\\"\\\\t\\\" '{print $2}' ./textJson_20190215.log >result.log\",\"10，cat file1 file2 | sort | uniq > fileAll 取出文件的并集（去重）\",\"11，远程复制拷贝 $scp local_file remote_username@remote_ip:remote_folder $scp local_file remote_username@remote_ip:remote_file $scp local_file remote_ip:remote_folder $scp local_file remote_ip:remote_file scp root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/\",\"12，字符串切割 awk '{FS=\\\":\\\"}{print $1\\\"\\\\t\\\" $3}' /etc/passwd，使用FS=””,指定分割符，第一行已经读完，用冒号分割已经来不及了，默认的用空格分割，后面的用冒号分割，在FS之前强制加个BEGIN *awk -F '\\\\t' '{print $3}'\",\"13，删除指定行 sed -i '1d' <file>\",\"14，删除包含特定字符的行 sed -e '/xxx/d' a1.txt > a2.txt\",\"15，文件授权（递归授权所有文件） chown -R testname <filename>\",\"16，压缩\",\"压缩方式：\",\"tar -zcvf archive_name.tar.gz filename\",\"解压缩方式：\",\"tar -zxvf archive_name.tar.gz\",\"压缩解压（zip）\",\"zip -r 123.zip 123.txt unzip 123.zip -d ./\",\"17，nohup\",\"nohup java -jar myProject.jar >> /usr/local/log/output.log 2>&1 &\",\"19，替换文件制定字符\",\"sed -i \\\"s/tf_ab/tf_qw/g\\\" result.txt\",\"20，git命令\",\" git status git add . git commit -m \\\"一些信息\\\" git push 仓库地址 ###分支 git checkout -b 分支名 #新建分支 git branch -a git checkout 分支名\",\"21，rsync -av ../log/textJson_$min\\\".log\\\" --port=9215 root@106.12.31.72::web_news_database\"]},\"95\":{\"h\":\"必看\"},\"96\":{\"h\":\"常见问题解答\",\"t\":[\"问最多的问题：\"]},\"97\":{\"h\":\"问题1: 可以把文章下载到本地吗，还想发到个人博客上去？\",\"t\":[\"答：可以的。\",\"不只可以下载，还提供了 GitHub 地址，点个下载连同项目一起打包你的本地，转载更没有限制，但是你要能注明出处（也就是你看到这篇文章的网站），那就是对我最大的支持。\"]},\"98\":{\"h\":\"问题2: 我有个朋友是初学者，可以学吗？要怎么开始学？\",\"t\":[\"答： 完全可以。\",\"你这个朋友我知道是谁了。\",\"首先如果你是计算机的学生，我建议你先将课程中的东西掌握，比如 编程基础、数据库、数据结构 等。然后再试着做一个项目，比如某管理系统等（参考 实战练手项目 ），对整体项目有一个了解，然后再开始针对性学习。比如试着解决某个业务场景，比如如何保证数据库和缓存的数据一致性；分布式场景中如何单例模型。\",\"如何是转行的人，我建议你跟着课程详细学习，现在市面上机构也很多。如果你担心费用太高、后面学不会怎么办等，可以联系我和我交流一下我的联系方式。\"]},\"99\":{\"h\":\"使用指南\"},\"100\":{\"h\":\"在准备面试\",\"t\":[\"对于面试的同学，我不建议慢工出细活，先通过个人实力和面试技巧拿到一个心仪的 offer，再在工作中茁壮成长。 《最少必要面试》 是一定要看的，其中都是精华中的精华，而且非常基础 (基础不牢，地动山摇)。\",\"其次，要根据薄弱点来学习，比如 数据库 ，不论你学什么语言，数据库都是非常重要的，还有 数据结构 、 基础 算法 等。\"]},\"101\":{\"h\":\"在学习\",\"t\":[\"在学习的同学，我建议学习一些实战项目，如果你会一些 Java ，可以更着做一些项目。全站工程师在哪儿都是稀缺的。\",\"重点关注 实战项目。如果平时时间充裕，也要多刷提到的 面试题 和 知识点。\"]},\"102\":{\"c\":[\"关于作者\"]},\"103\":{\"h\":\"网络\"},\"104\":{\"h\":\"网络面试题 TODO\",\"t\":[\"79.http 响应码 301 和 302 代表的是什么？有什么区别？\",\"80.forward 和 redirect 的区别？\",\"81.简述 tcp 和 udp的区别？\",\"82.tcp 为什么要三次握手，两次不行吗？为什么？\",\"83.说一下 tcp 粘包是怎么产生的？\",\"84.OSI 的七层模型都有哪些？\",\"85.get 和 post 请求有哪些区别？\",\"86.如何实现跨域？\",\"87.说一下 JSONP 实现原理？\"]},\"105\":{\"h\":\"运维Operations\"},\"106\":{\"h\":\"Nginx.Conf详解\",\"t\":[\"#user nobody nobody;#设置启动用户和用户组 worker_processes 1;#设置值和CPU核心数一致 #Specifies the value for maximum file descriptors that can be opened by this process. #指定进程可以打开的最大描述符：数目 #工作模式与连接数上限 #这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。 #现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。 #这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。 worker_rlimit_nofile 65535; #全局日志定义类型，[ debug | info | notice | warn | error | crit ] #error_log logs/error.log; #error_log logs/error.log notice;#日志位置和日志级别 #error_log logs/error.log info; #进程pid #pid logs/nginx.pid; events { #单个进程最大连接数（最大连接数=连接数*进程数） #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。 worker_connections 1024; #keepalive超时时间。 #keepalive_timeout 60; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 #分页大小可以用命令getconf PAGESIZE 取得。 #[root@web001 ~]# getconf PAGESIZE #4096 #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。 #client_header_buffer_size 4k; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。 #open_file_cache max=65535 inactive=60s; #这个是指多长时间检查一次缓存的有效信息。 #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息. #open_file_cache_valid 80s; #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态. #open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件时记录cache错误. #open_file_cache_errors on; } #设定http服务器，利用它的反向代理功能提供负载均衡支持 http { #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #服务器名字的hash表大小 #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小. #server_names_hash_bucket_size 128; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。 #client_header_buffer_size 32k; #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。 #large_client_header_buffers 4 64k; #设定通过nginx上传文件的大小，（这个是较长使用的配置） client_max_body_size 8m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 #sendfile on; #开启目录列表访问，合适下载服务器，默认关闭。 #autoindex on; #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用(这俩个不太理解) tcp_nopush on; tcp_nodelay on; #日志格式设定（也可以放在 server 模块） #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址； #$remote_user：用来记录客户端用户名称； #$time_local： 用来记录访问时间与时区； #$request： 用来记录请求的url与http协议； #$status： 用来记录请求状态；成功是200， #$body_bytes_sent ：记录发送给客户端文件主体内容大小； #$http_referer：用来记录从那个页面链接访问过来的； #$http_user_agent：记录客户浏览器的相关信息； #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。 #log_format main '$remote_addr - $remote_user [$time_local] \\\"$request\\\" ' # '$status $body_bytes_sent \\\"$http_referer\\\" ' # '\\\"$http_user_agent\\\" \\\"$http_x_forwarded_for\\\"'; #定义本虚拟主机的访问日志 #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #开启Gzip #gzip on; #gzip_http_version 1.0; #设置gzip压缩针对的HTTP协议版本 #gzip_min_length 1k #启用gzip压缩的最小文件，小于设置值的文件将不会压缩 #gzip_buffers 4 16k #设置压缩所需要的缓冲区大小 #gzip_comp_level 2 #gzip压缩比/压缩级别，压缩级别 1-9，级别越高压缩率越大，当然压缩时间也就越长（传输快但比较消耗cpu） #gzip_types #进行压缩的文件类型 #gzip_vary on #是否在http header中添加Vary: Accept-Encoding，建议开启 #开启限制IP连接数的时候需要使用 #limit_zone crawler $binary_remote_addr 10m; #（这块是比较重要一块，在大多数服务中要用到） #负载均衡配置 upstream javapub.rodert.com.github { #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weight参数表示权值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; #nginx的upstream目前支持4种方式的分配 #1、轮询（默认） #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 #weight #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 #例如： #upstream bakend { # server 192.168.0.14 weight=10; # server 192.168.0.15 weight=10; #} #2、ip_hash #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 #例如： #upstream bakend { # ip_hash; # server 192.168.0.14:88; # server 192.168.0.15:80; #} #3、fair（第三方） #按后端服务器的响应时间来分配请求，响应时间短的优先分配。 #upstream backend { # server server1; # server server2; # fair; #} #4、url_hash（第三方） #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 #upstream backend { # server squid1:3128; # server squid2:3128; # hash $request_uri; # hash_method crc32; #} #tips: #upstream bakend{#定义负载均衡设备的Ip及设备状态}{ # ip_hash; # server 127.0.0.1:9090 down; # server 127.0.0.1:8080 weight=2; # server 127.0.0.1:6060; # server 127.0.0.1:7070 backup; #} #在需要使用负载均衡的server中增加 proxy_pass http://bakend/; #每个设备的状态设置为: #1.down表示单前的server暂时不参与负载 #2.weight为weight越大，负载的权重就越大。 #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误 #4.fail_timeout:max_fails次失败后，暂停的时间。 #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 #nginx支持同时设置多组的负载均衡，用来给不同的server来使用。 #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug #client_body_temp_path设置记录文件的目录 可以设置最多3层目录 #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡 } #下面是server虚拟主机的配置 server { listen 80; #监听端口 server_name javapub.cn www.javapub.cn; #多个域名，空格分隔 index index.html index.htm index.php;#域名根路径下，默认访问地址 root /data/www/javapub; #charset koi8-r; #定义本虚拟主机的访问日志 #access_log logs/host.access.log main; #access_log /usr/local/nginx/logs/host.access.404.log log404; #localhost是根据用户请求的URL进行匹配， location / { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\\\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\\\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\\\.ht { # deny all; #} #图片缓存时间设置 #location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ #{ # expires 10d; #} #JS和CSS缓存时间设置 #location ~ .*.(js|css)?$ #{ # expires 1h; #} #对 \\\"/\\\" 启用反向代理 location / { proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; #允许客户端请求的最大单文件字节数 client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数， #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。 #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误 client_body_buffer_size 128k; #表示使nginx阻止HTTP应答代码为400或者更高的应答。 proxy_intercept_errors on; #后端服务器连接的超时时间_发起握手等候响应超时时间 #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 90; #后端服务器数据回传时间(代理发送超时) #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据 proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间） proxy_read_timeout 90; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小 proxy_buffer_size 4k; #proxy_buffers缓冲区，网页平均在32k以下的设置 #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k proxy_buffers 4 32k; #高负荷下缓冲大小（proxy_buffers*2） proxy_busy_buffers_size 64k; #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长 #设定缓存文件夹大小，大于这个值，将从upstream服务器传 proxy_temp_file_write_size 64k; } #设定查看Nginx状态的地址 location /NginxStatus { stub_status on; access_log on; auth_basic \\\"NginxStatus\\\"; auth_basic_user_file confpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 } #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; } #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt| pdf|xls|mp3|wma)$ { expires 15d; } location ~ .*.(js|css)?$ { expires 1h; } } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} }\"]},\"107\":{\"h\":\"快速搭建Prometheus+Grafana保姆级教程\"},\"108\":{\"h\":\"快速搭建 Prometheus+Grafana 保姆级教程\",\"t\":[\"[toc]\",\"演示环境在 MAC 下\"]},\"109\":{\"h\":\"前言\",\"t\":[\"确保电脑安装了 Homebrew。\",\"/bin/bash -c \\\"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\\\"\",\"安装 Prometheus\",\"brew install prometheus\",\"安装 Grafana\",\"brew install grafana\",\"启动 Prometheus 和 Grafana\",\"# 启动 Prometheus prometheus --config.file=/javapub/usr/local/etc/prometheus/prometheus.yml # 启动 Grafana brew services start grafana\",\"检测是否安装成功\",\"Grafana 控制台\",\"http://localhost:3000\",\"Prometheus 的 URL\",\"http://localhost:9090\",\"配置看板步骤：\",\"登录后，配置 Prometheus 作为数据源：\",\"点击左侧菜单的 \\\"Configuration\\\" 图标。\",\"选择 \\\"Data Sources\\\"。\",\"点击 \\\"Add data source\\\"。\",\"选择 Prometheus。\",\"配置 Prometheus 的 URL （通常是 http://localhost:9090）。\",\"完成后，你就可以在 Grafana 中创建仪表板，并使用 Prometheus 作为数据源来可视化监控数据了。\"]},\"110\":{\"h\":\"Prometheus 的四种类型\",\"t\":[\"https://zhuanlan.zhihu.com/p/592560633\"]},\"111\":{\"h\":\"其他\"},\"112\":{\"h\":\"go整合etcd\",\"t\":[\"案例源码仓库地址： https://github.com/Rodert/go-demo\",\"官方文档： https://etcd.io/\",\"视频教程： https://space.bilibili.com/404747369\",\"谈使用场景之前，看看他有哪些功能\",\"官方定义是这样的： etcd is a strongly consistent, distributed key-value store that provides a reliable way to store data that needs to be accessed by a distributed system or cluster of machines. It gracefully handles leader elections during network partitions and can tolerate machine failure, even in the leader node.\"]},\"113\":{\"h\":\"使用场景\",\"t\":[\"服务发现\",\"配置中心\",\"分布式锁\"]},\"114\":{\"h\":\"搭建 ETCD\",\"t\":[\"环境： mac\",\"# 安装 brew install etcd # 启动 brew services start etcd # 检查状态 brew services list | grep etcd # 停止 brew services stop etcd # 卸载 brew uninstall etcd\"]},\"115\":{\"h\":\"与 ETCD 交互\",\"t\":[\"# 检查工具是否安装 etcdctl version # 写入 etcdctl put mykey \\\"myvalue\\\" # 获取 etcdctl get mykey # 删除 etcdctl del mykey\"]},\"116\":{\"h\":\"集群\",\"t\":[\"# 查看集群状态 etcdctl cluster-health\",\"安装依赖\",\"go get go.etcd.io/etcd/client/v3\",\"编码\",\"https://github.com/Rodert/go-demo\",\"执行\",\"go run main.go\",\"执行结果：\"]},\"117\":{\"c\":[\"etcd\",\"go\"]},\"118\":{\"c\":[\"etcd\",\"go\"]},\"119\":{\"h\":\"rodert教你学FFmpeg实战这一篇就够了\"},\"120\":{\"h\":\"rodert教你学FFmpeg实战这一篇就够了\",\"t\":[\"[toc]\"]},\"121\":{\"h\":\"前言\",\"t\":[\"有人问rodert哥这篇文章干货有多干，问就是，硌牙。\",\"ffmpeg有多强大，我想你都知道了，现在很多市场上的剪辑软件都是基于它做的，只是加了一些包装。读完本篇，你会发现一切如此简单。\"]},\"122\":{\"h\":\"1. 简介\",\"t\":[\"官网地址：https://trac.ffmpeg.org/wiki\",\"FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。\",\"FFmpeg在Linux平台下开发，但它同样也可以在其它操作系统环境中编译运行，包括Windows、Mac OS X等。这个项目最早由Fabrice Bellard发起，2004年至2015年间由Michael Niedermayer主要负责维护。许多FFmpeg的开发人员都来自MPlayer项目，而且当前FFmpeg也是放在MPlayer项目组的服务器上。项目的名称来自MPEG视频编码标准，前面的\\\"FF\\\"代表\\\"Fast Forward\\\"。\"]},\"123\":{\"h\":\"2. 安装\"},\"124\":{\"h\":\"2.1. windows安装\"},\"125\":{\"h\":\"2.2. linux安装\",\"t\":[\"下载\",\"wget http://ffmpeg.org/releases/ffmpeg-3.4.1.tar.bz2\",\"解压\",\"tar -jxvf ffmpeg-3.4.1.tar.bz2\",\"安装\",\"yum install yasm\",\"cd ffmpeg-3.4.1\",\"./configure --enable-shared --prefix=/usr/local/ffmpeg\",\"make && make install\",\"编译时间较长\",\"修改文件/etc/ld.so.conf 中增加/usr/local/ffmpeg/lib\",\"使其生效：ldconfig\",\"加入环境变量：vim /etc/profile\",\"export FFMPEG_HOME=/usr/local/ffmpeg\",\"export PATH=$FFMPEG_HOME/bin:$PATH\",\"配置生效： source /etc/profile\"]},\"126\":{\"h\":\"3. 命令行操使用\"},\"127\":{\"h\":\"3.1.简单说明\",\"t\":[\"在操作前，简单介绍一下常用指令\",\"ffmpeg的使用方式： ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}... 常用参数说明： 主要参数： -i 设定输入流 -f 设定输出格式 -ss 开始时间 视频参数： -b 设定视频流量，默认为200Kbit/s -r 设定帧速率，默认为25 -s 设定画面的宽与高 -aspect 设定画面的比例 -vn 不处理视频 -vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器 音频参数： -ar 设定采样率 -ac 设定声音的Channel数 -acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器 -an 不处理音频\"]},\"128\":{\"h\":\"3.2.视频剪切\"},\"129\":{\"h\":\"3.2.1.掐头去尾\",\"t\":[\"ffmpeg -ss 00:00:15 -t 00:00:06 -i input.mp4 -vcodec copy -acodec copy output.mp4\",\"剪辑原视频input.mp4，15s开始向后6s，保存到output.mp4\",\"-ss 表示开始切割时间，-t 表示要切多少\"]},\"130\":{\"h\":\"3.2.2.\"},\"131\":{\"h\":\"3.3.视频格式转换\",\"t\":[\"准确来说，是视频容器转换\",\"ffmpeg -i input.avi output.mp4\",\"avi文件转为mp4\",\"ffmpeg -i input.mp4 output.ts\",\"mp4文件转为ts\"]},\"132\":{\"h\":\"3.4.提取音频\",\"t\":[\"ffmpeg -i JavaPub讲坛.mp4 -acodec copy -vn output.aac\",\"提取JavaPub讲坛.mp4音频到output.acc，acc是一种常见默认视频，也可以转为其他格式。或者防止出现异常，直接使用下面方式\",\"ffmpeg -i JavaPub讲坛.mp4 -acodec aac -vn output.aac\"]},\"133\":{\"h\":\"3.5.提取音频\",\"t\":[\"ffmpeg -i input.mp4 -vcodec copy -an output.mp4\",\"纯视频\"]},\"134\":{\"h\":\"3.6.码率控制\",\"t\":[\"码率控制对于在线视频比较重要。因为在线视频需要考虑其能提供的带宽。现在这个直播使用很广泛的时代\",\"码率是什么：\",\"bitrate = file size / duration\",\"比如一个文件20.8M，时长1分钟，那么，码率就是： biterate = 20.8M bit/60s = 20.810241024*8 bit/60s= 2831Kbps 一般音频的码率只有固定几种，比如是128Kbps， 那么，video的就是 video biterate = 2831Kbps -128Kbps = 2703Kbps。\",\"控制码率主要还是为了缩小文件大小，尽量不影响分辨率\",\"ffmpg控制码率有3种选择，-minrate -b:v -maxrate\",\"-b:v 控制平均码率\",\"比如一个视频源的码率太高了，有10Mbps，文件太大，想把文件弄小一点，但是又不破坏分辨率。\",\"ffmpeg -i input.mp4 -b:v 2000k output.mp4\",\"ffmpeg官方wiki比较建议，设置b:v时，同时加上 -bufsize -bufsize 用于设置码率控制缓冲器的大小，设置的好处是，让整体的码率更趋近于希望的值，减少波动。（简单来说，比如1 2的平均值是1.5， 1.49 1.51 也是1.5, 当然是第二种比较好）\",\"ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4\",\"-minrate -maxrate就简单了，在线视频有时候，希望码率波动，不要超过一个阈值，可以设置maxrate。\",\"ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4\"]},\"135\":{\"h\":\"3.7. 视频编码格式转换\",\"t\":[\"比如一个视频的编码是MPEG4，想用H264编码\",\"ffmpeg -i input.mp4 -vcodec h264 output.mp4\",\"相反也一样\",\"ffmpeg -i input.mp4 -vcodec mpeg4 output.mp4\",\"当然了，如果ffmpeg当时编译时，添加了外部的x265或者X264，那也可以用外部的编码器来编码。（不知道什么是X265，可以Google一下，简单的说，就是她不包含在ffmpeg的源码里，是独立的一个开源代码，用于编码HEVC，ffmpeg编码时可以调用它。当然了，ffmpeg自己也有编码器）\",\"ffmpeg -i input.mp4 -c:v libx265 output.mp4\",\"ffmpeg -i input.mp4 -c:v libx264 output.mp4\"]},\"136\":{\"h\":\"3.8. 只提取视频ES数据\",\"t\":[\"这个是不常用的，更多阅读下面链接\",\"ffmpeg –i input.mp4 –vcodec copy –an –f m4v output.h264\",\"更多：http://www.360doc.com/content/13/0829/15/13084517_310733557.shtml\"]},\"137\":{\"h\":\"3.9.过滤器的使用\"},\"138\":{\"h\":\"3.9.1. 将输入的1920x1080缩小到960x540输出\",\"t\":[\"fmpeg -i input.mp4 -vf scale=960:540 output.mp4`\",\"//ps: 如果540不写，写成-1，即scale=960:-1, 那也是可以的，ffmpeg会通知缩放滤镜在输出时保持原始的宽高比。\"]},\"139\":{\"h\":\"3.9.2.视频添加logo\",\"t\":[\"左上角\",\"ffmpeg -i input.mp4 -i logo.png -filter_complex overlay output.mp4\",\"右上角：\",\"ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4\",\"左下角：\",\"ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4\",\"右下角：\",\"ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4\"]},\"140\":{\"h\":\"3.9.3.去掉视频的logo\",\"t\":[\"有时候，下载了某个网站的视频，但是有logo很烦，咋办？有办法，用ffmpeg的delogo过滤器。 语法：-vf delogo=x:y:w:h[:t[:show]] x:y 离左上角的坐标 w:h logo的宽和高 t: 矩形边缘的厚度默认值4 show：若设置为1有一个绿色的矩形，默认值0。\",\"ffmpeg -i input.mp4 -vf delogo=0:0:220:90:100:1 output.mp4\",\"处理后的视频样式是在过滤处加磨砂处理，并加绿色边框\"]},\"141\":{\"h\":\"3.10.抓取视频的一些帧，存为jpeg图片\",\"t\":[\"视频抽取一些帧作为图片时很常用的操作。\",\"情况一\",\"ffmpeg -i input.mp4 -r 1 -q:v 2 -f image2 pic-%03d.jpeg\",\"-r 表示每一秒几帧, -q:v表示存储jpeg的图像质量，一般2是高质量。\",\"假设60s，会保存60张图片。\",\"情况二\",\"ffmpeg -i input.mp4 -ss 00:00:20 -t 10 -r 1 -q:v 2 -f image2 pic-%03d.jpeg\",\"ffmpeg会从input.mp4的第20s时间开始，往下10s，即20~30s这10秒钟之间，每隔1s就抓一帧，总共会抓10帧。\",\"情况三\",\"ffmpeg -i input.mp4 -vf \\\"select=between(n,84,208)*not(mod(n,4))\\\" -vsync 0 image_%05d.jpg\",\"主体是一个select 的过滤语句：\",\"其中：between(n,*) 是指 从第几帧到第几帧之间进行提取...\",\"not(mode(n, K))是指每隔几帧输出一帧。\"]},\"142\":{\"h\":\"3.11.查询操作\"},\"143\":{\"h\":\"3.11.1.查询视频总帧数\",\"t\":[\"ffprobe -v error -count_frames -select_streams v:0 -show_entries stream=nb_read_frames -of default=nokey=1:noprint_wrappers=1 input.mp4\",\"说明：读取帧数需要文件解码，时长取决于文件大小\",\"-v error：这隐藏了“info”输出(版本信息等)，使解析更容易。 -count_frames：计算每个流的帧数，并在相应的流部分中报告。 -select_streams v:0 ：仅选择视频流。 -show_entries stream = nb_read_frames ：只显示读取的帧数。 -of default = nokey = 1：noprint_wrappers = 1 ：将输出格式(也称为“writer”)设置为默认值，不打印每个字段的键(nokey = 1)，不打印节头和页脚(noprint_wrappers = 1)。\"]},\"144\":{\"h\":\"3.11.2.查询FFmpeg软件信息\",\"t\":[\"version 显示版本 demuxers 显示可用的demuxers muxers 显示可用的muxers devices 显示可用的设备 codecs 显示所有编解码器 decoders 显示可用编解码器 encoders 显示所有编码器 bsfs 显示比特流filter formats 显示可用的格式 protocols 显示可用的协议 filters 显示可用的过滤器 pix_fmts 显示可用的像素格式 sample_fmts 显示可用的采样格式 layouts 显示channel名称 colors 显示识别的颜色名称\",\"ffmpeg -version\"]},\"145\":{\"h\":\"3.12.录制\",\"t\":[\"查询有哪些设备\",\"ffmpeg -f avfoundation -list_devices true -i \\\"\\\"\",\"录屏\",\"ffmpeg -f avfoundation -i 1 -r 30 out.yuv\",\"-f 指定使用 avfoundation 采集数据。 -i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。 -r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而-r用于限制输出。 注意，桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。\",\"录屏+声音\",\"ffmpeg -f avfoundation -i 1:0 -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k out.flv\",\"-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的\\\"0\\\"代表的声音索相号。 -c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。 -crf 是 x264 的参数。 0 表式无损压缩。 -c:a 与参数 -acodec 一样，表示音频编码器。 -profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。 -b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。\",\"录视频\",\"ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4\",\"-framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。 -f 指定使用 avfoundation 采集数据。 -i 指定视频设备的索引号。\",\"录音\",\"ffmpeg -f avfoundation -i :0 out.wav\"]},\"146\":{\"h\":\"3.13.直播相关\",\"t\":[\"推流\",\"ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName`\",\"拉流保存\",\"ffmpeg -i rtmp://server/live/streamName -c copy dump.flv`\",\"转流\",\"ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v copy -f flv rtmp://server/live/h264Stream`\",\"实时推流\",\"ffmpeg -framerate 15 -f avfoundation -i \\\"1\\\" -s 1280x720 -c:v libx264 -f flv rtmp://localhost:1935/live/room`\"]},\"147\":{\"h\":\"RocketMq快速入门教程\",\"t\":[\"原文： https://mp.weixin.qq.com/s/kmUlX-5CtWVn0Qli1iyWng\"]},\"148\":{\"h\":\"rodert教你学Zookeeper-实战这一篇就够了\"},\"149\":{\"h\":\"rodert教你学Zookeeper-实战这一篇就够了\",\"t\":[\"[toc]\"]},\"150\":{\"h\":\"前言\",\"t\":[\"声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。\",\"本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，你有什么想看的可以催更，微信搜索：[JavaPub]\",\"有任何问题都可以来谈谈，等你哦！\",\"公众号二维码\",\"如果你对zookeeper有一定了解，那么直接跳到你需要的知识点。\"]},\"151\":{\"h\":\"1. 什么是Zookeeper\"},\"152\":{\"h\":\"1.2.Zookeeper简介\",\"t\":[\"ZooKeeper: A Distributed Coordination Service for Distributed Applications ZooKeeper is a distributed, open-source coordination service for distributed applications. It exposes a simple set of primitives that distributed applications can build upon to implement higher level services for synchronization, configuration maintenance, and groups and naming. It is designed to be easy to program to, and uses a data model styled after the familiar directory tree structure of file systems. It runs in Java and has bindings for both Java and C. Coordination services are notoriously hard to get right. They are especially prone to errors such as race conditions and deadlock. The motivation behind ZooKeeper is to relieve distributed applications the responsibility of implementing coordination services from scratch. https://zookeeper.apache.org/doc/current/zookeeperOver.html\",\"上边是Zookeeper官网的描述，as everyone knows，ZooKeeper是分布式应用程序的分布式协调服务。\"]},\"153\":{\"h\":\"1.3.为什么要用Zookeeper\",\"t\":[\"学习一个东西，anyhow，知道为什么学它至关重要。\",\"看到一个比较靠谱的例子：\",\"一个团队里面，需要一个leader，leader是干嘛用的？管理什么的咱不说，就说如果外面的人，想问关于这个团队的一切事情，首先就会去找这个leader，因为他知道的最多，而且他的回答最靠谱。 比如产品经理小饼过来要人，作为leader，老吕发现小耀最近没有项目安排，于是把小耀安排给了小饼的项目； 过了一会，另一个产品小西也过来要人，老吕发现刚刚把小耀安排走了，已经没人，于是就跟小西说，人都被你们产品要走了，你们产品自己去协调去。 如果老吕这时候忘了小耀已经被安排走了，把小耀也分配给小西，那到时两个产品就要打架了。 这就是leader在团队里的【协调作用】。 同样的，在分布式系统中，也需要这样的协调者，来回答系统下各个节点的提问。\",\"Zookeeper能完美解决分布式协调服务这个问题\",\"但是这个例子属于单机模式，当我们扩展为三台服务器集群，小西过来问leader02要人，这时leader们信息还没有同步。\",\"这时就会涉及到Zookeeper的其他几点特性： 1、配置信息同步 2、分布式锁控制 3、消息的发布与订阅（典型的生产者消费者模型） 4、集群内节点状态的快速感知 当信息还没有同步完成时，不对外提供服务，阻塞住查询请求，等待信息同步完成，再给查询请求返回信息。\",\"这样的系统，就叫分布式协调系统。谁能把这个数据同步的时间压缩的更短，谁的请求响应就更快，谁就更出色，Zookeeper就是其中的佼佼者。\",\"它用起来像单机一样，能够提供数据强一致性，但是其实背后是多台机器构成的集群，不会有SPOF。\"]},\"154\":{\"h\":\"2. Zookeeper介绍\",\"t\":[\"百度百科\",\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 ZooKeeper包含一个简单的原语集，提供Java和C的接口。 ZooKeeper代码版本中，提供了分布式独享锁、选举、队列的接口，代码在$zookeeper_home\\\\src\\\\recipes。其中分布锁和队列有Java和C两个版本，选举只有Java版本。\"]},\"155\":{\"h\":\"3. Zookeeper整体架构\",\"t\":[\"Zookeeper整体架构\"]},\"156\":{\"h\":\"4. 快速入门(quick start)\"},\"157\":{\"h\":\"4.1.安装\",\"t\":[\"Zookeeper是解压包，只需要安装、解压就可以启动使用\",\"wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz\",\"tar -zxf ./zookeeper-3.4.14.tar.gz\",\"在conf目录下，有默认启动配置文件【zoo_sample.cfg】，复制一份到同级目录下【zoo.cfg】。\",\"配置文件解读：\",\"# tickTime这个时间是作为zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔,也就是说每个tickTime时间就会发送一个心跳。（以毫秒为单位） tickTime = 2000 # dataDir ZooKeeper的状态存储位置，看名字就知是数据目录。在你的系统中检查这个目录是否存在，如果不存在手动创建，并且给予可写权限。 dataDir = /path/to/zookeeper/data # 这个端口就是客户端连接Zookeeper服务器的端口,Zookeeper会监听这个端口接受客户端的访问请求； clientPort = 2181 # initLimit这个配置项是用来配置zookeeper接受客户端（这里所说的客户端不是用户连接zookeeper服务器的客户端,而是zookeeper服务器集群中连接到leader的follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。 # 当已经超过10个心跳的时间（也就是tickTime）长度后 zookeeper 服务器还没有收到客户端的返回信息,那么表明这个客户端连接失败。总的时间长度就是 5*2000=10秒。 initLimit = 5 # syncLimit这个配置项标识leader与follower之间发送消息,请求和应答时间长度,最长不能超过多少个tickTime的时间长度,总的时间长度就是2*2000=4秒 syncLimit = 2 # 日志存放的位置 dataLogDir=/path/to/zookeeper/log # 2888,3888 are election port # 2888端口是zookeeper服务之间的通讯的端口，3888是zookeeper与其他应用程序通讯的端口。 # server.A=B:C:D中的A是一个数字,表示这个是第几号服务器,B是这个服务器的IP地址，C第一个端口用来集群成员的信息交换,表示这个服务器与集群中的leader服务器交换信息的端口，D是在leader挂掉时专门用来进行选举leader所用的端口。 server.1=localhost:2888:3888\"]},\"158\":{\"h\":\"4.2.启动\",\"t\":[\"[root@iz2zehz5b1m03ahtrhebcaz bin]# ./zkServer.sh ZooKeeper JMX enabled by default Using config: /home/soft/zookeeper-3.4.8/bin/../conf/zoo.cfg Usage: ./zkServer.sh {start|start-foreground|stop|restart|status|upgrade|print-cmd}\",\"进入到bin目录下，\",\"启动\",\"./zkServer.sh start\",\"状态\",\"./zkServer.sh status\"]},\"159\":{\"h\":\"4.3.查询\",\"t\":[\"Zookeeper客户端连接指令\",\"进入zookeeper下bin目录\",\"[root@iz2zehz5b1m03ahtrhebcaz bin]# pwd /home/soft/zookeeper-3.4.8/bin [root@iz2zehz5b1m03ahtrhebcaz bin]# ll total 44 -rwxr-xr-x 1 elasticsearch elasticsearch 232 Feb 6 2016 README.txt -rwxr-xr-x 1 elasticsearch elasticsearch 1937 Feb 6 2016 zkCleanup.sh -rwxr-xr-x 1 elasticsearch elasticsearch 1056 Feb 6 2016 zkCli.cmd -rwxr-xr-x 1 elasticsearch elasticsearch 1534 Feb 6 2016 zkCli.sh -rwxr-xr-x 1 elasticsearch elasticsearch 1628 Feb 6 2016 zkEnv.cmd -rwxr-xr-x 1 elasticsearch elasticsearch 2696 Feb 6 2016 zkEnv.sh -rwxr-xr-x 1 elasticsearch elasticsearch 1089 Feb 6 2016 zkServer.cmd -rwxr-xr-x 1 elasticsearch elasticsearch 6773 Feb 6 2016 zkServer.sh -rw-r--r-- 1 root root 7850 May 4 13:26 zookeeper.out\",\"可以看到很多脚本文件，通过zkCli.sh连接客户端\",\"./zkCli.sh -server 127.0.0.1:2181\",\"通过ls /，查看已注册服务， 例如查询dubbo\",\"ls /dubbo\",\"可以看到dubbo服务地外提供的接口\",\"消费者、生产者\",\"ls /dubbo/com.ivan.service.provider.UserService/consumers\",\"ls /dubbo/com.ivan.service.provider.UserService/providers\"]},\"160\":{\"h\":\"5. 常用指令\",\"t\":[\"客户端连接后整体使用和linux很相似，上一章做了介绍\"]},\"161\":{\"h\":\"6. 应用场景\"},\"162\":{\"h\":\"场景一 配置文件\",\"t\":[\"我们在开发的时候，有时候需要获取一些公共的配置，比如数据库连接信息等，并且偶然可能需要更新配置。如果我们的服务器有N多台的话，那修改起来会特别的麻烦，并且还需要重新启动。这里Zookeeper就可以很方便的实现类似的功能。\"]},\"163\":{\"h\":\"场景二 分布式锁\",\"t\":[\"在我们日常的开发中，如果是单个进程中对共享资源的访问，我们只需要用synchronized或者lock就能实现互斥操作。但是对于跨进程、跨主机、跨网络的共享资源似乎就无能为力了。\"]},\"164\":{\"h\":\"场景三 分布式队列\",\"t\":[\"在日常使用中，特别是像生产者消费者模式中，经常会使用BlockingQueue来充当缓冲区的角色。但是在分布式系统中这种方式就不能使用BlockingQueue来实现了，但是Zookeeper可以实现。\"]},\"165\":{\"h\":\"场景四 负载均衡\",\"t\":[\"首先我们需要简单的理解分布式和集群，通俗点说：分布式就是将一个系统拆分到多个独立运行的应用中（有可能在同一台主机也有可能在不同的主机上），集群就是将单个独立的应用复制多分放在不同的主机上来减轻服务器的压力。而Zookeeper不仅仅可以作为分布式集群的服务注册调度中心（例如dubbo），也可以实现集群的负载均衡。\",\"Zookeeper是一个功能非常强大的应用，除了上面几种应用外，还有命名服务、分布式协调通知等也是常用的场景。\"]},\"166\":{\"h\":\"7. 选举机制\",\"t\":[\"选举机制，顾名思义就是投票选举。\",\"分布式集群开发的目的就是为了保证系统的稳定运行，如果有一个服务挂掉，不会对整个系统造成大的影响。\",\"Leader选举是保证分布式数据一致性的关键所在。当Zookeeper集群中的一台服务器出现以下两种情况之一时，需要进入Leader选举。\",\"服务器初始化启动。\",\"服务器运行期间无法和Leader保持连接。\",\"情况一\",\"1. 服务器启动时期的Leader选举 若进行Leader选举，则至少需要两台机器，这里选取3台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程。选举过程如下 (1) 每个Server发出一个投票。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID，使用(myid, ZXID)来表示，此时Server1的投票为(1, 0)，Server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。 (2) 接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。 (3) 处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK规则如下 · 优先检查ZXID。ZXID比较大的服务器优先作为Leader。 · 如果ZXID相同，那么就比较myid。myid较大的服务器作为Leader服务器。 对于Server1而言，它的投票是(1, 0)，接收Server2的投票为(2, 0)，首先会比较两者的ZXID，均为0，再比较myid，此时Server2的myid最大，于是更新自己的投票为(2, 0)，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。 (4) 统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于Server1、Server2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出了Leader。 (5) 改变服务器状态。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。\",\"情况二\",\" 2. 服务器运行时期的Leader选举 在Zookeeper运行期间，Leader与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入，此时也不会影响Leader，但是一旦Leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮Leader选举，其过程和启动时期的Leader选举过程基本一致。假设正在运行的有Server1、Server2、Server3三台服务器，当前Leader是Server2，若某一时刻Leader挂了，此时便开始Leader选举。选举过程如下 (1) 变更状态。Leader挂后，余下的非Observer服务器都会讲自己的服务器状态变更为LOOKING，然后开始进入Leader选举过程。 (2) 每个Server会发出一个投票。在运行期间，每个服务器上的ZXID可能不同，此时假定Server1的ZXID为123，Server3的ZXID为122；在第一轮投票中，Server1和Server3都会投自己，产生投票(1, 123)，(3, 122)，然后各自将投票发送给集群中所有机器。 (3) 接收来自各个服务器的投票。与启动时过程相同。 (4) 处理投票。与启动时过程相同，此时，Server1将会成为Leader。 (5) 统计投票。与启动时过程相同。 (6) 改变服务器的状态。与启动时过程相同。\",\"总结：\",\"在选举时每个节点都有一个(myid,ZXID)表示；\",\"对于初始化或leader宕机时，每个server发出一个投票给集群其他机器，所有请求挂起，开始选举（如实例一）；\",\"超过半数的投票，就会成为Leader；\",\"比较自己的选票和接收到的投票，优先比较ZXID，再比较myid。如果大于自己，更换自己的选票并告诉其他server；\",\"ZXID 是指当前服务器数据越新，其成为Leader可能性越大。\",\"myid 是指当前server编号\"]},\"167\":{\"h\":\"8. 三大功能\",\"t\":[\"为用户提供数据的注册和查询服务\",\"为用户提供数据节点的监听注册服务\",\"跟用户之间保持心跳通信以感知用户的状态\"]},\"168\":{\"h\":\"其他编程语言\"},\"169\":{\"h\":\"编程规范\"},\"170\":{\"c\":[\"编程规范\"]},\"171\":{\"c\":[\"编程规范\"]},\"172\":{\"h\":\"TODO-优化if-else的八种方案\",\"t\":[\"TODO\",\"优雅永不过时！\",\"参考： https://mp.weixin.qq.com/s/Wd1w8OctSwPb0mdykFzbIQ\"]},\"173\":{\"c\":[\"编程规范\"]},\"174\":{\"c\":[\"编程规范\"]},\"175\":{\"h\":\"接口设计这11点要注意\",\"t\":[\"标题： 接口设计这11点要注意 ｜ 接口设计军规 | 干了3年程序员，老板让我这样写接口 | 11条军规，让你的接口设计无可挑剔\",\"cover\",\"作为后端工程师，多数情况都是给别人提供接口，写的好不好使你得重视起来。\",\"74076262d8f14d5390e1ba557e0296a0\",\"最近我手头一些活，需要和外部公司对接，我们需要提供一个接口文档，这样可以节省双方时间、也可以防止后续扯皮。这是就要考验我的接口是否规范化。\",\"接口设计规范JavaPub\"]},\"176\":{\"h\":\"1. 接口名称清晰、明确\",\"t\":[\"顾名思义，接口是做什么的，是否准确、清晰？让使用这一眼就能知道这个接口在做什么，力求言简意赅。比如：查询用户信息，简单明了。\",\"img\"]},\"177\":{\"h\":\"2. 接口路径规整\",\"t\":[\"接口地址，也就是接口的 URL 路径。当别人调用你的接口，就是通过 URL 配合请求时参数来调用。比如： /api/user/queryById 。一般来说，接口地址的命名也要可以大概看出接口的作用，比如前面这个接口，它是作用使用：通过用户id查询用户信息。\",\"除了接口路径，还需要指明接口的域名或IP。以 http 协议为例、端口是 8080，当我请求 javapub 的用户中心信息时：\",\"https://javapub.net.cn:8080/api/user/queryById\",\"4677eb13-b696-43be-b530-60766742a4e3\"]},\"178\":{\"h\":\"3. 请求方式规范\",\"t\":[\"请求方式常用的有如下几种：\",\"GET（SELECT）：从服务器取出资源，通常用于查询数据（一项或多项）。\",\"POST（CREATE）：在服务器新建一个资源，通常用在新增、修改、删除操作。\",\"PUT（UPDATE）：在服务器更新资源，通常用于更新数据（客户端提供改变后的完整资源）。\",\"PATCH（UPDATE）：在服务器更新资源，通常用于修改部分数据（客户端提供改变的属性）。\",\"DELETE（DELETE）：从服务器删除资源，通常用于删除数据。\",\"这么多请求方式，多数中小公司只用 GET 和 POST，可能还有些公司只用 POST。但是选择合适的请求方式可以提升开发效率、并且让我们的接口更容易复用。\",\"不管用哪种，一定要写清楚。\",\"eb21c081-f26c-4c8c-9197-4a35573e8b04\"]},\"179\":{\"h\":\"4. 接口详细说明\",\"t\":[\"如果是非常简单的接口，通过接口名就可以了解个大概。如果是一些非常复杂的接口，就一定要添加详细说明文档，包括功能描述、请求参数、请求相应参数等信息。\",\"力求言简意赅，通过入参、做了什么动作、返回哪些值。\",\"006r3PQBjw1fb5h84baewj306404lmx9\"]},\"180\":{\"h\":\"5. 编写接口请求示例\",\"t\":[\"接口文档需要提供接口示例，接口实例是为了帮助调用者理解接口的使用方法和调用流程，快速开始调试程序。一般是 CURL 格式的示例。\",\"curl javapub.net.cn\",\"img\"]},\"181\":{\"h\":\"6. 引入接口版本管理\",\"t\":[\"随着功能开发的日趋完善，可能对接口做出修改更新，例如添加、删除时变更参数，或者修改返回值的格式。这些新变更可能影响用户的 API 使用体验，造成现有客户端无法使用。\",\"https://javapub.net.cn:8080/api/user/v1/queryById https://javapub.net.cn:8080/api/user/v2/queryById\",\"56d7cbc6-0b2c-4a90-ac37-a8e65c040d47\"]},\"182\":{\"h\":\"7. 维护接口文档版本更新\",\"t\":[\"如果接口发生了变更，接口文档也要做出相应调整，维护文档。比如错误码更新、参数类型变更等，要明确记录。\",\"日期\",\"变更内容\",\"责任人\",\"2028-03-01\",\"创建接口文档，定义基本数据结构。\",\"JavaPub\",\"2028-05-10\",\"V2.0用户中心接口更新\",\"王哥\",\"b4fe3684d20e97fa311ca213c8dc7ea9\"]},\"183\":{\"h\":\"8. 明确请求头有哪些\",\"t\":[\"接口文档，要写清楚请求头信息，比如：有权限校验的接口请求，在请求头中 apiKey。还有一些参数是 JSON 的，要设置 application/json。\",\"Accept：指定客户端能够接收的内容类型，如：Accept: text/plain, text/html。\",\"Authorization：一般存放令牌信息，如：Authorization: Basic QzPhZGRpbjpvcGVuIHNlc2FtZQ==\",\"Cookie：存放 Cookie 信息。\",\"User-Agent：指定客户端信息，作为服务端处理时定制化。\",\"Accept-Encoding：指定客户端允许的数据压缩格式，如 gzip、deflate 等。\",\"image-20240521104426851\"]},\"184\":{\"h\":\"9. 接口安全\",\"t\":[\"有些接口参数涉及到隐私和敏感数据、需要参数加密做好脱敏处理和说明。此外，还要做好接口授权访问，防止出现拖库、击穿等P0问题。\",\"image-20240521104647299\"]},\"185\":{\"h\":\"10. 接口测试\",\"t\":[\"在编写接口文档时，编写测试案例也要给出测试数据，包括请求参数和返回结果。让调用者有一个预期，节省沟通成本。\",\"image-20240521105043027\"]},\"186\":{\"h\":\"11. 定义错误码\",\"t\":[\"接口文档，一定要错误码，错误码作为程序重要的参考，让下游知道什么时候做什么动作。比如：当查询不到用户信息时，可以提示它跳转到注册页面。\",\"错误码\",\"名称\",\"说明\",\"1001\",\"参数错误\",\"参数不合法\",\"1002\",\"数据库错误\",\"数据库请求出错\",\"image-20240521104901378\"]},\"187\":{\"c\":[\"编程规范\",\"接口\"]},\"188\":{\"c\":[\"编程规范\",\"接口\"]},\"189\":{\"h\":\"工作总结！日志打印的11条建议\",\"t\":[\"工作总结！日志打印的11条建议\"]},\"190\":{\"h\":\"前言\",\"t\":[\"大家好，我是 JavaPub。日志是我们定位问题的得力助手，也是我们团队间协作沟通（甩锅）、明确责任归属（撕B）的利器。没有日志的程序运行起来就如同脱缰的野🐎。打印日志非常重要。今天我们来聊聊日志打印的 N 个好建议～\",\"image-20240314165434764\"]},\"191\":{\"h\":\"选择合适的日志等级\",\"t\":[\"在开发中我们有常见的四种日志打印等级，debug、info、warn、error，要选择合适的等级打印，不要上来直接 info。\",\"image-20240314214602647\",\"error: 错误日志，指比较严重的问题，会对系统和有业务造成伤害。运维监控重点关注。\",\"warn: 警告日志，不会对系统运行造成大的影响，一般由开发人员关注。\",\"info: 关键日志，为了保留系统运行关键指标，比如函数的入参、出参，时间等信息。\",\"debug: 开发日志，在开发调试阶段，记录对象数据在关键处理步骤中的变化情况、快速定位。\"]},\"192\":{\"h\":\"要打印函数的入参、出参\",\"t\":[\"记录日志并不是要把所有信息都记录下来，那日志存储就要大到上天。我们只记录关键有效的日志，有效日志才是 battle 🆚 时杀手锏。\",\"image-20240314214637143\",\"哪些算是有效日志？比如函数的入口处，打印入参，还包括用户唯一标识 （uid）、链路标识 （traceId） 等。函数出口打印返回值及时间等。\",\" public String GetName(Request req, Integer id){ log.debug(\\\"method start param: {}\\\", req.UserID); String name = \\\"JavaPub\\\"; log.debug(\\\"method end result: {}\\\", name); return name; }\"]},\"193\":{\"h\":\"打印日志对象要做判空处理，避免阻断流程\",\"t\":[\"image-20240314214712731\",\"为了打印一行日志，程序写挂了。空指针异常在任何代码中都是最常见的异常之一。\",\"反例：当 book 对象是 NULL 的话，这行日志就会抛空指针异常。\",\"public void doSome(Book book){ log.info(\\\"do do and print log: {}\\\". book.getName()); // do something... ... }\"]},\"194\":{\"h\":\"不要使用日志系统的（Log4j、Logback），要使用 Slf4j\",\"t\":[\"image-20240314214745191\",\"Slf4j 是使用门面模式的日志框架，可以解耦具体的日志实现。可以在不修改代码的情况下，更换底层的日志框架。\",\"正例：\",\"import org.slf4j.Logger; import org.slf4j.LoggerFactory; private static final Logger logger = LoggerFactory.getLogger(JavaPub.class);\"]},\"195\":{\"h\":\"对低级别的日志输出，必须进行日志级别开关判断\",\"t\":[\"image-20240314214801114\",\"对于 trace、debug、info 这些比较低的日志级别，必须进行日志级别开关。\",\"正例：\",\"开关判断逻辑通常放在日志工具类中。\",\"public void doSomething(){ User user = new User(1, \\\"技术自媒体\\\", \\\"JavaPub\\\"); if (logger.isDebugEnabled()) { logger.debug(\\\"print debug log. 666 is {}\\\", user.getName()); } }\",\"反例：\",\"public void doSth(){ String name = \\\"JavaPub\\\"; logger.trace(\\\"print debug log\\\" + name); logger.debug(\\\"print debug log\\\" + name); logger.info(\\\"print info log\\\" + name); // 业务逻辑 ... }\",\"当日志级别是 warn 时，以上日志不会打印，但是会执行字符串拼接操作，如果打印值是对象的话，还会执行 toString() 方法，浪费了系统资源，因此建议加上日志开关判断。\"]},\"196\":{\"h\":\"不要用e.printStackTrace()打印日志\",\"t\":[\"反例：\",\"public void doSomething(){ try{ // 业务代码 ... } catch (Exception e){ e.printStackTrace(); } }\",\"e.printStackTrace() 打印出的日志包含堆栈信息，导致我们的日志信息不规整、增加定位问题的难度。如果使用 ELK 分析日志也会非常困难。\",\"e.printStackTrace() 语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了，即内存满了，系统请求也将被阻塞。\",\"正例：\",\"public void doSomething(){ try{ // 业务逻辑 ... } catch (Exception e){ log.error(\\\"程序异常 failed\\\", e); } }\"]},\"197\":{\"h\":\"打印全部的异常信息，方便定位问题\",\"t\":[\"image-20240314214823572\",\"反例：\",\"没有打印系统异常 e，无法定位出现了什么类型的异常。\",\"public void doSth(){ try{ // 业务逻辑 ... } catch (Exception e){ log.error(\\\"发生了一个异常\\\"); } }\"]},\"198\":{\"h\":\"不要打印重复日志\",\"t\":[\"image-20240314214836800\",\"在嵌套逻辑代码中打印重复日志，增加系统资源消耗占用。\",\"反例：\",\"public void doSomething(String s){ log.info(\\\"do something and print log: {}\\\", s); doSubSomething(s); } ​ private void doSubSomething(String s){ log.info(\\\"do sub something and print log: {}\\\", s); // 写点业务逻辑 ... }\",\"正例：\",\"应该直接删掉或者将为 debug 日志级别。\"]},\"199\":{\"h\":\"日志尽量使用英文\",\"t\":[\"反例：\",\"image-20240314155834611\",\"建议：尽量在打印时日志时输出英文，防止中文编码与终端不一致导致打印出现乱码，对排查故障造成感染。\"]},\"200\":{\"h\":\"核心业务逻辑，在每个分支首行都打印日志\",\"t\":[\"在编写核心业务逻辑代码时，遇到 if...else 或者 switch 这样的分支条件，在行首打印日志，通过日志可以快速排查定位异常。\",\"public void doSomething(){ if(user.isVip()){ log.info(\\\"该用户是 JavaPub 会员,Id:{},开始处理会员逻辑\\\",user,getUserId()); // dosomething 会员逻辑 }else{ log.info(\\\"该用户是非会员,Id:{},开始处理非会员逻辑\\\",user,getUserId()) // dosomething 非会员逻辑 } }\"]},\"201\":{\"h\":\"不要打印无意义的日志（不携带上下文、日志链路 id）\",\"t\":[\"image-20240314214848607\",\"反例：\",\"不携带任何业务信息的日志，对故障排查意义不大。\",\"public void doSomething(){ log.info(\\\"do something and print log. i am NB\\\"); // dosomething 业务逻辑 ... }\",\"正例：\",\"日志一定要携带业务信息相关内容，有利于快速定位问题原因\",\"public void doSomething(Request req, User user){ log.info(\\\"do something and print log, id={}, trace_id={}\\\", user.GetId, req.GetTraceId); // dosomething 业务逻辑 ... }\",\"如何打印日志呢？总的来说不要让你的程序在黑盒总运行，打印关键信息、保证在出现异常时通过日志快速定位到那里就可以啦。\"]},\"202\":{\"c\":[\"编程规范\",\"日志\"]},\"203\":{\"c\":[\"编程规范\",\"日志\"]},\"204\":{\"h\":\"面试专题合集\",\"t\":[\"面试必读专题。 实战项目组\"]},\"205\":{\"h\":\"项目实战\",\"t\":[\"实战项目组，从零到一写代码、从需求到部署上线。开始阅读。\",\"项目中用到的技术点和手记都免费公开，获取视频课程点击，点击了解星球🌍。\"]},\"206\":{\"c\":[\"项目实战\"]},\"207\":{\"c\":[\"项目实战\"]},\"208\":{\"h\":\"星球介绍\"},\"209\":{\"h\":\"资源获取说明\",\"t\":[\"JavaPub 分享了很多资源和源码等，大部分都免费开源到 Github。你可以访问 https://github.com/Rodert 进入 JavaPub 的 GitHub 主页。\",\"如何使用 GitHub:\",\"如何使用\",\"方案二，部分资源在百度网盘，加入群消息自行获取。备注【加群】，快速处理。点击加群\",\"群公告获取\"]},\"210\":{\"h\":\"星球介绍\",\"t\":[\"了解编程指南知识星球： 掌握编程 - 编程指南知识星球\"]},\"211\":{\"h\":\"编程指南的优势\",\"t\":[\"加入我们，你将获得以下特权：\",\"提问答疑，包括开发和面试中遇到的问题。\",\"简历优化，简历作为找工作的第一块敲门砖，写的好可以获得很大的加分。你可以直接发送到我的邮箱，我每天都会处理邮件：731444260@qq.com\",\"实战直播课，很多人没有做过企业级项目、不了解整个项目的开发流程，我们会出多个实战课带大家手把手做项目、也会有直播回看的哦。\",\"前沿技术分享，我一直在研究关注区块链和 AI 领域，会不定时分享一些我的看法。\",\"时常分享优质学习资源，终身学习我们一起行动。\",\"副业赚钱，聊聊我怎么用副业在赚钱。\"]},\"212\":{\"h\":\"付费加入\",\"t\":[\"星球初始定价格 59 元（🎈）。说实话，这个价格很低、甚至在网上买一个盗版项目源码的价格都要比这个高，还有一点也是为了可以筛选加入的小伙伴是真正要学习编程的同学。平均每天 0.16 元。（以后每新出一个项目加一次价格，越早入手越划算。）\",\"微信扫描下方二维码加入：\",\"加入 3 天不满意可以全额退款，感兴趣的同学可以先加入体验，毕竟知识学到都是自己的！\",\"如果不确定是否要加入，可以在公众号留言 公众号 - JavaPub ，备注：想要加入星球，然后说明自己的情况。\",\"星球链接 https://t.zsxq.com/14tMfIK7m\",\"星球优惠码先到先得\"]},\"213\":{\"h\":\"走进作者\"},\"214\":{\"h\":\"联系站长\",\"t\":[\"作者档案\",\"微信联系站长\",\"或者，搜索微信号： javapub\"]},\"215\":{\"c\":[\"站长\",\"关于我\"]},\"216\":{\"c\":[\"站长\",\"联系站长\"]},\"217\":{\"h\":\"作者信息\",\"t\":[\"作者档案\",\"联系站长\",\"站长是谁？\",\"大家都叫他王哥，生于 1996 年内蒙古边陲城市，他是一个普普通通的男生，毕业于 2019 年。全干开发工程师...，喜欢折腾。\",\"商务合作\"]},\"218\":{\"h\":\"视频\",\"t\":[\"西瓜视频\",\"哔哩哔哩\"]},\"219\":{\"h\":\"我做过的项目\",\"t\":[\"JavaPub官网\",\"旧版JavaPub官网\",\"JavaPub学习路线\",\"俩万通用后台管理系统\",\"...\",\"更多：点击了解\"]},\"220\":{\"c\":[\"站长\",\"关于我\"]},\"221\":{\"c\":[\"站长\"]},\"222\":{\"h\":\"档案主页\"},\"223\":{\"h\":\"介绍\",\"t\":[\"少年应有鸿鹄志，当骑骏马踏平川。\",\"作者生于 1996 年内蒙古边陲城市，毕业于 2019 年，双非本科。全栈工程师，包含 web、大数据、搜索、爬虫、区块链等领域。\"]},\"224\":{\"h\":\"网站更新记录\"},\"225\":{\"h\":\"网站更新时间线\",\"t\":[\"更新时间轴\",\"下面是站长的唠叨。\",\"JavaPub 最早诞生于 2019 年。我当时即将大学毕业，在一家大型安全公司实习。那时几个同学一块在那里实习，基本每天大家都晚上 10 点以后回家（因为公司十点以后走，第二天可以晚半小时来，还提供免费的面包和桶面😄）。那个阶段是毕业后成长非常快的，工作一年起码顶俩年。也就是在这个时间诞生了 JavaPub 。\",\"当时用了好几个夜晚来做起名、设计 logo ，感觉一个小宇宙即将爆发。但是，努力是反人性的，更新了一段时间，新鲜感过去后，停滞了很久很久。\",\"其实在这之前， 2017 年，我就尝试过搞自媒体，当时叫 【木须先生】 。这个账号的定位是写软文，也就是一些正能量的综合性文章，像社会、生活类的。当然也流产了。\"]},\"226\":{\"h\":\"历史图片\",\"t\":[\"保存历史图片，万一以后成为百万博主，也能拿出去吹。\",\"历史网站截图： \"]},\"227\":{\"c\":[\"网站\"]},\"228\":{\"c\":[\"网站\"]},\"229\":{\"h\":\"langchain\"},\"230\":{\"c\":[\"langchain\",\"ai\"]},\"231\":{\"c\":[\"langchain\",\"ai\"]},\"232\":{\"h\":\"LangChain\",\"t\":[\"TODO\",\"参考：\",\"https://python.langchain.com/v0.2/docs/introduction/\",\"https://blog.csdn.net/qq_35812205/article/details/131709720\"]},\"233\":{\"c\":[\"langchain\",\"ai\"]},\"234\":{\"c\":[\"langchain\",\"ai\",\"chatgpt\"]},\"235\":{\"h\":\"lm_studio\"},\"236\":{\"c\":[\"lm_studio\",\"ai\"]},\"237\":{\"c\":[\"lm_studio\",\"ai\"]},\"238\":{\"h\":\"LM Studio\",\"t\":[\"TODO\",\"参考：\",\"https://www.huwangyun.cn/blog/ollama-vs-lm-studio\"]},\"239\":{\"c\":[\"LMStudio\",\"ai\"]},\"240\":{\"c\":[\"LMStudio\",\"ai\",\"chatgpt\"]},\"241\":{\"h\":\"ollama\",\"t\":[\"ollama 使用\",\"参考：\",\"支持模型列表： https://ollama.com/library\",\"ollama官网： https://ollama.com\"]},\"242\":{\"c\":[\"ollama\",\"ai\"]},\"243\":{\"c\":[\"ollama\",\"ai\"]},\"244\":{\"h\":\"ollama本地调用大模型\",\"t\":[\"大语言模型，ollama轻松打造本地LLM应用 普通人如何快速搭建本地大语言模型\",\"视频 | 官网 | GitHub\",\"建议环境&配置 大于 4c8g\"]},\"245\":{\"h\":\"认识 ollama\",\"t\":[\"Ollama 是一个开源大语言模型工具，帮助用户快速在本地搭建运行大模型。支持一系列著名的模型。如Llama2、Mistral、Gemma，极大的简化了安装和配置的细节。\"]},\"246\":{\"h\":\"搭建\",\"t\":[\"根据不同操作系统，选择对应的安装包进行安装： https://ollama.com/download\"]},\"247\":{\"h\":\"Linux 为例\",\"t\":[\"一键安装\",\"curl -fsSL https://ollama.com/install.sh | sh\",\"加载 llama3 模型\",\"ollama run llama3\",\"查询模型安装是否成功\",\"ollama list\"]},\"248\":{\"h\":\"测试\",\"t\":[\"ollama 默认启动的端口是：11434\",\"curl http://127.0.0.1:11434/ # Ollama is running\"]},\"249\":{\"h\":\"调用llama3试用\",\"t\":[\"测试响应\",\"curl http://localhost:11434/api/generate -d '{ \\\"model\\\": \\\"llama3\\\", \\\"prompt\\\":\\\"你知道 JavaPub 吗？\\\" }'\",\"与模型对话\",\"curl http://localhost:11434/api/chat -d '{ \\\"model\\\": \\\"llama3\\\", \\\"messages\\\": [ { \\\"role\\\": \\\"user\\\", \\\"content\\\": \\\"你知道 JavaPub 吗？\\\" } ] }'\"]},\"250\":{\"h\":\"前言\",\"t\":[\"首先安装 docker\"]},\"251\":{\"h\":\"搭建\",\"t\":[\"推荐使用: https://github.com/open-webui/open-webui\",\"ollama 我已经单独安装，现在只需要安装 webui。\",\"docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main\",\"默认端口是 3000，http://127.0.0.1:3000\",\"image-\",\"第一次进来没有账户，点击 Create 创建，第一个新创建的账户拥有管理员权限。\",\"接下来登陆进来，就可以使用了。\",\"image\",\"TODO\",\"[ ] 搭建 llama3 模型，并调用成功 [ ] 整合 go 语言，实现 api 调用 [ ] 流式回复\",\"以 llama3 为例： https://ollama.com/library/llama3\",\"参考：\",\"https://zhuanlan.zhihu.com/p/694843237\",\"https://blog.csdn.net/tirestay/article/details/139744309\",\"https://blog.csdn.net/qq_40999403/article/details/139320266\",\"视频参考： https://www.bilibili.com/video/av1903594994/?vd_source=f2a0231e07e27f42fa11f05024479cb8\"]},\"252\":{\"h\":\"附录\",\"t\":[\"支持模型列表： https://ollama.com/library\",\"中文参考文档： https://ollama.fan/reference/api/#generate-a-completion-request-streaming\",\"webui: https://github.com/open-webui/open-webui\",\"原文： https://javapub.net.cn/posts/ai/\"]},\"253\":{\"c\":[\"ollama\",\"ai\"]},\"254\":{\"c\":[\"ollama\",\"ai\",\"llama3\",\"chatgpt\"]},\"255\":{\"h\":\"算法\"},\"256\":{\"c\":[\"算法\"]},\"257\":{\"c\":[\"算法\"]},\"258\":{\"h\":\"数据结构\"},\"259\":{\"c\":[\"数据结构\"]},\"260\":{\"c\":[\"数据结构\"]},\"261\":{\"h\":\"B树和B+树区别\",\"t\":[\"[toc]\"]},\"262\":{\"h\":\"写在前面\",\"t\":[\"大家在面试的时候，肯定都会被问到MySql的知识，以下是面试场景： B树 和B+树是 MySQL索引使用的数据结构，对于索引优化和原理理解都非常重要，下面我的写文章就是要把B树，B+树的神秘面纱揭开，让大家在面试的时候碰到这个知识点一往无前，不再成为你的知识盲点！\"]},\"263\":{\"h\":\"1、B树\",\"t\":[\"这里的 B 是 Balance（平衡）的缩写。它是一种多路的平衡搜索树。\",\"它跟普通的平衡二叉树的不同是，B树的每个节点可以存储多个数据，而且每个节点不止有两个子节点，最多可以有上千个子节点。\",\"B树中每个节点都存放着索引和数据，数据遍布整个树结构，搜索可能在非叶子节点结束，最好的情况是O(1)。\",\"一般一棵 B 树的高度在 3 层左右，3 层就可满足 百万级别的数据量\",\"在这里插入图片描述\",\"B树 每个节点都存储了一定的范围区间，区间更多的情况下，搜索也就更快。\",\"比如普通的二叉树对于 1~ 100 的索引值，首先分为 1~ 50 和51~ 100 两部分。\",\"而 B树可以分为四个区间 1~ 25, 26~ 50, 51~ 75, 76~ 100 。甚至可以划分为更多区间，这样一次就能排除四分之三的数据\"]},\"264\":{\"h\":\"2、B+树\",\"t\":[\"B+树是B树的一种变种，它与 B树 的 区别 是：\",\"叶子节点保存了完整的索引和数据，而非叶子节点只保存索引值，因此它的查询时间固定为 log(n).\",\"叶子节点中有指向下一个叶子节点的指针，叶子节点类似于一个单链表\",\"正因为叶子节点保存了完整的数据以及有指针作为连接，B+树可以增加了区间访问性，提高了范围查询，而B树的范围查询相对较差\",\"B+树更适合外部存储。因为它的非叶子节点不存储数据，只保存索引。\",\"B+树的示意图如下：\",\"在这里插入图片描述\",\"到此为止相信你已经对B树和B+树有一定认识，下面结合数据库深入了解\"]},\"265\":{\"h\":\"B树\",\"t\":[\"B-树有如下特点:\",\"所有键值分布在整颗树中（索引值和具体data都在每个节点里）；\",\"任何一个关键字出现且只出现在一个结点中；\",\"搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；\",\"在关键字全集内做一次查找,性能逼近二分查找；\"]},\"266\":{\"h\":\"B树深入\",\"t\":[\"B树由来\",\"定义：B-树是一类树，包括B-树、B+树、B*树等，是一棵自平衡的搜索树，它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。 B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。\",\"定义只需要知道B-树允许每个节点有更多的子节点即可（多叉树）。子节点数量一般在上千，具体数量依赖外部存储器的特性。\",\"先来看看为什么会出现B-树这类数据结构。\",\"传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。原因当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。这说明程序大部分时间会阻塞在磁盘 IO 上。那么我们如何提高程序性能？减少磁盘 IO 次数，像 AVL 树，红黑树这类平衡二叉树从设计上无法“迎合”磁盘。\",\" 上图是一颗简单的平衡二叉树，平衡二叉树是通过旋转来保持平衡的，而旋转是对整棵树的操作，若部分加载到内存中则无法完成旋转操作。其次平衡二叉树的高度相对较大为 log n（底数为2），这样逻辑上很近的节点实际可能非常远，无法很好的利用磁盘预读（局部性原理)，所以这类平衡二叉树在数据库和文件系统上的选择就被 pass 了。\",\"空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。\",\"我们从“迎合”磁盘的角度来看看B-树的设计。\",\"索引的效率依赖与磁盘 IO 的次数，快速索引需要有效的减少磁盘 IO 次数，如何快速索引呢？索引的原理其实是不断的缩小查找范围，就如我们平时用字典查单词一样，先找首字母缩小范围，再第二个字母等等。平衡二叉树是每次将范围分割为两个区间。为了更快，B-树每次将范围分割为多个区间，区间越多，定位数据越快越精确。那么如果节点为区间范围，每个节点就较大了。所以新建节点时，直接申请页大小的空间（磁盘存储单位是按 block 分的，一般为 512 Byte。磁盘 IO 一次读取若干个 block，我们称为一页，具体大小和操作系统有关，一般为 4 k，8 k或 16 k），计算机内存分配是按页对齐的，这样就实现了一个节点只需要一次 IO。\",\" 上图是一棵简化的B-树，多叉的好处非常明显，有效的降低了B-树的高度，为底数很大的 log n，底数大小与节点的子节点数目有关，一般一棵B-树的高度在 3 层左右。层数低，每个节点区确定的范围更精确，范围缩小的速度越快（比二叉树深层次的搜索肯定快很多）。上面说了一个节点需要进行一次 IO，那么总 IO 的次数就缩减为了 log n 次。B-树的每个节点是 n 个有序的序列(a1,a2,a3…an)，并将该节点的子节点分割成 n+1 个区间来进行索引(X1< a1, a2 < X2 < a3, … , an+1 < Xn < anXn+1 > an)。\",\"点评：B树的每个节点，都是存多个值的，不像二叉树那样，一个节点就一个值，B树把每个节点都给了一点的范围区间，区间更多的情况下，搜索也就更快了，比如：有1-100个数，二叉树一次只能分两个范围，0-50和51-100，而B树，分成4个范围 1-25， 25-50，51-75，76-100一次就能筛选走四分之三的数据。所以作为多叉树的B树是更快的\"]},\"267\":{\"h\":\"B-树的查找\",\"t\":[\"我们来看看B-树的查找，假设每个节点有 n 个 key值，被分割为 n+1 个区间，注意，每个 key 值紧跟着 data 域，这说明B-树的 key 和 data 是聚合在一起的。一般而言，根节点都在内存中，B-树以每个节点为一次磁盘 IO，比如上图中，若搜索 key 为 25 节点的 data，首先在根节点进行二分查找（因为 keys 有序，二分最快），判断 key 25 小于 key 50，所以定位到最左侧的节点，此时进行一次磁盘 IO，将该节点从磁盘读入内存，接着继续进行上述过程，直到找到该 key 为止。\",\"Data* BTreeSearch(Root *node, Key key) { Data* data; if(root == NULL) return NULL; data = BinarySearch(node); if(data->key == key) { return data; }else{ node = ReadDisk(data->next); BTreeSearch(node, key); } }\"]},\"268\":{\"h\":\"B+ 树\"},\"269\":{\"h\":\"B+树概述\",\"t\":[\"B+树是B-树的变体，也是一种多路搜索树, 它与 B- 树的不同之处在于:\",\"所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)\",\"为所有叶子结点增加了一个链指针\",\"简化 B+树 如下图\",\"因为内节点并不存储 data，所以一般B+树的叶节点和内节点大小不同，而B-树的每个节点大小一般是相同的，为一页。\",\"为了增加 区间访问性，一般会对B+树做一些优化。 如下图带顺序访问的B+树。\",\"在这里插入图片描述\"]},\"270\":{\"h\":\"B-树和B+树的区别\",\"t\":[\"1.B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。\",\"如下所示B-树/B+树查询节点 key 为 50 的 data。\",\"B-树：\",\" 从上图可以看出，key 为 50 的节点就在第一层，B-树只需要一次磁盘 IO 即可完成查找。所以说B-树的查询最好时间复杂度是 O(1)。\",\"B+树：\",\"由于B+树所有的 data 域都在根节点，所以查询 key 为 50的节点必须从根节点索引到叶节点，时间复杂度固定为 O(log n)。\",\"点评：B树的由于每个节点都有key和data，所以查询的时候可能不需要O(logn)的复杂度，甚至最好的情况是O(1)就可以找到数据，而B+树由于只有叶子节点保存了data，所以必须经历O(logn)复杂度才能找到数据\",\"2. B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。\",\" 根据空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。\",\"B+树可以很好的利用局部性原理，若我们访问节点 key为 50，则 key 为 55、60、62 的节点将来也可能被访问，我们可以利用磁盘预读原理提前将这些数据读入内存，减少了磁盘 IO 的次数。 当然B+树也能够很好的完成范围查询。比如查询 key 值在 50-70 之间的节点。\",\"点评：由于B+树的叶子节点的数据都是使用链表连接起来的，而且他们在磁盘里是顺序存储的，所以当读到某个值的时候，磁盘预读原理就会提前把这些数据都读进内存，使得范围查询和排序都很快\",\"3.B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确\",\"这个很好理解，由于B-树节点内部每个 key 都带着 data 域，而B+树节点只存储 key 的副本，真实的 key 和 data 域都在叶子节点存储。前面说过磁盘是分 block 的，一次磁盘 IO 会读取若干个 block，具体和操作系统有关，那么由于磁盘 IO 数据大小是固定的，在一次 IO 中，单个元素越小，量就越大。这就意味着B+树单次磁盘 IO 的信息量大于B-树，从这点来看B+树相对B-树磁盘 IO 次数少。\",\"点评：由于B树的节点都存了key和data，而B+树只有叶子节点存data，非叶子节点都只是索引值，没有实际的数据，这就时B+树在一次IO里面，能读出的索引值更多。从而减少查询时候需要的IO次数！\",\" 从上图可以看出相同大小的区域，B-树仅有 2 个 key，而B+树有 3 个 key。\"]},\"271\":{\"h\":\"拓展：MySQL为什么使用B-Tree（B+Tree）&& 存储知识\",\"t\":[\"上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。\",\"一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。\"]},\"272\":{\"h\":\"存储数据最小单元\",\"t\":[\"我们都知道计算机在存储数据的时候，有最小存储单元，这就好比我们今天进行现金的流通最小单位是一毛。\",\"在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是512字节，而文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是4k\",\"而对于我们的InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。\",\"下面几张图可以帮你理解最小存储单元：\",\"文件系统中一个文件大小只有1个字节，但不得不占磁盘上4KB的空间。\",\"磁盘扇区、文件系统、InnoDB存储引擎都有各自的最小存储单元。\",\" 在MySQL中我们的InnoDB页的大小默认是16k，当然也可以通过参数设置：\",\" 数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是1k，那么一个页可以存放16行这样的数据。\"]},\"273\":{\"h\":\"主存存取原理\",\"t\":[\"目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。\",\" 从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。\",\"主存的存取过程如下：\",\"当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。\",\"写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。\",\"这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。\"]},\"274\":{\"h\":\"磁盘存取原理\",\"t\":[\"上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。\",\"图6是磁盘的整体结构示意图。\",\"一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。\",\"图7是磁盘结构的示意图。\",\" 盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。\",\"当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。\",\"局部性原理与磁盘预读\",\"由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：\",\"当一个数据被用到时，其附近的数据也通常会马上被使用。\",\"程序运行期间所需要的数据通常比较集中。\",\"由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。\",\"预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。\",\"所以IO一次就是读一页的大小\"]},\"275\":{\"h\":\"总结\",\"t\":[\"MySQL的B树和B+树原理就说到这里了。\",\"我是JavaPub，下期见\",\"参考：https://blog.csdn.net/qq_40374604/article/details/120284492\"]},\"276\":{\"c\":[\"B树\",\"B+树\"]},\"277\":{\"h\":\"学习基础数据结构\",\"t\":[\"阅读大概需要10分钟，基础知识资料较长，建议收藏阅读\",\"[toc]\"]},\"278\":{\"h\":\"数据结构和算法的基本概念\"},\"279\":{\"h\":\"数据、数据元素、数据逻辑结构、数据存储结构、数据类型、抽象数据类型等\"},\"280\":{\"h\":\"算法、算法设计的要求、算法效率的度量、算法存储空间的需求等\"},\"281\":{\"h\":\"线性数据结构\"},\"282\":{\"h\":\"栈、队列和线性表的定义和基本概念\",\"t\":[\"线性表\",\"Java里一个很重要的数据结构——线性表，线性表里的元素是按线性排列的（这里的线性指逻辑上的），线性表分为两大类，分别是顺序表和链表。\",\"栈\",\"栈是一种采用“后进先出”策略的数据结构类型。其本质意义也是线性表的一种，不过是一种特殊的线性表。栈顶记做，top，栈底记做，bottom。\",\"栈有一个非常非常重要的一个特点：只允许在栈顶进行数据元素的插入或删除操作。根据这一特点我们可知，栈基本上只有两种操作，一是插入操作，另一个是删除操作。栈的插入操作也称为：进栈，压栈，入栈。栈的删除操作也称为，出栈，弹栈。英文记做，push(压栈),pop(弹栈)。“后进先出”策略英文记为，“LIFO”，Last In First Out。\",\"队列\",\"队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。支持先进先出 FIFO，跟我们生活中的排队类似。\"]},\"283\":{\"h\":\"栈、队列和线性表的实现，包括顺序和链式存储结构\"},\"284\":{\"h\":\"线性表\",\"t\":[\"线性表有两种实现方式，顺序存储和链式存储。\",\"顺序存储结构是元素在存储器中的相对位置来表示数据元素之间的逻辑关系。\",\"链式存储结构是依靠指针(Java中引用)来表现数据元素之间的逻辑关系。\",\"API:\",\"public interface List<E> { /** * 清空线性表 */ void clean(); /** * 判断线性表是否为空 * * @return true:空，false:非空 */ boolean isEmpty(); /** * 获取线性表的元素个数 * * @return 线性表的元素个数 */ int length(); /** * 添加元素 * * @param elem 添加元素 */ void addElem(E elem); /** * 添加线性表 * * @param list 待添加的线性表 */ void addAll(List<? extends E> list); /** * 指定位置插入元素 * * 1.将插入位置index的元素和之后的元素往后移动一位 * 2.将位置index的元素赋值 * * @param index 插入位置 * @param elem 插入元素 */ void insertElem(int index, E elem); /** * 替换元素 * * @param target 被替换元素 * @param replace 替换元素 * @return 替换的元素个数 */ int replace(E target, E replace); /** * 获取指定位置的元素 * * @param index 查找位置 * @return 位置对应的元素 */ E indexOf(int index); /** * 查找指定元素的位置 * * @param elem 待查找元素 * @return 第一次查找到元素的位置 */ int locateElem(E elem); /** * 获取指定元素的所有位置 * * @param elem 待查找元素 * @return 查找元素的所有位置 */ List<Integer> locateElements(E elem); /** * 批量删除元素 * * @param elem 待删除的元素 * @return 删除元素的位置 */ int removeElements(E elem); /** * 删除指定位置的元素 * 将index之后的元素往前面移动一位 * * @param index 删除的位置 * @return 删除位置的元素 */ E removeElem(int index); /** * 转化为数组 * @return 返回数组 */ Object[] toArray(); }\"]},\"285\":{\"h\":\"顺序存储实现（例如ArrayList）\",\"t\":[\"public class ArrayList<E> implements List<E> { //默认存储容器大小 private int defaultCapacity = 10; //存储容器 private Object[] elemData; //元素个数 private int size; /** * 初始化存储容器 */ public ArrayList() { elemData = new Object[defaultCapacity]; } /** * 初始化存储容器并且添加元素 * * @param initialList 待添加的线性表 */ public ArrayList(List<? extends E> initialList) { this(); addAll(initialList); } /** * 初始化存储容器 * * @param initialCapacity 存储容器初始大小 */ public ArrayList(int initialCapacity) { elemData = new Object[initialCapacity]; } /** * 检查位置是否合法 * * @param index 待检查位置 * @throws IndexOutOfBoundsException 位置不合法异常 */ private void rangeCheck(int index) throws IndexOutOfBoundsException { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(index + \\\"超出线性表范围\\\"); } } /** * 确保容量够用 * * @param length 添加后的容量 */ private void ensureCapacity(int length) { if (length > elemData.length) { extendedCapacity(length); } } /** * 1.5倍扩容 * * @param length 至少需要的大小 * @throws OutOfMemoryError 分配内存失败 */ private void extendedCapacity(int length) throws OutOfMemoryError { int extendedLength = length; extendedLength = extendedLength + extendedLength >> 1; try { elemData = Arrays.copyOf(elemData, extendedLength); } catch (OutOfMemoryError error) { throw new OutOfMemoryError(\\\"扩容失败\\\"); } } public void clean() { elemData = new Object[defaultCapacity]; size = 0; } public boolean isEmpty() { return size == 0; } public int length() { return size; } public void addElem(E elem) { ensureCapacity(size + 1); elemData[size++] = elem; } public void addAll(List<? extends E> list) { if (list == null) { return; } ensureCapacity(list.length() + size); System.arraycopy(list.toArray(), 0, elemData, size, list.length()); size += list.length(); } public void insertElem(int index, E elem) { if (index < 0 || index > size) { throw new IndexOutOfBoundsException(index + \\\"超出线性表范围\\\"); } ensureCapacity(size + 1); System.arraycopy(elemData, index, elemData, index + 1, size++ - index); elemData[index] = elem; } public int replace(E target, E replace) { int count = 0; if (target == null) { for (int i = 0; i < size; i++) { if (elemData[i] == null) { count++; elemData[i] = replace; } } } else { for (int i = 0; i < size; i++) { if (elemData[i].equals(target)) { count++; elemData[i] = replace; } } } return count; } public E indexOf(int index) { rangeCheck(index); return (E) elemData[index]; } public int locateElem(E elem) { if (elem == null) { for (int i = 0; i < size; i++) { if (elemData[i] == null) { return i; } } } else { for (int i = 0; i < size; i++) { if (elemData[i].equals(elem)) { return i; } } } return -1; } public List<Integer> locateElements(E elem) { List<Integer> result = new ArrayList<>(); if (elem == null) { for (int i = 0; i < size; i++) { if (elemData[i] == null) { result.addElem(i); } } } else { for (int i = 0; i < size; i++) { if (elemData[i] != null && elemData[i].equals(elem)) { result.addElem(i); } } } return result; } public int removeElements(E elem) { int result = 0; List<Integer> list = locateElements(elem); for (int i = 0; i < list.length(); i++) { removeElem(list.indexOf(i) - result++); } return result; } /** * 删除元素 * 使用System.arrayCopy是调用native方法,效率会比自己写的循环高 * @param index 删除的位置 * @return 删除的元素 */ public E removeElem(int index) { E result = (E) elemData[index]; System.arraycopy(elemData, index + 1, elemData, index, size-- - index - 1); return result; } public Object[] toArray() { return Arrays.copyOf(elemData, size); } }\"]},\"286\":{\"h\":\"链式存储实现（LinkedList）（双向链表）\",\"t\":[\"删除操作：\",\"找到待删除节点delete的前一个节点prev\",\"将prev的next指针指向delete的下一个节点\",\"将delete的next指针指向null,帮助GC回收\",\"插入操作:\",\"找到待插入位置的前一个节点prev\",\"新生成一个节点add\",\"保存节点after为add的下一个节点\",\"将add节点的next指针指向after\",\"将prev节点的next指针指向add\",\"public class LinkedList<E> implements List<E> { //头结点 private Node<E> head; //元素个数 private int size; //节点元素 private class Node<E> { //节点数据 private E elem; //指向下一个元素 private Node<E> next; } public LinkedList() { head = new Node<>(); } public LinkedList(List<? extends E> list) { this(); addAll(list); } /** * 检查位置是否合法 * * @param index 待检查位置 * @throws IndexOutOfBoundsException 位置不合法异常 */ private void rangeCheck(int index) throws IndexOutOfBoundsException { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(index + \\\"超出线性表范围\\\"); } } /** * 获取指定节点的node * * @param index 索引位置 * @return 索引位置的节点 */ private Node<E> getNode(int index) { if (index == -1) { return head; } Node<E> iterator = head.next; for (int i = 0; i < index; i++) { iterator = iterator.next; } return iterator; } @Override public void clean() { head = null; size = 0; } @Override public boolean isEmpty() { return size == 0; } @Override public int length() { return size; } @Override public void addElem(E elem) { Node<E> addNode = new Node<>(); addNode.elem = elem; Node<E> iterator = head; while (iterator.next != null) { iterator = iterator.next; } iterator.next = addNode; size++; } /** * 这里没有调用addElem来添加元素 * 原因为:调用addElem添加的时间复杂度为o(n²) * 使用以下方法添加的时间复杂度为o(n) * 当然你也可以再添加一个尾节点指针 * * @param list 待添加的线性表 */ @Override public void addAll(List<? extends E> list) { if (list == null || list.length() == 0) { return; } Node<E> iterator = head; //时间复杂度O(n) while (iterator.next != null) { iterator = iterator.next; } Node<E> addNodeHeader = new Node<>(); Node<E> addNodeIterator = addNodeHeader; //时间复杂度O(n) E[] addElements = (E[]) list.toArray(); //时间复杂度O(n) for (int i = 0; i < addElements.length; i++) { Node<E> node = new Node<>(); node.elem = addElements[i]; addNodeIterator.next = node; addNodeIterator = node; } iterator.next = addNodeHeader.next; //断开连接,帮助GC回收 addNodeHeader.next = null; } @Override public void insertElem(int index, E elem) { if (index < 0 || index > size) { throw new IndexOutOfBoundsException(index + \\\"位置不合法\\\"); } Node<E> prev = getNode(index - 1); Node<E> addNode = new Node<>(); addNode.elem = elem; addNode.next = prev.next; prev.next = addNode; size++; } @Override public int replace(E target, E replace) { Node<E> iterator = head.next; int result = 0; if (target == null) { while (iterator != null) { if (iterator.elem == null) { iterator.elem = replace; result++; } iterator = iterator.next; } } else { while (iterator != null) { if (iterator.elem != null && iterator.elem.equals(target)) { iterator.elem = replace; result++; } iterator = iterator.next; } } return result; } @Override public E indexOf(int index) { rangeCheck(index); //通过上次校验，肯定含有此位置。所以没有按照传统的方法来写。 //传统方法可以参考子标题下面的伪代码 return getNode(index).elem; } @Override public int locateElem(E elem) { Node<E> iterator = head.next; int result = 0; if (elem == null) { while (iterator != null) { if (iterator.elem == null) return result; result++; iterator = iterator.next; } } else { while (iterator != null) { if (iterator.elem != null && iterator.elem.equals(elem)) { return result; } result++; iterator = iterator.next; } } return -1; } @Override public List<Integer> locateElements(E elem) { List<Integer> list = new ArrayList<>(); Node<E> iterator = head.next; int index = 0; if (elem == null) { while (iterator != null) { if (iterator.elem == null) { list.addElem(index); } index++; iterator = iterator.next; } } else { while (iterator != null) { if (iterator.elem != null && iterator.elem.equals(elem)) { list.addElem(index); } index++; iterator = iterator.next; } } return list; } @Override public int removeElements(E elem) { Node<E> iterator = head.next; Node<E> prev = head; int result = 0; if (elem == null) { while (iterator != null) { if (iterator.elem == null) { prev.next = iterator.next; iterator.next = null; iterator = prev.next; result++; continue; } prev = prev.next; iterator = iterator.next; } } else { while (iterator != null) { if (iterator.elem != null && iterator.elem.equals(elem)) { prev.next = iterator.next; iterator.next = null; iterator = prev.next; result++; continue; } prev = prev.next; iterator = iterator.next; } } return result; } @Override public E removeElem(int index) { rangeCheck(index); Node<E> prev = getNode(index - 1); Node<E> delNode = prev.next; prev.next = delNode.next; E result = delNode.elem; //help GC delNode.next = null; size--; return result; } @Override public Object[] toArray() { Node<E> iterator = head.next; Object[] result = new Object[size]; int loop = 0; while (iterator != null) { result[loop++] = iterator.elem; iterator = iterator.next; } return result; } }\"]},\"287\":{\"h\":\"队列\",\"t\":[\"队列同样是一种特殊的线性表，其插入和删除的操作分别在表的两端进行，队列的特点就是先进先出(First In First Out)。我们把向队列中插入元素的过程称为入队(Enqueue|push)，删除元素的过程称为出队(Dequeue|pop)并把允许入队的一端称为队尾，允许出的的一端称为队头，没有任何元素的队列则称为空队。\",\"关于队列的操作，我们这里主要实现入队，出队，判断空队列和清空队列等操作，声明队列接口Queue（队列抽象数据类型）如下：\"]},\"288\":{\"h\":\"顺序队列\",\"t\":[\"顺序队列的实现可以使用数组来完成，一端做push，另一端做pop操作。下面是队列的操作示意图。\",\"顺序队列\",\"所以我们通常将数组弄成一个环状，即队头和队尾相连，这样就形成了“循环队列”，同时也解决了“假溢出”现象。循环队列是改进版的顺序队列。\",\"循环顺序队列\",\"对于普通队列的 push 或 pop 我们只需要对尾指针或头指针进行自增操作即可，但是循环队列我们就不能单纯的进行自增，当 front 或 rear=maxSize-1 时我们就不能进行自增操作了，比如一个队列尾长度为 4 的数组 datas[4]，那么当 front 或rear需要在 0,1,2,3 之间进行循环“推进”，以此达到循环队列的效果。所以我们可以使用 rear = （rear+1）%maxSize ；front = （front+1）%maxSize ；公式进行指针计算。\",\"需要注意的是：队空状态的条件为：front = rear。而如果整个队列全部存满数据那么，队满的条件也是 front = rear；所以循环队列需要损失一个存储空间，如下图：\",\"解决了这些问题我们就可以很轻松地实现循环队列了：\",\"package com.my.queue; /** * @Author: wangshiyu javapub rodert * @Date: 2020/12/19 18:13 */ public class SqQueue<T> { private T[] datas;//使用数组作为队列的容器 private int maxSize;//队列的容量 private int front;//头指针 private int rear;//尾指针 //初始化队列 public SqQueue(int maxSize) { if (maxSize < 1) { maxSize = 1; } this.maxSize = maxSize; this.front = 0; this.rear = 0; this.datas = (T[]) new Object[this.maxSize]; } //两个状态:队空&队满 public boolean isNull() { if (this.front == this.rear) return true; else return false; } public boolean isFull() { if ((rear + 1) % this.maxSize == front) return true; else return false; } //初始化队列 public void initQueue() { this.front = 0; this.front = 0; } //两个操作:进队&出队 public boolean push(T data) { if (isFull()) return false;//队满则无法进队 else { datas[rear] = data;//进队 rear = (rear + 1) % maxSize;//队尾指针+1. return true; } } public T pop() { if (isNull()) return null;//对空无法出队 else { T popData = datas[front++];//出队 front = (front + 1) % maxSize;//队头指针+1 return popData; } } //get() public T[] getDatas() { return datas; } public int getMaxSize() { return maxSize; } public int getFront() { return front; } public int getRear() { return rear; } }\",\"测试一下：\",\"class s { public static void main(String[] args) { SqQueue<Character> queue = new SqQueue<Character>(4); //判断 System.out.println(\\\"队列是否为空：\\\" + queue.isNull()); //入队A,B,C queue.push('A'); queue.push('B'); queue.push('C'); System.out.println(\\\"队列是否为满：\\\" + queue.isFull()); //出队 Character data = queue.pop(); System.out.println(\\\"出队：\\\" + data); } }\",\"运行结果：\",\"队列是否为空：true 队列是否为满：true 出队：A\"]},\"289\":{\"h\":\"链式队列\",\"t\":[\"链队实现，如图所示：\",\"链队的实现很简单，只要理解了链表的操作和队列的特点即可。（上文有写到链表的实现）\",\"package com.my.queue; /** * @Author: wangshiyu javapub rodert * @Date: 2020/12/19 18:30 */ public class LinkQueue<T> { private QNode<T> front;//队头指针 private QNode<T> rear;//队尾指针 private int maxSize;//为了便于操作，使用这个变量表示链队的数据容量 //初始化 public LinkQueue() { this.front = new QNode<T>(); this.rear = new QNode<T>(); this.maxSize = 0; } //初始化队列 public void initQueue() { front.next = null; rear.next = null; maxSize = 0; } //队空判断 public boolean isNull() { if (front.next == null || rear.next == null) return true; else return false; } //进队 public void push(QNode<T> node) { if (isNull()) { //第一次 front.next = node; rear.next = node; maxSize++; } else { node.next = front.next; front.next = node; maxSize++; } } //出队 public QNode<T> pop() { if (isNull()) return null;//队为空时，无法出队 else if (maxSize == 1) { //队只有一个元素时直接初始化即可 QNode<T> node = front.next; initQueue(); return node; } else { //准备工作 QNode<T> p = front;//使用p指针来遍历队列 for (int i = 1; i < maxSize - 1; i++) p = p.next; //pop QNode<T> node = rear.next; rear.next = p.next; maxSize--; return node; } } } //链队结点 class QNode<T> { private T data;//数据域 public QNode<T> next;//指针域 //初始化1 public QNode() { this.data = null; this.next = null; } //初始化2 public QNode(T data) { this.data = data; this.next = null; } public T getData() { return data; } public void setData(T data) { this.data = data; } }\",\"测试运行：\",\"class d { public static void main(String[] args) { LinkQueue<Integer> lq = new LinkQueue<Integer>(); System.out.println(\\\"队列是否为空：\\\" + lq.isNull()); //依次插入1、2、3、4 lq.push(new QNode<Integer>(1)); lq.push(new QNode<Integer>(2)); lq.push(new QNode<Integer>(3)); lq.push(new QNode<Integer>(4)); //依次出队 System.out.println(\\\"依次出队：\\\"); while (!lq.isNull()) { System.out.println(lq.pop().getData()); } } }\",\"运行结果：\",\"队列是否为空：true 依次出队： 1 2 3 4\"]},\"290\":{\"h\":\"栈的实现\"},\"291\":{\"h\":\"顺序栈\"},\"292\":{\"h\":\"链式栈\"},\"293\":{\"h\":\"栈、队列和线性表的应用\"},\"294\":{\"h\":\"基础排序\"},\"295\":{\"h\":\"排序的概念和分类\"},\"296\":{\"h\":\"直接插入排序、希尔排序和基数排序\"},\"297\":{\"h\":\"哈希表\"},\"298\":{\"h\":\"哈希表的构造\"},\"299\":{\"h\":\"哈希表的实现\"},\"300\":{\"h\":\"递归\"},\"301\":{\"h\":\"递归函数的执行过程\"},\"302\":{\"h\":\"折半查找、归并排序和快速排序\"},\"303\":{\"h\":\"广义表的定义、存储与实现\"},\"304\":{\"h\":\"二叉树\"},\"305\":{\"h\":\"二叉树的定义及其主要特征\"},\"306\":{\"h\":\"二叉树的实现，包括顺序和链式存储\"},\"307\":{\"h\":\"二叉树的遍历\"},\"308\":{\"h\":\"堆和堆排序\"},\"309\":{\"h\":\"二叉排序树\"},\"310\":{\"h\":\"二叉平衡树\"},\"311\":{\"h\":\"树和森林\"},\"312\":{\"h\":\"树的定义以及树的存储结构，包括双亲、双亲孩子和孩子兄弟表示法\"},\"313\":{\"h\":\"树和森林与二叉树的转换\"},\"314\":{\"h\":\"数和森林的遍历\"},\"315\":{\"h\":\"并查集\"},\"316\":{\"h\":\"B-树及其基本操作，B+树的基本概念\"},\"317\":{\"h\":\"图\"},\"318\":{\"h\":\"图的定义和基本概念\"},\"319\":{\"h\":\"图的实现，包括数组（邻接矩阵）和领接表表示法\"},\"320\":{\"h\":\"图的遍历\"},\"321\":{\"h\":\"图的典型应用\"},\"322\":{\"h\":\"最小生成树\"},\"323\":{\"h\":\"最短路径\"},\"324\":{\"h\":\"拓扑排序\"},\"325\":{\"h\":\"关键路径\"},\"326\":{\"c\":[\"数据结构\"]},\"327\":{\"c\":[\"数据结构\"]},\"328\":{\"h\":\"大白话讲解布隆过滤器（BloomFilter）\",\"t\":[\"阅读大概需要4\",\"封面图\",\"[toc]\",\"声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。\",\"本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub\",\"有任何问题都可以来谈谈，等你！\",\"微信公众号\"]},\"329\":{\"h\":\"JavaPub说\",\"t\":[\"布隆大家都知道吧，如果不知道没关系，介绍一下，E技能，坚不可摧\",\"坚不可摧 E 消耗法力：30/35/40/45/50冷却时间：18/16/14/12/10 布隆朝一个方向举起盾牌，持续3/3.25/3.5/3.75/4秒，并使来自目标\",\"英雄联盟布隆\",\"回忆完以上，下面继续\"]},\"330\":{\"h\":\"关于布隆过滤器\",\"t\":[\"布隆过滤器主要用来做去重操作。在对准确率要求不高的业务场景使用广泛。\",\"布隆过滤器的核心是：如果计算出有一个元素已存在，那么它可能存在，如果一个元素不存在，那么它一定不存在。\",\"简单来说，宁错杀三千，不放过一个。\",\"例如：长城防火墙有100亿个需要屏蔽的网站，计算机的每次请求都要经过防火墙的过滤判断请求URL是否在黑名单中，如果我们使用HashSet来实现过滤的话，我们假设每个URL的大小为64B，那么100亿个就至少需要大约640GB的内存空间，这显然是不符合实际情况的。\",\"到目前我使用比较多的是在数据采集中，url去重，邮箱中的垃圾邮件过滤等。\"]},\"331\":{\"h\":\"1.1.基础介绍\"},\"332\":{\"h\":\"1.1.1.百度百科\",\"t\":[\"百度百科：布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。\"]},\"333\":{\"h\":\"1.1.2.原理介绍\",\"t\":[\"布隆过滤器的原理和哈希表的原理有点类似，同样需要使用hash函数，但是在布隆过滤器中，需要使用多个hash函数。布隆过滤器的原理还是比较简单的。\",\"我们有一个位数组bitArray，假设长度为m，就是只存0、1那种。此时有个key，和n个hash函数，可以得到n个key被hash过后的数。我们分别取hash对应bitArray中位置的值，置位1。\",\"布隆过滤原理图\",\"如图 {x,y,z} 是一个集合，通过三次hash计算，映射对应的值到 位数组 对应位置。当我们要求 w 是否存在时，只要对w计算hash，再找对应位置是否为1即可。但是，也有可能正好hash值对应的 位数组 位置都为1，这个概念叫做误算率。实际上，这就和哈希表中哈希冲突的情况一样，因为可能会出现两个key值经过k个hash函数之后，取余之后的结果是一样的。\"]},\"334\":{\"h\":\"1.1.3.布隆过滤器的属性\",\"t\":[\"如果布隆过滤器判断数据不存在则数据绝对不存在。\",\"这个就是布隆过滤器的特点，数据先经过布隆过滤器，查询数据是否已经存在。如果布隆过滤器判断用户名不存在/或者存在，数据才能够继续向下走。\",\"在前面的判断中，可以判断数据绝对不存在，但是如果判断数据存在，则数据也可能不存在。\",\"布隆过滤器只能插入数据，而不能删除数据。\"]},\"335\":{\"h\":\"1.2.数学推导\",\"t\":[\"既然误算率一定存在，当然我们想减小误判到最小（key数量和bitArray长度确定）。\",\"数学公式\"]},\"336\":{\"h\":\"1.3.哈希\",\"t\":[\"读到这里我们对布隆过滤器有了一定了解，hash函数对 布隆过滤器 的优劣起了决定性作用。\",\"Hash参考百度百科：https://baike.baidu.com/item/hash/390310\",\"目标就是设计一种尽可能少碰撞的hash算法，尽可能让它平均分布到每一位。\"]},\"337\":{\"h\":\"2.1.Java版\",\"t\":[\"下面是一篇简单版本的布隆过滤器，使用了 java.util.BitSet\",\"package com.javapub.cache; import java.util.BitSet; /** * @author wangshiyu rodert JavaPub * @date 2020/5/26 15:23 * @description 一篇简单的布隆过滤器 */ public class BloomFilterSimple { private static final int SIZE = 1 << 24; private static BitSet bitSet = new BitSet(SIZE); private static Hash[] hashes = new Hash[5]; private static final int seeds[] = new int[]{3, 5, 7, 9, 11}; static { init(); } private static void init() { for (int i = 0; i < seeds.length; i++) { hashes[i] = new Hash(seeds[i]); } } private boolean add(String data) { for (Hash hash : hashes) { int hashCode = hash.getHash(data); bitSet.set(hashCode, true); } return true; } private boolean contains(String data) { boolean have = true; for (Hash hash : hashes) { have &= bitSet.get(hash.getHash(data)); } return have; } /** * 如果不存在就进行记录并返回false，如果存在了就返回true * * @param data * @return */ private boolean addIfNotExist(String data) { boolean contains = contains(data); if (contains) { return true; } else { add(data); return false; } } public static void main(String[] args) { String data = \\\"https://gitee.com/rodert\\\"; String data2 = \\\"https://gitee.com/rodert/JavaPub\\\"; BloomFilterSimple bloomFilterSimple = new BloomFilterSimple(); System.out.println(bloomFilterSimple.add(data)); System.out.println(bloomFilterSimple.contains(data)); System.out.println(bloomFilterSimple.addIfNotExist(data2)); System.out.println(bloomFilterSimple.contains(data2)); System.out.println(bitSet); } private static class Hash { private int seed = 0; private Hash(int seed) { this.seed = seed; } private int getHash(String string) { int val = 0; int len = string.length(); for (int i = 0; i < len; i++) { val = val * seed + string.charAt(i); } return val & (SIZE - 1); } } }\"]},\"338\":{\"h\":\"3.1.进阶一(参数定义)\"},\"339\":{\"h\":\"3.1.1.介绍\",\"t\":[\"如果你有兴趣了解更多，我们继续往下看\",\"前面写了一个简单的DEMO，位数组长度和误差率都是拍脑袋定的，这篇主要讲解如何定义合适的位数组长度，计算方式\",\"1.1.2.原理介绍\",\"我们有一个位数组bitArray，假设长度为m，就是只存0、1那种。此时有个key，和k个hash函数，可以得到k个key被hash过后的数。我们分别取hash对应bitArray中位置的值，置位1。\",\"布隆过滤原理图\",\"如图 {x,y,z} 是一个集合，通过三次hash计算，映射对应的值到 位数组 对应位置。当我们要求 w 是否存在时，只要对w计算hash，再找对应位置是否为1即可。但是，也有可能正好hash值对应的 位数组 位置都为1，这个概念叫做误算率。实际上，这就和哈希表中哈希冲突的情况一样，因为可能会出现两个key值经过k个hash函数之后，取余之后的结果是一样的。\",\"上面是我们在原理介绍讲到的，综上所述，我们需要多少个哈希函数，创建多长的bit数组比较合适，为了估算出k和m的值，在构造一个布隆过滤器时，需要传入两个参数，即可以接受的误判率fpp和元素总个数n（不一定完全精确）。至于参数估计的方法，有兴趣的同学可以参考维基英文页面，下面直接给出公式：\",\"布隆过滤器参数计算公式.jpg\",\"哈希函数的要求尽量满足平均分布，这样既降低误判发生的概率，又可以充分利用bit数组的空间；\",\"根据论文《Less Hashing, Same Performance: Building a Better Bloom Filter》提出的一个技巧，可以用2个哈希函数来模拟k个哈希函数，即gi(x) = h1(x) + ih2(x) ，其中0<=i<=k-1；\",\"在吴军博士的《数学之美》一书中展示了不同情况下的误判率，例如，假定一个元素用16位比特，8个哈希函数，那么假阳性的概率是万分之五，这已经相当小了。\"]},\"340\":{\"h\":\"3.1.2.Java实现\",\"t\":[\"计算 位数组长度\",\"n是准备存入数据数量，p是误判率。\",\"public static long optimalNumOfBits(long n, double p) { return (long)((double)(-n) * Math.log(p) / (Math.log(2.0D) * Math.log(2.0D))); }\",\"计算hash函数个数\",\"n是准备存入数据数量，m是bit数组长度。\",\"public static int optimalNumOfHashFunctions(long n, long m) { return Math.max(1, (int)Math.round((double)m / (double)n * Math.log(2.0D))); }\"]},\"341\":{\"h\":\"3.2.进阶二(redis版)\"},\"342\":{\"h\":\"3.2.1.介绍\",\"t\":[\"布隆过滤器自提出以后，很多开源工具中都对它进行了实现。如 Google 的 Guava 中。\",\"对于现在大趋势分布式架构，单机存到缓存肯定是适用场景有限，so，我们借助 redis。\",\"redis 数据类型 bit ，用法和上边一样，这里主要说关于动态扩容。\",\"扩容的核心就是在每次插入前判断当前 位数组 为1(jedis.bitcount)的个数比(/) 位数组总长度，超过50%，那么就新建一个 bit，布隆过滤器的核心思想。判断一个元素是否在集合中？可能在集合中 和 绝对不在集合中\"]},\"343\":{\"h\":\"3.2.2.Java代码\",\"t\":[\"由于篇幅过长，后面会在公众号单独发出\",\"布隆过滤器换包含：并行分区的布隆过滤器、稳定的布隆过滤器、可扩展的Bloom过滤器、空间布隆过滤器、衰减的布隆过滤器等。\",\"更多阅读阅读维基百科英文：https://en.wikipedia.org/wiki/Bloom_filter\"]},\"344\":{\"c\":[\"数据结构\"]},\"345\":{\"c\":[\"布隆过滤器\",\"redis\"]},\"346\":{\"h\":\"桶排序就是这么容易\",\"t\":[\"[toc]\",\"img\"]},\"347\":{\"h\":\"前言\",\"t\":[\"声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。\",\"本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub\",\"有任何问题都可以来谈谈 ！\",\"如果看上一篇**计数排序，你有没有这样疑问，当每个数据之间跨度过大(如从 0-2亿 数字中排序 20 个数)，就需要大量空间消耗。桶排序就是对计数排序**的改进。\"]},\"348\":{\"h\":\"1.桶排序(Bucket sort)\",\"t\":[\"百度百科:\",\"桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是 鸽巢排序 的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。\",\"继续 -->\",\"桶排序是**计数排序的升级版。它利用了函数的映射关系**，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：\",\"在额外空间充足的情况下，尽量增大桶的数量\",\"使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中\",\"同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。\",\"img\",\"桶排序是将待排序集合中处于同一个值域的元素存入同一个桶中，也就是根据元素值特性将集合拆分为多个区域，则拆分后形成的多个桶，从值域上看是处于有序状态的。对每个桶中元素进行排序，则所有桶中元素构成的集合是已排序的。\",\"快速排序是将集合拆分为两个值域，这里称为两个桶，再分别对两个桶进行排序，最终完成排序。桶排序则是将集合拆分为多个桶，对每个桶进行排序，则完成排序过程。两者不同之处在于，快排是在集合本身上进行排序，属于原地排序方式，且对每个桶的排序方式也是快排。桶排序则是提供了额外的操作空间，在额外空间上对桶进行排序，避免了构成桶过程的元素比较和交换操作，同时可以自主选择恰当的排序算法对桶进行排序。\"]},\"349\":{\"h\":\"2.原理\"},\"350\":{\"h\":\"2.1.关键\",\"t\":[\"元素值域的划分，也就是元素到桶的映射规则。映射规则需要根据待排序集合的元素分布特性进行选择，若规则设计的过于模糊、宽泛，则可能导致待排序集合中所有元素全部映射到一个桶上，则桶排序向比较性质排序算法演变。若映射规则设计的过于具体、严苛，则可能导致待排序集合中每一个元素值映射到一个桶上，则桶排序向计数排序方式演化。\",\"排序算法的选择，从待排序集合中元素映射到各个桶上的过程，并不存在元素的比较和交换操作，在对各个桶中元素进行排序时，可以自主选择合适的排序算法，桶排序算法的复杂度和稳定性，都根据选择的排序算法不同而不同。\"]},\"351\":{\"h\":\"2.2.算法过程\",\"t\":[\"根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数；\",\"遍历待排序集合，将每一个元素移动到对应的桶中；\",\"对每一个桶中元素进行排序，并移动到已排序集合中。\",\"步骤 3 中提到的已排序集合，和步骤 1、2 中的待排序集合是同一个集合。与计数排序不同，桶排序的步骤 2 完成之后，所有元素都处于桶中，并且对桶中元素排序后，移动元素过程中不再依赖原始集合，所以可以将桶中元素移动回原始集合即可。\",\"示意图\",\"元素分配到不同桶中：\",\"然后，元素在每个桶中排序：\",\"img\"]},\"352\":{\"h\":\"3.代码\",\"t\":[\"基于 Java 的代码，代码逻辑很好理解，使用到插入排序，如果不理解，点击传送。\",\"package utils; import java.util.Arrays; /** * @author wangshiyu rodert * @date 2020/6/21 15:13 * @description */ public class BucketSort { public static void main(String[] args) throws Exception { int[] array = {2, 1, 5, 3, 4}; BucketSort bucketSort = new BucketSort(); int[] sort = bucketSort.sort(array); System.out.println(Arrays.toString(sort)); } private static final InsertSort insertSort = new InsertSort(); public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return bucketSort(arr, 5); } private int[] bucketSort(int[] arr, int bucketSize) throws Exception { if (arr.length == 0) { return arr; } int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) { if (value < minValue) { minValue = value; } else if (value > maxValue) { maxValue = value; } } int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;//向下取整 + 1 int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i < arr.length; i++) { int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); } int arrIndex = 0; for (int[] bucket : buckets) { if (bucket.length <= 0) { continue; } // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) { arr[arrIndex++] = value; } } return arr; } /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrAppend(int[] arr, int value) { arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; } } class InsertSort { //插入排序 public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i < arr.length; i++) { // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j > 0 && tmp < arr[j - 1]) { arr[j] = arr[j - 1]; j--; } // 存在比其小的数，插入 if (j != i) { arr[j] = tmp; } } return arr; } }\",\"返回结果：\",\"[1, 2, 3, 4, 5]\",\"Arrays.copyOf() 方法理解：用于复制指定的数组内容以达到扩容的目的，该方法对不同的基本数据类型都有对应的重载方法。\"]},\"353\":{\"h\":\"4.扩展阅读\",\"t\":[\"真题：347. Top K Frequent Elements (Medium)，给定一个非空的整数数组，返回其中出现频率前 k 高的元素。\",\"Given a non-empty array of integers, return the k most frequent elements.\",\"题解：\",\"img\",\"//基于桶排序求解「前 K 个高频元素」 class Solution { public List<Integer> topKFrequent(int[] nums, int k) { List<Integer> res = new ArrayList(); // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值 HashMap<Integer,Integer> map = new HashMap(); for(int num : nums){ if (map.containsKey(num)) { map.put(num, map.get(num) + 1); } else { map.put(num, 1); } } //桶排序 //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标 List<Integer>[] list = new List[nums.length+1]; for(int key : map.keySet()){ // 获取出现的次数作为下标 int i = map.get(key); if(list[i] == null){ list[i] = new ArrayList(); } list[i].add(key); } // 倒序遍历数组获取出现顺序从大到小的排列 for(int i = list.length - 1;i >= 0 && res.size() < k;i--){ if(list[i] == null) continue; res.addAll(list[i]); } return res; } }\",\"桶排序就是这么容易\"]},\"354\":{\"c\":[\"数据结构\",\"排序\"]},\"355\":{\"c\":[\"数据结构\",\"排序\"]},\"356\":{\"h\":\"计数排序就是这么容易\",\"t\":[\"[toc]\",\"声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。\",\"本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub\",\"有任何问题都可以来谈谈 ！\",\"计数排序是比较容易的排序算法，但是对数量级较小的整数排序很实用。\"]},\"357\":{\"h\":\"1.1.计数排序(Counting Sort)\",\"t\":[\"计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为 Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。当然这是一种牺牲空间换取时间的做法，而且当 O(k)>O(n*log(n)) 的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n*log(n)), 如 归并排序，堆排序）\",\"例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。\",\"计数排序是一个简单的排序算法，看下边原理很容易理解。\"]},\"358\":{\"h\":\"2.1.步骤\",\"t\":[\"算法的步骤如下：\",\"找出待排序的数组中最大和最小的元素\",\"统计数组中每个值为i的元素出现的次数，存入数组C的第i项\",\"对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）\",\"反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1\",\"img\",\"如果有疑问，看下边一个例子\"]},\"359\":{\"h\":\"2.2.实例题目\",\"t\":[\"题目：数组里有20个随机数，取值范围为从0到10，要求用最快的速度把这20个整数从小到大进行排序。\",\"无论是归并排序，冒泡排序还是快速排序等等，都是基于元素之间的比较来进行排序的。但是有一种特殊的排序算法叫计数排序，这种排序算法不是基于元素比较，而是利用 数组下标 来确定元素的正确位置。\",\"通过计数排序特性分析题目，我们知道整数的取值范围是从0到10，那么这些整数的值肯定是在0到10这11个数里面。于是我们可以建立一个长度为11的数组，数组下标从0到10，元素初始值全为0，如下所示：\",\"img\",\"先假设20个随机整数的值是： 9, 3, 5, 4, 9, 1, 2, 7, 8，1，3, 6, 5, 3, 4, 0, 10, 9, 7, 9\",\"让我们先遍历这个无序的随机数组，每一个整数按照其值对号入座，对应数组下标的元素进行 加1 操作。\",\"比如第一个整数是 9，那么数组下标为 9 的元素加 1：\",\"img\",\"第二个整数是3，那么数组下标为 3 的元素加 1：\",\"img\",\"继续遍历数列并修改数组......\",\"最终，数列遍历完毕时，数组的状态如下：\",\"img\",\"数组中的每一个值，代表了数列中对应整数的出现次数。\",\"有了这个统计结果，排序就很简单了，直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次：\",\"0, 1, 1, 2, 3, 3, 3, 4, 4, 5, 5, 6, 7, 7, 8, 9, 9, 9, 9, 10\",\"这就是计数排序的基本过程，它适用于一定范围的整数排序。在取值范围不是很大的情况下，它的性能在某些情况甚至快过那些O(nlogn)的排序，例如快速排序、归并排序。\"]},\"360\":{\"h\":\"3.1.代码\",\"t\":[\"@Test public void sortJavaPub(){ int [] array = {2,1,5,3,4}; //1.得到数列的最大值 int max = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] > max) max = array[i]; } //2.根据数列的最大值确定统计数组的长度 int[] coutArray = new int[max + 1]; //3.遍历数列，填充统计数组 for(int i = 0; i < array.length; i++) coutArray[array[i]]++; //4.遍历统计数组，输出结果 int index = 0; int[] sortedArray = new int[array.length]; for (int i = 0; i < coutArray.length; i++) { for (int j = 0; j < coutArray[i]; j++) { sortedArray[index++] = i; } } System.out.println(Arrays.toString(sortedArray)); }\",\"返回结果：\",\"[1, 2, 3, 4, 5]\"]},\"361\":{\"h\":\"4.1.局限性\",\"t\":[\"1. 当数列最大最小值差距过大时，并不适用于计数排序\",\"比如给定20个随机整数，范围在0到1亿之间，此时如果使用计数排序的话，就需要创建长度为1亿的数组，不但严重浪费了空间，而且时间复杂度也随之升高。\",\"2. 当数列元素不是整数时，并不适用于计数排序\",\"如果数列中的元素都是小数，比如3.1415，或是0.00000001这样子，则无法创建对应的统计数组，这样显然无法进行计数排序。\"]},\"362\":{\"c\":[\"数据结构\",\"排序\"]},\"363\":{\"c\":[\"数据结构\",\"排序\"]},\"364\":{\"h\":\"堆排序就是这么容易\",\"t\":[\"声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。\",\"本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub\",\"有任何问题都可以来谈谈 ！\",\"堆排序在常用排序算法中属于比较难理解的，本篇就以最简单的方式讲解。如果还有什么疑问，\",\"弄清楚**以前，我们先要知道什么是**？\",\"堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。\",\"下图：\",\"简单用公式描述一下就是：\",\"大顶堆： arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]\",\"小顶堆： arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]\",\"问题二：什么是完全二叉树？\",\"百度百科:\",\"一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。\",\"百度百科:\",\"堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\",\"堆排序是利用这种数据结构而设计的一种排序算法，堆排序是一种，它的最坏，最好，平均均为O(nlogn)，它也是。\",\"堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了\",\"a.假设给定无序序列结构如下 b.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。 c.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。 d.这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。 此时，就将一个无需序列构造成了一个大顶堆。\",\"a.将堆顶元素9和末尾元素4进行交。 b.重新调整结构，使其继续满足堆定义。 c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8。 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序。 \",\"- 再简单总结下堆排序的基本思路：\",\"代码是基于 Java语言。\",\"package cn.javapub; import java.util.Arrays; public class HeapSort { public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; //构建大顶堆 buildMaxHeap(arr, len); //调整堆结构+交换堆顶元素与末尾元素 for (int i = len - 1; i > 0; i--) { swap(arr, 0, i);//将堆顶元素与末尾元素进行交换 len--; heapify(arr, 0, len);//重新对堆进行调整 } return arr; } private void buildMaxHeap(int[] arr, int len) { for (int i = (int) Math.floor(len / 2); i >= 0; i--) { //从第一个非叶子结点从下至上，从右至左调整结构 heapify(arr, i, len); } } //调整大顶堆 private void heapify(int[] arr, int i, int len) { int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left < len && arr[left] > arr[largest]) { largest = left; } if (right < len && arr[right] > arr[largest]) { largest = right; } if (largest != i) { swap(arr, i, largest); heapify(arr, largest, len); } } //交换元素 private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } public static void main(String[] args) throws Exception { int[] arr = {5, 1, 4, 2, 3}; HeapSort heapSort = new HeapSort(); int[] sort = heapSort.sort(arr); System.out.println(Arrays.toString(sort)); } }\",\"返回结果：\",\"[1, 2, 3, 3, 5]\",\"​ 堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。\"]},\"365\":{\"c\":[\"数据结构\",\"排序\"]},\"366\":{\"c\":[\"数据结构\",\"排序\"]},\"367\":{\"h\":\"基数排序就是这么容易\"},\"368\":{\"h\":\"前言\",\"t\":[\"欢迎关注公众号，白嫖原创PDF，也可以催更，微信搜：JavaPub\",\"[toc]\"]},\"369\":{\"h\":\"1.基数排序\"},\"370\":{\"h\":\"1.1.对比\",\"t\":[\"前面讲了计数排序、桶排序，那么它们有什么不同\",\"基数排序 vs 计数排序 vs 桶排序\",\"这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\",\"基数排序：根据键值的每位数字来分配桶；\",\"计数排序：每个桶只存储单一键值；\",\"桶排序：每个桶存储一定范围的数值；\"]},\"371\":{\"h\":\"1.2.基数排序\",\"t\":[\"百度百科：\",\"基数排序（radix sort）属于 “分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些 “桶” 中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为 O (nlog(r)m)，其中 r 为所采取的基数，而 m 为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。\"]},\"372\":{\"h\":\"1.3.特点\",\"t\":[\"时间复杂度为 O (nlog(r)m)，其中 r 为所采取的基数，而 m 为堆数。\",\"基数排序法是属于稳定性的排序。\"]},\"373\":{\"h\":\"2.原理\"},\"374\":{\"h\":\"2.1.实现原理\",\"t\":[\"基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机(Tabulation Machine)上的贡献。它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\",\"基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\"]},\"375\":{\"h\":\"2.2.步骤\",\"t\":[\"LSD 基数排序动图演示\",\"下面步骤介绍布局虽然不好看，但是非常有助于理解。\",\"第一步\",\"以 LSD 为例，假设原来有一串数值如下所示：\",\"73, 22, 93, 43, 55, 14, 28, 65, 39, 81\",\"首先根据个位数的数值，在走访数值时将它们分配至编号 0 到 9 的桶子中：\",\"0 1 81 2 22 3 73 93 43 4 14 5 55 65 6 7 8 28 9 39\",\"第二步\",\"接下来将这些桶子中的数值重新串接起来，成为以下的数列：\",\"81, 22, 73, 93, 43, 14, 55, 65, 28, 39\",\"接着再进行一次分配，这次是根据十位数来分配：\",\"0 1 14 2 22 28 3 39 4 43 5 55 6 65 7 73 8 81 9 93\",\"第三步\",\"接下来将这些桶子中的数值重新串接起来，成为以下的数列：\",\"14, 22, 28, 39, 43, 55, 65, 73, 81, 93\",\"这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。\",\"LSD 的基数排序适用于位数小的数列，如果位数多的话，使用 MSD 的效率会比较好。MSD 的方式与 LSD 相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。\"]},\"376\":{\"h\":\"3.代码\"},\"377\":{\"h\":\"3.1.Java 版\",\"t\":[\"代码基于 Java 语言\",\"package com.rodert.springbootes.test; import java.util.Arrays; /** * @author JavaPub rodert * @date 2020/6/28 20:46 * @description */ public class RadixSort { public static void sort(int[] number, int d) //d表示最大的数有多少位 { int k = 0; int n = 1; int m = 1; //控制键值排序依据在哪一位 int[][] temp = new int[10][number.length]; //数组的第一维表示可能的余数0-9 int[] order = new int[10]; //数组order[i]用来表示该位是i的数的个数 while (m <= d) { for (int value : number) { int lsd = ((value / n) % 10); temp[lsd][order[lsd]] = value; order[lsd]++; } for (int i = 0; i < 10; i++) { if (order[i] != 0) for (int j = 0; j < order[i]; j++) { number[k] = temp[i][j]; k++; } order[i] = 0; } n *= 10; k = 0; m++; } } public static void main(String[] args) { int[] data = {73, 22, 93, 43, 55, 14, 28, 65, 39, 81, 33, 100}; RadixSort.sort(data, 3); System.out.println(Arrays.toString(data)); } }\",\"返回结果：\",\"[14, 22, 28, 33, 39, 43, 55, 65, 73, 81, 93, 100]\",\" > 声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。 > 本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 > 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub > 有任何问题都可以来谈谈 ！\"]},\"378\":{\"c\":[\"数据结构\",\"排序\"]},\"379\":{\"c\":[\"数据结构\",\"排序\"]},\"380\":{\"h\":\"分布式唯一ID解决方案-雪花算法\",\"t\":[\"阅读大概需要3分钟\",\"附源码\",\"[toc]\",\"封面图\"]},\"381\":{\"h\":\"前言\",\"t\":[\"单体架构的服务的日子已经一去不复返了。\",\"当前系统业务和数据存储的复杂度都在提升，分布式系统是目前使用非常普遍的解决方案。\",\"全局唯一 ID 几乎是所有设计系统时都会遇到的，全局唯一 ID 在存储和检索中有至关重要的作用。\"]},\"382\":{\"h\":\"ID生成器\",\"t\":[\"在应用程序中，经常需要全局唯一的ID作为数据库主键。如何生成全局唯一ID？\",\"首先，需要确定全局唯一ID是整型还是字符串？如果是字符串，那么现有的UUID就完全满足需求，不需要额外的工作。缺点是字符串作为ID占用空间大，索引效率比整型低。\",\"如果采用整型作为ID，那么首先排除掉32位int类型，因为范围太小，必须使用64位long型。\",\"采用整型作为ID时，如何生成自增、全局唯一且不重复的ID？\"]},\"383\":{\"h\":\"数据库自增\",\"t\":[\"数据库自增 ID 是我们在数据量较小的系统中经常使用的，利用数据库的自增ID，从1开始，基本可以做到连续递增。Oracle可以用 SEQUENCE，MySQL可以用主键的 AUTO_INCREMENT，虽然不能保证全局唯一，但每个表唯一，也基本满足需求。\",\"数据库自增ID的缺点是数据在插入前，无法获得ID。数据在插入后，获取的ID虽然是唯一的，但一定要等到事务提交后，ID才算是有效的。有些双向引用的数据，不得不插入后再做一次更新，比较麻烦。\",\"在我们开发过程中，遇到一种 主主数据库同步（简单可以理解为，同样的sql再另一台数据库再执行一次）的场景，如果使用数据库自增 ID，就会出现主键不一致、或主键冲突问题。\"]},\"384\":{\"h\":\"分布式ID生成器\"},\"385\":{\"h\":\"方案一：UUID\",\"t\":[\"分布式环境不推荐使用\",\"uuid 是我们比较先想到的方法，在 java.util;包中就有对应方法。这是一个具有rfc标准的uuid：https://www.ietf.org/rfc/rfc4122.txt\",\"uuid 有很好的性能（本地调用），没有网络消耗。\",\"但是，uuid 不易存储（生成了字符串、存储过长、很多场景不适用）；信息不安全（基于 MAC 地址生成、可能会造成泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。 ）；无法保证递增（或趋势递增）；其他博主反馈，截取前20位做唯一 ID ，在大数量（大概只有220w）情况下会有重复问题。\",\"UUID.randomUUID().toString()\"]},\"386\":{\"h\":\"方案二：snowflake(雪花算法)\",\"t\":[\"这是目前使用较多分布式ID解决方案，推荐使用\",\"背景 Twitter 云云就不介绍了，就是前段时间封了懂王账号的 Twitter。\"]},\"387\":{\"h\":\"算法介绍\",\"t\":[\"SnowFlake算法生成id的结果是一个64bit大小的整数，它的结构如下图：\",\"snowflake-64bit\",\"1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0\",\"41位，用来记录时间戳（毫秒）。\",\"41位可以表示 2^{41}-1 个数字，\",\"如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 2^{41}-1，减1是因为可表示的数值范围是从0开始算的，而不是1。\",\"也就是说41位可以表示 2^{41}-1 个毫秒的值，转化成单位年则是 (2^{41}-1) / (1000 * 60 * 60 * 24 * 365) = 69 年\",\"10位，用来记录工作机器id。\",\"可以部署在 2^{10} = 1024 个节点，包括 5位 datacenterId 和 5位 workerId\",\"5位（bit）可以表示的最大正整数是 2^{5}-1 = 31 ，即可以用 0、1、2、3、....31 这 32 个数字，来表示不同的 datecenterId 或 workerId\",\"12位，序列号，用来记录同毫秒内产生的不同id。\",\"12位（bit）可以表示的最大正整数是 2^{12}-1 = 4095 ，即可以用 0、1、2、3、....4094 这 4095 个数字，来表示同一机器同一时间截（毫秒)内产生的 4095 个 ID 序号。\",\"由于在 Java 中 64bit 的整数是 long 类型，所以在 Java 中 SnowFlake 算法生成的 id 就是 long 来存储的。\",\"SnowFlake可以保证：\",\"同一台服务器所有生成的id按时间趋势递增\",\"整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分）\",\"存在的问题：\",\"机器ID（5位）和数据中心ID（5位）配置没有解决，分布式部署的时候会使用相同的配置，任然有ID重复的风险。\",\"使用的时候需要实例化对象，没有形成开箱即用的工具类。\",\"强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。（这点在正常情况下是不会发生的）\",\"针对上面问题，这里提供一种解决思路，workId 使用服务器 hostName 生成，dataCenterId 使用 IP 生成，这样可以最大限度防止 10 位机器码重复，但是由于两个 ID 都不能超过 32，只能取余数，还是难免产生重复，但是实际使用中，hostName 和 IP 的配置一般连续或相近，只要不是刚好相隔 32 位，就不会有问题，况且，hostName 和 IP 同时相隔 32 的情况更加是几乎不可能的事，平时做的分布式部署，一般也不会超过 10 台容器。\",\"生产上使用docker配置一般是一次编译，然后分布式部署到不同容器，不会有不同的配置。这种情况就对上面提到的出现了不确定情况，这个在评论中会再出一篇参考文章。\"]},\"388\":{\"h\":\"源码\",\"t\":[\"Java 版雪花ID生成算法\",\"package com.my.blog.website.utils; import org.apache.commons.lang3.RandomUtils; import org.apache.commons.lang3.StringUtils; import org.apache.commons.lang3.SystemUtils; import java.net.Inet4Address; import java.net.UnknownHostException; /** * Twitter_Snowflake<br> * SnowFlake的结构如下(每部分用-分开):<br> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br> * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0<br> * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69<br> * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId<br> * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号<br> * 加起来刚好64位，为一个Long型。<br> * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。 */ public class SnowflakeIdWorker { // ==============================Fields=========================================== /** 开始时间截 (2015-01-01) */ private final long twepoch = 1489111610226L; /** 机器id所占的位数 */ private final long workerIdBits = 5L; /** 数据标识id所占的位数 */ private final long dataCenterIdBits = 5L; /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private final long maxWorkerId = -1L ^ (-1L << workerIdBits); /** 支持的最大数据标识id，结果是31 */ private final long maxDataCenterId = -1L ^ (-1L << dataCenterIdBits); /** 序列在id中占的位数 */ private final long sequenceBits = 12L; /** 机器ID向左移12位 */ private final long workerIdShift = sequenceBits; /** 数据标识id向左移17位(12+5) */ private final long dataCenterIdShift = sequenceBits + workerIdBits; /** 时间截向左移22位(5+5+12) */ private final long timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits; /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */ private final long sequenceMask = -1L ^ (-1L << sequenceBits); /** 工作机器ID(0~31) */ private long workerId; /** 数据中心ID(0~31) */ private long dataCenterId; /** 毫秒内序列(0~4095) */ private long sequence = 0L; /** 上次生成ID的时间截 */ private long lastTimestamp = -1L; private static SnowflakeIdWorker idWorker; static { idWorker = new SnowflakeIdWorker(getWorkId(),getDataCenterId()); } //==============================Constructors===================================== /** * 构造函数 * @param workerId 工作ID (0~31) * @param dataCenterId 数据中心ID (0~31) */ public SnowflakeIdWorker(long workerId, long dataCenterId) { if (workerId > maxWorkerId || workerId < 0) { throw new IllegalArgumentException(String.format(\\\"workerId can't be greater than %d or less than 0\\\", maxWorkerId)); } if (dataCenterId > maxDataCenterId || dataCenterId < 0) { throw new IllegalArgumentException(String.format(\\\"dataCenterId can't be greater than %d or less than 0\\\", maxDataCenterId)); } this.workerId = workerId; this.dataCenterId = dataCenterId; } // ==============================Methods========================================== /** * 获得下一个ID (该方法是线程安全的) * @return SnowflakeId */ public synchronized long nextId() { long timestamp = timeGen(); //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp < lastTimestamp) { throw new RuntimeException( String.format(\\\"Clock moved backwards. Refusing to generate id for %d milliseconds\\\", lastTimestamp - timestamp)); } //如果是同一时间生成的，则进行毫秒内序列 if (lastTimestamp == timestamp) { sequence = (sequence + 1) & sequenceMask; //毫秒内序列溢出 if (sequence == 0) { //阻塞到下一个毫秒,获得新的时间戳 timestamp = tilNextMillis(lastTimestamp); } } //时间戳改变，毫秒内序列重置 else { sequence = 0L; } //上次生成ID的时间截 lastTimestamp = timestamp; //移位并通过或运算拼到一起组成64位的ID return ((timestamp - twepoch) << timestampLeftShift) | (dataCenterId << dataCenterIdShift) | (workerId << workerIdShift) | sequence; } /** * 阻塞到下一个毫秒，直到获得新的时间戳 * @param lastTimestamp 上次生成ID的时间截 * @return 当前时间戳 */ protected long tilNextMillis(long lastTimestamp) { long timestamp = timeGen(); while (timestamp <= lastTimestamp) { timestamp = timeGen(); } return timestamp; } /** * 返回以毫秒为单位的当前时间 * @return 当前时间(毫秒) */ protected long timeGen() { return System.currentTimeMillis(); } private static Long getWorkId(){ try { String hostAddress = Inet4Address.getLocalHost().getHostAddress(); int[] ints = StringUtils.toCodePoints(hostAddress); int sums = 0; for(int b : ints){ sums += b; } return (long)(sums % 32); } catch (UnknownHostException e) { // 如果获取失败，则使用随机数备用 return RandomUtils.nextLong(0,31); } } private static Long getDataCenterId(){ int[] ints = StringUtils.toCodePoints(SystemUtils.getHostName()); int sums = 0; for (int i: ints) { sums += i; } return (long)(sums % 32); } /** * 静态工具类 * * @return */ public static synchronized Long generateId(){ long id = idWorker.nextId(); return id; } //==============================Test============================================= /** 测试 */ public static void main(String[] args) { System.out.println(System.currentTimeMillis()); long startTime = System.nanoTime(); for (int i = 0; i < 50000; i++) { long id = SnowflakeIdWorker.generateId(); System.out.println(id); } System.out.println((System.nanoTime()-startTime)/1000000+\\\"ms\\\"); } }\",\"参考原文：https://blog.csdn.net/xiaopeng9275/article/details/72123709\",\"分享和在看是对我最大的鼓励。我是pub哥，我们下期见!\"]},\"389\":{\"c\":[\"数据结构\",\"雪花算法\"]},\"390\":{\"c\":[\"数据结构\"]},\"391\":{\"h\":\"ElasticSearch\"},\"392\":{\"c\":[\"elasticsearch\",\"springboot\"]},\"393\":{\"c\":[\"elasticsearch\",\"springboot\"]},\"394\":{\"h\":\"Springboot2.x整合ElasticSearch7.x实战（目录）\",\"t\":[\"本课程是实战课程，学习目标，在最短的时间学会使用elasticsearch7.x整合springboot。课程将在csdn学院上线。敬请期待\",\"@[toc]\",\"自我介绍\",\"elasticsearch springboot 介绍\",\"linux安装es，方法和要点\",\"es集群、初步配置和使用\",\"安装使用可视化工具插件head，Cerebro\",\"ik分词器插件安装\",\"拼音分词器插件安装\",\"自定义扩展词库\",\"Elasticsearch核心概念\",\"理解倒排索引\",\"例如倒排索引等内容\",\"mapping详解\",\"_source和_all字段解读\",\"https://blog.csdn.net/napoay/article/details/62233031\",\"搜索排序和高亮关键字\",\"https://blog.csdn.net/qq_38669394/article/details/87601992\",\"热加载组件，日志，api管理swagger，\",\"多环境配置\",\"新闻搜索页面设计\",\"新闻搜索结果页面设计\",\"索引构建\",\"CRUD新闻数据，批处理\",\"ES Java 进阶\",\"高亮，结果集分装，分页处理\",\"MySQL和Elasticsearch区别\",\"MySQL数据导入Elasticsearch搜索引擎\",\"搜索结果集展示\",\"搜索关键词高亮\",\"搜索结果优化排序和耗时处理\",\"搜索结果分页处理\",\"项目总结\",\"好事成双，这篇是附加篇，讲遇到的问题和难点\",\"在这里插入图片描述\",\"https://javapub.blog.csdn.net/category_8634753.html\"]},\"395\":{\"c\":[\"elasticsearch\",\"springboot\"]},\"396\":{\"c\":[\"elasticsearch\",\"springboot\"]},\"397\":{\"h\":\"Springboot2.x整合ElasticSearch7.x实战（一）\",\"t\":[\"学习一个新技术，最快的掌握方式就是先学会使用，让我们有了很强的满足感，在研究底层代码。\",\"本篇幅是继上一篇Springboot2.x整合ElasticSearch7.x实战目录，适合初学 Elasticsearch 的小白，可以跟着整个教程做一个练习。\",\"编者荐语：在大数据搜索中，Elasticsearch 使用频率非常高。学习 Java 了解大数据那是我们 Java 攻城狮很好的选择。\",\"[toc]\"]},\"398\":{\"h\":\"自我介绍\",\"t\":[\"大家好，我是pub哥\"]},\"399\":{\"h\":\"ElasticSearch SpringBoot 介绍\"},\"400\":{\"h\":\"ElasticSearch\",\"t\":[\"ElasticSearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库——无论是开源还是私有。\",\"ElasticSearch 使用 Java 编写的，它的内部使用的是 Lucene 做索引与搜索，它的目的是使全文检索变得简单，通过隐藏 Lucene 的复杂性，取而代之提供了一套简单一致的 RESTful API。\",\"然而，ElasticSearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎，它可以被下面这样准确地形容：\",\"一个分布式的实时文档存储，每个字段可以被索引与搜索\",\"一个分布式近实时分析搜索引擎\",\"能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据\",\"Elasticsearch 是与名为 Logstash 的数据收集和日志解析引擎以及名为 Kibana 的分析和可视化平台一起开发的。这三个产品被设计成一个集成解决方案，称为 “Elastic Stack” （以前称为“ELK stack”）。\"]},\"401\":{\"h\":\"SpringBoot\",\"t\":[\"Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。\",\"简单来说，使用 Spring Boot 可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用 Spring Boot 非常适合构建微服务。\"]},\"402\":{\"h\":\"环境介绍\",\"t\":[\"centOS 7.3 JDK1.8 及以上 ElasticSearch 7.*\"]},\"403\":{\"h\":\"服务器环境\",\"t\":[\"确保你的服务器安装了 jdk1.8 或以上版本环境\",\"Elasticsearch通过文件映射(mmap)来读取磁盘中的文件，这样可以比read系统调用少一次内存拷贝，也被称为0拷贝技术。ES映射的文件会很多，所以需要修改最大映射文件的数量，通过修改vm.max_map_count配置项可实现。设置方式\",\"文件最后添加一行 vim /etc/sysctl.conf vm.max_map_count=262144\",\"以上几点是环境搭建的基础\"]},\"404\":{\"h\":\"Linux安装JDK\",\"t\":[\"es 最小支持 jdk 版本是 jdk8\"]},\"405\":{\"h\":\"Linux安装es，方法和要点\",\"t\":[\"国内版本镜像页：https://mirrors.huaweicloud.com/elasticsearch/\",\"下载：\",\"wget https://mirrors.huaweicloud.com/elasticsearch/7.7.0/elasticsearch-7.7.0-linux-x86_64.tar.gz\",\"解压：\",\"tar -zxvf elasticsearch-7.7.0-linux-x86_64.tar.gz\"]},\"406\":{\"h\":\"es集群、初步配置和使用\",\"t\":[\"设置堆内存，修改 jvm.options ，学习阶段初学者 200m 即可，示例如下。 -Xms200m -Xmx200m\",\"在启动前，先修改配置文件， config/elasticsearch.yml\",\"贴一下全部配置（ip地址是服务器对外访问地址）：\",\"cluster.name: my-application node.name: node01 node.master: true node.data: true #bootstrap.memory_lock: false #bootstrap.system_call_filter: false network.host: 0.0.0.0 http.port: 9200 transport.tcp.port: 9300 http.cors.enabled: true http.cors.allow-origin: \\\"*\\\" # 集群发现:配置该节点会与哪些候选地址进行通信，默认端口9300，可填ip;ip+port;域名 discovery.seed_hosts: [\\\"39.12.1.1\\\"] # cluster.initial_master_nodes: [\\\"39.12.1.1\\\"] discovery.zen.minimum_master_nodes: 1 #http.cors.allow-headers: Authorization #xpack.security.enabled: true #xpack.security.transport.ssl.enabled: true\"]},\"407\":{\"h\":\"启动：\",\"t\":[\"./bin/elasticsearch\",\"到此为止，单机版本已搭建完成。访问下面地址，可以看到我们的es版本信息。 http://ip+9200/\"]},\"408\":{\"h\":\"安装使用可视化工具插件head，Cerebro\",\"t\":[\"这里只介绍 cerebro 安装\",\"下载：\",\"wget https://github.com/lmenezes/cerebro/releases/download/v0.6.5/cerebro-0.6.5.tgz\",\"解压：\",\"tar zxvf cerebro-0.6.5.tgz\",\"启动：\",\"cd cerebro-0.6.5 bin/cerebro\",\"cerebro\",\"在看和分享是对我最大的鼓励，我是 pub 哥，我们下期再见\",\"财经相关： 有色趋势很不错，不懂的同学建议不要交太多学费。\"]},\"409\":{\"c\":[\"elasticsearch\",\"springboot\"]},\"410\":{\"c\":[\"elasticsearch\",\"springboot\"]},\"411\":{\"h\":\"Springboot2.x整合ElasticSearch7.x实战（二）\",\"t\":[\"本教程是系列教程，对于初学者可以对 ES 有一个整体认识和实践实战。\",\"还没开始的同学，建议先读一下系列攻略目录：Springboot2.x整合ElasticSearch7.x实战目录\",\"本篇幅是继上一篇 Springboot2.x整合ElasticSearch7.x实战（一） ，适合初学 Elasticsearch 的小白，可以跟着整个教程做一个练习。\",\"使用搜索，少不了使用分词器，elasticsearch 自带了一些简单分词器，也可以使用第三方分词器插件，如 ik、pinyin 等。\",\"Standard Analyzer - 默认分词器，按词切分，小写处理 Simple Analyzer - 按照非字母切分(符号被过滤), 小写处理 Stop Analyzer - 小写处理，停用词过滤(the,a,is) Whitespace Analyzer - 按照空格切分，不转小写 Keyword Analyzer - 不分词，直接将输入当作输出 Patter Analyzer - 正则表达式，默认\\\\W+(非字符分割) Language - 提供了30多种常见语言的分词器 Customer Analyzer 自定义分词器\"]},\"412\":{\"h\":\"ik分词器插件安装\",\"t\":[\"下载和elasticsearch版本一致\",\"教程使用的是 7.7.0 版本。\",\"准备 ik 目录，\",\"cd plugins && mkdir ik\",\"下载\",\"wget https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.7.0/elasticsearch-analysis-ik-7.7.0.zip 有些地方从github下载网络不好，我在课件里有插件压缩包。\",\"解压到对应ik目录\",\"解压文件到目录 elasticsearch-7.7.0/plugins/ik 下。\",\"重启es，查看是否安装成功\",\"curl http://localhost:9200/_cat/plugins\",\"rest 实例：\"]},\"413\":{\"h\":\"拼音分词器插件安装\",\"t\":[\"下载和elasticsearch版本一致\",\"教程使用的是 7.7.0 版本。\",\"准备 ik 目录，\",\"cd plugins && mkdir pinyin\",\"下载\",\"wget https://github.com/medcl/elasticsearch-analysis-pinyin/archive/v7.7.0.zip 有些地方从github下载网络不好，我在课件放了插件的压缩包。\",\"解压到对应pinyin目录\",\"解压文件到目录 elasticsearch-7.7.0/plugins/pinyin 下。\",\"重启es，查看是否安装成功\",\"curl http://localhost:9200/_cat/plugins\",\"安装目录截图\"]},\"414\":{\"h\":\"更多扩展词库\",\"t\":[\"同义词词库\",\"https://github.com/ginobefun/elasticsearch-dynamic-synonym/releases\",\"有些情况会使用我们自己的分词服务，后面代码中会讲解使用方式。\"]},\"415\":{\"h\":\"Elasticsearch核心概念-相关术语解析\"},\"416\":{\"h\":\"Cluster\",\"t\":[\"Elasticsearch 集群，由一台或多台的Elasticsearch 节点(Node)组成。\"]},\"417\":{\"h\":\"Node\",\"t\":[\"Elasticsearch 节点，可以认为是Elasticsearch的服务进程，在同一台机器上启动两个Elasticsearch实例(进程)，就是两个node节点。\"]},\"418\":{\"h\":\"Index\",\"t\":[\"索引，具有相同结构的文档的集合，类似于关系型数据库的数据库实例（6.0.0版本type废弃后，索引的概念下降到等同于数据库表的级别）。一个集群中可以有多个索引。\"]},\"419\":{\"h\":\"Type\",\"t\":[\"类型，在索引中内进行逻辑细分，在新版的Elasticsearch中已经废弃。\",\"关于 type 废弃问题，如果你需要维护低版本 elasticsearch（在7.0.0、6.*、5.6版本变化较大），一定要阅读这篇官方英文文档 https://www.elastic.co/guide/en/elasticsearch/reference/current/removal-of-types.html\"]},\"420\":{\"h\":\"Document\",\"t\":[\"文档，Elasticsearch中的最小的数据存储单元，JSON数据格式，很多相同结构的文档组成索引。文档类似于关系型数据库中表内的一行记录。\",\"举个例子，一篇新闻的文档数据。\",\"news document { \\\"id\\\":\\\"1\\\", \\\"title\\\":\\\"China is a great country\\\", \\\"content\\\":\\\"I love China.\\\" }\"]},\"421\":{\"h\":\"Shard\",\"t\":[\"分片，单个索引切分成多个shard，分布在多台Node节点上存储。可以利用shard很好的横向扩展，以存储更多的数据，同时shard分布在多台node上，可以提升集群整体的吞吐量和性能。在创建索引的时候可以直接指定分片的数量即可，一旦指定就不能再修改了。\"]},\"422\":{\"h\":\"Replica\",\"t\":[\"索引副本，完全拷贝shard的内容，一个shard可以有一个或者多个replica，replica就是shard的数据拷贝，以提高冗余。\",\"replica承担三个任务：\",\"shard故障或者node宕机时，其中的一个replica可以升级成shard\",\"replica保证数据不丢失，保证高可用\",\"replica可以分担搜索请求，提高集群的吞吐和性能\",\"shard 的全称叫 primary shard，replica 全称叫 replica shard，primary shard 数量在创建索引时指定，后期不能修改，replica shard 后期可以修改。默认每个索引的 primary shard 值为5，replica shard 值为1，含义是5个primary shard，5个 replica shard，共10个 shard。因此 Elasticsearch 最小的高可用配置是2台服务器。\"]},\"423\":{\"h\":\"理解倒排索引\",\"t\":[\"例如倒排索引等内容\"]},\"424\":{\"h\":\"倒排索引相关术语\",\"t\":[\"倒排索引（Inverted Index）是整个搜索的核心，倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。\",\"单词词典(Lexicon)：常索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。\",\"倒排列表(PostingList)：倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。\",\"倒排文件(Inverted File)：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件即被称之为倒排文件，倒排文件是存储倒排索引的物理文件。\",\"概念关系：\"]},\"425\":{\"h\":\"简单倒排索引实例\",\"t\":[\"倒排索引从逻辑结构和基本思路上来讲非常简单。下面我们通过具体实例来进行说明，使得大家能够对倒排索引有一个宏观而直接的感受。\",\"假设有五个文档：\",\"通过分词后，每个文档就转换为由单词序列构成的数据流，为了系统后续处理方便，需要对每个不同的单词赋予唯一的单词编号，同时记录下哪些文档包含这个单词，在如此处理结束后，我们可以得到最简单的倒排索引。\",\"事实上，索引系统还可以记录除此之外的更多信息。下图是一个相对复杂些的倒排索引，与上图的基本索引系统比，在单词对应的倒排列表中不仅记录了文档编号，还记载了单词频率信息（TF），即这个单词在某个文档中的出现次数，之所以要记录这个信息，是因为词频信息在搜索结果排序时，计算查询和文档相似度是很重要的一个计算因子，所以将其记录在倒排列表中，以方便后续排序时进行分值计算。\",\"最后，实用的倒排索引还可以记载更多的信息，上图所示索引系统除了记录文档编号和单词频率信息外，额外记载了两类信息，即每个单词对应的“文档频率信息”（以及在倒排列表中记录单词在某个文档出现的位置信息。\",\"“文档频率信息”代表了在文档集合中有多少个文档包含某个单词，之所以要记录这个信息，其原因与单词频率信息一样，这个信息在搜索结果排序计算中是非常重要的一个因子。而单词在某个文档中出现的位置信息并非索引系统一定要记录的，在实际的索引系统里可以包含，也可以选择不包含这个信息，之所以如此，因为这个信息对于搜索系统来说并非必需的，位置信息只有在支持“短语查询”的时候才能够派上用场。\",\"参考：https://blog.csdn.net/hguisu/article/details/7969757\",\"微信搜：JavaPub\",\"在看和分享是对我最大的鼓励，我是 pub 哥，我们下期再见\"]},\"426\":{\"c\":[\"elasticsearch\",\"springboot\"]},\"427\":{\"c\":[\"elasticsearch\",\"springboot\"]},\"428\":{\"h\":\"Springboot2.x整合ElasticSearch7.x实战（三）\",\"t\":[\"大概阅读10分钟\",\"本教程是系列教程，对于初学者可以对 ES 有一个整体认识和实践实战。\",\"还没开始的同学，建议先读一下系列攻略目录：Springboot2.x整合ElasticSearch7.x实战目录\",\"本篇幅是继上一篇 Springboot2.x整合ElasticSearch7.x实战（二） ，适合初学 Elasticsearch 的小白，可以跟着整个教程做一个练习。\",\"[toc]\",\"Mapping 是整个 ES 搜索引擎中最重要的一部分之一，学会构建一个好的索引，可以让我们的搜索引擎更高效，更节省资源。\"]},\"429\":{\"h\":\"什么是 Mapping?\",\"t\":[\"Mapping 是Elasticsearch 中一种术语， Mapping 类似于数据库中的表结构定义 schema，它有以下几个作用：\",\"1. 定义索引中的字段的名称 2. 定义字段的数据类型，比如字符串、数字、布尔 3. 字段，倒排索引的相关配置，比如设置某个字段为不被索引、记录 position(位置) 等 \",\"在 ES 早期版本，一个索引下是可以有多个 Type ，从 7.0 开始，一个索引只有一个 Type，也可以说一个 Type 有一个 Mapping 定义。\",\"了解了什么是 Mapping 后，接下来对 Mapping 的设置坐下介绍：\"]},\"430\":{\"h\":\"Maping设置\"},\"431\":{\"h\":\"dynamic (动态Mapping)\",\"t\":[\"官网参考：https://www.elastic.co/guide/en/elasticsearch/reference/7.1/mapping.html\",\"PUT users { \\\"mappings\\\": { \\\"_doc\\\": { \\\"dynamic\\\": false } } }\",\"在创建一个索引的时候，可以对 dynamic 进行设置，可以设成 false、true 或者 strict。\",\"dynamic参数设置\",\"比如一个新的文档，这个文档包含一个字段，当 Dynamic 设置为 true 时，这个文档可以被索引进 ES，这个字段也可以被索引，也就是这个字段可以被搜索，Mapping 也同时被更新；当 dynamic 被设置为 false 时候，存在新增字段的数据写入，该数据可以被索引，但是新增字段被丢弃；当设置成 strict 模式时候，数据写入直接出错。\"]},\"432\":{\"h\":\"index\",\"t\":[\"另外还有 index 参数，用来控制当前字段是否被索引，默认为 true，如果设为 false（有些业务场景，某些字段不希望被搜索到），则该字段不可被搜索。\",\"# index属性控制 字段是否可以被索引 PUT user_test { \\\"mappings\\\": { \\\"properties\\\": { \\\"firstName\\\":{ \\\"type\\\": \\\"text\\\" }, \\\"lastName\\\":{ \\\"type\\\": \\\"text\\\" }, \\\"mobile\\\" :{ \\\"type\\\": \\\"text\\\", \\\"index\\\": false } } } }\"]},\"433\":{\"h\":\"index_options\",\"t\":[\"index_options\",\"参数 index_options 用于控制倒排索引记录的内容，有如下 4 种配置：\",\"doc：只记录 doc id\",\"freqs：记录 doc id 和 term frequencies\",\"positions：记录 doc id、term frequencies 和 term position\",\"offsets：记录 doc id、term frequencies、term position 和 character offects\",\"另外，text 类型默认配置为 positions，其他类型默认为 doc，记录内容越多，占用存储空间越大。\"]},\"434\":{\"h\":\"null_value\",\"t\":[\"null_value 主要是当字段遇到 null 值时的处理策略，默认为 NULL，即空值，此时 ES 会默认忽略该值，可以通过设定该值设定字段的默认值，另外只有 KeyWord 类型支持设定 null_value。\",\"示例\",\"# 设定Null_value DELETE users PUT users { \\\"mappings\\\" : { \\\"properties\\\" : { \\\"firstName\\\" : { \\\"type\\\" : \\\"text\\\" }, \\\"lastName\\\" : { \\\"type\\\" : \\\"text\\\" }, \\\"mobile\\\" : { \\\"type\\\" : \\\"keyword\\\", \\\"null_value\\\": \\\"NULL\\\" } } } } PUT users/_doc/1 { \\\"firstName\\\":\\\"Zhang\\\", \\\"lastName\\\": \\\"Fubing\\\", \\\"mobile\\\": null } PUT users/_doc/2 { \\\"firstName\\\":\\\"Zhang\\\", \\\"lastName\\\": \\\"Fubing2\\\" } # 查看结果，有且仅有_id为2的记录 GET users/_search { \\\"query\\\": { \\\"match\\\": { \\\"mobile\\\":\\\"NULL\\\" } } }\"]},\"435\":{\"h\":\"_all\",\"t\":[\"这个属性现在使用很少，不做深入讲解\",\"参考官网：https://www.elastic.co/guide/cn/elasticsearch/guide/current/root-object.html\"]},\"436\":{\"h\":\"copy_to\",\"t\":[\"这个属性用于将当前字段拷贝到指定字段。\",\"_all在7.x版本已经被copy_to所代替\",\"可用于满足特定场景\",\"copy_to将字段数值拷贝到目标字段，实现类似_all的作用\",\"copy_to的目标字段不出现在_source中\",\"DELETE users PUT users { \\\"mappings\\\": { \\\"properties\\\": { \\\"firstName\\\":{ \\\"type\\\": \\\"text\\\", \\\"copy_to\\\": \\\"fullName\\\" }, \\\"lastName\\\":{ \\\"type\\\": \\\"text\\\", \\\"copy_to\\\": \\\"fullName\\\" } } } } PUT users/_doc/1 { \\\"firstName\\\":\\\"Li\\\", \\\"lastName\\\": \\\"Sunke\\\" } //没有新建字段 GET users/_doc/1 { \\\"_index\\\" : \\\"users\\\", \\\"_type\\\" : \\\"_doc\\\", \\\"_id\\\" : \\\"1\\\", \\\"_version\\\" : 1, \\\"_seq_no\\\" : 0, \\\"_primary_term\\\" : 1, \\\"found\\\" : true, \\\"_source\\\" : { \\\"firstName\\\" : \\\"Li\\\", \\\"lastName\\\" : \\\"Sunke\\\" } } GET users/_search?q=fullName:(Li sunke)\",\"以前的用法是：\",\"curl -XPUT 'localhost:9200/my_index?pretty' -H 'Content-Type: application/json' -d' { \\\"mappings\\\": { \\\"my_type\\\": { \\\"properties\\\": { \\\"first_name\\\": { \\\"type\\\": \\\"text\\\", \\\"copy_to\\\": \\\"full_name\\\" # 1 }, \\\"last_name\\\": { \\\"type\\\": \\\"text\\\", \\\"copy_to\\\": \\\"full_name\\\" # 2 }, \\\"full_name\\\": { \\\"type\\\": \\\"text\\\" } } } } } ' curl -XPUT 'localhost:9200/my_index/my_type/1?pretty' -H 'Content-Type: application/json' -d' { \\\"first_name\\\": \\\"John\\\", \\\"last_name\\\": \\\"Smith\\\" } ' curl -XGET 'localhost:9200/my_index/_search?pretty' -H 'Content-Type: application/json' -d' { \\\"query\\\": { \\\"match\\\": { \\\"full_name\\\": { # 3 \\\"query\\\": \\\"John Smith\\\", \\\"operator\\\": \\\"and\\\" } } } } '\",\"first_name（名字）和 last_name（姓氏）字段复制到full_name 字段；\",\"first_name（名字）和 last_name（姓氏）字段仍然可以分别查询；\",\"full_name 可以通过 first_name（名字）和 last_name（姓氏）来查询；\",\"一些要点:\",\"复制的是字段值,而不是 term（词条）（由分析过程产生）.\",\"_source 字段不会被修改来显示复制的值.\",\"相同的值可以复制到多个字段,通过 \\\"copy_to\\\": [ \\\"field_1\\\", \\\"field_2\\\" ] 来操作.\"]},\"437\":{\"h\":\"分词器analyzer和arch_analyzer\",\"t\":[\"PUT /my_index { \\\"mappings\\\": { \\\"properties\\\": { \\\"text\\\": { \\\"type\\\": \\\"text\\\", \\\"fields\\\": { \\\"english\\\": { \\\"type\\\": \\\"text\\\", \\\"analyzer\\\": \\\"english\\\", \\\"search_analyzer\\\": \\\"english\\\" } } } } } } #使用_analyze 测试分词器 GET my_index/_analyze { \\\"field\\\": \\\"text\\\", \\\"text\\\": \\\"The quick Brown Foxes.\\\" } GET my_index/_analyze { \\\"field\\\": \\\"text.english\\\", \\\"text\\\": \\\"The quick Brown Foxes.\\\" }\"]},\"438\":{\"h\":\"构建Mapping方式\",\"t\":[\"我们知道 Mapping 是可以通过我们插入的文档自动生成索引，但是可能还是有一些问题。例如：生成的字段类型不正确，字段的附加属性不满足我们的需求。这是我们可以通过显式Mapping的方式来解决。俩种方法：\",\"参考官网api，纯手写\",\"构建临时索引；写入一些样本数据；通过Maping API 查询临时文件的动态Mapping 定义；修改后、再使用此配置创建索引；删除临时索引；\",\"推荐第二种，不容易出错，效率高。\"]},\"439\":{\"h\":\"类型自动识别\",\"t\":[\"ES 类型的自动识别是基于 JSON 的格式，如果输入的是 JSON 是字符串且格式为日期格式，ES 会自动设置成 Date 类型；当输入的字符串是数字的时候，ES 默认会当成字符串来处理，可以通过设置来转换成合适的类型；如果输入的是 Text 字段的时候，ES 会自动增加 keyword 子字段，还有一些自动识别如下图所示：\",\"类型自动识别字段对应表\",\"Demo：\",\"# 写入文档，查看 Mapping PUT mapping_test/_doc/1 { \\\"firstName\\\": \\\"Chan\\\", -- Text \\\"lastName\\\": \\\"Jackie\\\", -- Text \\\"loginDate\\\": \\\"2018-07-24T10:29:48.103Z\\\" -- Date } # Dynamic Mapping，推断字段的类型 PUT mapping_test/_doc/1 { \\\"uid\\\": \\\"123\\\", -- Text \\\"isVip\\\": false, -- Boolean \\\"isAdmin\\\": \\\"true\\\", -- Text \\\"age\\\": 19, -- Long \\\"heigh\\\": 180 -- Long } # 查看 Dynamic Mapping GET mapping_test/_mapping\"]},\"440\":{\"h\":\"映射参数\",\"t\":[\"映射参数解析\",\"mappings 中field定义选择：\",\"\\\"field\\\": { \\\"type\\\": \\\"text\\\", //文本类型 \\\"index\\\": \\\"false\\\"// ，设置成false，字段将不会被索引 \\\"analyzer\\\":\\\"ik\\\"//指定分词器 \\\"boost\\\":1.23//字段级别的分数加权 \\\"doc_values\\\":false//对not_analyzed字段，默认都是开启，analyzed字段不能使用，对排序和聚合能提升较大性能，节约内存,如果您确定不需要对字段进行排序或聚合，或者从script访问字段值，则可以禁用doc值以节省磁盘空间： \\\"fielddata\\\":{\\\"loading\\\" : \\\"eager\\\" }//Elasticsearch 加载内存 fielddata 的默认行为是 延迟 加载 。 当 Elasticsearch 第一次查询某个字段时，它将会完整加载这个字段所有 Segment 中的倒排索引到内存中，以便于以后的查询能够获取更好的性能。 \\\"fields\\\":{\\\"keyword\\\": {\\\"type\\\": \\\"keyword\\\",\\\"ignore_above\\\": 256}} //可以对一个字段提供多种索引模式，同一个字段的值，一个分词，一个不分词 \\\"ignore_above\\\":100 //超过100个字符的文本，将会被忽略，不被索引 \\\"include_in_all\\\":ture//设置是否此字段包含在_all字段中，默认是true，除非index设置成no选项 \\\"index_options\\\":\\\"docs\\\"//4个可选参数docs（索引文档号） ,freqs（文档号+词频），positions（文档号+词频+位置，通常用来距离查询），offsets（文档号+词频+位置+偏移量，通常被使用在高亮字段）分词字段默认是position，其他的默认是docs \\\"norms\\\":{\\\"enable\\\":true,\\\"loading\\\":\\\"lazy\\\"}//分词字段默认配置，不分词字段：默认{\\\"enable\\\":false}，存储长度因子和索引时boost，建议对需要参与评分字段使用 ，会额外增加内存消耗量 \\\"null_value\\\":\\\"NULL\\\"//设置一些缺失字段的初始化值，只有string可以使用，分词字段的null值也会被分词 \\\"position_increament_gap\\\":0//影响距离查询或近似查询，可以设置在多值字段的数据上火分词字段上，查询时可指定slop间隔，默认值是100 \\\"store\\\":false//是否单独设置此字段的是否存储而从_source字段中分离，默认是false，只能搜索，不能获取值 \\\"search_analyzer\\\":\\\"ik\\\"//设置搜索时的分词器，默认跟ananlyzer是一致的，比如index时用standard+ngram，搜索时用standard用来完成自动提示功能 \\\"similarity\\\":\\\"BM25\\\"//默认是TF/IDF算法，指定一个字段评分策略，仅仅对字符串型和分词类型有效 \\\"term_vector\\\":\\\"no\\\"//默认不存储向量信息，支持参数yes（term存储），with_positions（term+位置）,with_offsets（term+偏移量），with_positions_offsets(term+位置+偏移量) 对快速高亮fast vector highlighter能提升性能，但开启又会加大索引体积，不适合大数据量用 }\",\"总结一下：\",\"与域数据格式及约束相关的参数：normalizer，format，ignore_above，ignore_malformed，coerce\",\"与索引相关的参数：index，dynamic，enabled\",\"与存储策略相关的参数：store, fielddata，doc_values\",\"分析器相关参数：analyzer，search_analyzer\",\"其它参数：boost，copy_to，null_value\",\"对于这些参数的描述主要基于笔者的理解，可能有不准确之处。实际上这些参数与ES的实现机制（如存储结构，索引结构密切有关），只能在实际应用中去慢慢体会。\"]},\"441\":{\"h\":\"字段数据类型\",\"t\":[\"ES 字段类型类似于 MySQL 中的字段类型，ES 字段类型主要有：核心类型、复杂类型、地理类型以及特殊类型，具体的数据类型如下图所示：\",\"es字段数据类型\"]},\"442\":{\"h\":\"核心类型\",\"t\":[\"从图中可以看出核心类型可以划分为字符串类型、数字类型、日期类型、布尔类型、基于 BASE64 的二进制类型、范围类型。\"]},\"443\":{\"h\":\"字符串类型\",\"t\":[\"其中，在 ES 7.x 有两种字符串类型：text 和 keyword，在 ES 5.x 之后 string 类型已经不再支持了。\",\"text 类型适用于需要被全文检索的字段，例如新闻正文、邮件内容等比较长的文字，text 类型会被 Lucene 分词器（Analyzer）处理为一个个词项，并使用 Lucene 倒排索引存储，text 字段不能被用于排序，如果需要使用该类型的字段只需要在定义映射时指定 JSON 中对应字段的 type 为 text。\",\"keyword 适合简短、结构化字符串，例如主机名、姓名、商品名称等，可以用于过滤、排序、聚合检索，也可以用于精确查询。\"]},\"444\":{\"h\":\"数字类型\",\"t\":[\"数字类型分为 long、integer、short、byte、double、float、half_float、scaled_float。\",\"数字类型的字段在满足需求的前提下应当尽量选择范围较小的数据类型，字段长度越短，搜索效率越高，对于浮点数，可以优先考虑使用 scaled_float 类型，该类型可以通过缩放因子来精确浮点数，例如 12.34 可以转换为 1234 来存储。\"]},\"445\":{\"h\":\"日期类型\",\"t\":[\"在 ES 中日期可以为以下形式：\",\"格式化的日期字符串，例如 2020-03-17 00:00、2020/03/17 时间戳（和 1970-01-01 00:00:00 UTC 的差值），单位毫秒或者秒 即使是格式化的日期字符串，ES 底层依然采用的是时间戳的形式存储。\"]},\"446\":{\"h\":\"布尔类型\",\"t\":[\"JSON 文档中同样存在布尔类型，不过 JSON 字符串类型也可以被 ES 转换为布尔类型存储，前提是字符串的取值为 true 或者 false，布尔类型常用于检索中的过滤条件。\"]},\"447\":{\"h\":\"二进制类型\",\"t\":[\"二进制类型 binary 接受 BASE64 编码的字符串，默认 store 属性为 false，并且不可以被搜索。\"]},\"448\":{\"h\":\"范围类型\",\"t\":[\"范围类型可以用来表达一个数据的区间，可以分为5种：integer_range、float_range、long_range、double_range 以及 date_range。\"]},\"449\":{\"h\":\"复杂类型\",\"t\":[\"复合类型主要有对象类型（object）和嵌套类型（nested）：\"]},\"450\":{\"h\":\"对象类型\",\"t\":[\"JSON 字符串允许嵌套对象，一个文档可以嵌套多个、多层对象。可以通过对象类型来存储二级文档，不过由于 Lucene 并没有内部对象的概念，ES 会将原 JSON 文档扁平化，例如文档：\",\"{ \\\"name\\\": { \\\"first\\\": \\\"wu\\\", \\\"last\\\": \\\"px\\\" } }\",\"实际上 ES 会将其转换为以下格式，并通过 Lucene 存储，即使 name 是 object 类型：\",\"{ \\\"name.first\\\": \\\"wu\\\", \\\"name.last\\\": \\\"px\\\" }\"]},\"451\":{\"h\":\"嵌套类型\",\"t\":[\"嵌套类型可以看成是一个特殊的对象类型，可以让对象数组独立检索，例如文档：\",\"{ \\\"group\\\": \\\"users\\\", \\\"username\\\": [ { \\\"first\\\": \\\"wu\\\", \\\"last\\\": \\\"px\\\"}, { \\\"first\\\": \\\"hu\\\", \\\"last\\\": \\\"xy\\\"}, { \\\"first\\\": \\\"wu\\\", \\\"last\\\": \\\"mx\\\"} ] }\",\"username 字段是一个 JSON 数组，并且每个数组对象都是一个 JSON 对象。如果将 username 设置为对象类型，那么 ES 会将其转换为：\",\"{ \\\"group\\\": \\\"users\\\", \\\"username.first\\\": [\\\"wu\\\", \\\"hu\\\", \\\"wu\\\"], \\\"username.last\\\": [\\\"px\\\", \\\"xy\\\", \\\"mx\\\"] }\",\"可以看出转换后的 JSON 文档中 first 和 last 的关联丢失了，如果尝试搜索 first 为 wu，last 为 xy 的文档，那么成功会检索出上述文档，但是 wu 和 xy 在原 JSON 文档中并不属于同一个 JSON 对象，应当是不匹配的，即检索不出任何结果。\",\"嵌套类型就是为了解决这种问题的，嵌套类型将数组中的每个 JSON 对象作为独立的隐藏文档来存储，每个嵌套的对象都能够独立地被搜索，所以上述案例中虽然表面上只有 1 个文档，但实际上是存储了 4 个文档。\"]},\"452\":{\"h\":\"地理类型\",\"t\":[\"地理类型字段分为两种：经纬度类型和地理区域类型：\"]},\"453\":{\"h\":\"经纬度类型\",\"t\":[\"经纬度类型字段（geo_point）可以存储经纬度相关信息，通过地理类型的字段，可以用来实现诸如查找在指定地理区域内相关的文档、根据距离排序、根据地理位置修改评分规则等需求。\"]},\"454\":{\"h\":\"地理区域类型\",\"t\":[\"经纬度类型可以表达一个点，而 geo_shape 类型可以表达一块地理区域，区域的形状可以是任意多边形，也可以是点、线、面、多点、多线、多面等几何类型。\"]},\"455\":{\"h\":\"特殊类型\",\"t\":[\"特殊类型包括 IP 类型、过滤器类型、Join 类型、别名类型等，在这里简单介绍下 IP 类型和 Join 类型，其他特殊类型可以查看官方文档。\"]},\"456\":{\"h\":\"IP 类型\",\"t\":[\"IP 类型的字段可以用来存储 IPv4 或者 IPv6 地址，如果需要存储 IP 类型的字段，需要手动定义映射：\",\"{ \\\"mappings\\\": { \\\"properties\\\": { \\\"my_ip\\\": { \\\"type\\\": \\\"ip\\\" } } } }\"]},\"457\":{\"h\":\"Join类型\",\"t\":[\"Join 类型是 ES 6.x 引入的类型，以取代淘汰的 _parent 元字段，用来实现文档的一对一、一对多的关系，主要用来做父子查询。\",\"Join 类型的 Mapping 如下：\",\"PUT my_index { \\\"mappings\\\": { \\\"properties\\\": { \\\"my_join_field\\\": { \\\"type\\\": \\\"join\\\", \\\"relations\\\": { \\\"question\\\": \\\"answer\\\" } } } } }\",\"其中，my_join_field 为 Join 类型字段的名称；relations 指定关系：question 是 answer 的父类。\",\"例如定义一个 ID 为 1 的父文档：\",\"PUT my_join_index/1?refresh { \\\"text\\\": \\\"This is a question\\\", \\\"my_join_field\\\": \\\"question\\\" }\",\"接下来定义一个子文档，该文档指定了父文档 ID 为 1：\",\"PUT my_join_index/_doc/2?routing=1&refresh { \\\"text\\\": \\\"This is an answer\\\", \\\"my_join_field\\\": { \\\"name\\\": \\\"answer\\\", \\\"parent\\\": \\\"1\\\" } }\",\"join参考：https://www.elastic.co/guide/en/elasticsearch/reference/current/parent-join.html\"]},\"458\":{\"c\":[\"elasticsearch\",\"springboot\"]},\"459\":{\"c\":[\"elasticsearch\",\"springboot\"]},\"460\":{\"h\":\"Springboot2.x整合ElasticSearch7.x实战（四）\",\"t\":[\"本教程是系列教程，对于初学者可以对 ES 有一个整体认识和实践实战。\",\"还没开始的同学，建议先读一下系列攻略目录：Springboot2.x整合ElasticSearch7.x实战目录\",\"本篇幅是继上一篇 Springboot2.x整合ElasticSearch7.x实战（三） ，适合初学 Elasticsearch 的小白，可以跟着整个教程做一个练习。\",\"[toc]\",\"本篇都是基于前面搭建的环境来讲解，可视化使用的是 Cerebro v0.8.3。\",\"下文提到了很多 REST 操作，主要对创建索引和搜索做讲解。\"]},\"461\":{\"h\":\"集群\"},\"462\":{\"h\":\"检查集群状态\",\"t\":[\"curl http://localhost:9200/_cat/health?v\",\"更多查询集群状态的命令：\",\"curl http://localhost:9200/_cat\"]},\"463\":{\"h\":\"检查节点状态\"},\"464\":{\"h\":\"查询全部索引\"},\"465\":{\"h\":\"索引\"},\"466\":{\"h\":\"创建索引\"},\"467\":{\"h\":\"删除索引\"},\"468\":{\"h\":\"查询索引\"},\"469\":{\"h\":\"数据操作\"},\"470\":{\"h\":\"插入数据\"},\"471\":{\"h\":\"单条插入\"},\"472\":{\"h\":\"批量插入\"},\"473\":{\"h\":\"删除\"},\"474\":{\"h\":\"更新\"},\"475\":{\"h\":\"搜索\"},\"476\":{\"c\":[\"elasticsearch\",\"springboot\"]},\"477\":{\"c\":[\"elasticsearch\",\"springboot\"]},\"478\":{\"h\":\"Solidity\",\"t\":[\"技术和业务角度看区块链\"]},\"479\":{\"c\":[\"区块链\",\"soldity\",\"智能合约\"]},\"480\":{\"c\":[\"区块链\",\"soldity\",\"智能合约\"]},\"481\":{\"h\":\"空投合约\",\"t\":[\"关于 solidity、空投、智能合约\",\"空投作为区块链行业最大的惊喜之一，很多人都是通过空投才接触到了这一领域。\",\"甚至有很多专业薅空投羊毛的专业玩家。行业内有句话，小薅养活妻儿、大薅...\",\"[toc]\"]},\"482\":{\"h\":\"前言\",\"t\":[\"今天我们一块来看看\"]},\"483\":{\"h\":\"空投到底是什么\",\"t\":[\"简单来说，空投就是一种营销策略，希望将大家留在这个玩法中，有人气了就有共识，有共识就有价值。\",\"这里会涉及到一些运营的知识，为了用户有参与感，会让他们做一些任务、比如邀请、签到、分享等等，主要为了裂变、奖励机制、社区建设。总的来说，这个玩法从诞生起就很适合传播。\"]},\"484\":{\"h\":\"空投什么？\",\"t\":[\"以太坊为例。\",\"空投一般会是 ERC20 代币、或者是 ERC721 NFT 居多。\"]},\"485\":{\"h\":\"空投合约代码\",\"t\":[\"空投合约代码分为很多种，这主要基于产品设计的方案。下面分析一种比较常见的方式：\",\"需求： 当用户符合我设置的条件，点击领取就可以获取到对应空投。\"]},\"486\":{\"h\":\"空投步骤\",\"t\":[\"部署合约\",\"项目方部署空投合约，将打算发放空投的代币转入空投合约地址。\",\"设置条件\",\"合约中设置条件，比如用户持有一定数量的某种代币，或者完成某个任务（比如完成任务后的用户地址里有某个 NFT）。\",\"自动分发\",\"满足条件，自动发送代币到用户地址。\"]},\"487\":{\"h\":\"代码解析\",\"t\":[\"// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract AirdropContract { address public owner; mapping(address => bool) public claimed; uint public totalClaimed; uint public totalSupply; constructor(uint _totalSupply) { owner = msg.sender; totalSupply = _totalSupply; } function claim() public { require(!claimed[msg.sender], \\\"Already claimed\\\"); require(totalClaimed < totalSupply, \\\"Airdrop finished\\\"); uint amount = 100; // 每个用户可以领取的代币数量 require(totalClaimed + amount <= totalSupply, \\\"Not enough tokens\\\"); claimed[msg.sender] = true; totalClaimed += amount; payable(msg.sender).transfer(amount * 1 ether); // 假设代币是以太币 } function finish() public { require(msg.sender == owner, \\\"Only owner can finish airdrop\\\"); require(totalClaimed < totalSupply, \\\"Airdrop finished\\\"); payable(owner).transfer(address(this).balance); } }\"]},\"488\":{\"h\":\"代码详解\",\"t\":[\"如果你了解其他的编程语言，看 solidity 就会感觉很谨慎，这也是这门语言的特点，不要放过任何一个你模凌两可的点。\",\"// 代码开源协议，不写也行，但是目前多数编辑器会强制让写 // SPDX-License-Identifier: MIT // solidity 版本，表示支持 0.8.0 及以上版本 pragma solidity ^0.8.0; // 合约名 contract AirdropContract { // owner 一般存储合约的所有者地址，可以看到他的类型是 address address public owner; // 就和Java中map一样，这用于存储已经领取过空投的代币地址 mapping(address => bool) public claimed; // 存储已领取代币数 uint public totalClaimed; // 存储总代币数 uint public totalSupply; // 构造函数，也就是合约初始化时调用的函数，这里指定了空投合约拥有者地址和发型代币总数 constructor(uint _totalSupply) { owner = msg.sender; totalSupply = _totalSupply; } // 领取代币的函数 function claim() public { // 判断是否领取过 require(!claimed[msg.sender], \\\"Already claimed\\\"); // 判断被领取的代币是否超过总的额度， require(totalClaimed < totalSupply, \\\"Airdrop finished\\\"); uint amount = 100; // 每个用户可以领取的代币数量 // 再加一次校验，防止领超 require(totalClaimed + amount <= totalSupply, \\\"Not enough tokens\\\"); // 写入去重map，防止重复领取 claimed[msg.sender] = true; // 累加被领取的代币总和 totalClaimed += amount; // 将空投代币发送到制定地址 payable(msg.sender).transfer(amount * 1 ether); // 假设代币是以太币 } // 当活动结束有些代币可能未被领取，由 owner 可以领取回 function finish() public { // require 就是断言的作用，如果前面的判断为 True 就通过，否则中断并打印后面的说明 require(msg.sender == owner, \\\"Only owner can finish airdrop\\\"); require(totalClaimed < totalSupply, \\\"Airdrop finished\\\"); payable(owner).transfer(address(this).balance); } }\"]},\"489\":{\"c\":[\"区块链\",\"soldity\",\"空投\",\"智能合约\"]},\"490\":{\"c\":[\"区块链\",\"soldity\",\"空投\",\"智能合约\"]},\"491\":{\"h\":\"MySQL\"},\"492\":{\"h\":\"MySQL索引18连问_谁能顶住\",\"t\":[\"MySQL索引18连问，谁能顶住\",\"知乎 | 掘金\"]},\"493\":{\"h\":\"前言\",\"t\":[\"过完这个节，就要进入金银季，准备了 18 道 MySQL 索引题，一定用得上。\",\"image-20240325195000388\",\"作者：\",\"感谢每一个支持： github\"]},\"494\":{\"h\":\"1. 索引是什么\",\"t\":[\"image-20240325200012764\",\"索引是一种数据结构，用来帮助提升查询和检索数据速度。可以理解为一本书的目录，帮助定位数据位置。\",\"索引是一个文件，它要占用物理空间。\"]},\"495\":{\"h\":\"2. MySQL索引有哪些类型\",\"t\":[\"image-20240325195743437\",\"数据结构维度\",\"B+tree 索引： B+树是最常用的索引类型，所有数据都会存储在叶子节点上，时间复杂度是 O(logn) ，擅长范围查询。\",\"Hash 索引： 哈希索引就是采用哈希算法，将键值换算成新的哈希值，映射到对应槽位，然后存储到哈希表中，擅长做对等比较（=，in）。\",\"Full-text 索引： 全文索引是一种建立倒排索引，实现信息检索。在 MySQL 不同版本中支持程度不同。\",\"R-Tree 索引： 属于地理空间数据类型查询，通常使用较少。\",\"物理存储维度\",\"簇 cù\",\"聚簇索引： InnoDB 引擎 要求必须有聚簇索引，也就是在主键字段建立聚簇索引。\",\"非聚簇索引： 非聚簇索引就是以非主键创建的索引，在叶子节点存储的是表主键和索引列。 InnoDB 引擎\",\"逻辑维度\",\"主键索引： 主键索引是一种特殊的唯一索引，不允许值重复或者值为空。\",\"普通索引： 普通索引是 MySQL 中最基本的索引类型，允许在定义索引的列中插入重复值和空值。\",\"联合索引： 联合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用联合索引时遵循最左前缀集合。\",\"唯一索引： 唯一索引列的值必须唯一，允许有空值。\",\"空间索引： 空间索引是一种针对空间数据类型（如点、线、多边形等）建立的特殊索引，用于加速地理空间数据的查询和检索操作。\"]},\"496\":{\"h\":\"3. 主键索引和唯一索引有什么区别\",\"t\":[\"数量限制： 唯一索引有多个，但是主键索引一张表只能有一个。\",\"本质区别： 被唯一索引约束的健可以为空，主键索引不可以。\",\"外键引用： 主键可以被其他表作为外键，从而建立表之间的关系。而唯一索引则不能被其他表用作外键。\"]},\"497\":{\"h\":\"4. 什么是聚簇索引和非聚簇索引？它们在InnoDB存储引擎中是如何工作的？\",\"t\":[\"聚簇索引是将表的数据按照索引顺序存储在磁盘上，聚簇索引的叶子节点直接存储了实际的数据行，而不是指向数据的指针。所以在查询的时候减少了磁盘的随机读取，无需进行多次磁盘I/O效率很高。\",\"非聚簇索引是一种基于指针的索引，有时也叫它二级索引。非聚簇索引不直接存储实际的数据，seelec 语句在执行查询时，会先根据二级索引定位到数据所在的磁盘位置，然后再进行一次磁盘I/O操作，读取实际的数据行。\"]},\"498\":{\"h\":\"5. 复合索引和单列索引有何区别？\",\"t\":[\"顾名思义，单列索引就是在一个列上创建的索引，复合索引就是多个列上创建的索引。\",\"当只涉及到一个字段查询，单列是非常快速的。当涉及到多个字段查询，WHERE 子句引用了符合索引的所有列或者前导列时，查询速度会非常快。\",\"在复合索引中，列的顺序非常重要。MySQL会按照索引中列的顺序从左到右进行匹配。例如，对于复合索引(a, b, c)，它可以支持a、a,b和a,b,c三种组合的查询，但不支持b,c进行查询。因此，在创建复合索引时，应把最常被访问和选择性较高的列放在前面。\",\"当然具体如何选择需要看查询需求、数据分布和性能要求。如果你有开发需要欢迎在 JavaPub 下留言讨论。\"]},\"499\":{\"h\":\"6. Hash 索引和 B+ 树索引区别是什么？如何选择？\",\"t\":[\"哈希索引：\",\"工作原理：通过哈希算法将被索引的列的值存储到一个固定长度的桶（Bucket）。使得在查询特定值的时候非常高效，因为可以直接计算出存储位置，快速定位到数据。\",\"查询效率：在等值查询下，哈希查询效率极高，可以在常数时间复杂度内定位到目标数据。但是范围查询和排序操作时，哈希索引的效率较低，因为哈希算法会导致数据随机分布，无法保持原有的顺序。\",\"磁盘存储：hash 索引的存储是随机的，可能导致磁盘的随机访问，从而降低磁盘的利用效率和查询效率。\",\"插入和删除操作：Hash 索引在插入和删除操作方面相对简单，只需要通过哈希函数确定存储位置即可。\",\"B+树白话详解_下载\",\"B+树索引\",\"工作原理：B+树索引使用平衡树，将索引健的值按照顺序保存在树节点中，根据键值的大小关系，并通过节点之间的指针进行查找，快速定位存储了数据的叶子节点。\",\"查询效率：B+树擅长范围查询和排序操作，因为他是按照顺序存储数据，可以高效的支持范围查询和排序操作。\",\"磁盘存储：B+树索引的节点是有序存储的，有利于磁盘的顺序访问，从而减少磁盘的IO次数，提高查询效率。\",\"插入和删除操作：B+树在索引删除和插入操作时，需要维护树的平衡，可能进行节点的拆分和合并，相对哈希索引来说操作更复杂。\",\"所以在选择上：\",\"查询维度：如果查询主要是等值查询，且对性能要求较高，Hash 索引可能是一个好的选择。然而，如果查询涉及到范围查询、排序操作或模糊查询，B+ 树索引则更为合适。\",\"数据维度：如果索引列具有大量重复值，Hash索引的效率可能会下降，因为哈希碰撞会导致性能下降。在这种情况下，B+ 树索引可能更为稳定。\",\"磁盘存储和I/O维度：由于 Hash 索引可能导致磁盘的随机访问，如果磁盘 IO 是性能瓶颈，那么 B+ 树索引可能更适合，因为它更有利于磁盘的顺序访问。\",\"从这三个维度可以很好的应用在你的开发工作中，如果是小数据量的 web 网站查询、直接用 B+ 树就可以了。对于数据量的大小评估，后面单开一篇讲解。\"]},\"500\":{\"h\":\"7. 索引是否越多越好？为什么？\",\"t\":[\"不是。索引是建立在原数据上的数据结构，所以不论在查询还是更新维护、一定会带来开销。\",\"比如一本书有 100 页，我构建了 50 页的目录，你觉查询起来还会方便吗？\",\"数据量小的表不需要建立索引，建立索引反而会增加额外开销。\",\"数据变更后索引也需要更新，更多的索引意味着更多的维护成本。\",\"索引是放在磁盘的，更能的索引也意味着更多的存储空间。\",\"数据重复且分布平均的字短没必要建立索引（比如：性别）\",\"索引并非银弹，正确使用才能发挥奇效。\"]},\"501\":{\"h\":\"8. 索引什么时候会失效？\",\"t\":[\"慢 SQL 是数据库使用中最长遇见的问题，当遇到慢 SQL 时，首先我们就要去看是不是索引失效。一般会有以下几种常见的情况：\",\"Where 条件中包含 OR： 当查询条件中包含 OR，即使其中某些条件带有索引，也会全表扫描。下例中 username 没有索引，就算 id 走了索引也需要全表扫描，所以引擎大概率不会走索引。\",\"失效索引： id 有索引， username 没有索引。\",\"explain select * from t_user where id = 2 or username = 'javapub';\",\"多列索引没有最左匹配： 对于复合索引，如果查询条件没有从索引的第一部分匹配，则不会使用索引。也就是我们在使用联合索引时，要正确使用最左匹配。\",\"例如，如果你有一个(id, name)的多列索引，但查询条件只使用了name，那么索引不会被使用。\",\"LIKE 查询以%开头： 当使用LIKE操作符进行模糊查询，并且模式以%开头时，索引将不会生效。这是因为以%开头的模式匹配意味着匹配的字符串可以在任何位置，这使得索引无法有效定位数据。\",\"索引列参与计算： 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。比如：\",\"select * from t_user where id > age;\",\"类型不匹配导致隐式转换： 当表里存的是 varchar 类型的字段时，用 int 类型去查询，导致全表扫描。如下例子中：\",\"explain select * from t_user where id_no = 1002;\",\"表里的 id_no 是 varchar 类型。\",\"出了这几种情况还有一些导致索引失效。 例如：\",\"全表扫描效率更优：在某些情况下，MySQL 优 化器可能认为全表扫描比使用索引更快。\",\"数据分布不均：如果索引列的数据分布非常不均匀，MySQL 可能不会选择使用索引。\",\"索引列包含 NULL 值：如果索引列包含 NULL 值，MySQL可 能不会使用索引，因为 NULL 值的比较有特殊性。因为NULL值无法与其他值进行比较或匹配，所以无法使用索引。\"]},\"502\":{\"h\":\"9. 哪些情况下适合建立索引？\",\"t\":[\"image-20240325202047594\",\"高频查询列： 对于经常出现在查询条件中的列，建立索引可以加快查询速度。例如，经常根据username或email字段查询的用户表。\",\"作为连接键的列： 在执行表连接操作时，用于连接的列（通常在ON子句中指定）应该建立索引，以加快连接操作的速度。\",\"具有唯一性约束的列： 对于需要保证唯一性的列，如主键或具有唯一约束的列，建立索引是必要的，因为索引可以帮助快速检查重复的数据。\",\"排序和分组操作的列： 在ORDER BY、GROUP BY或DISTINCT操作中使用的列，通过建立索引可以加快排序和分组的处理速度。\",\"具有高选择性的列： 选择性是指不同值的数量与总行数的比率。具有高选择性的列（即列中的值分布广泛）适合建立索引，因为这样的索引可以更有效地缩小搜索范围。\",\"多列查询的前导列： 如果你经常执行涉及多个列的查询，可以在这些列上建立组合索引，其中最常用作查询条件的列应该放在索引的最前面。\",\"数据量大的表： 对于数据量较大的表，合理地建立索引可以大幅提高查询效率。但是，对于数据量小的表，由于数据量本身就少，索引可能不会带来太大的性能提升，反而可能增加插入、更新和删除操作的开销。\",\"在考虑建立索引时，也需要考虑以下因素：\",\"更新频率：频繁更新的列可能不适合建立索引，因为每次更新都可能导致索引的重新构建，增加开销。\",\"索引的维护成本：索引不仅占用存储空间，还会增加数据插入、删除和更新操作的维护成本。\",\"查询类型：需要分析查询类型，确保索引能够被有效利用。例如，对于只读或几乎只读的表，建立索引可能没有太大必要。\"]},\"503\":{\"h\":\"10. 为什么要用 B+ 树，而不用二叉树？\",\"t\":[\"查询性能稳定： B+树通过多层索引结构，使得查询性能更加稳定。在最坏的情况下，B+树的查询时间复杂度仍然是对数级别（O(log n)），而二叉树在最坏情况下（退化成链表）的时间复杂度为线性（O(n)）。这意味着即使数据分布极不均匀，B+树也能保持较高的查询效率。\",\"空间局部性： B+树的叶子节点包含了所有数据记录，并且通过指针相互连接，形成了一个有序链表。这种结构使得范围查询和顺序访问更加高效，因为相邻的数据在物理存储上也是相邻的。而二叉树不具备这种空间局部性，数据的物理存储位置可能分散。\",\"磁盘I/O优化： 数据库操作经常涉及磁盘I/O，B+树的设计更适合减少磁盘访问次数。由于B+树的非叶子节点不存储实际数据，可以使得每个节点包含更多的键值，从而降低树的高度。这样，在一次磁盘I/O操作中可以读取更多的索引信息，减少了I/O次数。\",\"高效的范围查询和排序： B+树的有序链表结构使得它在执行范围查询和排序操作时非常高效。而二叉树需要进行中序遍历才能得到有序的结果，效率较低。\",\"节点分裂和合并的开销： 在二叉树中，插入和删除操作可能导致频繁的节点分裂和合并，增加了操作的复杂性。B+树通过减少节点分裂和合并的次数，降低了维护开销。\",\"非叶子节点的简洁性： B+树的非叶子节点仅用于索引，不存储实际数据，这样可以使得每个节点包含更多的键值对，进一步降低树的高度。\",\"更新操作的效率： 由于B+树的高度通常较低，更新操作（插入、删除）时需要遍历的节点数量较少，从而提高了更新操作的效率。\",\"总的来说，B+树在数据库索引中提供了更稳定的查询性能、优化的磁盘I/O操作、高效的范围查询和排序，以及较低的维护成本。\"]},\"504\":{\"h\":\"11. 什么是回表？如何减少回表？\",\"t\":[\"回表定义： MySQL回表查询是指在使用索引进行查询时，MySQL数据库引擎在通过索引定位到数据行后，发现需要访问表中的其他列数据，而不是直接通过索引就能获取到所需的数据。这种情况下，MySQL需要再次访问表中的数据行，这个过程就称为回表查询（Referring to the table）。\",\"覆盖索引： 覆盖索引是指一个查询可以完全通过索引来得到结果，而不需要访问数据表的行。如果查询只需要索引中包含的字段，那么就无需回表。设计良好的覆盖索引可以显著减少回表操作。\",\"**避免SELECT ***： 在编写查询时，尽量指定需要的列，而不是使用SELECT *来选择所有列。这样可以减少不必要的数据访问，从而减少回表。\",\"索引包含所需列： 确保查询中涉及的列都被包含在索引中。如果索引包含了所有需要的列，那么查询可能不需要回表。\",\"使用复合索引： 如果查询经常根据多个列进行过滤，可以考虑创建一个包含这些列的复合索引。这样可以在一个索引中完成查询，减少回表。\",\"优化查询逻辑： 分析查询逻辑，尽量减少不必要的回表操作。例如，如果查询中的某些条件不太可能同时满足，可以考虑将它们分开处理，或者使用临时表来存储中间结果。\",\"使用物化视图或汇总表： 对于频繁执行的复杂查询，可以考虑使用物化视图或汇总表来存储查询结果。这样，当需要这些数据时，可以直接从物化视图或汇总表中获取，而无需进行回表操作。\",\"当然，不是所有情况都不允许回表，有时候，适当的回表是必要的，因为索引的设计需要平衡查询性能和存储空间的利用。\"]},\"505\":{\"h\":\"12. 能否解释什么是位图索引，以及它在MySQL中的使用场景？\",\"t\":[\"位图索引是一种将数据列的所有可能值映射到二进制位上的索引。每个位表示某个值是否存在于该列中，从而帮助我们快速定位符合某个条件的行。与其他类型的索引相比，位图索引通常在低基数列（即列中有限的不同值）上表现更好。\",\"可以参考 bitmap 数据结构来理解\",\"例子：\",\"在该示例中，我们为 age 和 country 列分别创建了位图索引。由于使用了位图索引，查询性能将大大提高。\",\"CREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(50), age INT, country VARCHAR(50) ); CREATE BITMAP INDEX idx_age ON users(age); CREATE BITMAP INDEX idx_country ON users(country); SELECT * FROM users WHERE age = 20 AND country = 'China';\"]},\"506\":{\"h\":\"13. 如何查看MySQL表中已有的索引？\",\"t\":[\"两种方式：\",\"使用 SHOW INDEX，也是最常用的。\",\"SHOW INDEX FROM your_table_name;\",\"查询 information_schema 数据库，information_schema 是 MySQL 中包含元数据的特殊数据库。我可以查询其中的 TABLES 和 STATISTICS 表来获取索引信息。\",\"SELECT TABLE_SCHEMA, TABLE_NAME, NON_UNIQUE, INDEX_NAME, INDEX_TYPE, INDEX_COMMENT, SEQ_IN_INDEX, COLUMN_NAME, CARDINALITY, SUB_PART, PACKED, NULLABLE, INDEX_DIR, INDEX_DISC FROM information_schema.STATISTICS WHERE TABLE_SCHEMA = 'your_database_name' AND TABLE_NAME = 'your_table_name';\"]},\"507\":{\"h\":\"14. 如何在MySQL中创建全文索引，并说明全文索引的使用场景？\",\"t\":[\"正例：\",\"CREATE TABLE articles ( id INT NOT NULL AUTO_INCREMENT, title VARCHAR(255) NOT NULL, content TEXT NOT NULL, PRIMARY KEY (id), FULLTEXT INDEX (title, content) -- 创建联合全文索引 ) ENGINE=MyISAM DEFAULT CHARSET=utf8;\",\"当已经建好表结构，使用 ALTER TABLE 创建：\",\"ALTER TABLE articles ADD FULLTEXT INDEX ft_index (title, content);\",\"全文索引一般用于内容管理平台（CMS），问答社区等检索场景，然而，全文索引也有一些限制，比如它只能用于MyISAM或InnoDB存储引擎（在MySQL 5.6及以上版本中），并且全文索引的列不能是NULL值。\",\"实际应用中其实很少会使用到，现在多数使用 ElasticSearch 来搭建全文搜索引擎。\"]},\"508\":{\"h\":\"15. 当表中的数据量非常大时，如何有效地维护和管理索引，以确保查询性能？\",\"t\":[\"索引主要是为了优化查询性能而设计的。如果一个字段的查询频率远低于更新频率，那么为该字段创建索引可能不会带来预期的性能提升，反而可能因为维护索引而降低整体性能。\",\"性能开销： 索引的维护需要额外的计算和存储资源。当对一个字段进行大量的更新操作时，数据库系统不仅需要更新数据本身，还需要更新所有相关的索引。这会导致性能开销增加，尤其是在高并发的写操作环境中。\",\"存储空间： 索引本身占用存储空间。对于经常更新的字段，如果创建了索引，那么每次数据更新都可能导致索引的页面分裂，进而需要更多的存储空间来维护索引结构。\",\"索引失效： 频繁的更新操作可能导致索引的页变得碎片化，从而降低索引的效率。索引页的碎片化意味着索引中的数据不再按照顺序存储，这会增加数据库在执行查询操作时的磁盘I/O次数，因为数据库可能需要读取多个不连续的页面来满足查询条件。\",\"更新锁竞争： 在高并发的更新操作中，索引可能会成为锁竞争的瓶颈。当多个事务尝试更新同一索引页时，可能会发生锁等待，这会降低并发性能。\"]},\"509\":{\"h\":\"16. 假设你有一个包含大量数据的表，并且经常需要根据某个字段进行排序。你应如何优化这个字段的索引以提高排序操作的性能？\",\"t\":[\"当你尝试为一个已经存在大量数据的表添加索引时，可能会遇到什么问题？如何解决这些问题？\",\"首先：\",\"如果是亿级大表，在建表时就要添加必要的索引，否则存入过多数据可能会出现加不成功的现象。\",\"垂直拆分\",\"按照业务维度拆分。\",\"水平拆分\",\"按照不同的行进行分片，分散到不同的物理表中。\",\"创建索引\",\"分区\",\"根据实际情况进行数据分区，但是要注意分区后可能影响写入性能。\",\"优化查询语句\",\"分布式数据库\"]},\"510\":{\"h\":\"17. 如何优化索引\",\"t\":[\"image-20240325201704103\",\"当你遇到查询性能问题时，如何分析和优化索引的使用？开放性问题。\",\"评估索引的必要性，不是所有字段都要走索引。\",\"选择正确的索引类型，例如，B-tree索引适合范围查询和排序操作，Hash索引适合等值查询，Bitmap索引适合低基数（不同值的数量较少）的列。\",\"优化索引的列顺序：在创建多列索引时，考虑列的访问模式和查询类型。通常，将最常用作查询条件的列放在索引的前面，因为数据库可以更有效地使用这些列来过滤数据。\",\"使用覆盖索引：如果查询只访问索引中包含的列，使用覆盖索引可以避免访问数据行本身，从而提高查询性能。\",\"分析数据分布：对于列的值分布进行分析，避免在高度重复的列上创建索引，因为这样的索引可能不会带来显著的性能提升。\",\"避免过度索引：过多的索引会增加数据库的维护成本，尤其是在数据插入、更新和删除时。确保每个索引都有其明确的用途，并定期审查和清理不再需要的索引。\"]},\"511\":{\"h\":\"18. 请谈谈你对 MySQL 索引碎片化的理解，并说明如何检测和修复索引碎片化。\",\"t\":[\"**如何检测索引碎片化？**两个方法\",\"使用SHOW TABLE STATUS命令： 通过执行 SHOW TABLE STATUS LIKE 'table_name'; 可以获取表的状态信息，其中包括 Data_free 字段，它表示表中未使用的空间百分比。如果这个值相对较高，可能表明表存在碎片化问题。\",\"使用 INFORMATION_SCHEMA.TABLES 表： 查询 INFORMATION_SCHEMA.TABLES 可以获取表的碎片化信息。例如：\",\"SELECT table_name, table_schema, Data_free / Data_length * 100 AS碎片化百分比 FROM information_schema.TABLES WHERE table_schema = 'your_database_name' AND Data_free > 0;\",\"如何修复索引碎片化？\",\"优化表的存储引擎：\",\"对于 MyISAM 存储引擎，可以使用 OPTIMIZE TABLE 命令来重新组织表的数据，减少碎片化。对于 InnoDB 存储引擎，这个命令也会尝试优化表，但效果可能不如 MyISAM 明显。\",\"OPTIMIZE TABLE table_name;\",\"重建索引：\",\"对于 InnoDB 存储引擎，可以通过 ALTER TABLE 命令来重建表的索引，这通常比 OPTIMIZE TABLE 更有效。\",\"ALTER TABLE table_name ENGINE=InnoDB;\",\"定期维护：\",\"定期执行 OPTIMIZE TABLE 或 ALTER TABLE 命令可以帮助维持索引的健康状况，减少碎片化。\",\"需要注意的是，优化表的操作可能会消耗大量的系统资源，并且可能需要较长的时间来完成，特别是对于大型表。因此，在执行这些操作之前，最好在测试环境中进行评估，并在业务低峰时段进行。此外，确保在执行优化操作之前备份数据，以防万一出现问题。\"]},\"512\":{\"c\":[\"mysql\"]},\"513\":{\"c\":[\"mysql\",\"索引\"]},\"514\":{\"h\":\"分表分库解决思路\"},\"515\":{\"h\":\"分表分库解决思路\",\"t\":[\"阅读大约3分钟，建议收藏阅读\",\"随着公司业务快速发展，数据库中的数据量猛增，访问性能也变慢了，优化迫在眉睫。\",\"分析一下问题出现在哪儿呢？ 关系型数据库本身比较容易成为系统瓶颈，单机存储容量、连接数、处理能力都有限。当单表的数据量达到 1000W 或 100G 以后，由于查询维度较多，即使添加从库、优化索引，做很多操作时性能仍下降严重。\",\"方案1：\",\"通过提升服务器硬件能力来提高数据处理能力，比如增加存储容量 、CPU等，这种方案成本很高，并且如果瓶颈在 MySQL 本身那么提高硬件也是很有限的。\",\"在这里插入图片描述\",\"方案2：\",\"把数据分散在不同的数据库中，使得单一数据库的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。\",\"如下图：将电商数据库拆分为若干独立的数据库，并且对于大表也拆分为若干小表，通过这种数据库拆分的方法来解决数据库的性能问题。就跟把鸡蛋放在多个篮子里是一样的。\",\"在这里插入图片描述\",\"分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成 ，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。\",\"分库分表包括分库和分表两个部分，在生产中通常包括：垂直分库、水平分库、垂直分表、水平分表四种方式。\",\"@[toc]\"]},\"516\":{\"h\":\"垂直分表\",\"t\":[\"垂直分表定义：将一个表按照字段分成多表，每个表存储其中一部分字段。\",\"它带来的提升是：\",\"为了避免IO争抢并减少锁表的几率\",\"充分发挥热门数据的操作效率，商品信息的操作的高效率不会被商品描述的低效率所拖累。\",\"为什么大字段IO效率低：第一是由于数据量本身大，需要更长的读取时间；第二是跨页，页是数据库存储单位，很多查找及定位操作都是以页为单位，单页内的数据行越多数据库整体性能越好，而大字段占用空间大，单页内存储行数少，因此IO效率较低。第三，数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。\",\"一般来说，某业务实体中的各个数据项的访问频次是不一样的，部分数据项可能是占用存储空间比较大的BLOB或是TEXT。例如上例中的商品描述。所以，当表数据量很大时，可以将表按字段切开，将热门字段、冷门字段分开放置在不同库中，这些库可以放在不同的存储设备上，避免IO争抢。垂直切分带来的性能提升主要集中在热门数据的操作效率上，而且磁盘争用情况减少。\",\"通常我们按以下原则进行垂直拆分:\",\"把不常用的字段单独放在一张表;\",\"把text，blob等大字段拆分出来放在附表中;\",\"经常组合查询的列放在一张表中;\"]},\"517\":{\"h\":\"垂直分库\",\"t\":[\"通过垂直分表性能得到了一定程度的提升，但是还没有达到要求，并且磁盘空间也快不够了，因为数据还是始终限制在一台服务器，库内垂直分表只解决了单一表数据量过大的问题，但没有将表分布到不同的服务器上，因此每个表还是竞争同一个物理机的CPU、内存、网络IO、磁盘。\",\"垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用。\",\"它带来的提升是：\",\"解决业务层面的耦合，业务清晰\",\"能对不同业务的数据进行分级管理、维护、监控、扩展等\",\"高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈\",\"垂直分库通过将表按业务分类，然后分布在不同数据库，并且可以将这些数据库部署在不同服务器上，从而达到多个服务器共同分摊压力的效果，但是依然没有解决单表数据量过大的问题。\"]},\"518\":{\"h\":\"水平分库\",\"t\":[\"水平分库是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。\",\"垂直分库是把不同表拆到不同数据库中。水平分库是对数据行的拆分，不影响表结构\",\"水平分库带来的提升是：\",\"解决了单库大数据，高并发的性能瓶颈。\",\"提高了系统的稳定性及可用性。\",\"稳定性体现在IO冲突减少，锁定减少，可用性指某个库出问题，部分可用`\",\"当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平分库了，经过水平切分的优化，往往能解决单库存储量及性能瓶颈。但由于同一个表被分配在不同的数据库，需要额外进行数据操作的路由工作，因此大大提升了系统复杂度。\"]},\"519\":{\"h\":\"水平分表\",\"t\":[\"水平分表是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。\",\"它带来的提升是：\",\"优化单一表数据量过大而产生的性能问题\",\"避免 IO 争抢并减少锁表的几率\",\"库内的水平分表，解决了单一表数据量过大的问题，分出来的小表中只包含一部分数据，从而使得单个表的数据量变小，提高检索性能。\"]},\"520\":{\"h\":\"总结\",\"t\":[\"垂直分表：可以把一个宽表的字段按访问频次、是否是大字段的原则拆分为多个表，这样既能使业务清晰，还能提升部分性能。拆分后，尽量从业务角度避免联查，否则性能方面将得不偿失。\",\"垂直分库：可以把多个表按业务耦合松紧归类，分别存放在不同的库，这些库可以分布在不同服务器，从而使访问压力被多服务器负载，大大提升性能，同时能提高整体架构的业务清晰度，不同的业务库可根据自身情况定制优化方案。但是它需要解决跨库带来的所有复杂问题。\",\"水平分库：可以把一个表的数据(按数据行)分到多个不同的库，每个库只有这个表的部分数据，这些库可以分布在不同服务器，从而使访问压力被多服务器负载，大大提升性能。它不仅需要解决跨库带来的所有复杂问题，还要解决数据路由的问题(数据路由问题后边介绍)。\",\"水平分表：可以把一个表的数据(按数据行)分到多个同一个数据库的多张表中，每个表只有这个表的部分数据，这样做能小幅提升性能，它仅仅作为水平分库的一个补充优化。\",\"一般来说，在系统设计阶段就应该根据业务耦合松紧来确定垂直分库，垂直分表方案，在数据量及访问压力不是特别大的情况，首先考虑缓存、读写分离、索引技术等方案。若数据量极大，且持续增长，再考虑水平分库水平分表方案。\",\"JavaPub参考教程：https://blog.csdn.net/weixin_44062339/article/details/100491744\"]},\"521\":{\"h\":\"后记\",\"t\":[\"现在是 2021 辛丑年 叄月，大家都知道我最近在做一套JavaPub系列面试题，前面已经更新过一部分，在接下来还会持续更新，欢迎大家分享、关注\"]},\"522\":{\"h\":\"序言\",\"t\":[\"再高大上的框架，也需要扎实的基础才能玩转，高频面试问题更是基础中的高频实战要点。\"]},\"523\":{\"h\":\"适合阅读人群\",\"t\":[\"Java 学习者和爱好者，有一定工作经验的技术人，准面试官等。\"]},\"524\":{\"h\":\"阅读建议\",\"t\":[\"本教程是系列教程，包含 Java 基础，JVM，容器，多线程，反射，异常，网络，对象拷贝，JavaWeb，设计模式，Spring-Spring MVC，Spring Boot / Spring Cloud，Mybatis / Hibernate，Kafka，RocketMQ，Zookeeper，MySQL，Redis，Elasticsearch，Lucene\",\"微信搜：JavaPub，阅读全套系列面试题教程\",\"wx\"]},\"525\":{\"h\":\"慢查询优化方案-SQL篇\",\"t\":[\"慢sql优化23式\",\"阅读大约6分钟，2021 0411 22:29 写于家中床边\",\"由于前期的快速开发、敏捷版本迭代，接口响应速度是每一个系统发展到中后期都会面临的一个问题。本系列从实战出发手把手一起对接口响应慢问题做优化。\",\"对于慢查询我们一般通过如下思路解决： 1. explain sql 分析慢SQL 2. 利用缓存 3. 读写分离和分库分表 4. 评论区补充，待续...\",\"本篇是系列文章（以 MySQL 为例），从多个角度分析、解决慢查询，如意犹未尽：【JavaPub】\",\"为了提高查询效率，当数据库表加完索引后还不不能满足性能需求，第二步，SQL 语句优化。\",\"系统前期开发阶段，为了快速开发，SQL 语句都是以实现功能为主，性能上可能没怎么在意。本篇主要讲述几个在实战中注意优化的性能点供大家参考。\",\"文章结构由简到难，以目录为结论，下文做详细讲解。\",\"目录：\",\"[toc]\"]},\"526\":{\"h\":\"1. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：\",\"t\":[\"select id from t where num is null\",\"可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：\",\"select id from t where num=0\",\"其实这条说的过于绝对，但是我们还是建议尽量避免使用字段为 NULL。在 MySQL 的个别引擎中是支持的，翻阅官方文档。如果使用的是 MyISAM、InnoDB 或 MEMORY 存储引擎，则可以在具有 NULL 值的列上添加索引。 否则，您必须声明一个索引列 NOT NULL，并且您不能在该列中插入 NULL。\",\"You can add an index on a column that can have NULL values if you are using the MyISAM, InnoDB, or MEMORY storage engine. Otherwise, you must declare an indexed column NOT NULL, and you cannot insert NULL into the column.\",\"NULL对于SQL的新手来说，值 的概念是一个常见的混淆源，他们经常认为这 NULL与空字符串是同一回事 '。但是第一个语句将插入一个 NULL值，第二个语句将 插入一个空字符串。第一个的含义可以视为 “未知电话号码”，第二个的含义可以视为“已知该人没有电话，因此也没有电话号码”。\",\"参考官网阅读（Mysql null 值问题）：https://dev.mysql.com/doc/refman/5.7/en/problems-with-null.html\"]},\"527\":{\"h\":\"2. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。\",\"t\":[\"这里是否放弃使用索引取决于 MySQL 优化器。\",\"Note：例如 or 、in | not in 、is null | is not null、!=、<>，使用时并不是完全不走索引，要考虑到：\",\"全表扫描是否比索引更快，以至于优化器选择全表扫描；\",\"mysql 的版本;\",\"可以通过优化语法或者配置优化器。\",\"参考： https://dev.mysql.com/doc/refman/5.6/en/statement-optimization.html https://dev.mysql.com/doc/refman/5.6/en/optimization-indexes.html https://dev.mysql.com/doc/refman/5.6/en/select-optimization.html\"]},\"528\":{\"h\":\"3. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：\",\"t\":[\"select id from t where num=10 or num=20\",\"可以这样查询：\",\"select id from t where num=10 union all select id from t where num=20\",\"避免使用不代表一定不使用，很多时候还取决于 MySql 引擎对查询的优化。参考前一篇：JavaPub【慢查询优化方案-索引篇【JavaPub版】】\"]},\"529\":{\"h\":\"4. in 和 not in 也要慎用，否则会导致全表扫描，如：\",\"t\":[\"select id from t where num in(1,2,3)\",\"对于连续的数值，能用 between 就不要用 in 了：\",\"select id from t where num between 1 and 3\"]},\"530\":{\"h\":\"5. 下面的查询也将导致全表扫描：\",\"t\":[\"select id from t where name like '%abc%';\",\"例如，SELECT id FROM t WHERE name LIKE 'abc%'; 这个查询将使用索引。\"]},\"531\":{\"h\":\"6. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：\",\"t\":[\"select id from t where num/2=100\",\"应改为:\",\"select id from t where num=100*2\"]},\"532\":{\"h\":\"7. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：\",\"t\":[\"select id from t where substring(name,1,3)='abc'; //name以abc开头的id\",\"应改为:\",\"select id from t where name like 'abc%';\"]},\"533\":{\"h\":\"8. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。\"},\"534\":{\"h\":\"9. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。\"},\"535\":{\"h\":\"10. 很多时候用 exists 代替 in 是一个好的选择：\",\"t\":[\"select num from a where num in(select num from b)\",\"用下面的语句替换：\",\"select num from a where exists(select 1 from b where num=a.num)\",\"in 和 not in 不会命中索引\"]},\"536\":{\"h\":\"11. 并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引。\",\"t\":[\"如一表中有字段 sex，male、female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。\",\"这就是我们 Boolean（一般用 tinyint ） 型字段上使用索引会不会用到的问题。\"]},\"537\":{\"h\":\"12. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，\",\"t\":[\"因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。 一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。\",\"这些原则都是原则上建议，要视情况而定。\"]},\"538\":{\"h\":\"13. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。\",\"t\":[\"这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。\"]},\"539\":{\"h\":\"14. 尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。\"},\"540\":{\"h\":\"15. 任何地方都不要使用 select * from t ，用具体的字段列表代替 “*”，不要返回用不到的任何字段。\",\"t\":[\"这个是大多数系统的通病，但是。\"]},\"541\":{\"h\":\"16. 避免频繁创建和删除临时表，以减少系统表资源的消耗。\",\"t\":[\"这条在大多数业务场景不会使用到。\",\"临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。\",\"在使用时要注意 drop table 、 truncate table、delete table 区别。\"]},\"542\":{\"h\":\"17. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。\",\"t\":[\"#MYSQL不支持: Select * Into new_table_name from old_table_name; 这是sql server中的用法 #替代方法: Create table new_table_name (Select * from old_table_name);\"]},\"543\":{\"h\":\"18. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。\"},\"544\":{\"h\":\"19. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。\"},\"545\":{\"h\":\"20. 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。\"},\"546\":{\"h\":\"21. 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。\",\"t\":[\"在结果集中包括 “合计” 的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于结果集的方法都可以尝试一下，看哪一种方法的效果更好。\"]},\"547\":{\"h\":\"22. 尽量避免大事务操作，提高系统并发能力。\"},\"548\":{\"h\":\"23. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。\",\"t\":[\"参考： https://dev.mysql.com/doc/refman/5.7/en/is-null-optimization.html\"]},\"549\":{\"c\":[\"mysql\"]},\"550\":{\"c\":[\"mysql\",\"慢SQL\"]},\"551\":{\"h\":\"数据库13问，谁能顶得住\",\"t\":[\"数据库13问，谁能顶得住 |\"]},\"552\":{\"h\":\"前言\",\"t\":[\"过完这个节，就要进入金银季，准备了 13 道数据库锁面试题，一定用得上。\",\"锁的问题归更到底就是资源竞争导致的，而并发场景一定会发生资源竞争，所以锁的问题，也是并发场景下必问的问题。理解好锁的原理，在编程中提升设计能力也非常重要。\",\"汇总xmind\",\"作者：\",\"感谢每一个支持： github\"]},\"553\":{\"h\":\"1. 为什么要在数据库中加锁\",\"t\":[\"就像我们生活中，每天出门都要给房子上锁，这时有人来拜访看到已上锁，就知道家里没人。\",\"我们的系统绝大多不是单机系统，都会从在资源的竞争（并发控制）和数据一致性的场景，比如：俩个人同时买一个商品、但是商品只剩下一件，这时就需要锁来保证谁拥有这件商品。锁是保证数据库事务四个特性，原子性、一致性、隔离性和持久性（ACID）的关键性技术之一。\",\"无锁的情况下就可能出现，如脏读、不可重复读和幻读等。\"]},\"554\":{\"h\":\"2. InnoDB 中有哪些锁\",\"t\":[\"image-20240527184946810\"]},\"555\":{\"h\":\"2.1 共享锁/排它锁\",\"t\":[\"共享锁（S锁）和排它锁（X锁）是最基础的锁类型，用于操作对数据的读取和写入。\",\"通过名字，我们也可以看出这两个锁的作用。当事务要读取一条记录时，先获取该记录的S锁；当事务要改动一条记录时，先获取该记录的X锁。\",\"img\",\"通过这个图可以知道，什么情况下可以获得 S 锁和 X 锁。可以看到，只有都是共享锁时，才可以同时在一行记录加锁。\",\"例子：\",\"加共享锁，共享锁允许其他事务读取这些行，但不允许其他事务修改或删除这些行，直到当前事务结束。\",\"SELECT ... LOCK IN SHARE MODE; 加共享锁 --- SELECT * FROM user WHERE id=1 LOCK IN SHARE MODE;\",\"加排他锁，相当于是独占记录。当一个事务对某行数据加上排他锁后，其他事务既不能读取也不能修改这些数据，直到持有排他锁的事务结束。\",\"SELECT ... FOR UPDATE; 加排他锁 --- START TRANSACTION; SELECT * FROM table_name WHERE condition FOR UPDATE; -- 执行一些更新操作 UPDATE table_name SET column = value WHERE condition; COMMIT;\"]},\"556\":{\"h\":\"2.2 行锁/临键锁\",\"t\":[\"行锁\",\"行锁通常在执行涉及单个行的操作时自动应用，例如 SELECT 语句中的 FOR UPDATE 子句，这会为查询结果中的每行添加排他锁。也就是上面说到的例子。\",\"START TRANSACTION; SELECT * FROM table_name WHERE id = 1 FOR UPDATE; -- 在此事务中，id为1的行将被锁定，其他事务不能修改或读取这行 COMMIT;\",\"临键锁\",\"临键锁结合了记录锁和间隙锁，用于行级锁定和范围查询，防止幻读。我们一般无法判断是行锁还是临键锁，都是行锁的形式，由存储引擎在执行查询时自动管理决定的。\",\"START TRANSACTION; SELECT * FROM table_name WHERE id BETWEEN 1 AND 10 FOR UPDATE; -- 这将锁定id在1到10之间的所有行，以及可能的下一个键值 COMMIT;\"]},\"557\":{\"h\":\"2.3 意向锁\",\"t\":[\"意向锁是针对多粒度锁定协议的系统，比如行粒度锁、表粒度锁。当一个事务打算在某个细粒度上请求锁（共享锁|排他锁），它会首先在更粗力度上设置意向锁。\",\"意向共识锁 - 简称 IS\",\"意向排他锁 - 简称 IX\",\"例子：如果一个事务要对一张表加排他锁，它会先在表级别加上意向排他锁，然后对表中的特定行加排他锁。\",\"img\"]},\"558\":{\"h\":\"2.4 间隙锁/插入意向锁\",\"t\":[\"间隙锁和插入意向锁针对实现了多版本并发控制（MVCC）的系统中，如 MySQL 的 InnoDB 存储引擎。\",\"间隙锁（Gap Locks）：\",\"间隙锁是一种行锁，它锁定一个范围内的间隙，但不锁定该范围内的任何具体行。间隙锁主要用于防止其他事务在这个间隙中插入新的行，从而维护数据的顺序性和一致性。 间隙锁通常在执行范围查询并加上共享或排他锁时自动应用。例如，如果一个事务执行了 SELECT ... WHERE index_column BETWEEN x AND y LOCK IN SHARE MODE ，InnoDB 会在索引列 x 和 y 之间的间隙上设置间隙锁，防止其他事务在这个范围内插入新行。\",\"示例：\",\"START TRANSACTION; SELECT * FROM table_name WHERE id BETWEEN 10 AND 20 LOCK IN SHARE MODE; -- 在id为10到20的范围内设置间隙锁 COMMIT;\",\"插入意向锁（Insert Intention Locks）：\",\"插入意向锁是一种特殊的间隙锁，它表明一个事务有意向在某个间隙中插入新行。 当一个事务想要在一个已经被其他事务加上间隙锁的范围内插入新行时，它会首先在该范围内设置一个插入意向锁。\",\"插入意向锁允许多个事务保留在特定间隙中插入新行的意图，而不直接与间隙锁冲突。这样，当间隙锁被释放时，持有插入意向锁的事务可以继续执行插入操作。\",\"示例：\",\"START TRANSACTION; -- 假设另一个事务已经在id为10到20的范围内设置了间隙锁 SELECT * FROM table_name WHERE id = 15 FOR UPDATE; -- 这将设置一个插入意向锁，表明事务有意向在id为10到20的范围内插入新行 COMMIT;\"]},\"559\":{\"h\":\"2.5 自增锁\",\"t\":[\"自增锁（Auto-Increment Locks，简称：AI Locks）是MySQL数据库中InnoDB存储引擎特有的一种锁机制，它与自增字段（AUTO_INCREMENT）相关联。AUTO_INCREMENT 你一定不陌生，我们在建表时多数情况都会让主键 id 自增来生成唯一序列。\",\"当一个表中包含自增字段时，InnoDB 会使用自增锁来确保在并发环境下，自增字段生成的值是唯一的，并且连续的。\",\"示例：\",\"START TRANSACTION; INSERT INTO table_name (auto_increment_column, other_columns) VALUES (NULL, 'value1'); -- InnoDB分配自增值并锁定它 COMMIT; -- 自增锁在事务提交时释放\",\"在这个示例中，auto_increment_column 是一个自增字段。当事务提交时，InnoDB 会分配一个新的自增值给插入的行，并在事务提交时释放自增锁。\"]},\"560\":{\"h\":\"2.6 外键锁\",\"t\":[\"外键（Foreign Key）是一种数据库完整性约束，它用于维护两个表之间的链接，并确保引用的数据的完整性。\",\"外键锁顾名思义就是针对外键的。外键锁并不是一个标准的锁类型，而是指与外键约束相关的锁定行为，这些行为确保在执行涉及外键的插入或更新操作时，数据库的完整性不被破坏。\",\"外键锁这个术语并不是用来描述一种特定的锁类型，而是用来描述与外键约束相关的锁定行为。数据库系统会自动处理这些锁定，以确保数据的完整性和一致性。\"]},\"561\":{\"h\":\"2.7 表锁/页锁\",\"t\":[\"表锁和页锁是两种不同粒度的锁，\",\"表锁（Table Locks）\",\"表锁是锁定整个表的锁，这意味着在锁定期间，没有其他事务可以对这张表进行读写操作。表锁通常用于批量操作，如全表扫描或全表更新，以及在不需要频繁锁定和解锁单个行的场景中。\",\"特点：\",\"粒度较大：表锁影响整个表的所有数据，因此粒度较大。\",\"冲突较少：由于锁定了整个表，减少了锁冲突的可能性，但在高并发环境下可能导致其他事务长时间等待。\",\"使用场景：适用于全表操作，如全表备份或全表删除。\",\"示例：\",\"LOCK TABLES table_name WRITE; -- 在此期间，其他事务不能访问table_name UNLOCK TABLES;\",\"页锁（Page Locks）\",\"页锁是锁定数据库中的一个“页”的锁。在许多数据库系统中，数据是按页存储的，每页包含一定数量的行。页锁允许多个事务同时访问不同的页，从而提供比表锁更细粒度的并发控制。\",\"特点：\",\"粒度较小：页锁锁定的是数据页，而不是整个表，因此粒度较小。\",\"并发性更好：允许多个事务并发访问不同的数据页，提高了并发性能。\",\"使用场景：适用于需要较高并发性能的场景，尤其是在大型表上进行部分数据的读写操作。\",\"注意：页锁通常由数据库管理系统自动管理，不需要用户显式操作。例如，在InnoDB存储引擎中，虽然页锁不是用户可以直接控制的锁类型，但InnoDB会根据需要自动在页级别上应用锁。\",\"总结： 粒度：行锁 < 页锁 < 表锁（从细到粗）。\"]},\"562\":{\"h\":\"3. 什么是死锁\",\"t\":[\"死锁是在事务数据库中会发生的一种特殊现象，多个事务在执行过程中，相互等待对方持有的资源，导致这些事务都无法继续执行。简单来说，就是两个或多个事务陷入了一个循环等待的状态，每个事务都在等待其他事务释放资源。\",\"比如这个蛇和青蛙互不放手。\",\"来源网络-互不放手\",\"死锁通常由以下四种情况同时出现时引起：\",\"互斥条件（Mutual Exclusion）： \",\"指某些资源（如数据库中的记录）一次只能被一个事务占用。\",\"持有和等待条件（Hold and Wait）： \",\"指一个事务至少持有一个资源，并在等待获取其他事务持有的资源。\",\"不可剥夺条件（No Preemption）： \",\"指已经分配给一个事务的资源，在事务使用完毕之前，不能被强行剥夺。\",\"循环等待条件（Circular Wait）： \",\"指事务之间形成了一个闭环，每个事务都在等待下一个事务所持有的资源。\"]},\"563\":{\"h\":\"4. 行锁、表锁、页面锁有什么区别\",\"t\":[\"从每种锁的锁粒度、并发性、冲突和使用场景几个角度来区分。\"]},\"564\":{\"h\":\"行锁（Row Locks）\",\"t\":[\"锁粒度：行锁是锁定表中的单行或多行。\",\"并发性：行锁允许多个事务同时访问表中的不同行，从而提供较高的并发性。\",\"冲突：行锁可能导致更多的锁冲突，因为它们需要在更细的粒度上管理锁。\",\"使用场景：适用于需要高并发读写操作的场景，尤其是在表中只有少数行会被访问时。\",\"示例：在InnoDB存储引擎中，使用SELECT ... FOR UPDATE可以显式地对行加排他锁。\"]},\"565\":{\"h\":\"表锁（Table Locks）\",\"t\":[\"锁粒度：表锁是锁定整个表。\",\"并发性：表锁期间，其他事务不能对表进行任何读写操作，直到锁被释放，因此并发性较低。\",\"冲突：由于锁定了整个表，减少了锁冲突的可能性，但可能导致其他事务长时间等待。\",\"使用场景：适用于需要对整个表执行批量操作的场景，如全表备份或全表删除。\",\"示例：在MySQL中，可以使用LOCK TABLES和UNLOCK TABLES语句显式地对表加锁和解锁。\"]},\"566\":{\"h\":\"页锁（Page Locks）\",\"t\":[\"锁粒度：页锁是锁定数据库中的一个数据页，每个页包含多行数据。\",\"并发性：页锁允许多个事务同时访问不同的数据页，提高了并发性。\",\"冲突：相比于行锁，页锁可能导致较少的锁冲突，但仍然存在一定的冲突可能。\",\"使用场景：适用于需要较高并发性能的场景，尤其是在大型表上进行部分数据的读写操作。\",\"示例：页锁通常由数据库管理系统自动管理，不需要用户显式操作。例如，在PostgreSQL中，页锁可以用于控制对表中特定数据页的访问。\"]},\"567\":{\"h\":\"总结\",\"t\":[\"粒度：行锁 < 页锁 < 表锁（从细到粗）。\",\"并发性：行锁提供最高的并发性，页锁次之，表锁最低。\",\"冲突：行锁可能导致最多的锁冲突，页锁和表锁的冲突较少。\",\"使用场景：行锁适用于高并发读写，表锁适用于全表操作，页锁适用于需要较高并发的场景。\",\"区分选择不同的锁，正确使用锁类型对于优化数据库性能、确保数据一致性至关重要。\"]},\"568\":{\"h\":\"5. 乐观锁和悲观锁有什么区别，它们什么场景会用\"},\"569\":{\"h\":\"乐观锁\",\"t\":[\"乐观锁基于这样的假设：多个事务在同一时间对同一数据对象进行操作的可能性很小，因此它允许多个事务同时进行，仅在事务提交时检查是否有其他事务对数据进行了修改。\",\"特点：\",\"无锁：乐观锁通常不使用数据库的锁定机制，而是通过其他方式（如时间戳、版本号）来确保数据一致性。\",\"性能：在冲突较少的情况下，乐观锁可以提供更好的性能，因为它允许高并发。\",\"冲突检测：在事务提交时检测冲突，如果检测到冲突，事务将被回滚。\",\"实现方式：\",\"版本号：在数据表中添加一个版本号字段或时间戳字段。事务开始时记录版本号，提交时检查版本号是否发生变化，如果变化了，则表示有冲突。\",\"时间戳：使用时间戳来控制事务的顺序，如果检测到时间戳冲突，则回滚事务。\",\"适用场景：\",\"写冲突较少：适用于写操作不频繁或者写冲突可能性较低的场景。\",\"读多写少：适用于读操作远多于写操作的环境。\",\"高并发：需要支持高并发访问的系统。\"]},\"570\":{\"h\":\"悲观锁\",\"t\":[\"悲观锁基于这样的假设：多个事务对同一数据对象的并发操作会产生冲突，因此它在事务开始时就对数据对象加锁，直到事务结束才释放锁。\",\"特点：\",\"锁定：悲观锁通过数据库的锁定机制来确保数据一致性，如行锁或表锁。\",\"性能：在高冲突环境下，悲观锁可能导致更多的等待和锁竞争，从而影响性能。\",\"预防冲突：通过锁定机制预防冲突，而不是检测冲突。\",\"实现方式：\",\"显式锁定：使用数据库的锁定命令（如SELECT ... FOR UPDATE）来显式地锁定需要的资源。\",\"隐式锁定：通过数据库事务的隔离级别隐式地实现锁定。\",\"适用场景：\",\"写冲突较多：适用于写操作频繁或者写冲突可能性较高的场景。\",\"写多读少：适用于写操作多于读操作的环境。\",\"数据一致性要求高：需要严格保证数据一致性的场合。\"]},\"571\":{\"h\":\"6. select...for update 加了行锁还是表锁\",\"t\":[\"行锁。\",\"这个在上面的例子中有提到过，这个 SQL 会锁定查询到的行，行锁的粒度更小、可以提高并发性。\",\"示例：\",\"START TRANSACTION; SELECT * FROM table_name WHERE column_name = 'some_value' FOR UPDATE; -- 在此事务中，column_name 等于 'some_value' 的行将被加上排他锁 COMMIT;\",\"在这个示例中，只有 column_name 等于 'some_value' 的行会被锁定，其他行仍然可以被其他事务访问。\"]},\"572\":{\"h\":\"7. 如何通过 SQL 手动给 MySQL 的某个表加锁\",\"t\":[\"手动加锁也就是显示的加表锁。\",\"MySQL提供了LOCK TABLES语句来显式地锁定一个或多个表。这可以用来阻止其他会话访问这些表。\",\"加写锁（排他锁）示例：\",\"LOCK TABLES table_name WRITE;\",\"加读锁（共享锁）示例：\",\"LOCK TABLES table_name READ;\",\"锁定多个表的示例：\",\"复制 LOCK TABLES table1 READ, table2 WRITE;\"]},\"573\":{\"h\":\"8. 高并发场景下，如何修改同一条数据\",\"t\":[\"这个要根据业务场景来选择锁。比如读多写少场景下，可以使用乐观锁，写冲突较多时可以使用悲观锁。\",\"例子：\",\"使用乐观锁： 乐观锁适用于写冲突较少的场景。通过在数据表中添加一个版本号或时间戳字段来实现。每次更新数据时，检查版本号或时间戳是否与读取时的值相同，如果相同，则进行更新并增加版本号或更新时间戳；如果不同，则放弃更新，提示用户冲突发生。\",\"START TRANSACTION; SELECT version_column, data_column FROM table_name WHERE id = 1; -- 检查并更新 UPDATE table_name SET data_column = 'new_value', version_column = version_column + 1 WHERE id = 1 AND version_column = read_version; COMMIT;\",\"使用悲观锁： 悲观锁适用于写冲突较多的场景。通过在事务开始时锁定需要修改的数据行，直到事务结束才释放锁。\",\"复制 START TRANSACTION; SELECT * FROM table_name WHERE id = 1 FOR UPDATE; -- 进行更新操作 UPDATE table_name SET data_column = 'new_value' WHERE id = 1; COMMIT;\"]},\"574\":{\"h\":\"9. MySQL 中的锁升级是什么\",\"t\":[\"锁升级指细粒度锁升级为粗粒度锁，如行锁升级为表锁。锁升级通常发生在一下情况：\",\"锁竞争： 当一个事务持有多个行锁，并且这些行锁的数量超过了系统预设的阈值时，数据库系统可能会将这些行锁升级为表锁，以减少系统开销和提高性能。\",\"锁定的行数： 如果锁定的行数占表中行数的很大一部分，数据库系统可能会认为整个表都被锁定了，因此会升级为表锁。\",\"锁定的页数： 类似地，如果锁定的页（数据库中数据的存储单位）数量占表中总页数的很大一部分，也可能触发锁升级。\",\"系统配置： MySQL的配置参数（如innodb_table_locks）会影响是否启用表锁以及何时进行锁升级。\",\"锁升级的优点包括：\",\"减少系统开销：管理大量行锁的开销可能很大，升级为表锁可以简化锁管理。\",\"提高性能：在某些情况下，锁升级可以减少死锁的可能性，并提高系统的整体性能。\",\"锁升级的缺点包括：\",\"降低并发性：表锁是一种粗粒度的锁，会阻止其他事务访问整个表，从而降低并发性。\",\"增加等待时间：其他事务可能需要等待表锁释放，增加了它们的等待时间。\",\"锁升级是数据库系统自动进行的，不需要用户干预。\"]},\"575\":{\"h\":\"10. MySql RR 的隔离级别下加锁规则\",\"t\":[\"重点\",\"在MySQL的可重复读（Repeatable Read，简称RR）隔离级别下，InnoDB存储引擎采用了一系列加锁规则来保证事务的隔离性。\",\"行锁： \",\"对于索引项的查询，如果能够定位到具体的索引记录，无论是主键索引还是二级索引，InnoDB会在这些具体的索引项上加上行锁（Record Lock）。\",\"间隙锁： \",\"如果查询条件的结果为空，即没有命中任何索引，那么在RR隔离级别下，InnoDB会在相关索引的间隙上加上间隙锁（Gap Lock）。\",\"Next-Key Lock： \",\"对于范围查询，InnoDB会使用Next-Key Lock，它是行锁和间隙锁的组合，用于锁定一个区间内的所有行以及区间的边界值。\",\"快照读与当前读： \",\"在RR隔离级别下，普通的SELECT语句是快照读（Snapshot Read），不加锁；但是当使用SELECT ... FOR UPDATE或SELECT ... LOCK IN SHARE MODE时，会变成当前读（Current Read），并加上相应的行锁或共享锁。\",\"幻读： \",\"RR隔离级别旨在防止幻读现象，即在一个事务中，两次读同一个范围的时候，第二次读到之前不存在的行。为了防止幻读，InnoDB会在查询涉及的范围上加上足够的间隙锁。\",\"锁升级： \",\"在RR隔离级别下，如果锁定的行数过多，InnoDB可能会将行锁升级为表锁，尽管这种行为在默认配置下不常见。\",\"自增锁： \",\"对于自增字段，InnoDB可能会使用自增锁（Auto-Increment Locks）来保证自增值的唯一性和连续性。\",\"意向锁： \",\"在多粒度锁定协议中，InnoDB使用意向锁（Intention Locks），如意向共享锁（Intention Shared Locks）和意向排他锁（Intention Exclusive Locks），以表明事务将在更细粒度上请求锁。\",\"锁的兼容性： \",\"共享锁（S锁）之间是兼容的，但排他锁（X锁）与任何其他类型的锁都不兼容。\",\"这些加锁规则共同作用，以确保在RR隔离级别下，事务可以看到一致的快照数据，并防止其他事务的干扰，直到事务完成。\"]},\"576\":{\"h\":\"11. 如何使用分布式锁\",\"t\":[\"实现分布式锁有以下几种方式：\"]},\"577\":{\"h\":\"11.1. 基于唯一索引实现\",\"t\":[\"这种方法通过尝试向一个表中插入具有唯一索引的记录来实现锁的获取。如果插入成功，则认为获取了锁；如果插入失败（由于唯一键冲突），则认为获取锁失败。\",\"创建锁表：\",\"CREATE TABLE `t_lock` ( `lock_key` varchar(64) NOT NULL COMMENT '锁的标识', PRIMARY KEY (`lock_key`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='分布式锁';\",\"获取锁：\",\"insert ignore into t_lock(lock_key) values('my_lock_key');\",\"使用insert ignore来避免违反唯一约束时产生的错误，如果返回值大于0，则认为成功获取了锁。\",\"释放锁：\",\"delete from t_lock where lock_key = 'my_lock_key';\",\"当操作完成时，删除记录以释放锁。\"]},\"578\":{\"h\":\"11.2. 基于排他锁（ ）实现\",\"t\":[\"这种方法通过在SELECT语句后增加FOR UPDATE来获取排他锁，确保某条记录在事务中被锁定，其他事务无法再获取到相同的排他锁。\",\"获取锁：\",\"SELECT * FROM some_table WHERE some_column = 'some_value' FOR UPDATE;\",\"这样就会在满足条件的行上加上排他锁。\",\"释放锁： 排他锁会在事务结束时释放，无论是通过COMMIT提交事务还是通过ROLLBACK回滚事务。\"]},\"579\":{\"h\":\"11.3. 基于乐观锁\",\"t\":[\"乐观锁通常通过在表中添加一个版本号或时间戳字段来实现。每次更新记录时，检查版本号或时间戳是否与读取时的值相同，如果相同则进行更新，否则放弃更新。\",\"获取锁： 使用普通的SELECT语句读取数据及版本号。\",\"更新操作：\",\"UPDATE some_table SET column1 = value1, version = version + 1 WHERE id = some_id AND version = some_version;\",\"只有当版本号匹配时才更新，并增加版本号。\",\"释放锁： 乐观锁通常不需要显式释放，因为它不依赖于数据库的锁定机制。\"]},\"580\":{\"h\":\"12. 如何检测死锁\",\"t\":[\"大多数数据库都自带死锁检测机制，内置的死锁检测器会在事务等待资源时自动检测死锁。例如：\",\"MySQL：可以使用INFORMATION_SCHEMA数据库中的INNODB_LOCK_WAITS表来查看死锁信息。\",\"SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;\",\"这个表展示了哪些事务被锁定，以及哪些事务持有其他事务正在等待的锁。\"]},\"581\":{\"h\":\"13. 你遇到过死锁吗，你怎么处理的\",\"t\":[\"解决死锁： 数据库管理系统通常有机制来检测和解决死锁：\",\"死锁检测：系统定期检查事务的执行状态，以识别是否存在死锁。\",\"超时：事务在等待资源超过一定时间后超时，系统自动回滚事务。\",\"回滚：检测到死锁后，系统可能会选择一个或多个事务进行回滚，释放它们持有的资源，从而打破死锁状态。\",\"锁升级：在某些情况下，系统可能会尝试将锁从更细的粒度升级到更粗的粒度，以减少死锁的可能性。\",\"这四种是解决死锁的办法，接下来实操如何发现处理死锁。\",\"监控死锁\",\"show engine innodb status\",\"image-20240527182546406\",\"这里返回了包含详细信息的输出，包括死锁检测到的信息。\",\"解决死锁\",\"回滚事务\",\"ROLLBACK;\",\"杀死引起死锁的进程\",\"找到引起死锁的进程 ID，使用 kill 杀死该进程。\",\"SHOW PROCESSLIST; KILL <process_id>\"]},\"582\":{\"c\":[\"mysql\"]},\"583\":{\"c\":[\"mysql\",\"数据库锁\"]},\"584\":{\"h\":\"Redis\"},\"585\":{\"h\":\"rodert单排学习redis入门【黑铁】\"},\"586\":{\"h\":\"rodert单排学习redis入门【黑铁】\",\"t\":[\"redis入门\",\"欢迎大家前来白嫖PDF。下图回复：666\",\"本教程致力于最实用教程，个别图片粘贴有丢失，还有来领取原版。\",\"在这里插入图片描述\",\"@[toc]\"]},\"587\":{\"h\":\"前言\",\"t\":[\"声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。\",\"本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub\",\"有任何问题都可以来谈谈 ！\",\"在这里插入图片描述\",\"本篇主要是 Redis 的入门，涉及一些基础命令和常见场景。\",\"redis是目前最热的缓存组件之一，如果你还不懂，那就开始，入门到实战\",\"本文主要是 Redis 入门知识，介绍 Redis 特性、使用场景、安装和数据类型。\",\"中文官网：http://www.redis.cn/\"]},\"588\":{\"h\":\"1.NoSql(not only sql)\",\"t\":[\"指非关系型数据库，不支持sql语句，nosql中存储的数据是KV形式\",\"常见的NoSQL产品有：Mongodb、Redis、Hbase hadoop、Cassandra hadoop。\"]},\"589\":{\"h\":\"2.Redis入门\",\"t\":[\"这是一些redis介绍，做一些简单了解即可。\",\"Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis 的开发由Pivotal赞助。\",\"redis 是一个 key-value 存储系统。和 Memcached 类似，它支持存储的 value 类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis 支持各种不同方式的排序。与 memcached 一样，为了保证效率，数据都是缓存在内存中。区别的是 Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave(主从)同步。\",\"Redis 是一个高性能的key-value数据库。 Redis 的出现，很大程度补偿了**memcached**这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。 Redis 支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得 Redis 可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。\",\"Redis 的官网地址，非常好记，是redis.io。（域名后缀io属于国家域名，是british Indian Ocean territory，即英属印度洋领地），Vmware在资助着 Redis 项目的开发和维护。\"]},\"590\":{\"h\":\"3.Redis特性\"},\"591\":{\"h\":\"3.1.性能\",\"t\":[\"下面是官方的bench-mark数据： 测试完成了 50 个并发执行 100000 个请求。 设置和获取的值是一个 256 字节字符串。 Linux box 是运行 Linux 2.6 , 这是 X3320 Xeon 2.5 ghz。 文本执行使用 loopback 接口(127.0.0.1)。 结果:读的速度是 110000次/s ,写的速度是 81000次/s 。\"]},\"592\":{\"h\":\"3.2.特性\",\"t\":[\"**Redis **与其他 key-value 缓存产品有以下三个特点：\",\"**Redis **支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\",\"**Redis **不仅仅支持简单的 **key-value**类型的数据，同时还提供 **list，set，zset，hash **等数据结构的存储。\",\"**Redis **支持数据的备份，即 master-slave 模式的数据备份。\"]},\"593\":{\"h\":\"3.3.优势\",\"t\":[\"性能极高 – **Redis **能读的速度是110000次/s,写的速度是81000次/s 。\",\"丰富的数据类型 – **Redis **支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\",\"原子 – **Redis 的所有操作都是原子性的，同时Redis **还支持对几个操作全并后的原子性执行。\",\"丰富的特性 – **Redis **还支持 publish/subscribe, 通知, key 过期等等特性。\"]},\"594\":{\"h\":\"4.Redis使用场景\",\"t\":[\"目前在互联网公司， Redis 使用非常广泛，我日常工作中，会用它做爬虫采集系统中队列使用，还有在后台管理系统中做分布式，存储 token 使用。\",\"1、缓存\",\"缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis 提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在 Redis 用在缓存的场合非常多。\",\"2、排行榜\",\"很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis 提供的有序集合数据类构能实现各种复杂的排行榜应用。\",\"3、计数器\",\"什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis 提供的 incr 命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。\",\"4、分布式会话\",\"集群模式下，在应用不多的情况下一般使用容器自带的 session 复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以 Redis 等内存数据库为中心的 session 服务，session 不再由容器管理，而是由 session 服务及内存数据库管理。\",\"5、分布式锁\",\"在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用 Redis 的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。\",\"6、社交网络\",\"点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。\",\"7、最新列表\",\"Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。\",\"8、消息系统\",\"消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka 等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis 提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。\"]},\"595\":{\"h\":\"5.安装\"},\"596\":{\"h\":\"5.1.单机安装\"},\"597\":{\"h\":\"5.1.1.windows下\",\"t\":[\"redis 开源在 github 上\",\"下载，解压\",\"下载地址：https://github.com/tporadowski/redis/releases\",\"Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。\",\"运行\",\"解压后，打开 cmd 窗口，cd 切换到 redis根目录下。\",\"redis-server.exe redis.windows.conf\",\"在这里插入图片描述\",\"客户端连接\",\"不要关闭原 cmd 窗口，新打开一个 cmd 窗口，切换到 redis 根目录\",\"redis-cli.exe -h 127.0.0.1 -p 6379\",\"6379 是 redis 默认端口，我们可以在配置中修改\",\"测试\",\"设置 key 值\",\"set myKey abc\",\"取出 key 值\",\"get myKey\"]},\"598\":{\"h\":\"5.1.2.linux下\",\"t\":[\"linux 和 windows 下类似，启动方式参考上文\",\"$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz $ tar xzf redis-2.8.17.tar.gz $ cd redis-2.8.17 $ make\"]},\"599\":{\"h\":\"6.五类数据结构\"},\"600\":{\"h\":\"6.0.说明\",\"t\":[\"类型中会涉及到很多的 Redis 操作命令，一定耐心看完，优化的基础是要了解。\"]},\"601\":{\"h\":\"6.1.介绍\",\"t\":[\"Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。\",\"redis是非常优秀的缓存工具，熟练使用redis，可以让我们的开发进一步。\",\"对于下面操作，可以通过 redis-cli 工具连接使用\"]},\"602\":{\"h\":\"6.2.Redis keys\",\"t\":[\"关于key的几条规则，一定不要以为它们不重要，了解一些对你排查问题至关重要。\",\"Redis key 值是二进制安全的，这意味着可以用任何二进制序列作为key值，从形如”foo”的简单字符串到一个 JPEG 文件的内容都可以。空字符串也是有效 key 值。\",\"关于key的几条规则：\",\"太长的键值不是个好主意，例如1024字节的键值就不是个好主意，不仅因为消耗内存，而且在数据中查找这类键值的计算成本很高。\",\"太短的键值通常也不是好主意，如果你要用”u:1000:pwd”来代替”user:1000:password”，这没有什么问题，但后者更易阅读，并且由此增加的空间消耗相对于**key object和value object**本身来说很小。当然，没人阻止您一定要用更短的键值节省一丁点儿空间。\",\"最好坚持一种模式。例如：”object-type:uid:field”就是个不错的注意，像这样”user:1000:password”。我喜欢对多单词的字段名中加上一个点，就像这样：”comment:q1234:reply.to”。\"]},\"603\":{\"h\":\"6.2.字符串（strings）\",\"t\":[\"二进制安全的字符串\",\"字符串方式是redis最简单的数据类型，redis就像一个可以持久化的memcached服务器。\",\"基本的操作方式**get 和 set **方式\",\"> set mykey somevalue OK > get mykey \\\"somevalue\\\"\",\"例如：当key存在时，set会失败。值的长度不能超过512MB。\",\"一个有趣的操作，原子递增，\",\"> set counter 100 OK > incr counter (integer) 101 > incr counter (integer) 102 > incrby counter 50 (integer) 152\",\"INCR 命令将字符串解析成整型，将其加一，再将结果保存成新的字符串，类似的命令还有 INCRBY , DECR 和 DECRBY 。\",\"还有一个有趣的命令， GETSET 命令：设置新值，返回原值。这个操作有什么用？在我们需要保证原子性操作时\",\"MSET 和 MGET 是批量操作\",\"> mset a 10 b 20 c 30 OK > mget a b c 1) \\\"10\\\" 2) \\\"20\\\" 3) \\\"30\\\"\",\"MGET 命令返回由值组成的数组。\",\"修改和查询存在操作\",\"exists:判断键是否存在，del：删除指定键\",\"> set mykey hello OK > exists mykey (integer) 1 > del mykey (integer) 1 > exists mykey (integer) 0\",\"TYPE 命令返回key对应的存储类型\",\"> set mykey x OK > type mykey string > del mykey (integer) 1 > type mykey none\",\"Redis超时\",\"对 key 设置**超时**。精度可以使用毫秒或秒。\",\"> set key some-value OK > expire key 5 (integer) 1 > get key (immediately) \\\"some-value\\\" > get key (after some time) (nil)\",\"使用了 EXPIRE 来设置超时时间(也可以再次调用这个命令来改变超时时间，使用 PERSIST 命令去除超时时间 )。我们也可以在创建值的时候设置超时时间:\",\"> set key 100 ex 10 OK > ttl key (integer) 9\",\"TTL 命令用来查看key对应的值剩余存活时间。\"]},\"604\":{\"h\":\"6.3.列表（Lists）\",\"t\":[\"值得注意的：Redis lists 基于 Linked Lists 实现。\",\"**Redis 列表**是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）\",\"一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。\",\"Redis Lists 入门\",\"> rpush mylist A (integer) 1 > rpush mylist B (integer) 2 > lpush mylist first (integer) 3 > lrange mylist 0 -1 1) \\\"first\\\" 2) \\\"A\\\" 3) \\\"B\\\"\",\"从右边(尾部)插入俩个元素，左边(头部)插入一个元素，**LRANGE **打印所有(0,-1)元素。\",\"**Redis Lists**常用指令\",\"BLPOP key1 [key2 ] timeout 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\",\"BRPOP key1 [key2 ] timeout 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\",\"BRPOPLPUSH source destination timeout 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\",\"LINDEX key index 通过索引获取列表中的元素\",\"LINSERT key BEFORE|AFTER pivot value 在列表的元素前或者后插入元素\",\"说明：Redis Linsert 命令用于在列表的元素前或者后插入元素。当指定元素不存在于列表中时，不执行任何操作。当列表不存在时，被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。\",\"实例：\",\"redis> RPUSH mylist \\\"Hello\\\" (integer) 1 redis> RPUSH mylist \\\"World\\\" (integer) 2 redis> LINSERT mylist BEFORE \\\"World\\\" \\\"There\\\" (integer) 3 redis> LRANGE mylist 0 -1 1) \\\"Hello\\\" 2) \\\"There\\\" 3) \\\"World\\\" redis>\",\"LLEN key 获取列表长度\",\"LPOP key 移出并获取列表的第一个元素\",\"LPUSH key value1 [value2] 将一个或多个值插入到列表头部\",\"LPUSHX key value 将一个值插入到已存在的列表头部\",\"LRANGE key start stop 获取列表指定范围内的元素\",\"LREM key count value 移除列表元素\",\"count > 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。 count < 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。 count = 0 : 移除表中所有与 VALUE 相等的值。\",\"LSET key index value 通过索引设置列表元素的值\",\"LTRIM key start stop 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。\",\"注意：下标从0开始\",\"RPOP key 移除列表的最后一个元素，返回值为移除的元素。\",\"RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。\",\"RPUSH key value1 [value2] 在列表中添加一个或多个值\",\"RPUSHX key value 为已存在的列表添加值\"]},\"605\":{\"h\":\"6.4.哈希(Hash)\",\"t\":[\"Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\",\"Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。\",\"序号 命令及描述 1 HDEL key field1 [field2] 删除一个或多个哈希表字段 2 HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。 3 HGET key field 获取存储在哈希表中指定字段的值。 4 HGETALL key 获取在哈希表中指定 key 的所有字段和值 5 HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。 6 HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 7 HKEYS key 获取所有哈希表中的字段 8 HLEN key 获取哈希表中字段的数量 9 HMGET key field1 [field2] 获取所有给定字段的值 10 HMSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 11 HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。 12 HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。 13 HVALS key 获取哈希表中所有值。 14 HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。\",\"参考:https://www.runoob.com/redis/redis-hashes.html\"]},\"606\":{\"h\":\"6.5.集合(Set)\",\"t\":[\"Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。\",\"Redis 中**集合 **是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。\",\"序号 命令及描述 1 SADD key member1 [member2] 向集合添加一个或多个成员 2 SCARD key 获取集合的成员数 3 SDIFF key1 [key2] 返回给定所有集合的差集 4 SDIFFSTORE destination key1 [key2] 返回给定所有集合的差集并存储在 destination 中 5 SINTER key1 [key2] 返回给定所有集合的交集 6 SINTERSTORE destination key1 [key2] 返回给定所有集合的交集并存储在 destination 中 7 SISMEMBER key member 判断 member 元素是否是集合 key 的成员 8 SMEMBERS key 返回集合中的所有成员 9 SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合 10 SPOP key 移除并返回集合中的一个随机元素 11 SRANDMEMBER key [count] 返回集合中一个或多个随机数 12 SREM key member1 [member2] 移除集合中一个或多个成员 13 SUNION key1 [key2] 返回所有给定集合的并集 14 SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中 15 SSCAN key cursor [MATCH pattern] [COUNT count] 迭代集合中的元素\",\"参考：https://www.runoob.com/redis/redis-sets.html\"]},\"607\":{\"h\":\"6.6.有序集合(sorted set)\",\"t\":[\"Redis **有序集合 和集合 **一样也是 string 类型元素的集合,且不允许重复的成员。\",\"不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。\",\"有序集合的成员是唯一的,但分数(score)却可以重复。\",\"集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\",\"序号 命令及描述 1 ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数 2 ZCARD key 获取有序集合的成员数 3 ZCOUNT key min max 计算在有序集合中指定区间分数的成员数 4 ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 increment 5 ZINTERSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 6 ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量 7 ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合指定区间内的成员 8 ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员 9 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员 10 ZRANK key member 返回有序集合中指定成员的索引 11 ZREM key member [member ...] 移除有序集合中的一个或多个成员 12 ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员 13 ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员 14 ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员 15 ZREVRANGE key start stop [WITHSCORES] 返回有序集中指定区间内的成员，通过索引，分数从高到低 16 ZREVRANGEBYSCORE key max min [WITHSCORES] 返回有序集中指定分数区间内的成员，分数从高到低排序 17 ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 18 ZSCORE key member 返回有序集中，成员的分数值 19 ZUNIONSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的并集，并存储在新的 key 中 20 ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值）\"]},\"608\":{\"h\":\"7.Redis常用\",\"t\":[\"如果你读到在这里，相信你对 Redis 已经有了一定了解，入门就先简单学到这里，下篇一起上**青铜**。\",\"后面的篇章，还将继续介绍 Redis 的一些高级用法，缓存击穿、缓存雪崩，源码分析等。看后不忘三连，还有需要更多技术博文可以留言催更。\"]},\"609\":{\"c\":[\"redis\"]},\"610\":{\"c\":[\"redis\",\"单排学习redis\"]},\"611\":{\"h\":\"rodert单排学习redis进阶【青铜】\"},\"612\":{\"h\":\"rodert单排学习redis进阶【青铜】\",\"t\":[\"redis之青铜\",\" @[toc]\"]},\"613\":{\"h\":\"前言\",\"t\":[\"声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。\",\"本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub\",\"有任何问题都可以来谈谈 ！\",\"在这里插入图片描述\",\"本篇继续学习 Redis ,上一篇 rodert单排学习redis入门【黑铁】 对 Redis **安装和常用数据**结构做了梳理，如果没看可以先回去看完再继续本篇~\",\"上一篇都是对一些 redis 基本数据类型 api 的讲解，本篇是数据类型底层实现，主要内容有：\",\"为什么使用Redis\",\"Redis数据结构解析\",\"SDS简单动态字符串\",\"哈希表\",\"跳跃表\",\"整数集合\",\"压缩列表\",\"Redis中数据结构的对象\",\"...\"]},\"614\":{\"h\":\"1.再谈Redis\",\"t\":[\"Redis 是什么？官话来说就是：\",\"Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.\",\"Redis 是一个开源的、基于内存的数据结构存储器，可以用作数据库、缓存和消息中间件。\",\"如果想尝试 Redis 命令又懒得安装，可以使用这个 http://try.redis.io/ 网站。\",\"在这里插入图片描述\"]},\"615\":{\"h\":\"2.为什么要用Redis\",\"t\":[\"上一篇咱们有一定了解\",\"Redis 是**基于内存**，常用作缓存的一种技术，并且 Redis 存储的方式是以 key-value 形式。\",\"那我们为什么不用 Java Map？\",\"Java Map是**本地缓存**的，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。\",\"JVM内存太大容易挂掉，还有各种**过期机制、存储结构**需要自己手动来写\",\"Redis 会定期把缓存保存到硬盘，重启恢复数据，丰富的数据结构，缓存机制等实用功能。\"]},\"616\":{\"h\":\"3.为什么要使用缓存？\",\"t\":[\"高并发，高可用这是现在互联网经常提到的一个词。在程序出现大量请求是就会出现**性能问题，一般性能问题第一道就是数据库扛不住了**，数据库的读写会有磁盘操作，而磁盘的速度相对内存来说慢很多。\",\"所有我们在中间加一道缓存：\",\"在这里插入图片描述\"]},\"617\":{\"h\":\"4.Redis数据结构\"},\"618\":{\"h\":\"4.1.SDS简单动态字符串\"},\"619\":{\"h\":\"4.1.1.SDS简单动态字符串\",\"t\":[\"Redis 是由C语言编写的。\",\"我们现在知道 Redis 所有键都是字符串，值有字符串（string）、散列（hash）、列表（list）、集合（set）和有序集合（sorted set）这五种类型的键的底层实现数据结构。\",\"Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。\",\"Redis 使用 sds.h/sdshdr 结构表示一个 SDS 值：\",\"struct sdshdr { // 记录 buf 数组中已使用字节的数量 // 等于 SDS 所保存字符串的长度 int len; // 记录 buf 数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[]; };\",\"在这里插入图片描述\",\"上图是 SDS 示例，以空字符结尾 '\\\\0'。遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数。\",\"举个例子， 如果我们有一个指向图 2-1 所示 SDS 的指针 s ， 那么我们可以直接使用 stdio.h/printf 函数， 通过执行以下语句：\",\"printf(\\\"%s\\\", s->buf);\",\"来打印出 SDS 保存的字符串值 \\\"Redis\\\" ， 而无须为 SDS 编写专门的打印函数。\"]},\"620\":{\"h\":\"4.1.2.SDS简单动态字符串好处\",\"t\":[\"sdshdr数据结构中用len属性记录了字符串的长度。那么获取字符串的长度时，时间复杂度只需要 O(1)。常数复杂度获取字符串长度。\",\"SDS不会发生溢出的问题，如果修改SDS时，空间不足。先会扩展空间，再进行修改！(内部实现了动态扩展机制)。杜绝缓冲区溢出。\",\"SDS可以**减少内存分配的次数(空间预分配机制)。在扩展空间时，除了分配修改时所必要的空间，还会分配额外的空闲空间(free 属性)。减少修改字符串长度时所需的内存重分配次数**。\",\"SDS是**二进制安全**的，SDS 以二进制的方式来处理SDS存放在buf数组里的数据。\",\"可以使用一部分 <string.h> 库中的函数。兼容部分 C 字符串函数。\"]},\"621\":{\"h\":\"4.2.Redis 链表和链表节点\",\"t\":[\"Java 学习者对链表应该都很熟悉，链表是 Java 中一种典型且常用的数据构。\",\"每个**链表节点**使用一个 adlist.h/listNode 结构来表示：\",\"typedef struct listNode { // 前置节点 struct listNode *prev; // 后置节点 struct listNode *next; // 节点的值 void *value; } listNode;\",\"使用listNode是可以组成链表了，Redis中**使用list结构来持有链表**：\",\"typedef struct list { // 表头节点 listNode *head; // 表尾节点 listNode *tail; // 链表所包含的节点数量 unsigned long len; // 节点值复制函数 void *(*dup)(void *ptr); // 节点值释放函数 void (*free)(void *ptr); // 节点值对比函数 int (*match)(void *ptr, void *key); } list;\",\"由一个 list 结构和三个 listNode 结构组成的链表：\",\"在这里插入图片描述\"]},\"622\":{\"h\":\"4.2.2.Redis 链表重点\",\"t\":[\"链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。\",\"每个链表节点由一个 listNode 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。\",\"每个链表使用一个 list 结构来表示，这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。\",\"因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL ， 所以 Redis 的链表实现是无环链表。\",\"通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。\"]},\"623\":{\"h\":\"4.3.Redis 字典\"},\"624\":{\"h\":\"4.3.1.哈希表\",\"t\":[\"字典是 Redis 中的一个概念，Redis 的字典使用哈希表作为底层实现。 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。\",\"空哈希表 Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：\",\"typedef struct dictht { // 哈希表数组 dictEntry **table; // 哈希表大小 unsigned long size; // 哈希表大小掩码，用于计算索引值 // 总是等于 size - 1 unsigned long sizemask; // 该哈希表已有节点的数量 unsigned long used; } dictht;\",\"在这里插入图片描述\",\"哈希表节点 哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：\",\"typedef struct dictEntry { // 键 void *key; // 值 union { void *val; uint64_t u64; //uint64_t整数 int64_t s64; //int64_t整数 } v; // 指向下个哈希表节点，形成链表 struct dictEntry *next; } dictEntry;\",\"在这里插入图片描述\",\"有没有注意到，上图有个冲突，俩个键在同一个节点，这就是 Redis 解决键冲突 ，Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。\",\"字典 Redis 中的字典由 dict.h/dict 结构表示：\",\"typedef struct dict { // 类型特定函数 dictType *type; // 私有数据 void *privdata; // 哈希表 dictht ht[2]; // rehash 索引 // 当 rehash 不在进行时，值为 -1 int rehashidx; /* rehashing not in progress if rehashidx == -1 */ } dict; ------------------分割线--------------------------- typedef struct dictType { // 计算哈希值的函数 unsigned int (*hashFunction)(const void *key); // 复制键的函数 void *(*keyDup)(void *privdata, const void *key); // 复制值的函数 void *(*valDup)(void *privdata, const void *obj); // 对比键的函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 销毁键的函数 void (*keyDestructor)(void *privdata, void *key); // 销毁值的函数 void (*valDestructor)(void *privdata, void *obj); } dictType;\",\"​ ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。\",\"在这里插入图片描述\"]},\"625\":{\"h\":\"4.3.2.Redis rehash(重新散列)\",\"t\":[\"随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的**负载因子**（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。\",\"在对哈希表进行扩展或者收缩操作时，reash 过程并不是一次性地完成的，而是**渐进式**地完成的。\",\"以下是哈希表渐进式 rehash 的详细步骤： 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。\"]},\"626\":{\"h\":\"4.3.3.重点\",\"t\":[\"字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。\",\"Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用。\",\"当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。\",\"哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。\",\"在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。\"]},\"627\":{\"h\":\"4.4.跳跃表\"},\"628\":{\"h\":\"4.4.1.跳跃表\",\"t\":[\"Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向**表头节点和表尾节点**的指针， 等等。\",\"跳跃表节点\",\"typedef struct zskiplistNode { // 后退指针 struct zskiplistNode *backward; // 分值 double score; // 成员对象 robj *obj; // 层 struct zskiplistLevel { // 前进指针 struct zskiplistNode *forward; // 跨度 unsigned int span; } level[]; } zskiplistNode;\",\"zskiplistNode 不同层高节点\",\"在这里插入图片描述\",\"跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的**速度就越快**。\",\"在这里插入图片描述\",\"看到这里，如果还有疑惑，不理解什么是跳跃表，传送一篇不错的跳跃表介绍文章：https://www.cnblogs.com/hunternet/p/11248192.html\"]},\"629\":{\"h\":\"4.4.2.重点\",\"t\":[\"跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。\",\"Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成， 其中 zskiplist 用于保存**跳跃表信息（比如表头节点、表尾节点、长度）， 而 zskiplistNode 则用于表示跳跃表节点**。\",\"每个跳跃表节点的层高都是 1 至 32 之间的**随机数**。\",\"在同一个跳跃表中， 多个节点可以包含**相同的分值， 但每个节点的成员对象必须是唯一**的。\",\"跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。\"]},\"630\":{\"h\":\"4.5.整数集合\",\"t\":[\"整数集合是**集合键(set)**的底层实现之一。\",\"整数集合的底层实现为**数组， 这个数组以有序、无重复的方式保存集合元素，在有需要时， 程序会根据新添加元素**的类型， 改变这个数组的类型。\",\"升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。\",\"整数集合**只支持升级**操作， 不支持降级操作。\",\"整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现**重复元素**。\",\"数据结构：\",\"typedef struct intset { // 编码方式 uint32_t encoding; // 集合包含的元素数量 uint32_t length; // 保存元素的数组 int8_t contents[]; } intset;\",\"在这里插入图片描述\"]},\"631\":{\"h\":\"4.6.压缩列表\"},\"632\":{\"h\":\"4.6.1.前言\",\"t\":[\"同整数集合一样压缩列表也不是基础数据结构，而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片**连续的内存空间**，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。\",\"我们知道，数组要求每个元素大大小相同，如果要存储长度不同的字符串，那就需要用**最大长度**的字符串大小作为元素的大小。以最大长度为标准，就会浪费一部分存储空间。\",\"数组的优势占用一片**连续的空间**可以很好的利用CPU缓存访问数据。如果我们想要保留这种优势，又想节省存储空间我们可以对数组进行压缩。\",\"那就需要给每个节点增加一个 lenght 的属性。\"]},\"633\":{\"h\":\"4.6.2.Redis 压缩列表\",\"t\":[\"压缩列表(zip1ist)是 Redis 列表和 Redis 哈希的底层实现之一。\",\"当一个列表只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表的底层实现。\",\"当一个哈希只包含少量键值对,比且每个键值对的键和值要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做哈希的底层实现。\",\"在这里插入图片描述\",\"参考：https://www.cnblogs.com/hunternet/p/11306690.html\",\"表是Redis为节约内存自己设计的一种顺序型数据结构。\",\"表被用作列表键和哈希键的底层实现之一。\",\"压缩列表可以包含多个节点,每个节点可以保存一个字节数组或者整数值。\",\"添加新节点到压缩列表,或者从压缩列表中删除节点,可能会引发连锁更新操作,但这种操作出现的几率并不高。\"]},\"634\":{\"h\":\"4.7.Redis的对象\"},\"635\":{\"h\":\"4.7.1.Redis的对象\",\"t\":[\"Redis 中当我们创建一个键值对时，我们至少会创建俩个对象，一个用作键(键对象)，一个用作值(值对象)。\",\"Redis 对象结构\",\"typedef struct redisObject { // 类型 unsigned type:4; // 编码 unsigned encoding:4; // 指向底层实现数据结构的指针 void *ptr; // ... } robj;\",\"Redis 内存回收\",\"值得一提的是 redis 内存回收，因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个**引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收**。每个对象的引用计数信息由 redisObject 结构的 refcount 属性记录：\",\"typedef struct redisObject { // ... // 引用计数 int refcount; // ... } robj;\",\"Redis 对象共享\",\"举个例子， 假设键 A 创建了一个包含整数值 100 的字符串对象作为值对象，如果这时键 B 也要创建一个同样保存了整数值 100 的字符串对象作为值对象。\",\"在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：\",\"将数据库键的值指针指向一个现有的值对象；\",\"将被共享的值对象的引用计数增一。\",\"目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。\",\"Redis 对象的空转时长\",\"除了前面介绍过的 type 、 encoding 、 ptr 和 refcount 四个属性之外， redisObject 结构包含的最后一个属性为 lru 属性， 该属性记录了对象最后一次被命令程序访问的时间：\",\"typedef struct redisObject { // ... unsigned lru:22; // ... } robj;\"]},\"636\":{\"h\":\"4.7.2.重点\",\"t\":[\"内存回收和对象的空转时长涉及到 Redis 配置文件(内存的算法 volatile-lru、allkeys-lru等其他知识点)，后面单独一篇详细讲解。\",\"Redis 数据库中的每个键值对的键和值都是一个对象。\",\"Redis 共有字**符串、列表、哈希、集合、有序集合**五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。\",\"服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。\",\"Redis 的对象系统带有引用计数实现的**内存回收机制**， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。\",\"Redis 会共享值为 0 到 9999 的字符串对象。\",\"对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的**空转时间**。\"]},\"637\":{\"c\":[\"redis\"]},\"638\":{\"c\":[\"redis\",\"单排学习redis\"]},\"639\":{\"h\":\"rodert单排学习redis进阶【白银一】\"},\"640\":{\"h\":\"rodert单排学习redis进阶【白银一】\",\"t\":[\"redis之白银一\",\"说些题外话，最近帝都疫情又严重，大家都身处时代洪流中，这不是个别人能左右的，希望你能保护好自己，天天开心。\",\"@[toc]\"]},\"641\":{\"h\":\"前言\",\"t\":[\"声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。\",\"前文推荐阅读：\",\"rodert单排学习redis入门【黑铁】\",\"rodert 单排学习 redis 进阶【青铜】\"]},\"642\":{\"h\":\"1.Redis 客户端\"},\"643\":{\"h\":\"1.1.Redis Desktop Manager\",\"t\":[\"使用称手的工具，做起事来 事半功倍 ，用 redis-cli 自然不错。我推荐一款我经常用的 Redis可视化工具，Redis Desktop Manager 。\",\"启动界面如下：\",\"至于安装方式是 一键安装 。\",\"官网下载地址：https://redisdesktop.com/pricing\",\"学生和学习者可以公众号后台回复：【666】，免费获取。\"]},\"644\":{\"h\":\"2.Redis 连接池\"},\"645\":{\"h\":\"2.2.0.连接池\",\"t\":[\"池技术被广泛使用在系统开发中，像 JDBC 连接池、线程池等。连连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用。\",\"在处理一个任务时，我们大多情况要在数毫秒级别就完成，如果重复创建、关闭资源，会占用较长时间和大量系统资源。\",\"使用连接池优势\",\"减少连接创建时间\",\"连接在系统初始化时就创建完成，需要时直接从池中取用，减少了时间开销。\",\"简化的编程模式\",\"当使用连接池时，每一个单独的线程能够像创建了一个自己的 JDBC 连接一样操作。\",\"受控的资源使用\",\"连接池能够控制一个模块的资源占用率，不会让一个模块资源占用过高，导致整个系统崩溃。\"]},\"646\":{\"h\":\"2.1.Redis 连接池\"},\"647\":{\"h\":\"2.1.1.前言引入\",\"t\":[\"Redis 修炼之连接池篇，前面讲了Redis入门篇：rodert单排学习redis入门【黑铁】、rodert 单排学习 redis 进阶【青铜】，对 Redis 基本数据类型的操作做了讲解。\",\"在以前没有开源连接池时，很多人自写连接池工具，简单来说就是创建一个集合，存放一批连接，动态维护着。保证每个连接都是有效的。\"]},\"648\":{\"h\":\"2.1.2.Redis 连接池\",\"t\":[\"本教程涉及到的一些代码都是 Java 语言编写。\",\"maven 依赖，引入 pom.xml 文件\",\"pom.xml\",\"<dependency> <groupId>redis.clients</groupId> <artifactId>jedis</artifactId> <version>3.3.0</version> </dependency>\",\"RedisUtil.java\",\"public final class RedisUtil { //IP 地址 private static String ADDR = \\\"127.0.0.1\\\"; //端口号 private static int PORT = 6379; //redis 服务端密码 private static String PWD = \\\"123456\\\"; //可用连接实例最大数目，默认为 8，若赋值 -1，表示不被限制 private static Integer MAX_TOTAL = 1024; //控制一个连接池最多有多少个状态为空闲的 jedis 实例，默认值为 8 private static Integer MAX_IDLE = 200; //等待可用连接最大的等待时间，单位 ms，默认值 -1，表示永不超时，若等待超时抛出 JedisConnectionException private static Integer MAX_WAIT_MILLIS = 10000; //超时 private static Integer TIMEOUT = 10000; //在用一个 jedis 实例时，是否提前进行 validate 操作，若结果为 true 则 jedis 实例可用 private static Boolean TEST_ON_BORROW = true; //jedis 连接池 private static JedisPool jedisPool = null; /** * 初始化 jedis 连接池的静态块,RedisPool 第一次类加载时执行，以后便不再执行 */ static { try { JedisPoolConfig conf = new JedisPoolConfig(); /* * 高版本 jedis jar 中 JedisPoolConfig 没有 setMaxActive 和 setMaxWait 属性，因为官方在高版本 * 中启用了此方法，用以下两个属性替换 * maxActive ==> maxTotal * maxWait ==> maxWaitMillis */ //设置连接实例最大数目 conf.setMaxTotal(MAX_TOTAL); //设置最多多少空闲的 jedis 实例 conf.setMaxIdle(MAX_IDLE); //设置等待可用连接的最大时间 conf.setMaxWaitMillis(MAX_WAIT_MILLIS); //设置是否提前进行测试借用 conf.setTestOnBorrow(TEST_ON_BORROW); //新建 jedis 连接池 jedisPool = new JedisPool(conf, ADDR, PORT, TIMEOUT, PWD); } catch (Exception e) { e.printStackTrace(); } } /* * 获取 jedis 实例来操作数据，每次使用完要将连接返回给连接池 jedis.close() * @return */ public synchronized static Jedis getRedis() { try { if(jedisPool != null) { //获取 jedis 实例 Jedis jedis = jedisPool.getResource(); return jedis; } else{ System.out.println(\\\"没有找到 Jedis 连接池！\\\"); return null; } } catch (Exception e) { e.printStackTrace(); return null; } } /* * 用来回收 Jedis 对象资源，用户需要用到此方法释放资源，否则一直占用资源，在新版本中，`returnResource(jedis) 将被废弃不推荐使用，`直接调用 `jedis.close();` 归还连接到连接池。 * @param Jedis jedis */ public synchronized static void returnJedis(Jedis jedis) { try { if(jedis != null) { //回收 jedis 对象资源 jedisPool.returnResource(jedis); System.out.println(\\\"Jedis 被成功回收！\\\"); } } catch (Exception e) { e.printStackTrace(); } } }\",\"本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub\",\"有任何问题都可以来谈谈 ！\",\"在这里插入图片描述\"]},\"649\":{\"c\":[\"redis\"]},\"650\":{\"c\":[\"redis\",\"单排学习redis\"]},\"651\":{\"h\":\"Redis基础数据结构\"},\"652\":{\"h\":\"redis基本类型使用场景都懂了\",\"t\":[\"学习 Redis 基础数据结构，不讲虚的。\",\"一个群友给我发消息，“该学的都学了，怎么就找不到心意的工作，太难了”。\",\"很多在近期找过工作的同学一定都知道了，背诵八股文已经不是找工作的绝对王牌。企业最终要的是可以创造价值，或者首先需要干活的人，所以实战很重要。今天这篇文章就是给大家分享一下如何在我们实战生产中使用 redis。\",\"如果不了解 redis 的同学，可以先学习之前的 redis 入门教程。reids 从黑铁到王者\",\"...\",\"⚠️注意：命令不区分大小写，而 key 是区分大小写的。\"]},\"653\":{\"h\":\"String\",\"t\":[\"String 作为最基本的类型，就是普通的 get、set，做简单的 key - value 存储\",\"应用场景：\",\"比如在商品编号的生成、订单编号的生成（当然现在很少用到了，毕竟现在这种编号已经不足以承载当今的电商服务）\",\"商品编号生成\",\"是否喜欢的文章\",\"文章点赞打赏截图\"]},\"654\":{\"h\":\"Hash\",\"t\":[\"Hash 是一个类似于 Map 的结构，我们可以将整个对象缓存到 redis 中（这个对象不可以在嵌套其他对象），每次读写缓存时可以直接操作 hash 这个对象里的某个字段值。\",\"类似于 Java 中的 Map<String, Map<Object, Object>>\",\"语法：\",\"redis 127.0.0.1:6379> HSET KEY_NAME FIELD VALUE\",\"应用场景：购物车早期，当前小中厂可用\",\"image-20210110223728047\"]},\"655\":{\"h\":\"List\",\"t\":[\"List 就是编程中常用的字符串列表，列表的最大长度是 2^32 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。\",\"比如文章列表、粉丝列表等需要缓存的场景。\",\"可以作为一个单项或者双向队列，lpush、rpop、rpush、lpop。\",\"LRANGE 命令可以指定元素获取区间，实现分页查询，比如微博新闻的列表页面、一些高性能查询的场景\",\"应用场景：\",\"循环抓取新闻的主站点列表\",\"redis 127.0.0.1:6379> RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME\",\"redis 127.0.0.1:6379> RPOPLPUSH news:list:websites news:list:websites\",\"分页查询网站首页的新闻资讯，查询第 0～10 条的数据。\",\"lrange article:list 0 10\"]},\"656\":{\"h\":\"Set\",\"t\":[\"无序列表，自动去重。\",\"和 Java 中的 hashset 一样，当需要进行大量数据的去重、之前你是基于 JVM 在内存去重，现在多机器部署的程序可以基于 redis 去重。\",\"比如需要进行交集计算，两个自媒体账号属于同一个人、他的粉丝一共有多少，需要将两个账号粉丝进行去重统计。当然，并集、差集都可以这样操作。\",\"应用场景：\",\"微信抽奖小程序\",\"image-20210111131808595\",\"image-20210111131949452\",\"微信朋友圈点赞\",\"image-20210111133506484\",\"微博好友关注社交关系\",\"共同关注的人：我去到 gakki 的微博，马上获得我和 gakki 共同关注的人\",\"image-20210111133650920\",\"我关注的人也关注他(大家爱好相同)\",\"image-20210111133831044\",\"qq推荐可能认识的人\",\"image-20210111133958782\"]},\"657\":{\"h\":\"SortedSet\",\"t\":[\"排序的 set，去重但是可以排序，写进去的时候给一个分数，自动根据分数排序，这个可以玩儿很多的花样，最大的特点是有个分数可以自定义排序规则。\",\"比如说你要是想根据时间对数据排序，那么可以写入进去的时候用某个时间作为分数，人家自动给你按照时间排序了。\",\"排行榜：将每个用户以及其对应的什么分数写入进去，zadd board score username，接着 zrevrange board 0 99，就可以获取排名前100的用户；zrank board username，可以看到用户在排行榜里的排名。\",\"应用场景：\",\"根据商品销售对商品进行排序显示。\",\"image-20210111140054296\",\"抖音热搜\",\"image-20210111140639166\",\"下面这三个你可能不太熟悉，耐心看完，这是通俗易懂的。\"]},\"658\":{\"h\":\"Bitmap\",\"t\":[\"Bitmap 大家可能有些陌生，什么是 Bitmap 呢？\",\"Bitmap 的底层数据结构用的是 String 类型的 SDS 数据结构来保存位数组，Redis 把每个字节数组的 8 个 bit 位利用起来，每个 bit 位 表示一个元素的二值状态（不是 0 就是 1）。\",\"可以将 Bitmap 看成是一个 bit 为单位的数组，数组的每个单元只能存储 0 或者 1，数组的下标在 Bitmap 中叫做 offset 偏移量。\",\"8 个 bit 组成一个 Byte，所以 Bitmap 会极大地节省存储空间。 这就是 Bitmap 的优势。\",\"比如判断用户是否登录状态，可以将用户 id 映射为一个唯一 id 编号，将 bit 位映射为 1。\",\"布隆过滤器底层选用的数据结构就是 bitmap（在程序中也用 bitset）。\",\"应用场景：\",\"用户每月签到情况。在签到统计中，每个用户每天的签到用 1 个 bit 位表示，一年的签到只需要 365 个 bit 位。一个月最多只有 31 天，只需要 31 个 bit 位即可。\",\"1. 编号 9527 的用户在 2024 年 1 月 16 号打卡。 SETBIT uid:sign:9527:202401 15 1 2. 判断是否打卡。 GETBIT uid:sign:9527:202401 15 3. 统计 1 月份打卡次数，使用 `BITCOUNT` 命令。该指令用于统计给定的 bit 数组中，值 = 1 的 bit 位的数量。 BITCOUNT uid:sign:9527:202401\"]},\"659\":{\"h\":\"HyperLogLog\",\"t\":[\"HyperLogLog 并非 Redis 一家独有，Redis 只是基于 HyperLogLog 算法实现可一个 HyperLogLog 数据结构，并用该数据结构提供基数统计的功能。其优势就是可以做到只需要 12 kb 的空间大小，就可以实现接近 2^64 量级的基数统计。\",\"HyperLogLog 数据结构并不会保存真实的元数据，所以其核心就是基数估算算法 在工程实践中，通常会用于 App 或页面的 UV 统计。\",\"HyperLogLog 是一种基数估算算法。所谓基数估算，就是估算在一批数据中，不重复元素的个数有多少。\",\"应用场景：\",\"计算 javapub.net.cn 网站的日活跃用户。通过 ip 在程序中用 HashSet 分析、如果有几百万用户，占用存储无疑是很大的。但是用了 HyperLogLog，事情变得如此简单。因为存储日活数据所需要的内存只有 12K。\",\"HyperLogLog 只提供了 3 个简单的命令。\",\"1. 添加元素到 HyperLogLog 中。 PFADD key element [element ...] 127.0.0.1:6379> pfadd website:javapub:uv 39.1.2.0 2. 返回给定 HyperLogLog 的基数估算。 PFCOUNT key [key ...] 127.0.0.1:6379> pfcount website:javapub:uv 3. 将多个 HyperLogLog 合并为一个 HyperLogLog。PFMERGE destkey sourcekey [sourcekey ...] 127.0.0.1:6379> pfmerge website:javapub:uv website:javapub-2:uv\"]},\"660\":{\"h\":\"GEO\",\"t\":[\"看到这个名字就知道是经纬度坐标相关。需要涉及到地图的业务才会使用。\",\"Redis GEO 有如下操作方法：\",\"geoadd：添加地理位置的坐标。\",\"geopos：获取地理位置的坐标。\",\"geodist：计算两个位置之间的距离。\",\"georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。\",\"georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。\",\"geohash：返回一个或多个位置对象的 geohash 值。\",\"应用场景：\",\"计算 Palermo 与 Catania 之间的距离：\",\"redis> GEOADD Sicily 13.361389 38.115556 \\\"Palermo\\\" 15.087269 37.502669 \\\"Catania\\\" (integer) 2 redis> GEODIST Sicily Palermo Catania \\\"166274.1516\\\" redis> GEODIST Sicily Palermo Catania km \\\"166.2742\\\" redis> GEODIST Sicily Palermo Catania mi \\\"103.3182\\\" redis> GEODIST Sicily Foo Bar (nil) redis>\"]},\"661\":{\"c\":[\"redis\"]},\"662\":{\"c\":[\"redis\"]},\"663\":{\"h\":\"Redis分布式锁要点注意\",\"t\":[\"参考： https://juejin.cn/post/7178327462869205051#heading-1\"]},\"664\":{\"h\":\"Redis分布式锁要注意哪几点...离BUG远一点\",\"t\":[\"当前开发中，为了避免应用出现单点故障，大多数应用都会部署多个节点。分布式应用部署，就会涉及到状态同步的场景，比如 session 共享，单点抢占式任务执行、秒杀抢购等等。比如我最近开发中需要一个邮件验证码发送服务，这个邮件服务是一个死循环，持续轮训表里有没有需要发送验证码的邮箱地址，保证实时性的同时，并且不可以重复发送。\",\"这时，分布式锁就成为一个必要、且简单的解决方案。这里基于 Redis 特性和分布式场景来分析会遇到哪些关键点。\",\"前言 众所周知，redis 是单线程应用，就算是 v6 版本也是网络并发、键值读写依然是单线程。\",\"原子操作（setnx + expire）\",\"说到分布式锁，很多人一定会想到 setnx + expire 命令， setnx 用来抢占锁（不存在就创建、存在就不做任何操作），抢到后再设置过期时间。\",\"// 抢占锁 if (jedis.setnx(key_lock, value) == 1) { // 设置过期时间 jedis.expire(key_lock, expiration_time); // TODO Something }\",\"这个代码有很明显的问题，当程序执行完 setnx 后出现异常宕机，这是后这个锁就永久无法释放了。造成的后果是：需要拿到这个锁来获取执行任务权限的应用都停止了。\",\"原文： https://javapub.net.cn/posts/database/redis/\"]},\"665\":{\"c\":[\"redis\",\"分布式\",\"锁\"]},\"666\":{\"c\":[\"redis\",\"分布式\",\"锁\",\"lock\"]},\"667\":{\"h\":\"Linux下redis安装\"},\"668\":{\"h\":\"基于 centOS7 的 redis 安装\",\"t\":[\"基于SpringBoot+VUE的后台管理系统免费开源，欢迎观赏。在线地址：http://liawan.javapub.net.cn/。详细参考文档及视频同步更新。\"]},\"669\":{\"h\":\"前言\",\"t\":[\"安装环境：\",\"centos7、redis5、\"]},\"670\":{\"h\":\"安装教程\"},\"671\":{\"h\":\"1. 下载\",\"t\":[\"国内镜像地址：https://mirrors.huaweicloud.com/redis/\",\"image\"]},\"672\":{\"h\":\"2. 安装\",\"t\":[\"解压：\",\"tar -zxvf redis-5.0.8.tar.gz\",\"编译：\",\"cd redis-5.0.8 make install\"]},\"673\":{\"h\":\"3. 修改配置\",\"t\":[\"修改redis.conf\",\"开启外网访问\",\"bind 0.0.0.0\",\"关闭Redis的服务保护模式\",\"protected-mode no\",\"修改密码\",\"requirepass javapub\"]},\"674\":{\"h\":\"4. 启动\",\"t\":[\"redis-server redis.conf\",\"后台启动：\",\"nohup redis-server redis.conf &\"]},\"675\":{\"h\":\"5. 访问测试\",\"t\":[\"注意，如果外网访问，要保证防火墙对应端口开放。\",\"原文：https://blog.csdn.net/qq_40374604/article/details/124857707\"]},\"676\":{\"c\":[\"redis\"]},\"677\":{\"c\":[\"redis\"]},\"678\":{\"h\":\"JavaSE\"},\"679\":{\"c\":[\"java\"]},\"680\":{\"c\":[\"java\"]},\"681\":{\"h\":\"自定义注解实现AOP切面日志[源码]\",\"t\":[\"https://github.com/Rodert/SpringBoot-javapub/tree/main/spring-boot-annotation\",\"[toc]\"]},\"682\":{\"h\":\"前言\",\"t\":[\"注解是JavaEE的基础，更是在Spring中发扬光大。AOP中有大量使用。\"]},\"683\":{\"h\":\"说明\",\"t\":[\"本案例主要通过俩个实操讲解、演示\",\"切面注解日志\",\"切面注解锁\",\"切面注解权限\",\"后俩个分别再出一个Demo，源码全部都在gitee免费提供\"]},\"684\":{\"h\":\"代码讲解\",\"t\":[\"在这里插入图片描述\"]},\"685\":{\"h\":\"切面注解日志\"},\"686\":{\"h\":\"1. 新建接口\",\"t\":[\"新建接口用于测试\",\"com\\\\javapub\\\\demo\\\\annotation\\\\springbootannotation\\\\controller\"]},\"687\":{\"h\":\"2. 引入依赖\",\"t\":[\" <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-aop</artifactId> </dependency>\"]},\"688\":{\"h\":\"3. 注解\",\"t\":[\"package com.javapub.demo.annotation.springbootannotation.annotation; /** * @Author: JavaPub * @License: https://github.com/Rodert/ https://gitee.com/rodert/ * @Contact: https://javapub.blog.csdn.net/ * @Date: 2022/1/25 15:22 * @Version: 1.0 * @Description: #自定义日志注解。 * <p> * ①：什么时候使用该注解，我们定义为运行时； * ②：注解用于什么地方，我们定义为作用于方法上； * ③：注解是否将包含在 JavaDoc 中； * ④：注解名为 Log; * ⑤：定义一个属性，默认为空字符串； */ import java.lang.annotation.*; @Target(ElementType.METHOD) //注解用于什么地方，我们定义为作用于方法上； @Retention(RetentionPolicy.RUNTIME) //什么时候使用该注解，我们定义为运行时； @Documented //注解是否将包含在 JavaDoc 中； public @interface Log {//注解名为Log String value() default \\\"\\\"; //定义一个属性，默认为空字符串； }\"]},\"689\":{\"h\":\"4. AOP切点类\",\"t\":[\"这里实现了对自定义注解的环绕增强切点，对使用了自定义注解的方法进行AOP切面处理；\",\"对方法运行时间进行监控；\",\"对方法名，参数名，参数值，对日志描述的优化处理；\",\"在方法上增加 @Aspect 注解声明切面,使用 @Pointcut 注解定义切点，标记方法。\",\"使用切点增强的时机注解:@Before (前置通知),@Around,@AfterReturning,@AfterThrowing,@After(后置通知)\",\"在这里插入图片描述\",\"package com.javapub.demo.annotation.springbootannotation.aop; /** * @Author: JavaPub * @License: https://github.com/Rodert/ https://gitee.com/rodert/ * @Contact: https://javapub.blog.csdn.net/ * @Date: 2022/1/25 15:42 * @Version: 1.0 * @Description: 注释式日志切面 */ import lombok.extern.slf4j.Slf4j; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.*; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.stereotype.Component; import java.lang.reflect.Method; import java.util.Arrays; @Slf4j @Aspect //@Aspect：声明该类为一个注解类 @Component public class LogAspect { /** * @Pointcut：定义一个切点，后面跟随一个表达式，表达式可以定义为切某个注解，也可以切某个 package 下的方法； * <p> * 此处的切点是注解的方式，也可以用包名的方式达到相同的效果 * '@Pointcut(\\\"execution(* com.javapub.demo.annotation.springbootannotation.*.*(..))\\\")' */ @Pointcut(\\\"@annotation(com.javapub.demo.annotation.springbootannotation.annotation.Log)\\\") public void logPointCut() { } /** * @param joinPoint * @return * @throws Throwable * @Around 环绕，可以在切入点前后织入代码，并且可以自由的控制何时执行切点； * @Description: 这里其实应该使用 try{}catch(){}finally{} 做容错，为了代码简洁易懂就不加了 */ @Around(\\\"logPointCut()\\\") public Object around(ProceedingJoinPoint joinPoint) throws Throwable { long beginTime = System.currentTimeMillis(); // 执行方法 Object result = joinPoint.proceed(); // 执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; //异步保存日志 saveLog(joinPoint, time); return result; } void saveLog(ProceedingJoinPoint joinPoint, long time) { MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); String methodName = signature.getName(); // 请求的方法名 String className = joinPoint.getTarget().getClass().getName(); System.out.println(\\\"**************************\\\"); System.out.println(method); log.info(\\\"------------------------接口日志-----------------------\\\" + \\\"\\\\n\\\" + \\\"类名称:\\\" + className + \\\"\\\\n\\\" + \\\"方法名:\\\" + methodName + \\\"\\\\n\\\" + \\\"执行时间:\\\" + time + \\\"毫秒\\\"); log.info(\\\"接口参数\\\" + \\\"\\\\n\\\" + Arrays.toString(joinPoint.getArgs())); } /** * 在切点之前，织入相关代码； * * @param joinPoint */ @Before(\\\"logPointCut()\\\") public void doBeforeAdvice(JoinPoint joinPoint) { log.info(\\\"进入方法前执行.....\\\"); } /** * 在切点返回内容后，织入相关代码，一般用于对返回值做些加工处理的场景； * * @param ret */ @AfterReturning(returning = \\\"ret\\\", pointcut = \\\"logPointCut()\\\") public void doAfterReturning(Object ret) { log.info(\\\"方法的返回值 : {}\\\", ret); } /** * 用来处理当织入的代码抛出异常后的逻辑处理; */ @AfterThrowing(\\\"logPointCut()\\\") public void throwss(JoinPoint jp) { log.info(\\\"方法异常时执行.....\\\"); } /** * 后置最终通知,final增强，不管是抛出异常或者正常退出都会执行 */ @After(\\\"logPointCut()\\\") public void after(JoinPoint jp) { log.info(\\\"方法最后执行.....\\\"); } }\"]},\"690\":{\"h\":\"测试\",\"t\":[\"http://127.0.0.1:9001/order/order-info?id=1\",\"http://127.0.0.1:9001/order/order-info-2/1\",\"源码仓库：https://gitee.com/rodert/SpringBoot-javapub/tree/main/spring-boot-annotation\",\"在这里插入图片描述\"]},\"691\":{\"c\":[\"annotation\",\"aop\",\"log\",\"java\"]},\"692\":{\"h\":\"volatile关键字的作用\",\"t\":[\"引言：以前只是看过介绍 volatile 的文章，对其的理解也只是停留在理论的层面上，由于最近在项目当中用到了关于并发方面的技术，所以下定决心深入研究一下java并发方面的知识。网上关于volatile的文章非常多，但是并没有讲解非常详细的文章。（哪位要是有好的资料麻烦共享一份给我！）多数的都是一些理论讲解，没有实际的例子代码，就算有代码的也测试不出效果，总之理论总是与代码不匹配。\",\"后来在我不懈的努力之下总算研究出一些成果，在此分享给大家！如果大家发现有错误的地方欢迎大家指正，谢谢！\",\"在Java线程并发处理中，有一个关键字 volatile 的使用目前存在很大的混淆，以为使用这个关键字，在进行多线程并发处理的时候就可以万事大吉。\",\"Java 语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了 同步块(synchronized) 和 volatile 关键字机制。\",\"synchronized(不做过多解释)\",\"同步块大家都比较熟悉，通过 synchronized 关键字来实现，所有加上synchronized 和 块语句，在多线程访问的时候，同一时刻只能有一个线程能够用\",\"synchronized 修饰的方法 或者 代码块。\",\"volatile\",\"用 volatile 修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile 很容易被误用，用来进行原子性操作。\",\"如果要深入了解 volatile 关键字的作用，就必须先来了解一下 JVM 在运行时候的内存分配过程。\",\"在 java 垃圾回收整理一文中，描述了 jvm 运行时刻内存的分配。其中有一个内存区域是 jvm 虚拟机栈，每一个线程运行时都有一个线程栈，\",\"线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存\",\"变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，\",\"在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。下面一幅图\",\"描述这写交互！\",\"JVM在运行时候的内存分配过程\",\"那么在了解完JVM在运行时候的内存分配过程以后，我们开始真正深入的讨论volatile的具体作用\",\"请看代码:\",\"public class VolatileTest extends Thread { boolean flag = false; int i = 0; public void run() { while (!flag) { i++; } } public static void main(String[] args) throws Exception { VolatileTest vt = new VolatileTest(); vt.start(); Thread.sleep(2000); vt.flag = true; System.out.println(\\\"stope\\\" + vt.i); } }\",\"上面的代码是通过标记flag来控制 VolatileTest 线程 while 循环退出的例子!\",\"下面让我用伪代码来描述一下我们的程序\",\"首先创建 VolatileTest vt = new VolatileTest();\",\"然后启动线程 vt.start();\",\"暂停主线程2秒（Main） Thread.sleep(2000);\",\"这时的 vt 线程已经开始执行，进行i++;\",\"主线程暂停2秒结束以后将 vt.flag = true;\",\"打印语句 System.out.println(\\\"stope\\\" + vt.i); 在此同时由于 vt.flag 被设置为 true,所以 vt 线程在进行下一次 while 判断 while (!flag) 返回假 结束循环 vt 线程方法结束退出！\",\"主线程结束\",\"上面的叙述看似并没有什么问题，“似乎”完全正确。那就让我们把程序运行起来看看效果吧，执行 mian 方法。2 秒钟以后控制台打印 stope-202753974。\",\"可是奇怪的事情发生了 程序并没有退出。vt 线程仍然在运行，也就是说我们在主线程设置的 vt.flag = true;没有起作用。\",\"在这里我需要说明一下，有的同学可能在测试上面代码的时候程序可以正常退出。那是因为你的JVM没有优化造成的！在DOC下面输入 java -version 查看 如果显示Java HotSpot(TM) ... Server 则JVM会进行优化。\",\"如果显示Java HotSpot(TM) ... Client 为客户端模式，需要设置成Server模式 设置方法问Google\",\"java-version\",\"问题出现了，为什么我在主线程（main）中设置了vt.flag = true; 而vt线程在进行判断flag的时候拿到的仍然是false?\",\"那么按照我们上面所讲的 “JVM在运行时候的内存分配过程” 就很好解释上面的问题了。\",\"首先 vt线程在运行的时候会把 变量 flag 与 i (代码3,4行) 从“主内存” 拷贝到 线程栈内存（上图的线程工作内存）\",\"然后 vt 线程开始执行 while 循环\",\" 7 while (!flag) { 8 i++; 9 }\",\"while (!flag) 进行判断的 flag 是在线程工作内存当中获取，而不是从 “主内存”中获取。\",\"i++; 将线程内存中的 i++; 加完以后将结果写回至 \\\"主内存\\\"，如此重复。\",\"然后再说说主线程的执行过程。 我只说明关键的地方\",\"vt.flag = true;\",\"主线程将 vt.flag 的值同样 从主内存中拷贝到自己的线程工作内存 然后修改 flag=true. 然后再将新值回到主内存。\",\"这就解释了为什么在主线程（main）中设置了 vt.flag = true; 而 vt 线程在进行判断 flag 的时候拿到的仍然是 false。那就是因为vt线程每次判断flag标记的时候是从它自己的“工作内存中”取值，而并非从主内存中取值！\",\"这也是 JVM 为了提供性能而做的优化。那我们如何能让 vt 线程每次判断 flag 的时候都强制它去主内存中取值呢。这就是 volatile 关键字的作用。\",\"再次修改我们的代码\",\"public class VolatileTest extends Thread { volatile boolean flag = false; int i = 0; public void run() { while (!flag) { i++; } } public static void main(String[] args) throws Exception { VolatileTest vt = new VolatileTest(); vt.start(); Thread.sleep(2000); vt.flag = true; System.out.println(\\\"stope\\\" + vt.i); } }\",\"在 flag 前面加上 volatile 关键字，强制线程每次读取该值的时候都去“主内存”中取值。在试试我们的程序吧，已经正常退出了。\",\"可见性-volatile写\"]},\"693\":{\"c\":[\"volatile\",\"java\"]},\"694\":{\"h\":\"Maven\"},\"695\":{\"c\":[\"java\",\"maven\"]},\"696\":{\"c\":[\"java\",\"maven\"]},\"697\":{\"h\":\"rodert教你学Maven-实战这一篇就够了\"},\"698\":{\"h\":\"rodert教你学Maven-实战这一篇就够了\",\"t\":[\"[toc]\",\"声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。\",\"本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：JavaPub\",\"有任何问题都可以来谈谈，等你哦！\",\"微信公众号\",\"我搞Java也有段时间了，对maven的理解停留在能管理依赖、作为仓库使用，那它还能干什么？\",\"我前面发过一些实战项目，很多初学者和爱好者都有用到，但是对其中maven不了解，不知道如何部署。应一位fans同学要求，redert肝一篇maven，各位看官。\",\"这是一篇文档型文章，能对maven有一个完整的了解。\",\"搞Java都能说出，maven是什么，他都能回答出maven是一个项目管理工具，这篇文章学习再来一起学习。\",\"Maven是基于项目对象模型(POM Project Object Model)，可以通过一小段描述信息（配置文件）来管理项目的构建、报告和文档的软件项目管理工具。\",\"其官网地址为：http://maven.apache.org\",\"这段官方文档已经说的很明白\",\"Maven翻译为“专家”、“内行”；是一个采用纯Java编写的开源项目管理工具，Maven采用了一种被称之为Project Object Model (POM)概念来管理项目，所有的项目配置信息都被定义在一个叫做POM.xml的文件中, 通过该文件Maven可以管理项目的整个声明周期，包括清除、编译、测试、报告、打包、部署等。目前Apache下绝大多数项目都已经采用Maven进行管理. 而Maven本身还支持多种插件，可以方便更灵活的控制项目, 开发人员的主要任务应该是关注业务逻辑并去实现它，而不是把时间浪费在学习如何在不同的环境中去依赖jar包、项目部署等。Maven正是为了将开发人员从这些任务中解脱出来而诞生的一个项目管理工具。\"]},\"699\":{\"h\":\"2.1.Maven的功能\",\"t\":[\"Maven是跨平台的项目管理工具。主要服务于基于Java平台的项目构建，依赖管理和项目信息管理。\",\"什么是项目构建？\",\"什么是理想的项目构建？\",\"高度自动化，跨平台，可重用的组件，标准化的\",\"什么是依赖？为什么要进行依赖管理？\",\"自动下载，统一依赖管理\",\"有哪些项目信息？\",\"项目名称描述，开发人员信息等\"]},\"700\":{\"h\":\"2.2.为什么使用maven\",\"t\":[\"下面这几个痛点，相信是每个Java攻城狮都遇到过的。\",\"传统方式管理jar依赖的问题：\",\"jar冲突 jar依赖 jar体积过大 jar在不同阶段无法个性化配置\",\"使用maven方式管理jar依赖的好处：\",\"解决jar冲突 解决jar依赖问题 jar文件不用在每个项目保存，只需要放在仓库即可 maven可以指定jar的依赖范围\"]},\"701\":{\"h\":\"3.1.安装\",\"t\":[\"现在为止应该没有使用jdk1.7以下的吧，如果有，这篇文章可以跳过。\",\"1. 下载Maven\",\"下载地址：http://maven.apache.org/download.cgi\",\"下载地址\",\"2. 解压文件\",\"解压maven压缩包“apache-maven-3.5.2.bin.zip”到一个路径（尽量编码路径中不要包含中文）\",\"image-20200610223114895\",\"bin：含有mvn运行的脚本\",\"boot：含有plexus-classworlds类加载器框架\",\"lib：含有Maven运行时所需要的java类库\",\"conf：含有settings.xml配置文件\",\"settings.xml 中默认的用户库: ${user.home}/.m2/repository[通过- maven下载的jar包都会存储到此仓库中]\"]},\"702\":{\"h\":\"3.2.配置\",\"t\":[\"1. 添加环境变量MAVEN_HOME\",\"MAVEN_HOME : E:\\\\maven\\\\apache-maven-3.5.2-bin（注意：配置为你自己的maven路径）\",\"MAVEN_OPTS : -Xms256m -Xmx512m（注意：可以不配置）\",\"2. 设置系统环境变量path\",\"在Path中追加: %MAVEN_HOME%\\\\bin\",\"image-20200610223813357\",\"3. 验证成功\",\"打开 cmd 输入：mvn -version\",\"maven_version\",\"4. 配置本地仓库\",\"Maven的默认本地仓库在：${user.home}/.m2/repository；这地址可以在settings.xml中修改指定自定义的仓库路径。\",\"【自定义仓库路径】 找到${maven_home}/conf/settings.xml文件，修改如下：\",\"maven_setting_repository\",\"需要注意的是上图中的自定义路径必须存在。repository是本地仓库，也即本地下载的jar存放路径。\",\"到这里为止，你的项目已经可以打包、部署，做一些简单操作了。\",\"这是一套科学的约定，使用它\",\"什么是Maven项目规约？其实就是maven项目的目录结构。\",\"maven项目的目录结构遵守以下规范：\",\"maven项目目录\"]},\"703\":{\"h\":\"5.1.命令行构建Java项目\",\"t\":[\"下面通过maven命令，快速构建一个java项目结构。\",\"在命令行中可以通过Maven中的命令（插件）可以自动创建文件结构和自动生成pom.xml文件。\",\"打开cmd，执行以下cmd命令：\",\"mvn archetype:generate -DarchetypeCatalog=internal -DgroupId=com.yiidian -DartifactId=hellojava -DarchetypeArtifactId=maven-archetype-quickstart -Dversion=0.0.1-snapshot\",\"执行后结果：\",\"image-20200610225900548\",\"参数说明： #核心命令 mvn 框架:生成 即生成Maven项目最基本的目录结构 mvn archetype:generate #读取archetype-catalog.xml文件的位置；内置的 -DarchetypeCatalog=internal #公司域名倒写 -DgroupId=com.yiidian #项目名称 -DartifactId=hellojava #Maven项目的模板；最简单的Maven项目模板 -DarchetypeArtifactId=maven-archetype-quickstart #项目版本号，snapshot 内测版，release 正式发行版 -Dversion=0.0.1-snapshot\"]},\"704\":{\"h\":\"5.2.使用命令行创建web项目\",\"t\":[\"创建web项目时，不但创建目录结构和pom.xml，并创建webapp目录放置web资源文件。\",\"执行以下cmd命令：\",\"mvn archetype:generate -DarchetypeCatalog=internal -DgroupId=com.yiidian -DartifactId=helloweb -DarchetypeArtifactId=maven-archetype-webapp -Dversion=0.0.1-snapshot\",\"执行后结果：\",\"image-20200610230144920\",\"参数说明： #核心命令 mvn 框架:生成 即生成Maven项目最基本的目录结构 mvn archetype:generate #读取archetype-catalog.xml文件的位置；内置的 -DarchetypeCatalog=internal #公司域名倒写 -DgroupId=com.yiidian #项目名称 -DartifactId=helloweb #Maven项目的模板；Maven web项目模板 -DarchetypeArtifactId=maven-archetype-webapp #项目版本号 -Dversion=0.0.1-snapshot\"]},\"705\":{\"h\":\"5.3.构建Maven项目命令的使用\",\"t\":[\"注意：进入项目后再操作\",\"mvn clean\",\"清除原来的编译结果 \",\"mvn compile\",\"编译 \",\"mvn test\",\"运行测试代码；mvn test -Dtest=类名//单独运行测试类 \",\"mvn package\",\"打包项目；mvn package -Dmanven.test.skip=true//打包时不执行测试 \",\"mvn install\",\"将项目打包并安装到本地仓库 \",\"mvn deploy\",\"发布到本地仓库或者服务器 \",\"我常用的打包命令：\",\"mvn clean install -DskipTests\",\"了解内容，可跳过\",\"Maven在某个统一的位置存储所有项目的共享的构件，这个统一的位置，就称之为仓库。（仓库就是存放依赖和插件的地方）Maven的仓库有两大类：\",\"本地仓库 远程仓库，在远程仓库中又分成了3种：中央仓库、私服、其它公共库。\",\"本地仓库：就是Maven在本机存储构件的地方。maven的本地仓库，在安装maven后并不会创建，它是在第一次执行maven命令的时候才被创建。maven本地仓库的默认位置：在用户的目录下都只有一个.m2/repository/的仓库目录；可以修改。\",\"中央仓库：包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。开源的Java项目依赖的构件都可以在这里下载到。 中央仓库的地址：http://repo1.maven.org/maven2/\",\"私服：是一种特殊的远程仓库，它是架设在局域网内的仓库。\",\"没有使用私服的仓库构件下载\",\"使用私服的仓库构件下载\",\"在平面几何中坐标（x,y）可以标识平面中唯一的一点。\",\"Maven坐标主要组成 groupId：定义当前Maven项目隶属项目、组织 artifactId：定义实际项目中的一个模块 version：定义当前项目的当前版本 packaging：定义该项目的打包方式（pom/jar/war，默认为jar） groupId、artifactId、version简称为GAV。\",\"Maven为什么使用坐标？\",\"Maven世界拥有大量构件，需要找一个用来唯一标识一个构建的统一规范 拥有了统一规范，就可以把查找工作交给机器\",\"如何获取Maven坐标\",\"推荐一个Maven坐标查询网站：http://mvnrepository.com/\",\"网站上可以搜索具体的组织或项目关键字，之后复制对应的坐标到pom.xml中。如：\",\"image-20200610231456317\"]},\"706\":{\"h\":\"8.1.依赖范围\",\"t\":[\"参考：http://www.yiidian.com/maven/maven-dependence.html\",\"依赖范围scope 用来控制依赖和编译，测试，运行的classpath的关系。具体的依赖范围有如下6种：\",\"compile： 默认编译依赖范围。对于编译，测试，运行三种classpath都有效\",\"test：测试依赖范围。只对于测试classpath有效\",\"provided：已提供依赖范围。对于编译，测试的classpath都有效，但对于运行无效。因为由容器已经提供，例如servlet-api\",\"runtime：运行时提供。例如:jdbc驱动\",\"system：系统范围,自定义构件，指定systemPath；跟provided 相似，但是在系统中要以外部JAR包的形式提供，maven不会在repository查找它。\",\"import：只使用在 <dependencyManagement> 中，表示从其它的pom中导入dependency的配置。\",\"依赖范围\",\"下面是为了解决冲突依赖内容，如果你在写一个Demo，可作为了解部份。\"]},\"707\":{\"h\":\"8.2.传递性依赖\",\"t\":[\"假设 C 依赖 B ， B 依赖 A ，那么称 C 对 B 是第一直接依赖， B 对 A 是第二直接依赖， C 对 A 是传递依赖。\",\"对于传递性依赖，依赖的范围如下表：\"]},\"708\":{\"h\":\"8.3.可选依赖\",\"t\":[\"在依赖节点dependency中的<optional>可以控制当前的依赖是否向下传递；默认值为false，表示向下传递。\",\"【示例】A项目依赖于log4j，然后B项目依赖于A项目；那么如果在A中对log4j依赖的optional配置成false时，B项目中自动传递依赖于log4j。否则反之。\",\"1）项目A配置slf4j的依赖并设置optional为true\",\" <dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-log4j12</artifactId> <version>1.6.4</version> <!-- 配置为true时不向下传递此依赖，默认为false --> <optional>true</optional> </dependency>\",\"2）配置项目B依赖于项目A，检查项目B的依赖包\",\"<!-- 依赖于A --> <dependency> <groupId>com.JavaPub</groupId> <artifactId>A</artifactId> <version>0.0.1-SNAPSHOT</version> </dependency>\",\"这时发现B项目没有依赖slf4j-log4j12\"]},\"709\":{\"h\":\"8.4.依赖冲突\",\"t\":[\"依赖冲突是很常见的问题\",\"如果直接与间接依赖中包含有同一个坐标不同版本的资源依赖，以直接依赖的版本为准（就近原则）\",\"最终A依赖的X的版本为2.0\",\"【比如】：项目A中，依赖了slf4j1.6.4版本的包，通过slf4j1.6.4间接依赖log4j1.2.16版本；如果项目A中直接配置了log4j 1.2.17版本，那么最终的版本为1.2.17。\",\"<dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-log4j12</artifactId> <version>1.6.4</version> <!-- 配置为true时不向下传递此依赖，默认为false --> <optional>true</optional> </dependency> <dependency> <groupId>log4j</groupId> <artifactId>log4j</artifactId> <version>1.2.17</version> </dependency>\",\"如果直接依赖中包含有同一个坐标不同版本的资源依赖，以配置顺序下方的版本为准\",\"如果间接依赖中包含有同一个坐标不同版本的资源依赖，以配置顺序上方的版本为准\",\"如下对应spring-core的间接依赖的版本号，以struts2-spring-plugin为准\",\"<dependency> <groupId>org.apache.struts</groupId> <artifactId>struts2-spring-plugin</artifactId> <version>2.3.24.1</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-beans</artifactId> <version>4.1.0.RELEASE</version> </dependency>\"]},\"710\":{\"h\":\"8.4.排除依赖\",\"t\":[\"这个在项目中使用频率较高\",\"在pom中的依赖节点中，如果引入的依赖包含了很多其它的传递依赖，而且项目需要的这些依赖的版本和传递依赖的不相符；那么可以在依赖节点中设置排除依赖节点：<exclusions> 然后再添加 <exclusion>，其里面的内容包括： ①所包含坐标 ②排除依赖包中所包含的依赖关系 【注意】不需要添加版本，直接按照类别排除\",\"<dependency> <groupId>org.apache.struts</groupId> <artifactId>struts2-spring-plugin</artifactId> <version>2.3.24.1</version> <exclusions> <!-- 排除spring-core的传递依赖 --> <exclusion> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> <eclusion> <exclusions> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-beans</artifactId> <version>4.1.0.RELEASE</version> </dependency>\"]},\"711\":{\"h\":\"9.1.Maven生命周期\",\"t\":[\"Maven生命周期就是为了对所有的构建过程进行抽象和统一；包括项目清理，初始化，编译，打包，测试，部署等几乎所有构建步骤。 Maven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是：\",\"Clean Lifecycle 在进行真正的构建之前进行一些清理工作。\",\"Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。\",\"Site Lifecycle 生成项目报告，站点，发布站点。\",\"再次强调它们是相互独立的，可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。不过也可以直接运行 mvn clean install site 运行所有这三套生命周期。\"]},\"712\":{\"h\":\"9.2.clean生命周期\",\"t\":[\"clean生命周期每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是clean生命周期的一个阶段。有clean生命周期，也有clean阶段。clean生命周期一共包含了三个阶段：\",\"pre-clean 执行一些需要在clean之前完成的工作\",\"clean 移除所有上一次构建生成的文件\",\"post-clean 执行一些需要在clean之后立刻完成的工作\",\"mvn clean 中的clean就是上面的clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，mvn clean 等同于 mvn pre-clean clean ，如果我们运行 mvn post-clean ，那么 pre-clean，clean 都会被运行。这是Maven很重要的一个规则，可以大大简化命令行的输入。\"]},\"713\":{\"h\":\"9.3.default生命周期\",\"t\":[\"default生命周期default生命周期是Maven生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。比较重要和常用的阶段如下：\",\"validate generate-sources process-sources generate-resources process-resources 复制并处理资源文件，至目标目录，准备打包。 compile 编译项目的源代码。 process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources 复制并处理资源文件，至目标测试目录。 test-compile 编译测试源代码。 process-test-classes test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 prepare-package package 接受编译好的代码，打包成可发布的格式，如 JAR 。 pre-integration-test integration-test post-integration-test verify 运行任何检查，验证包是否有效且达到质量标准。 install 将包安装至本地仓库，以让其它项目依赖。 deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享。 运行任何一个阶段的时候，它前面的所有阶段都会被运行，这也就是为什么运行mvn install 的时候，代码会被编译，测试，打包。此外，Maven的插件机制是完全依赖Maven的生命周期的。\"]},\"714\":{\"h\":\"9.4.site生命周期\",\"t\":[\"site生命周期包含如下4个阶段：\",\"pre-site 执行一些需要在生成站点文档之前完成的工作\",\"site 生成项目的站点文档\",\"post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备\",\"site-deploy 将生成的站点文档部署到特定的服务器上\",\"这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。\",\"参考：http://www.yiidian.com/maven/maven-plugins.html\"]},\"715\":{\"h\":\"11.1.maven继承\",\"t\":[\"继承为了消除重复，可以把pom中很多相同的配置提取出来；如：grouptId，version等。在使用的时候子工程直接继承父工程的依赖版本号，子工程中不再需要指定具体版本号，方便统一管控项目的依赖版本问题。\",\"父工程设置依赖\",\"<project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>cn.sm1234</groupId> <artifactId>parent</artifactId> <version>0.0.1-SNAPSHOT</version> <packaging>pom</packaging> <!-- 集中定义依赖版本号 --> <properties> <junit.version>4.10</junit.version> <spring.version>4.1.0.RELEASE</spring.version> <slf4j.version>1.6.4</slf4j.version> </properties> <!-- 版本锁定，当子工程中有需要并且自行添加了具体依赖后才有效 --> <dependencyManagement> <dependencies> <!-- 单元测试 --> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>${junit.version}</version> <scope>test</scope> </dependency> <!-- Spring --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>${spring.version}</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-beans</artifactId> <version>${spring.version}</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-aspects</artifactId> <version>${spring.version}</version> </dependency> <dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-log4j12</artifactId> <version>${slf4j.version}</version> </dependency> </dependencies> </dependencyManagement> </project>\",\"子工程设置依赖\",\"在子工程中的pom.xml需要设置父工程：\",\"<project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <!-- 父工程 --> <parent> <groupId>cn.sm1234</groupId> <artifactId>parent</artifactId> <version>0.0.1-SNAPSHOT</version> <!-- 父项目的pom.xml文件的相对路径；一般可不指定 --> <relativePath>../parent</relativePath> </parent> <groupId>cn.sm1234</groupId> <artifactId>sm1234-C</artifactId> <version>0.0.1-SNAPSHOT</version> <!-- 依赖 --> <dependencies> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <!-- 版本号由父工程里面统一指定不再需要特别指定 --> <!-- <version>${junit.version}</version> --> <scope>test</scope> </dependency> </dependencies> </project>\",\"relativePath：父项目的pom.xml文件的相对路径。默认值为../pom.xml。maven首先从当前构建项目开始查找父项目的pom文件，然后从本地仓库，最后从远程仓库。RelativePath允许你选择一个不同的位置；一般Eclipse找不到parent项目时可以先update project，还不行则可配置此项。\"]},\"716\":{\"h\":\"11.2.聚合\",\"t\":[\"多模块项目是现在开发中比较常用的方式。\",\"如果想一次构建多个项目模块，那则需要对多个项目模块进行聚合。\",\"<modules> <module>../子项目名称1</module> <module>../子项目名称2</module> <module>../子项目名称3</module> </modules>\",\"很实用，推荐阅读\",\"参考：http://www.yiidian.com/maven/maven-ssh-project.html\"]},\"717\":{\"c\":[\"java\",\"maven\"]},\"718\":{\"c\":[\"java\",\"maven\"]},\"719\":{\"h\":\"MyBatis\"},\"720\":{\"c\":[\"mybatis\",\"java\"]},\"721\":{\"c\":[\"mybatis\",\"java\"]},\"722\":{\"h\":\"MyBatisSQL批量更新（代码➕案例）\",\"t\":[\"一条记录update一次，性能比较差，容易造成阻塞。基于 mybatis 批量更新，特此记录。\",\"[toc]\"]},\"723\":{\"h\":\"1.场景\",\"t\":[\"当我们在做更新或者是插入操作时，数据为多对多、一一对应的情况\",\"例如：\",\"编号。 名字。 状态 1 tom 0 2 jerry 0 3 jeck 1\",\"代码中循环写入、更新这是大多数人做法，但是肯定不是最优解\"]},\"724\":{\"h\":\"2.MyBatis XML\",\"t\":[\"先直接上个终极版\",\"这里数据库中存储了下划线式，代码中用驼峰式。\",\"这里是通过userId修改userStatus。当user_id为1时、user_status为0，当user_id为3时、user_status为1。\",\" <update id=\\\"updateBatch\\\"> update <include refid=\\\"tableName\\\"/> <trim prefix=\\\"set\\\" suffixOverrides=\\\",\\\"> <trim prefix=\\\"user_status =case\\\" suffix=\\\"end,\\\"> <foreach collection=\\\"list\\\" item=\\\"i\\\" index=\\\"index\\\"> <if test=\\\"i.userId!=null\\\"> when user_id=#{i.userId} then #{i.userStatus} </if> </foreach> </trim> </trim> where user_id in <foreach collection=\\\"list\\\" item=\\\"i\\\" index=\\\"index\\\" open=\\\"(\\\" separator=\\\",\\\" close=\\\")\\\"> #{i.userId} </foreach> </update>\",\"<trim 属性说明\",\"prefix,suffix 表示在 trim 标签包裹的部分的前面或者后面添加内容\",\"如果同时有 prefixOverrides,suffixOverrides 表示会用 prefix,suffix 覆盖 Overrides 中的内容。\",\"如果只有 prefixOverrides,suffixOverrides 表示删除开头的或结尾的 xxxOverides 指定的内容。\"]},\"725\":{\"h\":\"2.1.打印sql\",\"t\":[\"==> Preparing: update `table_test_01` set user_status =case when user_id=? then ? when user_id=? then ? end where user_id in ( ? , ? ) ==> Parameters: 1(Long), 10(Integer), 2(Long), 20(Integer), 1(Long), 2(Long) <== Updates: 2\"]},\"726\":{\"h\":\"2.2.数据库结构\",\"t\":[\"SQL结构体：\",\"CREATE TABLE `table_test_01` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) NOT NULL, `status` tinyint(4) NOT NULL DEFAULT '0', `test_column` varchar(32) NOT NULL DEFAULT '' COMMENT '测试字段', `user_id` bigint(20) NOT NULL DEFAULT '0' COMMENT '测试字段id', `user_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '测试字段status', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=latin1;\",\"INSERT INTO `table_test_01` VALUES (1, 'tom', 0, '', 1, 10), (2, 'jetty', 0, '', 2, 20), (3, 'dog', 0, '', 3, 1), (4, 'cat', 0, '', 4, 1);\"]},\"727\":{\"h\":\"3.实例二\",\"t\":[\"多个字段更新，那就增加 <item 。\",\"使用 case when 语法。\",\"UPDATE course SET name = CASE id WHEN 1 THEN 'name1' WHEN 2 THEN 'name2' WHEN 3 THEN 'name3' END, title = CASE id WHEN 1 THEN 'New Title 1' WHEN 2 THEN 'New Title 2' WHEN 3 THEN 'New Title 3' END WHERE id IN (1,2,3)\",\"这条sql的意思是，如果id为1，则name的值为name1，title的值为New Title1；依此类推。\",\" <update id=\\\"updateBatch1\\\" parameterType=\\\"list\\\"> update course <trim prefix=\\\"set\\\" suffixOverrides=\\\",\\\"> <trim prefix=\\\"name=case\\\" suffix=\\\"end,\\\"> <foreach collection=\\\"list\\\" item=\\\"item\\\" index=\\\"index\\\"> <if test=\\\"item.name!=null\\\"> when id=#{item.id} then #{item.name} </if> </foreach> </trim> <trim prefix=\\\"title =case\\\" suffix=\\\"end,\\\"> <foreach collection=\\\"list\\\" item=\\\"item\\\" index=\\\"index\\\"> <if test=\\\"item.title!=null\\\"> when id=#{item.id} then #{item.title} </if> </foreach> </trim> </trim> where <foreach collection=\\\"list\\\" separator=\\\"or\\\" item=\\\"item\\\" index=\\\"index\\\"> id=#{item.id} </foreach> </update>\"]},\"728\":{\"h\":\"4.重点\",\"t\":[\"但是大家要注意一点，这种情况如果出错，我们并不知道是哪条错误，如果使用事务，就会全部回滚，好的办法就是一次批量一部分，分担出错概率。\",\"源码案例下载：https://download.csdn.net/download/qq_40374604/19765415\"]},\"729\":{\"c\":[\"MyBatis\",\"java\"]},\"730\":{\"h\":\"rodert教你学MyBatis-实战这一篇就够了\"},\"731\":{\"h\":\"rodert教你学MyBatis-实战这一篇就够了\",\"t\":[\"[toc]\"]},\"732\":{\"h\":\"前言\",\"t\":[\"声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。\",\"本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。 欢迎关注公众号，白嫖原创PDF，也可以催更，微信搜：JavaPub\",\"有任何问题都可以来谈谈，等你哦！\",\"微信公众号\",\"对mybatis有一定了解的，可以直接跳过前面基础引入部分。\"]},\"733\":{\"h\":\"1，什么是Mybatis之JDBC攻城狮\"},\"734\":{\"h\":\"1,1，使用idea构建maven工程\"},\"735\":{\"h\":\"1，2，引入mysql依赖包\",\"t\":[\"<dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.32</version> </dependency>\"]},\"736\":{\"h\":\"1，3，准备数据\",\"t\":[\"创建数据库：\",\"create database mydatabase;\",\"创建表：\",\"DROP TABLE IF EXISTS tb_user; CREATE TABLE tb_user ( id char(32) NOT NULL, user_name varchar(32) DEFAULT NULL, password varchar(32) DEFAULT NULL, name varchar(32) DEFAULT NULL, age int(10) DEFAULT NULL, sex int(2) DEFAULT NULL, birthday date DEFAULT NULL, created datetime DEFAULT NULL, updated datetime DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;\",\"插入数据\",\"INSERT INTO mydatabase.tb_user ( userName, password, name, age, sex, birthday, created, updated) VALUES ( ‘zpc’, ‘123456’, ‘小明’, ‘22’, ‘1’, ‘1990-09-02’, sysdate(), sysdate()); INSERT INTO mydatabase.tb_user ( userName, password, name, age, sex, birthday, created, updated) VALUES ( ‘hj’, ‘123456’, ‘静静’, ‘22’, ‘1’, ‘1993-09-05’, sysdate(), sysdate());\"]},\"737\":{\"h\":\"1,4，jdbc代码回顾\",\"t\":[\"JDBCTest.class\",\"7步操作数据库\",\"import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; /** * @author Evan */ public class JDBCTest { public static void main(String[] args) throws Exception { Connection connection = null; PreparedStatement prepareStatement = null; ResultSet rs = null; try { // 1,加载驱动 Class.forName(\\\"com.mysql.jdbc.Driver\\\"); // 2,获取连接 String url = \\\"jdbc:mysql://127.0.0.1:3306/mydatabase\\\"; String user = \\\"root\\\"; String password = \\\"123456\\\"; connection = DriverManager.getConnection(url, user, password); // 3,获取statement，preparedStatement String sql = \\\"select * from tb_user where id=?\\\"; prepareStatement = connection.prepareStatement(sql); // 4,设置参数 prepareStatement.setLong(1, 1l); // 5,执行查询 rs = prepareStatement.executeQuery(); // 6,处理结果集 while (rs.next()) { System.out.println(rs.getString(\\\"userName\\\")); System.out.println(rs.getString(\\\"name\\\")); System.out.println(rs.getInt(\\\"age\\\")); System.out.println(rs.getDate(\\\"birthday\\\")); } } finally { // 7,关闭连接，释放资源 if (rs != null) { rs.close(); } if (prepareStatement != null) { prepareStatement.close(); } if (connection != null) { connection.close(); } } } }\"]},\"738\":{\"h\":\"1，5，jdbc缺点分析\",\"t\":[\".\\\\rodert教你学MyBatis-实战这一篇就够了\\\\一号图片.jpg\"]},\"739\":{\"h\":\"4，MyBatis介绍\",\"t\":[\"介绍截图\",\"官方文档 http://www.mybatis.org/mybatis-3/getting-started.html\"]},\"740\":{\"h\":\"3，MyBatis整体架构\",\"t\":[\"架构图\"]},\"741\":{\"h\":\"4，快速入门（quick start）\"},\"742\":{\"h\":\"4，1，引入依赖(pom.xml)\",\"t\":[\"<dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.2.8</version> </dependency>\"]},\"743\":{\"h\":\"4，2，全局配置文件(mybatis-config.xml)\",\"t\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <!-- 根标签 --> <configuration> <!--<properties>--> <!-- <property name=\\\"driver\\\" value=\\\"com.mysql.jdbc.Driver\\\"/>--> <!-- <property name=\\\"url\\\" value=\\\"jdbc:mysql://127.0.0.1:3306/mybatis-110?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true\\\"/>--> <!-- <property name=\\\"username\\\" value=\\\"root\\\"/>--> <!-- <property name=\\\"password\\\" value=\\\"123456\\\"/>--> <!--</properties>--> <!-- 环境，可以配置多个，default：指定采用哪个环境 --> <environments default=\\\"test\\\"> <!-- id：唯一标识 --> <environment id=\\\"test\\\"> <!-- 事务管理器，JDBC类型的事务管理器 --> <transactionManager type=\\\"JDBC\\\" /> <!-- 数据源，池类型的数据源 --> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"com.mysql.jdbc.Driver\\\" /> <property name=\\\"url\\\" value=\\\"jdbc:mysql://127.0.0.1:3306/mybatis-110\\\" /> <property name=\\\"username\\\" value=\\\"root\\\" /> <property name=\\\"password\\\" value=\\\"123456\\\" /> </dataSource> </environment> <environment id=\\\"development\\\"> <!-- 事务管理器，JDBC类型的事务管理器 --> <transactionManager type=\\\"JDBC\\\" /> <!-- 数据源，池类型的数据源 --> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"${driver}\\\" /> <!-- 配置了properties，所以可以直接引用 --> <property name=\\\"url\\\" value=\\\"${url}\\\" /> <property name=\\\"username\\\" value=\\\"${username}\\\" /> <property name=\\\"password\\\" value=\\\"${password}\\\" /> </dataSource> </environment> </environments> </configuration>\"]},\"744\":{\"h\":\"4,3，配置Map.xml(MyMapper.xml)\",\"t\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --> <mapper namespace=\\\"MyMapper\\\"> <!-- statement，内容：sql语句。id：唯一标识，随便写，在同一个命名空间下保持唯一 resultType：sql语句查询结果集的封装类型,tb_user即为数据库中的表名 --> <select id=\\\"selectUser\\\" resultType=\\\"com.zpc.mybatis.User\\\"> select * from tb_user where id = #{id} </select> </mapper>\"]},\"745\":{\"h\":\"4，4，修改全局配置文件(mybatis-config.xml)\",\"t\":[\"加入MyMapper.xml配置\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <!-- 根标签 --> <configuration> <!-- 环境，可以配置多个，default：指定采用哪个环境 --> <environments default=\\\"test\\\"> <!-- id：唯一标识 --> <environment id=\\\"test\\\"> <!-- 事务管理器，JDBC类型的事务管理器 --> <transactionManager type=\\\"JDBC\\\" /> <!-- 数据源，池类型的数据源 --> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"com.mysql.jdbc.Driver\\\" /> <property name=\\\"url\\\" value=\\\"jdbc:mysql://127.0.0.1:3306/mydatabase\\\" /> <property name=\\\"username\\\" value=\\\"root\\\" /> <property name=\\\"password\\\" value=\\\"123456\\\" /> </dataSource> </environment> </environments> <mappers> <mapper resource=\\\"mappers/MyMapper.xml\\\" /> </mappers> </configuration>\"]},\"746\":{\"h\":\"4，5，构建SqlSessionFactory(MybatisTest.java)\",\"t\":[\" // 指定全局配置文件 String resource = \\\"mybatis-config.xml\\\"; // 读取配置文件 InputStream inputStream = Resources.getResourceAsStream(resource); // 构建sqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\"]},\"747\":{\"h\":\"4,6，打开sqlSession回话，并执行sql(MyBatisTest.xml)\",\"t\":[\" // 获取sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 操作CRUD，第一个参数：指定statement，规则：命名空间+“.”+statementId // 第二个参数：指定传入sql的参数：这里是用户id User user = sqlSession.selectOne(\\\"MyMapper.selectUser\\\", 1); System.out.println(user);\",\"完整代码\",\"MyBatisTest.java\",\"import com.zpc.test.pojo.User; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.InputStream; public class MybatisTest { public static void main(String[] args) throws Exception { // 指定全局配置文件 String resource = \\\"mybatis-config.xml\\\"; // 读取配置文件 InputStream inputStream = Resources.getResourceAsStream(resource); // 构建sqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 获取sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); try { // 操作CRUD，第一个参数：指定statement，规则：命名空间+“.”+statementId // 第二个参数：指定传入sql的参数：这里是用户id User user = sqlSession.selectOne(\\\"MyMapper.selectUser\\\", 1); System.out.println(user); } finally { sqlSession.close(); } } }\",\"User.java\",\"import java.text.SimpleDateFormat; import java.util.Date; public class User { private String id; private String userName; private String password; private String name; private Integer age; private Integer sex; private Date birthday; private String created; private String updated; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Integer getSex() { return sex; } public void setSex(Integer sex) { this.sex = sex; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } public String getCreated() { return created; } public void setCreated(String created) { this.created = created; } public String getUpdated() { return updated; } public void setUpdated(String updated) { this.updated = updated; } }\"]},\"748\":{\"h\":\"4,7，目录结构\",\"t\":[\"二号图片\"]},\"749\":{\"h\":\"5，分析\"},\"750\":{\"h\":\"5,1，日志\"},\"751\":{\"h\":\"5,2，MyBatis使用步骤总结\",\"t\":[\"1)配置mybatis-config.xml 全局的配置文件 (1、数据源，2、外部的mapper)\",\"2)创建SqlSessionFactory\",\"3)通过SqlSessionFactory创建SqlSession对象\",\"4)通过SqlSession操作数据库 CRUD\",\"5)调用session.commit()提交事务\",\"6)调用session.close()关闭会话\"]},\"752\":{\"h\":\"6，完整增删查改操作(CURD)\"},\"753\":{\"h\":\"6，1，创建USerDao.java接口\",\"t\":[\"import com.zpc.mybatis.pojo.User; import java.util.List; public interface UserDao { /** * 根据id查询用户信息 * * @param id * @return */ public User queryUserById(String id); /** * 查询所有用户信息 * * @return */ public List<User> queryUserAll(); /** * 新增用户 * * @param user */ public void insertUser(User user); /** * 更新用户信息 * * @param user */ public void updateUser(User user); /** * 根据id删除用户信息 * * @param id */ public void deleteUser(String id); }\"]},\"754\":{\"h\":\"6,2,创建UserDaoImpl.java\",\"t\":[\"import com.zpc.mybatis.dao.UserDao; import com.zpc.mybatis.pojo.User; import org.apache.ibatis.session.SqlSession; import java.util.List; public class UserDaoImpl implements UserDao { public SqlSession sqlSession; public UserDaoImpl(SqlSession sqlSession) { this.sqlSession = sqlSession; } @Override public User queryUserById(String id) { return this.sqlSession.selectOne(\\\"UserDao.queryUserById\\\", id); } @Override public List<User> queryUserAll() { return this.sqlSession.selectList(\\\"UserDao.queryUserAll\\\"); } @Override public void insertUser(User user) { this.sqlSession.insert(\\\"UserDao.insertUser\\\", user); } @Override public void updateUser(User user) { this.sqlSession.update(\\\"UserDao.updateUser\\\", user); } @Override public void deleteUser(String id) { this.sqlSession.delete(\\\"UserDao.deleteUser\\\", id); } }\"]},\"755\":{\"h\":\"6,3，编写UserDao对应Mapper(UserDaoMapper.xml)\",\"t\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --> <mapper namespace=\\\"UserDao\\\"> <!-- statement，内容：sql语句。id：唯一标识，随便写，在同一个命名空间下保持唯一 resultType：sql语句查询结果集的封装类型,tb_user即为数据库中的表 --> <!--<select id=\\\"queryUserById\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\">--> <!--select * from tb_user where id = #{id}--> <!--</select>--> <!--使用别名--> <select id=\\\"queryUserById\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select tuser.id as id, tuser.user_name as userName, tuser.password as password, tuser.name as name, tuser.age as age, tuser.birthday as birthday, tuser.sex as sex, tuser.created as created, tuser.updated as updated from tb_user tuser where tuser.id = #{id}; </select> <select id=\\\"queryUserAll\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user; </select> <!--插入数据--> <insert id=\\\"insertUser\\\" parameterType=\\\"com.zpc.mybatis.pojo.User\\\"> INSERT INTO tb_user ( user_name, password, name, age, sex, birthday, created, updated ) VALUES ( #{userName}, #{password}, #{name}, #{age}, #{sex}, #{birthday}, now(), now() ); </insert> <update id=\\\"updateUser\\\" parameterType=\\\"com.zpc.mybatis.pojo.User\\\"> UPDATE tb_user <trim prefix=\\\"set\\\" suffixOverrides=\\\",\\\"> <if test=\\\"userName!=null\\\">user_name = #{userName},</if> <if test=\\\"password!=null\\\">password = #{password},</if> <if test=\\\"name!=null\\\">name = #{name},</if> <if test=\\\"age!=null\\\">age = #{age},</if> <if test=\\\"sex!=null\\\">sex = #{sex},</if> <if test=\\\"birthday!=null\\\">birthday = #{birthday},</if> updated = now(), </trim> WHERE (id = #{id}); </update> <delete id=\\\"deleteUser\\\"> delete from tb_user where id=#{id} </delete> </mapper>\",\"添加配置(mybatis-config.xml)\",\"<mappers> <mapper resource=\\\"mappers/MyMapper.xml\\\"/> <mapper resource=\\\"mappers/UserDaoMapper.xml\\\"/> </mappers>\"]},\"756\":{\"h\":\"6,4,添加UserDao测试用例\",\"t\":[\"pom.xml文件添加junit依赖\",\"<dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> </dependency>\",\"UserDao.java，按住Alt+Enter,选择create test\",\"图片三\"]},\"757\":{\"h\":\"6.5.编写UserDao的测试用例\",\"t\":[\"import com.zpc.mybatis.dao.UserDao; import com.zpc.mybatis.dao.impl.UserDaoImpl; import com.zpc.mybatis.pojo.User; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Before; import org.junit.Test; import java.io.InputStream; import java.util.Date; import java.util.List; public class UserDaoTest { public UserDao userDao; public SqlSession sqlSession; @Before public void setUp() throws Exception { // mybatis-config.xml String resource = \\\"mybatis-config.xml\\\"; // 读取配置文件 InputStream is = Resources.getResourceAsStream(resource); // 构建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); // 获取sqlSession sqlSession = sqlSessionFactory.openSession(); this.userDao = new UserDaoImpl(sqlSession); } @Test public void queryUserById() throws Exception { System.out.println(this.userDao.queryUserById(\\\"1\\\")); } @Test public void queryUserAll() throws Exception { List<User> userList = this.userDao.queryUserAll(); for (User user : userList) { System.out.println(user); } } @Test public void insertUser() throws Exception { User user = new User(); user.setAge(16); user.setBirthday(new Date(\\\"1990/09/02\\\")); user.setName(\\\"大鹏\\\"); user.setPassword(\\\"123456\\\"); user.setSex(1); user.setUserName(\\\"evan\\\"); this.userDao.insertUser(user); this.sqlSession.commit(); } @Test public void updateUser() throws Exception { User user = new User(); user.setBirthday(new Date()); user.setName(\\\"静鹏\\\"); user.setPassword(\\\"654321\\\"); user.setSex(1); user.setUserName(\\\"evanjin\\\"); user.setId(\\\"1\\\"); this.userDao.updateUser(user); this.sqlSession.commit(); } @Test public void deleteUser() throws Exception { this.userDao.deleteUser(\\\"4\\\"); this.sqlSession.commit(); } }\"]},\"758\":{\"h\":\"6.6.目录结构\",\"t\":[\"图片四\"]},\"759\":{\"h\":\"6.7.解决数据库字段名和实体类属性名不一致的问题\",\"t\":[\"查询数据的时候，发现查不到userName的信息， User{id=‘2’, userName=‘null’, password=‘123456’, name=‘静静’, age=22, sex=0, birthday=‘1993-09-05’, created=‘2018-06-30 18:22:28.0’, updated=‘2018-06-30 18:22:28.0’} 原因：数据库的字段名是user_name，POJO中的属性名字是userName 两端不一致，造成mybatis无法填充对应的字段信息。修改方法：在sql语句中使用别名。\",\"解决方案1：在sql语句中使用别名：\",\"<select id=\\\"queryUserById\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select tuser.id as id, tuser.user_name as userName, tuser.password as password, tuser.name as name, tuser.age as age, tuser.birthday as birthday, tuser.sex as sex, tuser.created as created, tuser.updated as updated from tb_user tuser where tuser.id = #{id}; </select>\",\"解决方案2： 参考后面的resultMap –mapper具体的配置的时候\",\"解决方案3：参考驼峰匹配 — mybatis-config.xml 的时候\"]},\"760\":{\"h\":\"7. 动态代理Mapper实现类\"},\"761\":{\"h\":\"7.1.思考上述CRUD中的问题\",\"t\":[\"接口 -> 实现类 -> mapping.xml\",\"实现类中，使用mybatis的方式非常相似\",\"xml的sql statement 硬编码到Java代码中\",\"思考：能否直接写接口，不写实现类。只编写接口和Mapping.xml即可？\",\"因为再dao(mapper)的实现类中对sqlsession的使用方式很类似。因此mybatis提供了接口的动态代理。\"]},\"762\":{\"h\":\"7，2，使用动态代理改造CRUD\",\"t\":[\"修改测试用例的setUp方法\",\"图片五\",\"执行queryUserAll()方法\",\"图片6\",\"org.apache.ibatis.binding.BindingException: Type interface com.zpc.mybatis.dao.UserDao is not known to the MapperRegistry. at org.apache.ibatis.binding.MapperRegistry.getMapper(MapperRegistry.java:47) at org.apache.ibatis.session.Configuration.getMapper(Configuration.java:655) at org.apache.ibatis.session.defaults.DefaultSqlSession.getMapper(DefaultSqlSession.java:222) at com.zpc.mybatis.test.UserDaoTest.setUp(UserDaoTest.java:32)\",\"分析原因，在 UserMapper.xml 中配置接口的全路径\",\"mapper.xml namespace\",\"如果希望使用mybatis通过的动态代理的接口，就需要namespace中的值，和需要对应的Mapper(dao)接口的全路径一致。Mapper中Namespace的定义本身是没有限制的，只要不重复即可，但如果使用Mybatis的DAO接口动态代理，则namespace必须为DAO接口的全路径，\",\"例如：com.zpc.mybatis.dao.UserDao\",\"<mapper namespace=\\\"com.zpc.mybatis.dao.UserDao\\\">\"]},\"763\":{\"h\":\"7.3.完整的例子\",\"t\":[\"创建UserMapper接口(对应原UserDao)\",\"public interface UserMapper { /** * 登录（直接使用注解指定传入参数名称） * @param userName * @param password * @return */ public User login(@Param(\\\"userName\\\") String userName, @Param(\\\"password\\\") String password); /** * 根据表名查询用户信息（直接使用注解指定传入参数名称） * @param tableName * @return */ public List<User> queryUserByTableName(@Param(\\\"tableName\\\") String tableName); /** * 根据Id查询用户信息 * @param id * @return */ public User queryUserById(Long id); /** * 查询所有用户信息 * @return */ public List<User> queryUserAll(); /** * 新增用户信息 * @param user */ public void insertUser(User user); /** * 根据id更新用户信息 * @param user */ public void updateUser(User user); /** * 根据id删除用户信息 * @param id */ public void deleteUserById(Long id); }\",\"创建Usermapper.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 ，为了使用接口动态代理，这里必须是接口的全路径名--> <mapper namespace=\\\"com.zpc.mybatis.dao.UserMapper\\\"> <!-- 1.#{},预编译的方式preparedstatement，使用占位符替换，防止sql注入，一个参数的时候，任意参数名可以接收 2.${},普通的Statement，字符串直接拼接，不可以防止sql注入，一个参数的时候，必须使用${value}接收参数 --> <select id=\\\"queryUserByTableName\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from ${tableName} </select> <select id=\\\"login\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user where user_name = #{userName} and password = #{password} </select> <!-- statement，内容：sql语句。 id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致 resultType：sql语句查询结果集的封装类型，使用动态代理之后和方法的返回类型一致；resultMap：二选一 parameterType：参数的类型，使用动态代理之后和方法的参数类型一致 --> <select id=\\\"queryUserById\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user where id = #{id} </select> <select id=\\\"queryUserAll\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user </select> <!-- 新增的Statement id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致 parameterType：参数的类型，使用动态代理之后和方法的参数类型一致 useGeneratedKeys:开启主键回写 keyColumn：指定数据库的主键 keyProperty：主键对应的pojo属性名 --> <insert id=\\\"insertUser\\\" useGeneratedKeys=\\\"true\\\" keyColumn=\\\"id\\\" keyProperty=\\\"id\\\" parameterType=\\\"com.zpc.mybatis.pojo.User\\\"> INSERT INTO tb_user ( id, user_name, password, name, age, sex, birthday, created, updated ) VALUES ( null, #{userName}, #{password}, #{name}, #{age}, #{sex}, #{birthday}, NOW(), NOW() ); </insert> <!-- 更新的statement id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致 parameterType：参数的类型，使用动态代理之后和方法的参数类型一致 --> <update id=\\\"updateUser\\\" parameterType=\\\"com.zpc.mybatis.pojo.User\\\"> UPDATE tb_user <trim prefix=\\\"set\\\" suffixOverrides=\\\",\\\"> <if test=\\\"userName!=null\\\">user_name = #{userName},</if> <if test=\\\"password!=null\\\">password = #{password},</if> <if test=\\\"name!=null\\\">name = #{name},</if> <if test=\\\"age!=null\\\">age = #{age},</if> <if test=\\\"sex!=null\\\">sex = #{sex},</if> <if test=\\\"birthday!=null\\\">birthday = #{birthday},</if> updated = now(), </trim> WHERE (id = #{id}); </update> <!-- 删除的statement id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致 parameterType：参数的类型，使用动态代理之后和方法的参数类型一致 --> <delete id=\\\"deleteUserById\\\" parameterType=\\\"java.lang.String\\\"> delete from tb_user where id=#{id} </delete> </mapper>\",\"全局配置文件mybatis-config.xml引入UserMapper.xml\",\"<mappers> <mapper resource=\\\"mappers/MyMapper.xml\\\"/> <mapper resource=\\\"mappers/UserDaoMapper.xml\\\"/> <mapper resource=\\\"mappers/UserMapper.xml\\\"/> </mappers>\",\"创建UserMapper测试用例\",\"import com.zpc.mybatis.dao.UserMapper; import com.zpc.mybatis.pojo.User; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Before; import org.junit.Test; import java.io.InputStream; import java.util.Date; import java.util.List; public class UserMapperTest { public UserMapper userMapper; @Before public void setUp() throws Exception { // 指定配置文件 String resource = \\\"mybatis-config.xml\\\"; // 读取配置文件 InputStream inputStream = Resources.getResourceAsStream(resource); // 构建sqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 获取sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(true); // 1. 映射文件的命名空间（namespace）必须是mapper接口的全路径 // 2. 映射文件的statement的id必须和mapper接口的方法名保持一致 // 3. Statement的resultType必须和mapper接口方法的返回类型一致 // 4. statement的parameterType必须和mapper接口方法的参数类型一致（不一定） this.userMapper = sqlSession.getMapper(UserMapper.class); } @Test public void testQueryUserByTableName() { List<User> userList = this.userMapper.queryUserByTableName(\\\"tb_user\\\"); for (User user : userList) { System.out.println(user); } } @Test public void testLogin() { System.out.println(this.userMapper.login(\\\"hj\\\", \\\"123456\\\")); } @Test public void testQueryUserById() { System.out.println(this.userMapper.queryUserById(\\\"1\\\")); } @Test public void testQueryUserAll() { List<User> userList = this.userMapper.queryUserAll(); for (User user : userList) { System.out.println(user); } } @Test public void testInsertUser() { User user = new User(); user.setAge(20); user.setBirthday(new Date()); user.setName(\\\"大神\\\"); user.setPassword(\\\"123456\\\"); user.setSex(2); user.setUserName(\\\"bigGod222\\\"); this.userMapper.insertUser(user); System.out.println(user.getId()); } @Test public void testUpdateUser() { User user = new User(); user.setBirthday(new Date()); user.setName(\\\"静静\\\"); user.setPassword(\\\"123456\\\"); user.setSex(0); user.setUserName(\\\"Jinjin\\\"); user.setId(\\\"1\\\"); this.userMapper.updateUser(user); } @Test public void testDeleteUserById() { this.userMapper.deleteUserById(\\\"1\\\"); } }\",\"目录结构：\",\"图片七\"]},\"764\":{\"h\":\"7,4，动态代理总结\",\"t\":[\"使用mapper接口不用写接口实现类即可完成数据库操作，使用非常方便，也是官方推荐的使用方式。\",\"Mapper的namespace必须和mapper接口的全路径一致。\",\"Mapper接口的方法名必须和sql定义的id一致。\",\"Mapper接口中方法的输入参数类型必须和sql定义的parameterType一致。(这句需要再琢磨)\",\"Mapper接口中方法的输出参数类型必须和sql定义的resultType一致。\"]},\"765\":{\"h\":\"8，mybatis-config.xml详解\",\"t\":[\"mybatis-config.xml讲究严格的顺序，具体顺序遵循文档的顺序。\",\"图片八\"]},\"766\":{\"h\":\"8,1，properties属性读取外部资源\",\"t\":[\"properties配置的属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。例如：\",\"<properties resource=\\\"org/mybatis/example/config.properties\\\"> <property name=\\\"username\\\" value=\\\"dev_user\\\"/> <property name=\\\"password\\\" value=\\\"F2Fa3!33TYyg\\\"/> </properties>\",\"然后其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值。比如:\",\"<dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"${driver}\\\"/> <property name=\\\"url\\\" value=\\\"${url}\\\"/> <property name=\\\"username\\\" value=\\\"${username}\\\"/> <property name=\\\"password\\\" value=\\\"${password}\\\"/> </dataSource>\",\"这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。\",\"属性也可以被传递到 SqlSessionFactoryBuilder.build()方法中。例如：\",\"SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props); // ... or ... SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);\",\"如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载：\",\"在 properties 元素体内指定的属性首先被读取。\",\"然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。\",\"最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。\",\"因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。\"]},\"767\":{\"h\":\"8,2,settings设置\",\"t\":[\"图片九\",\"开启驼峰匹配：\",\"<settings> <setting name=\\\"mapUnderscoreToCamelCase\\\" value=\\\"true\\\"/> </settings>\"]},\"768\":{\"h\":\"8,3,typeAliases(别名)\",\"t\":[\"类型别名是为 Java 类型命名的一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。\",\"<typeAliases> <typeAlias type=\\\"com.zpc.mybatis.pojo.User\\\" alias=\\\"User\\\"/> </typeAliases>\",\"缺点：每个pojo类都要去配置。 解决方案：使用扫描包，扫描指定包下的所有类，扫描之后的别名就是类名（不区分大小写），建议使用的时候和类名一致\",\"<typeAliases> <!--type:实体类的全路径。alias:别名，通常首字母大写--> <!--<typeAlias type=\\\"com.zpc.mybatis.pojo.User\\\" alias=\\\"User\\\"/>--> <package name=\\\"com.zpc.mybatis.pojo\\\"/> </typeAliases>\",\"Mybatis已经为普通的 Java 类型内建了许多相应的类型别名。它们都是大小写不敏感的。\",\"图片十\"]},\"769\":{\"h\":\"8,4,typeHandlers(类处理器)\",\"t\":[\"无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。\"]},\"770\":{\"h\":\"8.5.plugins（插件）拦截器\",\"t\":[\"MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括： Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query)\",\"现在一些MyBatis 插件比如PageHelper都是基于这个原理，有时为了监控sql执行效率，也可以使用插件机制 原理：\",\"图片十一\",\"// ExamplePlugin.java @Intercepts({@Signature( type= Executor.class, method = \\\"update\\\", args = {MappedStatement.class,Object.class})}) public class ExamplePlugin implements Interceptor { public Object intercept(Invocation invocation) throws Throwable { return invocation.proceed(); } public Object plugin(Object target) { return Plugin.wrap(target, this); } public void setProperties(Properties properties) { } }\",\"配置：\",\"<!-- mybatis-config.xml --> <plugins> <plugin interceptor=\\\"org.mybatis.example.ExamplePlugin\\\"> <property name=\\\"someProperty\\\" value=\\\"100\\\"/> </plugin> </plugins>\",\"上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。\"]},\"771\":{\"h\":\"8.6.environments(环境)\",\"t\":[\"MyBatis 可以配置成适应多种环境，例如，开发、测试和生产环境需要有不同的配置； 尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。 虽然，这种方式也可以做到很方便的分离多个环境，但是实际使用场景下，我们更多的是选择使用spring来管理数据源，来做到环境的分离。\"]},\"772\":{\"h\":\"8.7.mappers\",\"t\":[\"需要告诉 MyBatis 到哪里去找到 SQL 映射语句。即告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。例如：\",\"<!-- 使用相对于类路径的资源引用 --> <mappers> <mapper resource=\\\"org/mybatis/builder/AuthorMapper.xml\\\"/> <mapper resource=\\\"org/mybatis/builder/BlogMapper.xml\\\"/> <mapper resource=\\\"org/mybatis/builder/PostMapper.xml\\\"/> </mappers> <!-- 使用映射器接口实现类的完全限定类名 --> <mappers> <mapper class=\\\"org.mybatis.builder.AuthorMapper\\\"/> <mapper class=\\\"org.mybatis.builder.BlogMapper\\\"/> <mapper class=\\\"org.mybatis.builder.PostMapper\\\"/> </mappers>\",\"这里所谓的mapper接口路径。实际上就是dao的接口路径。在mybatis中，通常把dao的包叫做mapper。类名，也叫做mapper\",\"定义一个接口。\",\"在接口所在的包中定义mapper.xml，并且要求xml文件和interface的名称要相同。\",\"在mybatis-config.xml 中通过class路径，引入mapper（注解方式）。要求mapper.xml 中的名称空间是类的接口的全路径。\",\"注解方式：\",\"<mappers> <mapper resource=\\\"mappers/MyMapper.xml\\\"/> <mapper resource=\\\"mappers/UserDaoMapper.xml\\\"/> <!--注解方式可以使用如下配置方式--> <mapper class=\\\"com.zpc.mybatis.dao.UserMapper\\\"/> </mappers>\",\"问题：\",\"mapper.xml 和 java 文件没有分离。 之后的教程讲述和spring整合之后解决。\",\"需要一个一个的去加载mapper。\",\"当然也可以使用包扫描（必须使用注解方式，即在接口方法上使用注解，如 @Select(\\\"select * from tb_user \\\")）： 缺点：\",\"如果包的路径有很多？\",\"mapper.xml 和 mapper.java 没有分离。\",\"spring 整合的时候解决。\"]},\"773\":{\"h\":\"9.Mapper XML文件详解\"},\"774\":{\"h\":\"9.1.CRUD标签\"},\"775\":{\"h\":\"9.1.1.select\",\"t\":[\"select – 书写查询sql语句 select中的几个属性说明： id属性：当前名称空间下的statement的唯一标识。必须。要求id和mapper接口中的方法的名字一致。 resultType：将结果集映射为java的对象类型。必须（和 resultMap 二选一） parameterType：传入参数类型。可以省略\"]},\"776\":{\"h\":\"9.1.2.insert\",\"t\":[\"insert 的几个属性说明： id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致 parameterType：参数的类型，使用动态代理之后和方法的参数类型一致 useGeneratedKeys:开启主键回写 keyColumn：指定数据库的主键 keyProperty：主键对应的pojo属性名 标签内部：具体的sql语句。\"]},\"777\":{\"h\":\"9.1.3.update\",\"t\":[\"id属性：当前名称空间下的statement的唯一标识(必须属性)； parameterType：传入的参数类型，可以省略。 标签内部：具体的sql语句。\"]},\"778\":{\"h\":\"9.1.4.delete\",\"t\":[\"delete 的几个属性说明： id属性：当前名称空间下的statement的唯一标识(必须属性)； parameterType：传入的参数类型，可以省略。 标签内部：具体的sql语句。\"]},\"779\":{\"h\":\"9.2.#{}和${}\",\"t\":[\"场景：数据库有两个一模一样的表。历史表，当前表 查询表中的信息，有时候从历史表中去查询数据，有时候需要去新的表去查询数据。 希望使用1个方法来完成操作。\",\"<select id=\\\"queryUserByTableName\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from #{tableName} </select> /** * 根据表名查询用户信息（直接使用注解指定传入参数名称） * * @param tableName * @return */ public List<User> queryUserByTableName(String tableName);\",\"测试输出：\",\"有问题,报语法错误：相当于执行了这样一条sql: select * from “tb_user”; 显然表名多了引号。\",\"改正：\",\"<select id=\\\"queryUserByTableName\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from ${tableName} </select>\",\"注意： #{} 只是替换？，相当于PreparedStatement使用占位符去替换参数，可以防止sql注入。 ${} 是进行字符串拼接，相当于sql语句中的Statement，使用字符串去拼接sql；$可以是sql中的任一部分传入到Statement中，不能防止sql注入。\",\"使用${} 去取出参数值信息，需要使用${value} #{} 只是表示占位，与参数的名字无关，如果只有一个参数，会自动对应。\",\"推荐：\",\"/** * 根据表名查询用户信息（直接使用注解指定传入参数名称） * * @param tableName * @return */ public List<User> queryUserByTableName(@Param(\\\"tableName\\\") String tableName); <select id=\\\"queryUserByTableName\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from ${tableName} </select>\",\"#{}多个参数时：\",\"/** * 登录（直接使用注解指定传入参数名称） * * @param userName * @param password * @return */ public User login( String userName, String password); <select id=\\\"login\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user where user_name = #{userName} and password = #{password} </select>\",\"报错：\",\"org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.binding.BindingException: Parameter 'userName' not found. Available parameters are [0, 1, param1, param2] ### Cause: org.apache.ibatis.binding.BindingException: Parameter 'userName' not found. Available parameters are [0, 1, param1, param2]\",\"解决方案一：\",\"<select id=\\\"login\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user where user_name = #{0} and password = #{1} </select>\",\"解决方案二：\",\"<select id=\\\"login\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user where user_name = #{param1} and password = #{param2} </select>\",\"最终解决方案：\",\"/** * 登录（直接使用注解指定传入参数名称） * * @param userName * @param password * @return */ public User login(@Param(\\\"userName\\\") String userName, @Param(\\\"password\\\") String password); <select id=\\\"login\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user where user_name = #{userName} and password = #{password} </select>\",\"通常在方法的参数列表上加上一个注释@Param(“xxxx”) 显式指定参数的名字，然后通过${“xxxx”}或#{“xxxx”} sql语句动态生成的时候，使用${}; sql语句中某个参数进行占位的时候#{}\"]},\"780\":{\"h\":\"9.3.面试题（#、$区别）\",\"t\":[\"/** * #号 * @param username1 * @return */ User queryUserListByName1(@Param(\\\"username1\\\") String username1); /** * $号 * @param username2 * @return */ User queryUserListByName2(@Param(\\\"username2\\\") String username2); <select id=\\\"queryUserListByName1\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user WHERE user_name=#{username1} </select> <select id=\\\"queryUserListByName2\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user WHERE user_name='${username2}'//手动加了引号 </select>\"]},\"781\":{\"h\":\"9.4.resultMap\",\"t\":[\"图片十二\",\"图片十三\",\"使用： \"]},\"782\":{\"h\":\"9.5.sql片段\",\"t\":[\"<sql id=””></sql> <include refId=”” />\",\"例如在UserMapper.xml中定义如下片段：\",\"<sql id=\\\"commonSql\\\"> id, user_name, password, name, age, sex, birthday, created, updated </sql>\",\"则可以在UserMapper.xml中使用它：\",\"<select id=\\\"queryUserById\\\" resultMap=\\\"userResultMap\\\"> select <include refid=\\\"commonSql\\\"></include> from tb_user where id = #{id} </select> <select id=\\\"queryUsersLikeUserName\\\" resultType=\\\"User\\\"> select <include refid=\\\"commonSql\\\"></include> from tb_user where user_name like \\\"%\\\"#{userName}\\\"%\\\" </select>\",\"Sql片段也可以定义在单独的.xml文件中如： 定义CommonSQL.xml：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"CommonSQL\\\"> <sql id=\\\"commonSql\\\"> id, user_name, password, name, age, sex, birthday, created, updated </sql> </mapper>\",\"使用：\",\" <select id=\\\"queryUserById\\\" resultMap=\\\"userResultMap\\\"> select <include refid=\\\"CommonSQL.commonSql\\\"></include> from tb_user where id = #{id} </select> <select id=\\\"queryUsersLikeUserName\\\" resultType=\\\"User\\\"> select <include refid=\\\"CommonSQL.commonSql\\\"></include> from tb_user where user_name like \\\"%\\\"#{userName}\\\"%\\\" </select>\",\"当然要完成这个功能还需要在全局配置文件mybatis-config.xml中引入该外部配置文件：\",\"<mappers> <mapper resource=\\\"CommonSQL.xml\\\"/> <!-- 开启mapper接口的包扫描，基于class的配置方式 --> <package name=\\\"com.zpc.mybatis.mapper\\\"/> </mappers>\"]},\"783\":{\"h\":\"10.动态sql\",\"t\":[\"场景：查询男性用户，如果输入了姓名，按姓名模糊查询 \"]},\"784\":{\"h\":\"10.1.if\",\"t\":[\"场景：查询男性用户，如果输入了姓名，则按姓名查询\",\"定义接口：\",\"/** * 查询男性用户，如果输入了姓名，则按姓名查询 * @param name * @return */ List<User> queryUserList(@Param(\\\"name\\\") String name);\",\"编写mapper\",\"<select id=\\\"queryUserList\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user WHERE sex=1 <if test=\\\"name!=null and name.trim()!=''\\\"> and name like '%${name}%' </if> </select>\",\"测试：\",\"@Test public void testqueryUserList() { List<User> users = this.userMapper.queryUserList(null); for (User user : users) { System.out.println(user); } }\"]},\"785\":{\"h\":\"10.2.choose when otherwise\",\"t\":[\"场景：查询男性用户，如果输入了姓名则按照姓名模糊查找，否则如果输入了年龄则按照年龄查找，否则查找姓名为“鹏程”的用户。\",\"定义接口：\",\"/** * 查询男性用户，如果输入了姓名则按照姓名模糊查找，否则如果输入了年龄则按照年龄查找，否则查找姓名为“鹏程”的用户。 * @param name * @param age * @return */ List<User> queryUserListByNameOrAge(@Param(\\\"name\\\") String name,@Param(\\\"age\\\") Integer age);\",\"编写mapper配置：\",\"<select id=\\\"queryUserListByNameOrAge\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user WHERE sex=1 <!-- 1.一旦有条件成立的when，后续的when则不会执行 2.当所有的when都不执行时,才会执行otherwise --> <choose> <when test=\\\"name!=null and name.trim()!=''\\\"> and name like '%${name}%' </when> <when test=\\\"age!=null\\\"> and age = #{age} </when> <otherwise> and name='鹏程' </otherwise> </choose> </select>\",\"测试:\",\"@Test public void queryUserListByNameOrAge() throws Exception { List<User> users = this.userMapper.queryUserListByNameOrAge(null, 16); for (User user : users) { System.out.println(user); } }\"]},\"786\":{\"h\":\"10.3.where 和set\",\"t\":[\"场景一：查询所有用户，如果输入了姓名按照姓名进行模糊查询，如果输入年龄，按照年龄进行查询，如果两者都输入，两个条件都要成立。\",\"接口：\",\"/** * 查询所有用户，如果输入了姓名按照姓名进行模糊查询，如果输入年龄，按照年龄进行查询，如果两者都输入，两个条件都要成立 * @param name * @param age * @return */ List<User> queryUserListByNameAndAge(@Param(\\\"name\\\") String name,@Param(\\\"age\\\") Integer age);\",\"配置：\",\"<select id=\\\"queryUserListByNameAndAge\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user <!--如果多出一个and，会自动去除，如果缺少and或者多出多个and则会报错--> <where> <if test=\\\"name!=null and name.trim()!=''\\\"> and name like '%${name}%' </if> <if test=\\\"age!=null\\\"> and age = #{age} </if> </where> </select>\",\"测试：\",\"@Test public void queryUserListByNameAndAge() throws Exception { List<User> users = this.userMapper.queryUserListByNameAndAge(\\\"鹏程\\\", 20); for (User user : users) { System.out.println(user); } }\",\"场景二：修改用户信息，如果参数user中的某个属性为null，则不修改。 接口：\",\"/** * 根据id更新用户信息 * * @param user */ public void updateUser(User user);\",\"配置：\",\"<update id=\\\"updateUser\\\" parameterType=\\\"com.zpc.mybatis.pojo.User\\\"> UPDATE tb_user <trim prefix=\\\"set\\\" suffixOverrides=\\\",\\\"> <if test=\\\"userName!=null\\\">user_name = #{userName},</if> <if test=\\\"password!=null\\\">password = #{password},</if> <if test=\\\"name!=null\\\">name = #{name},</if> <if test=\\\"age!=null\\\">age = #{age},</if> <if test=\\\"sex!=null\\\">sex = #{sex},</if> <if test=\\\"birthday!=null\\\">birthday = #{birthday},</if> updated = now(), </trim> WHERE (id = #{id}); </update>\",\"测试：\",\"@Test public void testUpdateUser() { User user = new User(); user.setBirthday(new Date()); user.setName(\\\"静静\\\"); user.setPassword(\\\"123456\\\"); user.setSex(0); user.setUserName(\\\"Jinjin\\\"); user.setId(\\\"1\\\"); this.userMapper.updateUser(user); }\"]},\"787\":{\"h\":\"10.4.foreach\",\"t\":[\"场景：按照多个id查询用户信息\",\"接口：\",\"/** * 按多个Id查询 * @param ids * @return */ List<User> queryUserListByIds(@Param(\\\"ids\\\") String[] ids);\",\"配置：\",\"<select id=\\\"queryUserListByIds\\\" resultType=\\\"com.zpc.mybatis.pojo.User\\\"> select * from tb_user where id in <foreach collection=\\\"ids\\\" item=\\\"id\\\" open=\\\"(\\\" close=\\\")\\\" separator=\\\",\\\"> #{id} </foreach> </select>\",\"测试：\",\"@Test public void queryUserListByIds() throws Exception { List<User> users = this.userMapper.queryUserListByIds(new String[]{\\\"1\\\",\\\"2\\\"}); for (User user : users) { System.out.println(user); } }\",\"If：testognl表达式或者简单java代码 Choose when otherwise—>相当于if else if else When test参考if Where set 都有一定的纠错功能 Trim：prefix suffix prefixOverrides suffixOverrides Foreach：collection item saparator open close\"]},\"788\":{\"h\":\"11.缓存\"},\"789\":{\"h\":\"11.1.一级缓存\",\"t\":[\"图片十六\",\"在mybatis中，一级缓存默认是开启的，并且一直无法关闭\",\"一级缓存满足条件： 1、同一个session中 2、相同的SQL和参数\",\"测试：\",\"@Test public void testQueryUserById() { System.out.println(this.userMapper.queryUserById(\\\"1\\\")); System.out.println(this.userMapper.queryUserById(\\\"1\\\")); }\",\"2018-07-01 17:08:50,156 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2018-07-01 17:08:50,421 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 242355057. 2018-07-01 17:08:50,423 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] ==> Preparing: select * from tb_user where id = ? 2018-07-01 17:08:50,476 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] ==> Parameters: 1(String) 2018-07-01 17:08:50,509 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] <== Total: 1 User{id='1', userName='bigGod222', password='123456', name='鹏程', age=20, sex=1, birthday='2018-07-01', created='2018-07-01 13:35:40.0', updated='2018-07-01 13:35:40.0'} User{id='1', userName='bigGod222', password='123456', name='鹏程', age=20, sex=1, birthday='2018-07-01', created='2018-07-01 13:35:40.0', updated='2018-07-01 13:35:40.0'}\",\"使用： sqlSession.clearCache(); 可以强制清除缓存\",\"测试：\",\"@Test public void testQueryUserById() { System.out.println(this.userMapper.queryUserById(\\\"1\\\")); sqlSession.clearCache(); System.out.println(this.userMapper.queryUserById(\\\"1\\\")); }\",\"日志：\",\"2018-07-01 17:10:51,065 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2018-07-01 17:10:51,359 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 242355057. 2018-07-01 17:10:51,360 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] ==> Preparing: select * from tb_user where id = ? 2018-07-01 17:10:51,408 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] ==> Parameters: 1(String) 2018-07-01 17:10:51,437 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] <== Total: 1 User{id='1', userName='bigGod222', password='123456', name='鹏程', age=20, sex=1, birthday='2018-07-01', created='2018-07-01 13:35:40.0', updated='2018-07-01 13:35:40.0'} 2018-07-01 17:10:51,438 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] ==> Preparing: select * from tb_user where id = ? 2018-07-01 17:10:51,438 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] ==> Parameters: 1(String) 2018-07-01 17:10:51,440 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] <== Total: 1 User{id='1', userName='bigGod222', password='123456', name='鹏程', age=20, sex=1, birthday='2018-07-01', created='2018-07-01 13:35:40.0', updated='2018-07-01 13:35:40.0'}\",\"执行 update、insert、delete 的时候，会清空缓存 测试：\",\"@Test public void testQueryUserById() { System.out.println(this.userMapper.queryUserById(\\\"1\\\")); //sqlSession.clearCache(); User user=new User(); user.setName(\\\"美女\\\"); user.setId(\\\"1\\\"); userMapper.updateUser(user); System.out.println(this.userMapper.queryUserById(\\\"1\\\")); }\",\"日志：\",\"2018-07-01 17:18:15,128 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2018-07-01 17:18:15,399 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 242355057. 2018-07-01 17:18:15,401 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] ==> Preparing: select * from tb_user where id = ? 2018-07-01 17:18:15,466 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] ==> Parameters: 1(String) 2018-07-01 17:18:15,492 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] <== Total: 1 User{id='1', userName='bigGod222', password='123456', name='鹏程', age=20, sex=1, birthday='2018-07-01', created='2018-07-01 13:35:40.0', updated='2018-07-01 13:35:40.0'} 2018-07-01 17:18:15,527 [main] [com.zpc.mybatis.dao.UserMapper.updateUser]-[DEBUG] ==> Preparing: UPDATE tb_user set name = ?, updated = now() WHERE (id = ?); 2018-07-01 17:18:15,529 [main] [com.zpc.mybatis.dao.UserMapper.updateUser]-[DEBUG] ==> Parameters: 美女(String), 1(String) 2018-07-01 17:18:15,532 [main] [com.zpc.mybatis.dao.UserMapper.updateUser]-[DEBUG] <== Updates: 1 2018-07-01 17:18:15,532 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] ==> Preparing: select * from tb_user where id = ? 2018-07-01 17:18:15,533 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] ==> Parameters: 1(String) 2018-07-01 17:18:15,538 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] <== Total: 1 User{id='1', userName='bigGod222', password='123456', name='美女', age=20, sex=1, birthday='2018-07-01', created='2018-07-01 13:35:40.0', updated='2018-07-01 17:18:15.0'}\"]},\"790\":{\"h\":\"11.2.二级缓存\",\"t\":[\"mybatis 的二级缓存的作用域是一个mapper的namespace ，同一个namespace中查询sql可以从缓存中命中。\",\"开启二级缓存：\",\"<mapper namespace=\\\"com.zpc.mybatis.dao.UserMapper\\\"> <cache/> </mapper>\",\"测试：\",\"@Test public void testCache() { System.out.println(this.userMapper.queryUserById(\\\"1\\\")); sqlSession.close(); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); System.out.println(mapper.queryUserById(\\\"1\\\")); }\",\"开启二级缓存，必须序列化：\",\"public class User implements Serializable{ private static final long serialVersionUID = -3330851033429007657L;\",\"日志：\",\"2018-07-01 17:23:39,335 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2018-07-01 17:23:39,664 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 2092769598. 2018-07-01 17:23:39,665 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] ==> Preparing: select * from tb_user where id = ? 2018-07-01 17:23:39,712 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] ==> Parameters: 1(String) 2018-07-01 17:23:39,734 [main] [com.zpc.mybatis.dao.UserMapper.queryUserById]-[DEBUG] <== Total: 1 User{id='1', userName='bigGod222', password='123456', name='美女', age=20, sex=1, birthday='2018-07-01', created='2018-07-01 13:35:40.0', updated='2018-07-01 17:18:15.0'} 2018-07-01 17:23:39,743 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@7cbd213e] 2018-07-01 17:23:39,744 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Returned connection 2092769598 to pool. 2018-07-01 17:23:39,746 [main] [com.zpc.mybatis.dao.UserMapper]-[DEBUG] Cache Hit Ratio [com.zpc.mybatis.dao.UserMapper]: 0.5 User{id='1', userName='bigGod222', password='123456', name='美女', age=20, sex=1, birthday='2018-07-01', created='2018-07-01 13:35:40.0', updated='2018-07-01 17:18:15.0'}\",\"关闭二级缓存： 不开启，或者在全局的mybatis-config.xml 中去关闭二级缓存\",\"图片十七\",\"<settings> <!--开启驼峰匹配--> <setting name=\\\"mapUnderscoreToCamelCase\\\" value=\\\"true\\\"/> <!--开启二级缓存,全局总开关，这里关闭，mapper中开启了也没用--> <setting name=\\\"cacheEnabled\\\" value=\\\"false\\\"/> </settings>\",\"图片十八\"]},\"791\":{\"h\":\"12.高级查询\"},\"792\":{\"h\":\"12.1.表关系说明\",\"t\":[\"图片十九\",\"创建order表： CREATE TABLE tb_order ( id int(11) NOT NULL AUTO_INCREMENT, user_id int(11) DEFAULT NULL, order_number varchar(255) DEFAULT NULL, create datetime DEFAULT NULL, updated datetime DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\",\"public class Order { private Integer id; private Long userId; private String orderNumber; private Date created; private Date updated; }\",\"需求说明： \"]},\"793\":{\"h\":\"12.2.一对一查询\",\"t\":[\"方法一：核心思想扩展Order对象，来完成映射 新建OrderUser实体类继承Order：\",\"public class OrderUser extends Order { private String userName; private String password; private String name; private Integer age; private Integer sex; private Date birthday; private Date created; private Date updated; }\",\"OrderMapper接口：\",\"public interface OrderMapper { OrderUser queryOrderUserByOrderNumber(@Param(\\\"number\\\") String number); }\",\"配置OrderMapper：\",\" <mapper namespace=\\\"com.zpc.mybatis.dao.OrderMapper\\\"> <select id=\\\"queryOrderUserByOrderNumber\\\" resultType=\\\"com.zpc.mybatis.pojo.OrderUser\\\"> select * from tb_order o left join tb_user u on o.user_id=u.id where o.order_number = #{number} </select> </mapper>\",\"测试：\",\"@Test public void queryOrderUserByOrderNumber() throws Exception { OrderUser orderUser = orderMapper.queryOrderUserByOrderNumber(\\\"201807010001\\\"); System.out.println(orderUser); }\",\"方法二：面向对象的思想，在Order对象中添加User对象。\",\"在Order对象中添加User属性：\",\"public class Order { private Integer id; private Long userId; private String orderNumber; private Date created; private Date updated; private User user; }\",\"接口：\",\"/** * 根据订单号查询订单用户的信息 * @param number * @return */ Order queryOrderWithUserByOrderNumber(@Param(\\\"number\\\") String number);\",\"使用resultType不能完成自动映射，需要手动完成结果集映射resultMap：\",\" <resultMap id=\\\"OrderUserResultMap\\\" type=\\\"com.zpc.mybatis.pojo.Order\\\" autoMapping=\\\"true\\\"> <id column=\\\"id\\\" property=\\\"id\\\"/> <!--association:完成子对象的映射--> <!--property:子对象在父对象中的属性名--> <!--javaType:子对象的java类型--> <!--autoMapping:完成子对象的自动映射，若开启驼峰，则按驼峰匹配--> <association property=\\\"user\\\" javaType=\\\"com.zpc.mybatis.pojo.User\\\" autoMapping=\\\"true\\\"> <id column=\\\"user_id\\\" property=\\\"id\\\"/> </association> </resultMap> <select id=\\\"queryOrderWithUserByOrderNumber\\\" resultMap=\\\"OrderUserResultMap\\\"> select * from tb_order o left join tb_user u on o.user_id=u.id where o.order_number = #{number} </select>\",\"测试：\",\"@Test public void queryOrderWithUserByOrderNumber() throws Exception { Order order = orderMapper.queryOrderWithUserByOrderNumber(\\\"201807010001\\\"); System.out.println(order.getUser()); }\"]},\"794\":{\"h\":\"12.3.一对多查询\",\"t\":[\"一对多查询：查询订单，查询出下单人信息并且查询出订单详情。\",\"Order类：\",\"public class Order { private Integer id; private Long userId; private String orderNumber; private Date created; private Date updated; private User user; private List<OrderDetail> detailList; }\",\"public class OrderDetail { private Integer id; private Integer orderId; private Double totalPrice; private Integer status; }\",\"接口：\",\"/** * 根据订单号查询订单用户的信息及订单详情 * @param number * @return */ Order queryOrderWithUserAndDetailByOrderNumber(@Param(\\\"number\\\") String number);\",\"Mapper映射：\",\"<resultMap id=\\\"OrderUserDetailResultMap\\\" type=\\\"com.zpc.mybatis.pojo.Order\\\" autoMapping=\\\"true\\\"> <id column=\\\"id\\\" property=\\\"id\\\"/> <!--collection:定义子对象集合映射--> <!--association:完成子对象的映射--> <!--property:子对象在父对象中的属性名--> <!--javaType:子对象的java类型--> <!--autoMapping:完成子对象的自动映射，若开启驼峰，则按驼峰匹配--> <association property=\\\"user\\\" javaType=\\\"com.zpc.mybatis.pojo.User\\\" autoMapping=\\\"true\\\"> <id column=\\\"user_id\\\" property=\\\"id\\\"/> </association> <collection property=\\\"detailList\\\" javaType=\\\"List\\\" ofType=\\\"com.zpc.mybatis.pojo.OrderDetail\\\" autoMapping=\\\"true\\\"> <id column=\\\"id\\\" property=\\\"id\\\"/> </collection> </resultMap> <select id=\\\"queryOrderWithUserAndDetailByOrderNumber\\\" resultMap=\\\"OrderUserDetailResultMap\\\"> select * from tb_order o left join tb_user u on o.user_id=u.id left join tb_orderdetail od on o.id=od.order_id where o.order_number = #{number} </select>\",\"测试：\",\"@Test public void queryOrderWithUserAndDetailByOrderNumber() throws Exception { Order order = orderMapper.queryOrderWithUserAndDetailByOrderNumber(\\\"201807010001\\\"); System.out.println(order.getUser()); System.out.println(order.getDetailList()); }\"]},\"795\":{\"h\":\"12.4.多对多查询\",\"t\":[\"多对多查询：查询订单，查询出下单人信息并且查询出订单详情中的商品数据。\",\"OrderDetail类\",\"public class OrderDetail { private Integer id; private Integer orderId; private Double totalPrice; private Integer status; private Item item; } public class Item { private Integer id; private String itemName; private Float itemPrice; private String itemDetail; }\",\"接口：\",\"/** * 根据订单号查询订单用户的信息及订单详情及订单详情对应的商品信息 * @param number * @return */ Order queryOrderWithUserAndDetailItemByOrderNumber(@Param(\\\"number\\\") String number);\",\"Mapper配置：\",\"<resultMap id=\\\"OrderUserDetailItemResultMap\\\" type=\\\"com.zpc.mybatis.pojo.Order\\\" autoMapping=\\\"true\\\"> <id column=\\\"id\\\" property=\\\"id\\\"/> <association property=\\\"user\\\" javaType=\\\"com.zpc.mybatis.pojo.User\\\" autoMapping=\\\"true\\\"> <id column=\\\"user_id\\\" property=\\\"id\\\"/> </association> <collection property=\\\"detailList\\\" javaType=\\\"List\\\" ofType=\\\"com.zpc.mybatis.pojo.OrderDetail\\\" autoMapping=\\\"true\\\"> <id column=\\\"detail_id\\\" property=\\\"id\\\"/> <association property=\\\"item\\\" javaType=\\\"com.zpc.mybatis.pojo.Item\\\" autoMapping=\\\"true\\\"> <id column=\\\"item_id\\\" property=\\\"id\\\"/> </association> </collection> </resultMap> <select id=\\\"queryOrderWithUserAndDetailItemByOrderNumber\\\" resultMap=\\\"OrderUserDetailItemResultMap\\\"> select * ,od.id as detail_id from tb_order o left join tb_user u on o.user_id=u.id left join tb_orderdetail od on o.id=od.order_id left join tb_item i on od.item_id=i.id where o.order_number = #{number} </select>\",\"测试：\",\"@Test public void queryOrderWithUserAndDetailItemByOrderNumber() throws Exception { Order order = orderMapper.queryOrderWithUserAndDetailItemByOrderNumber(\\\"201807010001\\\"); System.out.println(order); System.out.println(order.getUser()); System.out.println(order.getDetailList()); }\",\"至此，目录结构如下：\",\"图片二十一\",\"数据库脚本： CREATE TABLE tb_order ( id int(11) NOT NULL AUTO_INCREMENT, user_id int(11) DEFAULT NULL, order_number varchar(255) DEFAULT NULL, create datetime DEFAULT NULL, updated datetime DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO tb_order VALUES (‘1’, ‘2’, ‘201807010001’, ‘2018-07-01 19:38:35’, ‘2018-07-01 19:38:40’); CREATE TABLE tb_item ( id int(11) NOT NULL, itemName varchar(255) DEFAULT NULL, itemPrice decimal(10,2) DEFAULT NULL, itemDetail varchar(255) DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO tb_item VALUES (‘1’, ‘袜子’, ‘29.90’, ‘香香的袜子’); INSERT INTO tb_item VALUES (‘2’, ‘套子’, ‘99.99’, ‘冈本001’); CREATE TABLE tb_orderdetail ( id int(11) NOT NULL AUTO_INCREMENT, order_id int(11) DEFAULT NULL, total_price decimal(10,0) DEFAULT NULL, item_id int(11) DEFAULT NULL, status int(10) unsigned zerofill DEFAULT NULL COMMENT ‘0成功非0失败’, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; INSERT INTO tb_orderdetail VALUES (‘1’, ‘1’, ‘10000’, ‘1’, ‘0000000001’); INSERT INTO tb_orderdetail VALUES (‘2’, ‘1’, ‘2000’, ‘2’, ‘0000000000’);\"]},\"796\":{\"h\":\"12.5.resultMap的继承\",\"t\":[\"图片二十二\"]},\"797\":{\"h\":\"12.6.高级查询的整理\",\"t\":[\"resutlType无法帮助我们自动的去完成映射，所以只有使用resultMap手动的进行映射。 type 结果集对应的数据类型 id 唯一标识，被引用的时候，进行指定。\",\"<resultMap type=\\\"Order\\\" id=\\\"orderUserLazyResultMap\\\"> <!—定义pojo中的单个对象的 property 定义对象的属性名， javaType 属性的类型， <association property=\\\"user\\\" javaType=\\\"User\\\" autoMapping=\\\"true\\\"> <id /> </association> <!—如果属性是集合使用collection ,javaType 集合的类型，ofType 表示集中的存储的元素类型 <collection property=\\\"details\\\" javaType=\\\"List\\\" ofType=\\\"OrderDetail\\\" autoMapping=\\\"true\\\"> <id /> </resultMap>\"]},\"798\":{\"h\":\"13.延迟加载\",\"t\":[\"后续补充\"]},\"799\":{\"h\":\"14.如果sql语句中出现’<’的解决方案\"},\"800\":{\"h\":\"14,1，使用xml中的字符实体\",\"t\":[\"23\",\"因为业务，需要在mybatis中，使用到大于号，小于号，所以就在SQL中直接使用了。\",\"SELECT * FROM test WHERE 1 = 1 AND start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE 可是，在执行时，总报错误： ```Error creating document instance. Cause: org.xml.sax.SAXParseException; lineNumber: 74; columnNumber: 17; ``元素内容必须由格式正确的字符数据或标记组成。 把 AND start_date >= CURRENT_DATE AND end_date <= CURRENT_DATE 去掉，就没有问题，所以确定是因为大于号，小于号引起的问题。\",\"于是就想到了特殊符号，于是用了转义字符把>和<替换掉，然后就没有问题了。\",\"SELECT * FROM test WHERE 1 = 1 AND start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE 案例：\",\"1.<if test=\\\"startDateTime!=null\\\"> and mm.ttime &gt; to_date(#{startDateTime},'yyyy-mm-dd hh24:mi:ss')</if> 2.<if test=\\\"endDateTime!=null\\\"> and mm.ttime &lt;= to_date(#{endDateTime},'yyyy-mm-dd hh24:mi:ss')</if>\"]},\"801\":{\"h\":\"14,2,使用\",\"t\":[\"案例1：\",\"<![CDATA[ and mm.ttime > to_date(#{startDateTime},'yyyy-mm-dd hh24:mi:ss') and mm.ttime <= to_date(#{endDateTime},'yyyy-mm-dd hh24:mi:ss') ]]>\",\"案例2：\",\"mapper文件示例代码 ：\",\"and (t1.status <![CDATA[ >= ]]> 1 and t1.status <![CDATA[ <= ]]> 2) 上述代码其实对应的sql： and (t1.status > =1 andt1.status <= 2)\",\"注意：\",\"使用 <![CDATA[ ]]> 标记的sql语句中的 <where> <if> 等标签不会被解析。\",\"CDATA 部分中的所有内容都会被解析器忽略。 CDATA 部分由 <![CDATA[\\\" 开始，由 \\\"]]> 结束\"]},\"802\":{\"c\":[\"mybatis\",\"java\"]},\"803\":{\"c\":[\"mybatis\",\"java\"]},\"804\":{\"h\":\"Spring\"},\"805\":{\"c\":[\"spring\",\"java\"]},\"806\":{\"c\":[\"spring\",\"java\"]},\"807\":{\"h\":\"手把手整合SSM框架\",\"t\":[\"如果看过前几篇文章，对 Spring 和 MyBatis 有了一定了解，一定想上手试试。这篇文章从 0 到 1，手把手整合 SSM (Spring、Spring MVC、MyBatis)。\",\"本篇是代码篇，在 PC 端浏览更佳，源码在文末\",\"[toc]\"]},\"808\":{\"h\":\"开发环境\",\"t\":[\"idea\",\"MySql5.x\",\"jdk8\",\"maven\",\"对应的技术入门在 公众号 历史文章 都可以找到\"]},\"809\":{\"h\":\"目录\",\"t\":[\"目录包括 main、resources、mapper、webapp，不一一介绍，不熟悉查看前面文章。\"]},\"810\":{\"h\":\"环境搭建\"},\"811\":{\"h\":\"新建项目\",\"t\":[\"这里使用的是 IDEA 编辑器，新建一个 Maven 工程，选择 web 项目。\"]},\"812\":{\"h\":\"导入依赖\",\"t\":[\"使用 Maven 管理项目 jar ，只需要在 pom.xml 加如相关依赖即可。\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>javapub.rodert.github</groupId> <artifactId>ssm_helloword_web</artifactId> <version>1.0-SNAPSHOT</version> <packaging>war</packaging> <url></url> <!-- 源码：https://github.com/Rodert/JavaPub--> <properties> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <spring.version>4.3.6.RELEASE</spring.version> </properties> <dependencies> <!-- 单元测试 --> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> </dependency> <!-- 1.日志 --> <!-- 实现slf4j接口并整合 --> <dependency> <groupId>ch.qos.logback</groupId> <artifactId>logback-classic</artifactId> <version>1.1.1</version> </dependency> <!-- 2.数据库 --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.37</version> <scope>runtime</scope> </dependency> <dependency> <groupId>c3p0</groupId> <artifactId>c3p0</artifactId> <version>0.9.1.2</version> </dependency> <!-- DAO: MyBatis --> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.3.0</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis-spring</artifactId> <version>1.2.3</version> </dependency> <!-- 3.Servlet web --> <dependency> <groupId>taglibs</groupId> <artifactId>standard</artifactId> <version>1.1.2</version> </dependency> <dependency> <groupId>jstl</groupId> <artifactId>jstl</artifactId> <version>1.2</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.5.4</version> </dependency> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> </dependency> <!-- 4.Spring --> <!-- 1)Spring核心 --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> <version>${spring.version}</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-beans</artifactId> <version>${spring.version}</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>${spring.version}</version> </dependency> <!-- 2)Spring DAO层 --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-jdbc</artifactId> <version>${spring.version}</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-tx</artifactId> <version>${spring.version}</version> </dependency> <!-- 3)Spring web --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-web</artifactId> <version>${spring.version}</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>${spring.version}</version> </dependency> <!-- 4)Spring test --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-test</artifactId> <version>${spring.version}</version> </dependency> <!-- redis客户端:Jedis --> <dependency> <groupId>redis.clients</groupId> <artifactId>jedis</artifactId> <version>2.7.3</version> </dependency> <dependency> <groupId>com.dyuproject.protostuff</groupId> <artifactId>protostuff-core</artifactId> <version>1.0.8</version> </dependency> <dependency> <groupId>com.dyuproject.protostuff</groupId> <artifactId>protostuff-runtime</artifactId> <version>1.0.8</version> </dependency> <!-- Map工具类 --> <dependency> <groupId>commons-collections</groupId> <artifactId>commons-collections</artifactId> <version>3.2</version> </dependency> <!--注解--> <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.12</version> <scope>provided</scope> </dependency> </dependencies> <build> <finalName>ssm_helloword_web</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <configuration> <source>7</source> <target>7</target> </configuration> </plugin> </plugins> </build> </project> <!-- 源码：https://github.com/Rodert/JavaPub-->\"]},\"813\":{\"h\":\"编码\"},\"814\":{\"h\":\"配置文件\"},\"815\":{\"h\":\"spring-dao.xml\",\"t\":[\"先在spring文件夹里新建spring-dao.xml文件，我们这里分三层，分别是dao service web。\",\"加载数据库配置\",\"配置数据库连接池\",\"配置 SqlSessionFactory 对象（MyBatis）\",\"配置扫描 dao 层接口，动态代理实现 Dao 实现类，执行 sql 写在 xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\\\"> <!-- 配置整合mybatis过程 --> <!-- 1.配置数据库相关参数properties的属性：${url} --> <context:property-placeholder location=\\\"classpath:jdbc.properties\\\" /> <!-- 2.数据库连接池 --> <bean id=\\\"dataSource\\\" class=\\\"com.mchange.v2.c3p0.ComboPooledDataSource\\\"> <!-- 配置连接池属性 --> <property name=\\\"driverClass\\\" value=\\\"${jdbc.driver}\\\" /> <property name=\\\"jdbcUrl\\\" value=\\\"${jdbc.url}\\\" /> <property name=\\\"user\\\" value=\\\"${jdbc.username}\\\" /> <property name=\\\"password\\\" value=\\\"${jdbc.password}\\\" /> <!-- c3p0连接池的私有属性 --> <property name=\\\"maxPoolSize\\\" value=\\\"30\\\" /> <property name=\\\"minPoolSize\\\" value=\\\"10\\\" /> <!-- 关闭连接后不自动commit --> <property name=\\\"autoCommitOnClose\\\" value=\\\"false\\\" /> <!-- 获取连接超时时间 --> <property name=\\\"checkoutTimeout\\\" value=\\\"10000\\\" /> <!-- 当获取连接失败重试次数 --> <property name=\\\"acquireRetryAttempts\\\" value=\\\"2\\\" /> </bean> <!-- 3.配置SqlSessionFactory对象 --> <bean id=\\\"sqlSessionFactory\\\" class=\\\"org.mybatis.spring.SqlSessionFactoryBean\\\"> <!-- 注入数据库连接池 --> <property name=\\\"dataSource\\\" ref=\\\"dataSource\\\" /> <!-- 配置MyBaties全局配置文件:mybatis-config.xml --> <property name=\\\"configLocation\\\" value=\\\"classpath:Mybatis-config.xml\\\" /> <!-- 扫描entity包 使用别名 --> <property name=\\\"typeAliasesPackage\\\" value=\\\"javapub.rodert.github.entity\\\" /> <!-- 扫描sql配置文件:mapper需要的xml文件 --> <property name=\\\"mapperLocations\\\" value=\\\"classpath:mapper/*.xml\\\" /> </bean> <!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --> <bean class=\\\"org.mybatis.spring.mapper.MapperScannerConfigurer\\\"> <!-- 注入sqlSessionFactory --> <property name=\\\"sqlSessionFactoryBeanName\\\" value=\\\"sqlSessionFactory\\\" /> <!-- 给出需要扫描Dao接口包 --> <property name=\\\"basePackage\\\" value=\\\"javapub.rodert.github.dao\\\" /> </bean> </beans>\"]},\"816\":{\"h\":\"jdbc.properties\",\"t\":[\"数据库配置，在 resources 文件夹里新建一个 jdbc.properties 文件，注意自己的密码。\",\"jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssm1?useUnicode=true&characterEncoding=utf8 jdbc.username=root jdbc.password=\"]},\"817\":{\"h\":\"mybatis-config.xml\",\"t\":[\"MyBatis 核心文件，在recources文件夹里新建mybatis-config.xml文件。\",\"使用自增主键\",\"使用列别名\",\"开启驼峰命名转换 create_time -> createTime\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <!-- 配置全局属性 --> <settings> <!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --> <setting name=\\\"useGeneratedKeys\\\" value=\\\"true\\\" /> <!-- 使用列别名替换列名 默认:true --> <setting name=\\\"useColumnLabel\\\" value=\\\"true\\\" /> <!-- 开启驼峰命名转换:Table{create_time} -> Entity{createTime} --> <setting name=\\\"mapUnderscoreToCamelCase\\\" value=\\\"true\\\" /> </settings> </configuration>\"]},\"818\":{\"h\":\"spring-service.xml\",\"t\":[\"在 spring 文件夹里新建 spring-service.xml 文件。\",\"扫描 service 包所有注解 @Service\",\"配置事务管理器，把事务管理交由 spring 来完成\",\"基于注解的 声明式事务，可以直接在方法上 @Transaction\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xmlns:tx=\\\"http://www.springframework.org/schema/tx\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\\\"> <!-- 扫描service包下所有使用注解的类型 --> <context:component-scan base-package=\\\"javapub.rodert.github.service\\\" /> <!-- 配置事务管理器 --> <bean id=\\\"transactionManager\\\" class=\\\"org.springframework.jdbc.datasource.DataSourceTransactionManager\\\"> <!-- 注入数据库连接池 --> <property name=\\\"dataSource\\\" ref=\\\"dataSource\\\" /> </bean> <!-- 配置基于注解的声明式事务 --> <tx:annotation-driven transaction-manager=\\\"transactionManager\\\" /> </beans>\"]},\"819\":{\"h\":\"spring-web.xml\",\"t\":[\"web 层，在 spring 文件夹里新建 spring-web.xml 文件。\",\"开启SpringMVC注解模式，可以使用@RequestMapping，@PathVariable，@ResponseBody等\",\"对静态资源处理，如js，css，jpg等\",\"配置jsp 显示ViewResolver，及渲染后的 JSP\",\"扫描web层 @Controller\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xmlns:mvc=\\\"http://www.springframework.org/schema/mvc\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd\\\"> <!-- 配置SpringMVC --> <!-- 1.开启SpringMVC注解模式 --> <!-- 简化配置： (1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter (2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持 --> <mvc:annotation-driven /> <!-- 2.静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用\\\"/\\\"做整体映射 --> <mvc:default-servlet-handler/> <!-- 3.配置jsp 显示ViewResolver --> <bean class=\\\"org.springframework.web.servlet.view.InternalResourceViewResolver\\\"> <property name=\\\"viewClass\\\" value=\\\"org.springframework.web.servlet.view.JstlView\\\" /> <!-- <property name=\\\"contentType\\\" value=\\\"text/html\\\"/>--> <property name=\\\"prefix\\\" value=\\\"/WEB-INF/jsp/\\\" /> <property name=\\\"suffix\\\" value=\\\".jsp\\\" /> </bean> <!-- 4.扫描web相关的bean --> <context:component-scan base-package=\\\"javapub.rodert.github.web\\\" /> </beans>\"]},\"820\":{\"h\":\"web.xml\",\"t\":[\"修改 web.xml 文件了，它在 webapp 的 WEB-INF 下。也可以在这里配置过滤器、监听器等。\",\"<web-app xmlns=\\\"http://xmlns.jcp.org/xml/ns/javaee\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\\\" version=\\\"3.1\\\" metadata-complete=\\\"true\\\"> <!-- 如果是用mvn命令生成的xml，需要修改servlet版本为3.1 --> <!-- 配置DispatcherServlet --> <servlet> <servlet-name>dispatcherServlet</servlet-name> <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> <!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml Mybatis - > spring -> springmvc --> <init-param> <param-name>contextConfigLocation</param-name> <param-value>classpath:spring/spring-*.xml</param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>dispatcherServlet</servlet-name> <!-- 默认匹配所有的请求 --> <url-pattern>/</url-pattern> </servlet-mapping> <welcome-file-list> <welcome-file>index.jsp</welcome-file> </welcome-file-list> </web-app>\"]},\"821\":{\"h\":\"日志\",\"t\":[\"配置一些简单的日志，使用 logback ，在 resources 文件夹里新建logback.xml 文件。\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <configuration debug=\\\"true\\\"> <appender name=\\\"STDOUT\\\" class=\\\"ch.qos.logback.core.ConsoleAppender\\\"> <!-- encoders are by default assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder --> <encoder> <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern> </encoder> </appender> <root level=\\\"debug\\\"> <appender-ref ref=\\\"STDOUT\\\" /> </root> </configuration>\"]},\"822\":{\"h\":\"配置说明\",\"t\":[\"以上配置是整合 SSM 的基础配置，目录结构如图所示：\"]},\"823\":{\"h\":\"SSM实例-图书管理系统\"},\"824\":{\"h\":\"sql\",\"t\":[\"以上部分整个 SSM 框架就已经搭建好了，下面是一个 Demo ，供参考。\",\"新建俩张表，图书表 book 和 预约图书表 appointment，并初始化数据。\",\"/* Navicat MySQL Data Transfer Source Server : localhost Source Server Version : 50716 Source Host : localhost:3306 Source Database : ssm1 Target Server Type : MYSQL Target Server Version : 50716 File Encoding : 65001 Date: 2020-07-12 16:50:43 */ SET FOREIGN_KEY_CHECKS=0; -- ---------------------------- -- Table structure for appointment -- ---------------------------- DROP TABLE IF EXISTS `appointment`; CREATE TABLE `appointment` ( `book_id` bigint(20) NOT NULL COMMENT '图书ID', `student_id` bigint(20) NOT NULL COMMENT '学号', `appoint_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '预约时间', PRIMARY KEY (`book_id`,`student_id`), KEY `idx_appoint_time` (`appoint_time`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='预约图书表'; -- ---------------------------- -- Records of appointment -- ---------------------------- -- ---------------------------- -- Table structure for book -- ---------------------------- DROP TABLE IF EXISTS `book`; CREATE TABLE `book` ( `book_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '图书ID', `name` varchar(100) NOT NULL COMMENT '图书名称', `number` int(11) NOT NULL COMMENT '馆藏数量', PRIMARY KEY (`book_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1004 DEFAULT CHARSET=utf8 COMMENT='图书表'; -- ---------------------------- -- Records of book -- ---------------------------- INSERT INTO `book` VALUES ('2000', 'Java程序设计', '20'); INSERT INTO `book` VALUES ('2001', '数据结构', '7'); INSERT INTO `book` VALUES ('2002', '设计模式', '20'); INSERT INTO `book` VALUES ('2003', '编译原理', '20');\"]},\"825\":{\"h\":\"实体\",\"t\":[\"在 entity 包下新建实体 Book 和 Appointment\",\"Book.java\",\"package javapub.rodert.github.entity; import lombok.Getter; import lombok.Setter; import lombok.ToString; /** * @author wangshiyu rodert * @date 2020/7/6 20:58 * @description * * @Data 注解，简化代码，自动添加get set toSting 方法 * @Getter * @Setter * @ToString */ @Getter @Setter @ToString public class Book { private long bookId;// 图书ID private String name;// 图书名称 private int number;// 馆藏数量 // 省略构造方法，getter和setter方法，toString方法 }\",\"Appointment.java\",\"package javapub.rodert.github.entity; /** * @author wangshiyu rodert * @date 2020/7/6 20:58 * @description */ import lombok.Data; import lombok.Getter; import lombok.Setter; import lombok.ToString; import java.util.Date; /** * 预约图书实体 * @Data 注解，简化代码，自动添加get set toSting 方法 */ @Data public class Appointment { private long bookId;// 图书ID private long studentId;// 学号 private Date appointTime;// 预约时间 // 多对一的复合属性 private Book book;// 图书实体 // 省略构造方法，getter和setter方法，toString方法 }\"]},\"826\":{\"h\":\"dao接口\",\"t\":[\"在dao包新建接口 BookDao.java 和 Appointment.java\",\"BookDao.java\",\"package javapub.rodert.github.dao; /** * @author wangshiyu rodert * @date 2020/7/6 21:01 * @description */ import javapub.rodert.github.entity.Book; import org.apache.ibatis.annotations.Param; import java.util.List; public interface BookDao { /** * 通过ID查询单本图书 * * @param id * @return */ Book queryById(long id); /** * 查询所有图书 * * @param offset 查询起始位置 * @param limit 查询条数 * @return */ List<Book> queryAll(@Param(\\\"offset\\\") int offset, @Param(\\\"limit\\\") int limit); /** * 减少馆藏数量 * * @param bookId * @return 如果影响行数等于>1，表示更新的记录行数 */ int reduceNumber(long bookId); }\",\"AppointmentDao.java\",\"package javapub.rodert.github.dao; /** * @author wangshiyu rodert * @date 2020/7/6 21:01 * @description */ import javapub.rodert.github.entity.Appointment; import org.apache.ibatis.annotations.Param; public interface AppointmentDao { /** * 插入预约图书记录 * * @param bookId * @param studentId * @return 插入的行数 */ int insertAppointment(@Param(\\\"bookId\\\") long bookId, @Param(\\\"studentId\\\") long studentId); /** * 通过主键查询预约图书记录，并且携带图书实体 * * @param bookId * @param studentId * @return */ Appointment queryByKeyWithBook(@Param(\\\"bookId\\\") long bookId, @Param(\\\"studentId\\\") long studentId); }\",\"提示：这里为什么要给方法的参数添加 @Param注解呢？是因为该方法有两个或以上的参数，一定要加，不然 mybatis 识别不了。上面的 BookDao 接口的 queryById 方法和 reduceNumber 方法只有一个参数 book_id ，所以可以不用加 @Param 注解。\"]},\"827\":{\"h\":\"dao接口xml\",\"t\":[\"这里不需要写 dao接口 的实现类，mybatis会帮我们动态实现，上面我们已经在 spring-dao.xml 配置了动态扫描。现在需要编写相应的 mapper。 在 mapper 目录里新建两个文件 BookDao.xml 和 AppointmentDao.xml ，分别对应上面两个dao接口。\",\"BookDao.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"javapub.rodert.github.dao.BookDao\\\"> <!-- 目的：为dao接口方法提供sql语句配置 --> <select id=\\\"queryById\\\" resultType=\\\"Book\\\" parameterType=\\\"long\\\"> <!-- 具体的sql --> SELECT book_id, name, number FROM book WHERE book_id = #{bookId} </select> <select id=\\\"queryAll\\\" resultType=\\\"Book\\\"> SELECT book_id, name, number FROM book ORDER BY book_id LIMIT #{offset}, #{limit} </select> <update id=\\\"reduceNumber\\\"> UPDATE book SET number = number - 1 WHERE book_id = #{bookId} AND number > 0 </update> </mapper>\",\"AppointmentDao.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"javapub.rodert.github.dao.AppointmentDao\\\"> <insert id=\\\"insertAppointment\\\"> <!-- ignore 主键冲突，报错 --> INSERT ignore INTO appointment (book_id, student_id) VALUES (#{bookId}, #{studentId}) </insert> <select id=\\\"queryByKeyWithBook\\\" resultType=\\\"Appointment\\\"> <!-- 如何告诉MyBatis把结果映射到Appointment同时映射book属性 --> <!-- 可以自由控制SQL --> SELECT a.book_id, a.student_id, a.appoint_time, b.book_id \\\"book.book_id\\\", b.`name` \\\"book.name\\\", b.number \\\"book.number\\\" FROM appointment a INNER JOIN book b ON a.book_id = b.book_id WHERE a.book_id = #{bookId} AND a.student_id = #{studentId} </select> </mapper>\",\"mapper 说明：namespace 是 xml 对应的接口全名，select 和 update 中的 id 对应方法名（唯一），resultType 是返回值类型，parameterType 是参数类型（这个其实可选），#{...} 中填写的是方法的参数\"]},\"828\":{\"h\":\"dao接口测试\",\"t\":[\"现在的写法是从数据库层向前（web）写，现在测试一下 dao 接口，编写测试类。\",\"因为每次测试都要加载配置文件，所有抽离一个类（BaseTest），每次测试方法都继承它。\",\"BaseTest.java\",\"package javapub.rodert.github; /** * @author wangshiyu rodert * @date 2020/7/6 21:07 * @description */ import org.junit.runner.RunWith; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; /** * 配置spring和junit整合，junit启动时加载springIOC容器 spring-test,junit */ @RunWith(SpringJUnit4ClassRunner.class) // 告诉junit spring配置文件 @ContextConfiguration({ \\\"classpath:spring/spring-dao.xml\\\", \\\"classpath:spring/spring-service.xml\\\" }) public class BaseTest { }\",\"新建 BookDaoTest.java 和 AppointmentDaoTest.java 两个 dao 测试文件。\",\"BookDao.java\",\"package javapub.rodert.github.dao; /** * @author wangshiyu rodert * @date 2020/7/6 21:08 * @description */ import javapub.rodert.github.BaseTest; import javapub.rodert.github.entity.Book; import org.junit.Test; import org.springframework.beans.factory.annotation.Autowired; import java.util.List; public class BookDaoTest extends BaseTest { @Autowired private BookDao bookDao; @Test public void testQueryById() throws Exception { long bookId = 1000; Book book = bookDao.queryById(bookId); System.out.println(book); } @Test public void testQueryAll() throws Exception { List<Book> books = bookDao.queryAll(0, 4); for (Book book : books) { System.out.println(book); } } @Test public void testReduceNumber() throws Exception { long bookId = 1000; int update = bookDao.reduceNumber(bookId); System.out.println(\\\"update=\\\" + update); } }\",\"AppointmentDaoTest.java\",\"package javapub.rodert.github.dao; /** * @author wangshiyu rodert * @date 2020/7/6 21:18 * @description */ import javapub.rodert.github.BaseTest; import javapub.rodert.github.entity.Appointment; import org.junit.Test; import org.springframework.beans.factory.annotation.Autowired; public class AppointmentDaoTest extends BaseTest { @Autowired private AppointmentDao appointmentDao; @Test public void testInsertAppointment() throws Exception { long bookId = 1000; long studentId = 12345678910L; int insert = appointmentDao.insertAppointment(bookId, studentId); System.out.println(\\\"insert=\\\" + insert); } @Test public void testQueryByKeyWithBook() throws Exception { long bookId = 1000; long studentId = 12345678910L; Appointment appointment = appointmentDao.queryByKeyWithBook(bookId, studentId); System.out.println(appointment); System.out.println(appointment.getBook()); } }\",\"BookDaoTest.java -- > testQueryById()\",\"测试方法都验证过，没有问题，不一一测试了\"]},\"829\":{\"h\":\"业务层-结果集封装\",\"t\":[\"到这里，我们的 dao 层，及数据库接口操作都没有问题，下面开始业务层编写。\",\"如果你有实战项目经验，那一定会发现，对于后端接口，我们都会定义一个统一的返回格式，及定义一个返回标准方便前端解析，如下：\",\"{ \\\"code\\\":200, \\\"message\\\":\\\"成功\\\", \\\"result\\\":{}, \\\"isSuccess\\\":true }\",\"开始写我们的代码，新建枚举类，用来定义预约业务的数据字典。如果不太明白，先看代码，后面在 JavaPub 微信公众号文章索引中查找对应文章。\",\"新建一个包叫 enums，在里面新建一个枚举类 AppointStateEnum.java。\",\"AppointStateEnum.java\",\"package javapub.rodert.github.enums; /** * @author wangshiyu rodert * @date 2020/7/6 21:20 * @description */ /** * 使用枚举表述常量数据字典 */ public enum AppointStateEnum { SUCCESS(1, \\\"预约成功\\\"), NO_NUMBER(0, \\\"库存不足\\\"), REPEAT_APPOINT(-1, \\\"重复预约\\\"), INNER_ERROR(-2, \\\"系统异常\\\"); private int state; private String stateInfo; private AppointStateEnum(int state, String stateInfo) { this.state = state; this.stateInfo = stateInfo; } public int getState() { return state; } public String getStateInfo() { return stateInfo; } public static AppointStateEnum stateOf(int index) { for (AppointStateEnum state : values()) { if (state.getState() == index) { return state; } } return null; } }\",\"在 dto 包下新建 AppointExecution.java 用来存储我们执行预约操作的返回结果。\",\"AppointExecution.java\",\"package javapub.rodert.github.dto; /** * @author wangshiyu rodert * @date 2020/7/7 16:26 * @description */ import javapub.rodert.github.entity.Appointment; import javapub.rodert.github.enums.AppointStateEnum; import lombok.Data; /** * 封装预约执行后结果 */ @Data public class AppointExecution { // 图书ID private long bookId; // 秒杀预约结果状态 private int state; // 状态标识 private String stateInfo; // 预约成功对象 private Appointment appointment; public AppointExecution() { } // 预约失败的构造器 public AppointExecution(long bookId, AppointStateEnum stateEnum) { this.bookId = bookId; this.state = stateEnum.getState(); this.stateInfo = stateEnum.getStateInfo(); } // 预约成功的构造器 public AppointExecution(long bookId, AppointStateEnum stateEnum, Appointment appointment) { this.bookId = bookId; this.state = stateEnum.getState(); this.stateInfo = stateEnum.getStateInfo(); this.appointment = appointment; } // 省略getter和setter方法，toString方法 }\",\"在 exception 包下新建三个文件\",\"NoNumberException.javaRepeatAppointException.javaAppointException.java\",\"预约业务异常类（都需要继承 RuntimeException ---运行时异常类），分别是无库存异常、重复预约异常、预约未知错误异常，用于业务层非成功情况下的返回（即成功返回结果，失败抛出异常）。为事务做准备。\",\"AppointException.java\",\"package javapub.rodert.github.exception; /** * @author wangshiyu rodert * @date 2020/7/7 16:31 * @description */ /** * 预约业务异常 */ public class AppointException extends RuntimeException { public AppointException(String message) { super(message); } public AppointException(String message, Throwable cause) { super(message, cause); } }\",\"NoNumberException.java\",\"/** * @author wangshiyu rodert * @date 2020/7/7 16:30 * @description */ package javapub.rodert.github.exception; /** * 库存不足异常 */ public class NoNumberException extends RuntimeException { public NoNumberException(String message) { super(message); } public NoNumberException(String message, Throwable cause) { super(message, cause); } }\",\"RepeatAppointException.java\",\" /** * @author wangshiyu rodert * @date 2020/7/7 16:31 * @description */ package javapub.rodert.github.exception; /** * 重复预约异常 */ public class RepeatAppointException extends RuntimeException { public RepeatAppointException(String message) { super(message); } public RepeatAppointException(String message, Throwable cause) { super(message, cause); } }\"]},\"830\":{\"h\":\"Service 业务接口代码\",\"t\":[\"在service包下新建BookService.java图书业务接口。\",\"BookService.java\",\" /** * @author wangshiyu rodert * @date 2020/7/7 16:32 * @description */ package javapub.rodert.github.service; import javapub.rodert.github.dto.AppointExecution; import javapub.rodert.github.entity.Book; import java.util.List; /** * 业务接口：站在\\\"使用者\\\"角度设计接口 三个方面：方法定义粒度，参数，返回类型（return 类型/异常） */ public interface BookService { /** * 查询一本图书 * * @param bookId * @return */ Book getById(long bookId); /** * 查询所有图书 * * @return */ List<Book> getList(); /** * 预约图书 * * @param bookId * @param studentId * @return */ AppointExecution appoint(long bookId, long studentId); }\",\"在 service.impl 包下新建 BookServiceImpl.java 使用 BookService 接口，并实现里面的方法。\",\"BookServiceImpl.java\",\" /** * @author wangshiyu rodert * @date 2020/7/7 16:39 * @description */ package javapub.rodert.github.service.impl; import javapub.rodert.github.dao.AppointmentDao; import javapub.rodert.github.dao.BookDao; import javapub.rodert.github.dto.AppointExecution; import javapub.rodert.github.entity.Appointment; import javapub.rodert.github.entity.Book; import javapub.rodert.github.enums.AppointStateEnum; import javapub.rodert.github.exception.AppointException; import javapub.rodert.github.exception.NoNumberException; import javapub.rodert.github.exception.RepeatAppointException; import javapub.rodert.github.service.BookService; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.util.List; @Service public class BookServiceImpl implements BookService { private Logger logger = LoggerFactory.getLogger(this.getClass()); // 注入Service依赖 @Autowired private BookDao bookDao; @Autowired private AppointmentDao appointmentDao; @Override public Book getById(long bookId) { return bookDao.queryById(bookId); } @Override public List<Book> getList() { return bookDao.queryAll(0, 1000); } @Override @Transactional /** * 使用注解控制事务方法的优点： * 1.开发团队达成一致约定，明确标注事务方法的编程风格 * 2.保证事务方法的执行时间尽可能短，不要穿插其他网络操作，RPC/HTTP请求或者剥离到事务方法外部 * 3.不是所有的方法都需要事务，如只有一条修改操作，只读操作不需要事务控制 */ public AppointExecution appoint(long bookId, long studentId) { try { // 减库存 int update = bookDao.reduceNumber(bookId); if (update <= 0) {// 库存不足 //return new AppointExecution(bookId, AppointStateEnum.NO_NUMBER);//错误写法 throw new NoNumberException(\\\"no number\\\");// 抛出异常，保证触发事务执行 } else { // 执行预约操作 int insert = appointmentDao.insertAppointment(bookId, studentId); if (insert <= 0) {// 重复预约 //return new AppointExecution(bookId, AppointStateEnum.REPEAT_APPOINT);//错误写法 throw new RepeatAppointException(\\\"repeat appoint\\\"); } else {// 预约成功 Appointment appointment = appointmentDao.queryByKeyWithBook(bookId, studentId); return new AppointExecution(bookId, AppointStateEnum.SUCCESS, appointment); } } // 要先于catch Exception异常前先catch住再抛出，不然自定义的异常也会被转换为AppointException，导致控制层无法具体识别是哪个异常 } catch (NoNumberException | RepeatAppointException e1) { throw e1; } catch (Exception e) { logger.error(e.getMessage(), e); // 所有编译期异常转换为运行期异常 //return new AppointExecution(bookId, AppointStateEnum.INNER_ERROR);//错误写法 throw new AppointException(\\\"appoint inner error:\\\" + e.getMessage()); } } }\",\"实现类使用了我们上边定义的异常方法 RepeatAppointException ，用于业务层非成功情况下的返回（即成功返回结果，失败抛出异常）。触发事务。\",\"测试一下业务层代码，这里演示预约图书业务。\",\"BookServiceImplTest.java\",\" /** * @author wangshiyu rodert * @date 2020/7/7 16:40 * @description */ package javapub.rodert.github.service.impl; import javapub.rodert.github.BaseTest; import javapub.rodert.github.dto.AppointExecution; import javapub.rodert.github.service.BookService; import org.junit.Test; import org.springframework.beans.factory.annotation.Autowired; public class BookServiceImplTest extends BaseTest { @Autowired private BookService bookService; @Test public void testAppoint() throws Exception { long bookId = 1001; long studentId = 12345678910L; AppointExecution execution = bookService.appoint(bookId, studentId); System.out.println(execution); } }\",\"测试结果：\",\"首次执行是“预约成功”，如果再次执行的话，应该会出现“重复预约”，至此，我们所有的后台代码都通过单元测试啦~~ 是不是很开心~\",\"咱们还需要在dto包里新建一个封装json返回结果的类Result.java，设计成泛型。\",\"Result.java\",\"package javapub.rodert.github.dto; /** * @author wangshiyu rodert * @date 2020/7/7 21:00 * @description */ import lombok.Data; /** * 封装json对象，所有返回结果都使用它 */ @Data public class Result<T> { private boolean success;// 是否成功标志 private T data;// 成功时返回的数据 private String error;// 错误信息 public Result() { } // 成功时的构造器 public Result(boolean success, T data) { this.success = success; this.data = data; } // 错误时的构造器 public Result(boolean success, String error) { this.success = success; this.error = error; } // 省略getter和setter方法 使用注解代替 }\"]},\"831\":{\"h\":\"web层\",\"t\":[\"web 层，也就是 controller 层，我们在web包下新建BookController.java文件。\",\"BookController.java\",\"package javapub.rodert.github.web; /** * @author wangshiyu rodert * @date 2020/7/7 21:05 * @description */ import javapub.rodert.github.dto.AppointExecution; import javapub.rodert.github.dto.Result; import javapub.rodert.github.entity.Book; import javapub.rodert.github.enums.AppointStateEnum; import javapub.rodert.github.exception.NoNumberException; import javapub.rodert.github.exception.RepeatAppointException; import javapub.rodert.github.service.BookService; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.ModelAndView; import java.util.List; @RestController @RequestMapping(\\\"/book\\\") // url:/模块/资源/{id}/细分 /seckill/list public class BookController { private Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private BookService bookService; @RequestMapping(value = \\\"/test\\\") public ModelAndView test(){ ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\\\"book/test\\\"); modelAndView.addObject(\\\"key\\\",\\\"welcome javaPub\\\"); return modelAndView; } @RequestMapping(value = \\\"/list\\\", method = RequestMethod.GET) private String list(Model model) { List<Book> list = bookService.getList(); model.addAttribute(\\\"list\\\", list); // list.jsp + model = ModelAndView return \\\"list\\\";// WEB-INF/jsp/\\\"list\\\".jsp } @RequestMapping(value = \\\"/{bookId}/detail\\\", method = RequestMethod.GET) private String detail(@PathVariable(\\\"bookId\\\") Long bookId, Model model) { if (bookId == null) { return \\\"redirect:/book/list\\\"; } Book book = bookService.getById(bookId); if (book == null) { return \\\"forward:/book/list\\\"; } model.addAttribute(\\\"book\\\", book); return \\\"detail\\\"; } //ajax json //method = RequestMethod.POST, @RequestMapping(value = \\\"/{bookId}/appoint\\\", produces = { \\\"application/json; charset=utf-8\\\" }) @ResponseBody private Result<AppointExecution> appoint(@PathVariable(\\\"bookId\\\") Long bookId, @RequestParam(\\\"studentId\\\") Long studentId) { if (studentId == null || studentId.equals(\\\"\\\")) { return new Result<>(false, \\\"学号不能为空\\\"); } //AppointExecution execution = bookService.appoint(bookId, studentId);//错误写法，不能统一返回，要处理异常（失败）情况 AppointExecution execution = null; try { execution = bookService.appoint(bookId, studentId); } catch (NoNumberException e1) { execution = new AppointExecution(bookId, AppointStateEnum.NO_NUMBER); } catch (RepeatAppointException e2) { execution = new AppointExecution(bookId, AppointStateEnum.REPEAT_APPOINT); } catch (Exception e) { execution = new AppointExecution(bookId, AppointStateEnum.INNER_ERROR); } return new Result<AppointExecution>(true, execution); } }\",\"目前大多项目都是前后端分离，我们作为服务端，一般和前端通过接口数据交互（json），像接口方法 appoint ，应该添加 @ResponseBody 注解。 测试 controller --> appoint 方法可以通过 curl ，如：\",\"curl -H “Accept: application/json; charset=utf-8” -d “studentId=1234567890” localhost:8080/book/1003/appoint\"]},\"832\":{\"h\":\"运行项目\",\"t\":[\"现在整个项目全部完成，配置tomcat，通过左上角引入 tomcat ，选择我们的项目 ssm。\",\"启动成功后：\",\"这里对前端代码只写较少部分，具体可参考 BookController --> book/test 接口，有需要帮助请留言。\",\"BookController.java --> book/test\",\" @RequestMapping(value = \\\"/test\\\") public ModelAndView test(){ ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\\\"book/test\\\"); modelAndView.addObject(\\\"key\\\",\\\"welcome javaPub\\\"); return modelAndView; }\",\"test.jsp\",\"<%@ page language=\\\"java\\\" contentType=\\\"text/html; charset=UTF-8\\\" pageEncoding=\\\"UTF-8\\\"%> <!DOCTYPE HTML> <html> <head> <%@ page isELIgnored=\\\"false\\\"%> <meta charset=\\\"UTF-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0, minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\\\"/> <title>news detail</title> </head> <body class=\\\"fn-pd24\\\"> <h1>大家好 ${key}</h1> <a href=\\\"https://mp.weixin.qq.com/s/kfyRAPnRDp8LLktjgd658Q\\\">JavaPub知识清单</a> </body> </html>\",\"通过 ModelAndView 将我们需要渲染的数据存储传输到对应视图，由 Sping MVC 定义好的视图解析器对该对象解析，最后将结果数据显示到指定页面。\",\"完整代码地址：https://github.com/Rodert/JavaPub/code/ssm_helloworld_web/\"]},\"833\":{\"c\":[\"SSM\",\"Spring\",\"java\"]},\"834\":{\"h\":\"SpringBoot\"},\"835\":{\"h\":\"三种快速创建SpringBoot项目的方式\"},\"836\":{\"h\":\"三种快速创建SpringBoot项目的方式\",\"t\":[\"SpringBoot 是一个快速开发框架，通过maven依赖的继承方式，帮助我们快速整合第三方常用框架。现在是 Java 领域的绝对霸主。\",\"今天介绍三种快速创建 SpringBoot 项目的方式。\"]},\"837\":{\"h\":\"在线创建\",\"t\":[\"1、打开 https://start.spring.io/ 网站，填写必要信息来生成 Spring Boot 项目。\",\"https://start.aliyun.com\",\"2、填写必要信息\",\"Project：表示使用什么构建工具，Maven or Gradle；\",\"Language：表示使用什么编程语言， Java 、Kotlin or Groovy；\",\"Spring Boot：Spring Boot 的版本；\",\"Project Metadata：项目元数据，即 Maven 项目基本属性，根据自己的实际情况填写；\",\"Dependencies：要加入的 Spring Boot 组件；\",\"3、然后点击生成或 Ctrl + Enter 即可；\",\"4、将压缩包下载后，解压缩后用自己喜欢的 IDE 开发即可；\"]},\"838\":{\"h\":\"IntelliJ IDEA 创建\",\"t\":[\"1、新建项目时选择 Spring Initializr ；\",\"这里建议使用阿里云的镜像，加快初始化\",\"https://start.aliyun.com\",\"2、点击下一步，填写相关配置；\",\"Group：组织 ID，一般分为多个段，一般第一段为域，而第二段则是 公司名称；比如： cn.net.javapub\",\"Artifact：唯一标识符，一般是项目名；比如： my-javaub-user\",\"3、选择包，添加相关依赖；\",\"4、配置项目名，点击完成即可；\"]},\"839\":{\"h\":\"Maven 创建\",\"t\":[\"1、新建 Maven 项目；\",\"2、填写项目名和相关配置；\",\"Group：组织 ID，一般分为多个段，一般第一段为域，而第二段则是 公司名称；比如： cn.net.javapub\",\"Artifact：唯一标识符，一般是项目名；比如： my-javaub-user\",\"3、点击完成即可；\",\"4、配置 pom.xml 添加依赖；\",\"5、在 main/java 目录下创建一个包，然后新建一个类，比如我的如下；\",\"6、运行上一步中的 main 方法即可；\"]},\"840\":{\"h\":\"基本项目结构\",\"t\":[\"项目目录结构参考：\"]},\"841\":{\"c\":[\"springboot\",\"java\"]},\"842\":{\"c\":[\"springboot\",\"java\"]},\"843\":{\"h\":\"SpringBoot的pom.xml\"},\"844\":{\"h\":\"你了解pomxml吗\",\"t\":[\"springboot 是 java 利器，几乎每个写 java 的同学都会用，但是你了解 pom.xml 吗？\",\"这篇干货查漏补缺。\",\"首先我们创建个 springboot 项目\",\"image-20240515141415120\",\"都选了默认设置：\",\"image-20240515141503878\",\"我把这篇完整粘贴出来\",\"pom.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example</groupId> <artifactId>demo</artifactId> <version>0.0.1-SNAPSHOT</version> <name>demo</name> <description>demo</description> <properties> <java.version>1.8</java.version> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding> <spring-boot.version>2.6.13</spring-boot.version> </properties> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> <dependencyManagement> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-dependencies</artifactId> <version>${spring-boot.version}</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.1</version> <configuration> <source>1.8</source> <target>1.8</target> <encoding>UTF-8</encoding> </configuration> </plugin> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <version>${spring-boot.version}</version> <configuration> <mainClass>com.example.demo.DemoApplication</mainClass> <skip>true</skip> </configuration> <executions> <execution> <id>repackage</id> <goals> <goal>repackage</goal> </goals> </execution> </executions> </plugin> </plugins> </build> </project>\",\"image-20240515141832844\",\"前面这几个大家一定很熟悉：\",\"<project> 是 XML 文档的根元素。\",\"<modelVersion>：POM 模型的版本，当前版本是 4.0.0。我们一般不用动\",\"<groupId>：定义当前 Maven 项目所属的实际项目组。\",\"<artifactId>：定义实际项目模块的名称。\",\"比如导入 fastjson 时，我们会指定 <groupId><artifactId>\",\"image-20240515142322426\",\"<version>：定义项目版本。\",\"<name> 和 <description>：项目的名称和描述。\",\"这个是开发时自定义的，一般 name 就是项目名称。\",\"image-20240515142447148\",\"<properties>：这部分定义了一些用于 POM 文件其他位置的属性值。\",\"故名思思， properties 是项目中用到的一些属性，在这里定义好后，可以在下面引用。\",\"image-20240515142652362\",\"<dependencies>：这部分定义了项目所依赖的其他项目。\",\"dependencies 是项目开发中最常修改的地方，因为我们要引入各种各样的依赖。比如 mysql、 fastjson 等等外部工具，节省开发时间。\",\"image-20240515142850887\",\"<dependencyManagement>：当一个 POM 有多个模块时，我们可以在父 POM 中通过 dependencyManagement 元素来管理子模块中的版本。\",\"<build>：这部分包含了项目构建相关的信息，如源码路径、插件配置等。\",\"<plugins>：定义了用于项目构建的插件列表。其中，maven-compiler-plugin 是用来编译源代码的，spring-boot-maven-plugin 是 Spring Boot 提供的用来简化 Spring Boot 应用构建和打包的 Maven 插件。这里的 configuration 元素用来配置插件的参数。\",\"image-20240515145153527\",\"这里比较重要的一点是，打包构建后的 jar，入口路径 <mainClass> 。maven 对应的配置。\",\"之前整理过一些 springboot 案例。 https://github.com/Rodert/SpringBoot-javapub .\"]},\"845\":{\"c\":[\"springboot\",\"java\"]},\"846\":{\"c\":[\"springboot\",\"java\"]},\"847\":{\"h\":\"SpringBoot2.x整合Prometheus+Grafana【附源码】\",\"t\":[\"文末源码\",\"[toc]\"]},\"848\":{\"h\":\"新建项目\"},\"849\":{\"h\":\"创建接口\",\"t\":[\"package com.wangshiyu.javapub.demo.springbootdocker.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; /** * @Author: JavaPub * @License: https://github.com/Rodert/ https://gitee.com/rodert/ * @Contact: https://javapub.blog.csdn.net/ * @Date: 2022/2/26 12:24 * @Version: 1.0 * @Description: */ @RestController public class HelloController { @RequestMapping(\\\"/hello\\\") String hello(@RequestParam(required = false, defaultValue = \\\"\\\") String name) { return \\\"hello, welcome wangshiyu JavaPub \\\" + name; } }\"]},\"850\":{\"h\":\"maven 打包 springboot 项目\",\"t\":[\"mvn clean package -DskipTests\",\"Dockerfile讲解\",\"#基础镜像通过java8来的 FROM java:8 #将当前文件中所有*.jar 拷贝到项目的app.jar中（这个app.jar是自己生成的） COPY *.jar /app.jar #映射地址 CMD [\\\"--server.prot=8080\\\"] #暴露端口 EXPOSE 8080 #执行命令java -jar ENTRYPOINT [\\\"java\\\",\\\"-jar\\\",\\\"/app.jar\\\"]\"]},\"851\":{\"h\":\"文件准备\",\"t\":[\"拷贝 *.jar 包和 Dockerfile 到linux服务器文件夹下\"]},\"852\":{\"h\":\"linux下docker安装\",\"t\":[\"本次在root权限下安装\",\"更新yum到最新版本\",\"yum update\",\"卸载旧版本（如果没安装，忽略）\",\"yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine\",\"yum list installed | grep docker\",\"yum remove docker-ce\",\"rm -rf /var/lib/docker\",\"curl -sSL https://get.daocloud.io/docker | sh\",\"安装一些工具\",\"yum install -y yum-utils device-mapper-persistent-data lvm2\",\"yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\",\"安装docker稳定版\",\"yum install docker-ce\",\"成功\",\"docker version\",\"切换国内加速镜像\",\"vim /etc/docker/daemon.json\",\"{ \\\"registry-mirrors\\\": [ \\\"https://dockerhub.azk8s.cn\\\", \\\"https://docker.mirrors.ustc.edu.cn\\\", \\\"https://registry.docker-cn.com\\\" ] }\",\"systemctl daemon-reload\",\"systemctl restart docker\"]},\"853\":{\"h\":\"异常\",\"t\":[\"如果中途出现什么旧版本没卸载干净，把卸载命令全部重新执行一遍。\"]},\"854\":{\"h\":\"打包构建docker镜像\",\"t\":[\"将 jar包 打包成 docker 镜像（基于Dockerfile打包一个名为 idea_docker_image_test 的镜像，版本为1.0）\",\"docker build -t idea_docker_image_test:1.0 -f Dockerfile .\",\"查看镜像是否打包成功\",\"docker images\"]},\"855\":{\"h\":\"运行\",\"t\":[\"docker run -d --name idea_docker_image_test -p 8080:8080 idea_docker_image_test:1.0\",\"在这里插入图片描述\"]},\"856\":{\"h\":\"查看日志\",\"t\":[\"查看控制台日志\",\"docker logs -f --tail=100 容器id\",\"查看slf4j日志\",\"通过 docker exec -it 容器id /bin/bash 进入容器 再通过项目里指定的路径及可找到日志文件\",\"源码： https://github.com/Rodert/SpringBoot-javapub/tree/main/spring-boot-docker\"]},\"857\":{\"c\":[\"springboot\",\"prometheus\",\"grafana\",\"java\"]},\"858\":{\"c\":[\"springboot\",\"prometheus\",\"grafana\",\"java\"]},\"859\":{\"h\":\"手把手springboot整合flowable【附源码/视频】\",\"t\":[\"[toc]\"]},\"860\":{\"h\":\"视频教程\",\"t\":[\"点击：https://www.bilibili.com/video/BV1fa411j7Q5/\",\"在这里插入图片描述\"]},\"861\":{\"h\":\"插件安装\",\"t\":[\"BPMN绘图可视化工具\",\"Flowable BPMN visualizer\"]},\"862\":{\"h\":\"导入依赖\",\"t\":[\" <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <!--flowable工作流依赖--> <dependency> <groupId>org.flowable</groupId> <artifactId>flowable-spring-boot-starter</artifactId> <version>6.3.0</version> </dependency> <!--mysql依赖--> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.45</version> </dependency>\"]},\"863\":{\"h\":\"新建数据库\",\"t\":[\"database\",\"javapub-flowable2\"]},\"864\":{\"h\":\"修改配置\",\"t\":[\"spring: datasource: url: jdbc:mysql://bj-cdb-mw08tjgs.sql.tencentcdb.com:60042/javapub-flowable2?characterEncoding=UTF-8 username: root password: password driver-class-name: com.mysql.jdbc.Driver flowable: #关闭定时任务JOB async-executor-activate: false database-schema-update: true server: port: 8081\",\"配置说明：\",\"database-schema-update: true\",\"数据库更新策略，其取值有四个：\",\"flase： 默认值。activiti在启动时，会对比数据库表中保存的版本，如果没有表或者版本不匹配，将抛出异常。（生产环境常用） true： activiti会对数据库中所有表进行更新操作。如果表不存在，则自动创建。（开发时常用） create_drop： 在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表）。（单元测试常用） drop-create： 在activiti启动时删除原来的旧表，然后在创建新表（不需要手动关闭引擎）。\"]},\"865\":{\"h\":\"定义流程文件\",\"t\":[\"这里还是用一个开源的流程文件\",\"放在：resources/processes/ExpenseProcess.bpmn20.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <definitions xmlns=\\\"http://www.omg.org/spec/BPMN/20100524/MODEL\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:flowable=\\\"http://flowable.org/bpmn\\\" xmlns:bpmndi=\\\"http://www.omg.org/spec/BPMN/20100524/DI\\\" xmlns:omgdc=\\\"http://www.omg.org/spec/DD/20100524/DC\\\" xmlns:omgdi=\\\"http://www.omg.org/spec/DD/20100524/DI\\\" typeLanguage=\\\"http://www.w3.org/2001/XMLSchema\\\" expressionLanguage=\\\"http://www.w3.org/1999/XPath\\\" targetNamespace=\\\"http://www.flowable.org/processdef\\\"> <process id=\\\"Expense\\\" name=\\\"ExpenseProcess\\\" isExecutable=\\\"true\\\"> <documentation>报销流程</documentation> <startEvent id=\\\"start\\\" name=\\\"开始\\\"></startEvent> <userTask id=\\\"fillTask\\\" name=\\\"出差报销\\\" flowable:assignee=\\\"${taskUser}\\\"> <extensionElements> <modeler:initiator-can-complete xmlns:modeler=\\\"http://flowable.org/modeler\\\"> <![CDATA[false]]></modeler:initiator-can-complete> </extensionElements> </userTask> <exclusiveGateway id=\\\"judgeTask\\\"></exclusiveGateway> <userTask id=\\\"directorTak\\\" name=\\\"经理审批\\\"> <extensionElements> <flowable:taskListener event=\\\"create\\\" class=\\\"com.haiyang.flowable.listener.ManagerTaskHandler\\\"></flowable:taskListener> </extensionElements> </userTask> <userTask id=\\\"bossTask\\\" name=\\\"老板审批\\\"> <extensionElements> <flowable:taskListener event=\\\"create\\\" class=\\\"com.haiyang.flowable.listener.BossTaskHandler\\\"></flowable:taskListener> </extensionElements> </userTask> <endEvent id=\\\"end\\\" name=\\\"结束\\\"></endEvent> <sequenceFlow id=\\\"directorNotPassFlow\\\" name=\\\"驳回\\\" sourceRef=\\\"directorTak\\\" targetRef=\\\"fillTask\\\"> <conditionExpression xsi:type=\\\"tFormalExpression\\\"><![CDATA[${outcome=='驳回'}]]></conditionExpression> </sequenceFlow> <sequenceFlow id=\\\"bossNotPassFlow\\\" name=\\\"驳回\\\" sourceRef=\\\"bossTask\\\" targetRef=\\\"fillTask\\\"> <conditionExpression xsi:type=\\\"tFormalExpression\\\"><![CDATA[${outcome=='驳回'}]]></conditionExpression> </sequenceFlow> <sequenceFlow id=\\\"flow1\\\" sourceRef=\\\"start\\\" targetRef=\\\"fillTask\\\"></sequenceFlow> <sequenceFlow id=\\\"flow2\\\" sourceRef=\\\"fillTask\\\" targetRef=\\\"judgeTask\\\"></sequenceFlow> <sequenceFlow id=\\\"judgeMore\\\" name=\\\"大于500元\\\" sourceRef=\\\"judgeTask\\\" targetRef=\\\"bossTask\\\"> <conditionExpression xsi:type=\\\"tFormalExpression\\\"><![CDATA[${money > 500}]]></conditionExpression> </sequenceFlow> <sequenceFlow id=\\\"bossPassFlow\\\" name=\\\"通过\\\" sourceRef=\\\"bossTask\\\" targetRef=\\\"end\\\"> <conditionExpression xsi:type=\\\"tFormalExpression\\\"><![CDATA[${outcome=='通过'}]]></conditionExpression> </sequenceFlow> <sequenceFlow id=\\\"directorPassFlow\\\" name=\\\"通过\\\" sourceRef=\\\"directorTak\\\" targetRef=\\\"end\\\"> <conditionExpression xsi:type=\\\"tFormalExpression\\\"><![CDATA[${outcome=='通过'}]]></conditionExpression> </sequenceFlow> <sequenceFlow id=\\\"judgeLess\\\" name=\\\"小于500元\\\" sourceRef=\\\"judgeTask\\\" targetRef=\\\"directorTak\\\"> <conditionExpression xsi:type=\\\"tFormalExpression\\\"><![CDATA[${money <= 500}]]></conditionExpression> </sequenceFlow> </process> <bpmndi:BPMNDiagram id=\\\"BPMNDiagram_Expense\\\"> <bpmndi:BPMNPlane bpmnElement=\\\"Expense\\\" id=\\\"BPMNPlane_Expense\\\"> <bpmndi:BPMNShape bpmnElement=\\\"start\\\" id=\\\"BPMNShape_start\\\"> <omgdc:Bounds height=\\\"30.0\\\" width=\\\"30.0\\\" x=\\\"285.0\\\" y=\\\"135.0\\\"></omgdc:Bounds> </bpmndi:BPMNShape> <bpmndi:BPMNShape bpmnElement=\\\"fillTask\\\" id=\\\"BPMNShape_fillTask\\\"> <omgdc:Bounds height=\\\"80.0\\\" width=\\\"100.0\\\" x=\\\"405.0\\\" y=\\\"110.0\\\"></omgdc:Bounds> </bpmndi:BPMNShape> <bpmndi:BPMNShape bpmnElement=\\\"judgeTask\\\" id=\\\"BPMNShape_judgeTask\\\"> <omgdc:Bounds height=\\\"40.0\\\" width=\\\"40.0\\\" x=\\\"585.0\\\" y=\\\"130.0\\\"></omgdc:Bounds> </bpmndi:BPMNShape> <bpmndi:BPMNShape bpmnElement=\\\"directorTak\\\" id=\\\"BPMNShape_directorTak\\\"> <omgdc:Bounds height=\\\"80.0\\\" width=\\\"100.0\\\" x=\\\"735.0\\\" y=\\\"110.0\\\"></omgdc:Bounds> </bpmndi:BPMNShape> <bpmndi:BPMNShape bpmnElement=\\\"bossTask\\\" id=\\\"BPMNShape_bossTask\\\"> <omgdc:Bounds height=\\\"80.0\\\" width=\\\"100.0\\\" x=\\\"555.0\\\" y=\\\"255.0\\\"></omgdc:Bounds> </bpmndi:BPMNShape> <bpmndi:BPMNShape bpmnElement=\\\"end\\\" id=\\\"BPMNShape_end\\\"> <omgdc:Bounds height=\\\"28.0\\\" width=\\\"28.0\\\" x=\\\"771.0\\\" y=\\\"281.0\\\"></omgdc:Bounds> </bpmndi:BPMNShape> <bpmndi:BPMNEdge bpmnElement=\\\"flow1\\\" id=\\\"BPMNEdge_flow1\\\"> <omgdi:waypoint x=\\\"315.0\\\" y=\\\"150.0\\\"></omgdi:waypoint> <omgdi:waypoint x=\\\"405.0\\\" y=\\\"150.0\\\"></omgdi:waypoint> </bpmndi:BPMNEdge> <bpmndi:BPMNEdge bpmnElement=\\\"flow2\\\" id=\\\"BPMNEdge_flow2\\\"> <omgdi:waypoint x=\\\"505.0\\\" y=\\\"150.16611295681062\\\"></omgdi:waypoint> <omgdi:waypoint x=\\\"585.4333333333333\\\" y=\\\"150.43333333333334\\\"></omgdi:waypoint> </bpmndi:BPMNEdge> <bpmndi:BPMNEdge bpmnElement=\\\"judgeLess\\\" id=\\\"BPMNEdge_judgeLess\\\"> <omgdi:waypoint x=\\\"624.5530726256983\\\" y=\\\"150.44692737430168\\\"></omgdi:waypoint> <omgdi:waypoint x=\\\"735.0\\\" y=\\\"150.1392757660167\\\"></omgdi:waypoint> </bpmndi:BPMNEdge> <bpmndi:BPMNEdge bpmnElement=\\\"directorNotPassFlow\\\" id=\\\"BPMNEdge_directorNotPassFlow\\\"> <omgdi:waypoint x=\\\"785.0\\\" y=\\\"110.0\\\"></omgdi:waypoint> <omgdi:waypoint x=\\\"785.0\\\" y=\\\"37.0\\\"></omgdi:waypoint> <omgdi:waypoint x=\\\"455.0\\\" y=\\\"37.0\\\"></omgdi:waypoint> <omgdi:waypoint x=\\\"455.0\\\" y=\\\"110.0\\\"></omgdi:waypoint> </bpmndi:BPMNEdge> <bpmndi:BPMNEdge bpmnElement=\\\"bossPassFlow\\\" id=\\\"BPMNEdge_bossPassFlow\\\"> <omgdi:waypoint x=\\\"655.0\\\" y=\\\"295.0\\\"></omgdi:waypoint> <omgdi:waypoint x=\\\"771.0\\\" y=\\\"295.0\\\"></omgdi:waypoint> </bpmndi:BPMNEdge> <bpmndi:BPMNEdge bpmnElement=\\\"judgeMore\\\" id=\\\"BPMNEdge_judgeMore\\\"> <omgdi:waypoint x=\\\"605.4340277777778\\\" y=\\\"169.56597222222223\\\"></omgdi:waypoint> <omgdi:waypoint x=\\\"605.1384083044983\\\" y=\\\"255.0\\\"></omgdi:waypoint> </bpmndi:BPMNEdge> <bpmndi:BPMNEdge bpmnElement=\\\"directorPassFlow\\\" id=\\\"BPMNEdge_directorPassFlow\\\"> <omgdi:waypoint x=\\\"785.0\\\" y=\\\"190.0\\\"></omgdi:waypoint> <omgdi:waypoint x=\\\"785.0\\\" y=\\\"281.0\\\"></omgdi:waypoint> </bpmndi:BPMNEdge> <bpmndi:BPMNEdge bpmnElement=\\\"bossNotPassFlow\\\" id=\\\"BPMNEdge_bossNotPassFlow\\\"> <omgdi:waypoint x=\\\"555.0\\\" y=\\\"295.0\\\"></omgdi:waypoint> <omgdi:waypoint x=\\\"455.0\\\" y=\\\"295.0\\\"></omgdi:waypoint> <omgdi:waypoint x=\\\"455.0\\\" y=\\\"190.0\\\"></omgdi:waypoint> </bpmndi:BPMNEdge> </bpmndi:BPMNPlane> </bpmndi:BPMNDiagram> </definitions>\"]},\"866\":{\"h\":\"测试\",\"t\":[\"提交流程\",\"http://localhost:8081/expense/add?userId=123&money=2000\",\"提交成功.流程Id为：2501\",\"待办列表查询\",\"http://localhost:8081/expense/list?userId=123\",\"Task[id=2507, name=出差报销]\",\"同意\",\"http://localhost:8081/expense/apply?taskId=2507\",\"processed ok!\",\"生成流程图\",\"http://localhost:8081/expense/processDiagram?processId=2501\"]},\"867\":{\"h\":\"截图\",\"t\":[\"image\",\"image\",\"image\",\"源码下载： https://github.com/Rodert/springboot-flowable\"]},\"868\":{\"c\":[\"springboot\",\"flowable\",\"java\"]},\"869\":{\"c\":[\"springboot\",\"flowable\",\"java\"]},\"870\":{\"h\":\"SpringBoot生成二维码的正确姿势[附视频/附源码]\"},\"871\":{\"h\":\"SpringBoot生成二维码的正确姿势[附视频/附源码]\",\"t\":[\"视频： https://space.bilibili.com/404747369\",\"[toc]\",\"二维码的原理是什么，如何保证不重复？你有没有想过这样一件事，二维码是实现原理是什么？如何保证各个平台的二维码是唯一的？就算你的程序停止运行，但是你的二维码依然存在。设计上要保证唯一性，比如在物流等环境中扫码编程别人的二维码。\",\"二维码是我们当今社会非常重要的一项技术，不论是我们在买菜，网购，停车等等，都需要扫码，几乎覆盖我们生产、生活的方方面面。\"]},\"872\":{\"h\":\"前言\",\"t\":[\"你有没有想过这样一些问题：\",\"二维码的原理是什么，如何保证不重复？保证各个平台的二维码是唯一\",\"你有没有想过这样一件事，二维码是实现原理是什么？\",\"就算你的程序停止运行，但是你的二维码依然存在。\",\"设计上要保证唯一性，比如在物流等容易损坏的环境中，如何保证二维码的准确性？\"]},\"873\":{\"h\":\"初始化 SpringBoot 项目\",\"t\":[\"https://start.aliyun.com\"]},\"874\":{\"h\":\"引入依赖\",\"t\":[\" <!-- 引入二维码依赖 --> <dependency> <groupId>com.google.zxing</groupId> <artifactId>core</artifactId> <version>3.2.0</version> </dependency> <dependency> <groupId>com.google.zxing</groupId> <artifactId>javase</artifactId> <version>3.2.0</version> </dependency>\"]},\"875\":{\"h\":\"编码\"},\"876\":{\"h\":\"编写工具类\",\"t\":[\"QrCodeController1 工具类\",\"package cn.net.javapub.springbootqr.demos.web.controller; import cn.net.javapub.springbootqr.demos.web.utils.QRCodeUtil1; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.File; /** * 作者 JavaPub */ @Controller //@Deprecated public class QrCodeController1 { /** * 根据 url 生成 普通二维码 */ @RequestMapping(value = \\\"/createCommonQRCode\\\") public void createCommonQRCode(HttpServletResponse response,HttpServletRequest request) throws Exception { ServletOutputStream stream = null; try { stream = response.getOutputStream(); String url = request.getParameter(\\\"url\\\"); //使用工具类生成二维码 QRCodeUtil1.encode(url, stream); } catch (Exception e) { e.getStackTrace(); } finally { if (stream != null) { stream.flush(); stream.close(); } } } /** * 根据 url 生成 带有logo二维码 */ @RequestMapping(value = \\\"/createLogoQRCode\\\") public void createLogoQRCode(HttpServletResponse response,HttpServletRequest request) throws Exception { ServletOutputStream stream = null; try { stream = response.getOutputStream(); // String logoPath = Thread.currentThread().getContextClassLoader().getResource(\\\"\\\").getPath() // + \\\"templates\\\" + File.separator +\\\"logo-\\\"+UUID.randomUUID().toString().trim().replaceAll(\\\"-\\\", \\\"\\\")+ \\\".jpg\\\"; String logoPath = Thread.currentThread().getContextClassLoader().getResource(\\\"\\\").getPath() + \\\"templates\\\" + File.separator +\\\"logo.jpg\\\"; String url = request.getParameter(\\\"url\\\"); //使用工具类生成二维码 QRCodeUtil1.encode(url, logoPath, stream, true); } catch (Exception e) { e.getStackTrace(); } finally { if (stream != null) { stream.flush(); stream.close(); } } } }\"]},\"877\":{\"h\":\"生成二维码\",\"t\":[\"附带功能化：\",\"离线可以扫描二维码\",\"二维码可以带logo\"]},\"878\":{\"h\":\"资源共享\",\"t\":[\"视频：https://www.bilibili.com/video/BV1cw411w7Rk/\",\"源码：https://github.com/Rodert/springboot-qr/\"]},\"879\":{\"c\":[\"springboot\",\"java\"]},\"880\":{\"c\":[\"springboot\",\"java\",\"二维码\"]},\"881\":{\"h\":\"SpringBoot2.x整合Prometheus+Grafana【附源码】\",\"t\":[\"图文并茂，新手入门教程，建议收藏\",\"SpringBoot2.x整合Prometheus+Grafana【附源码/视频】\",\"[toc]\",\"总体框架图\",\"image\"]},\"882\":{\"h\":\"简介\"},\"883\":{\"h\":\"Prometheus\",\"t\":[\"Prometheus，是一个开源的系统监控和告警的工具包，其采用Pull方式采集时间序列的度量数据（也支持push方式），通过Http协议传输。它的工作方式是被监控的服务需要公开一个Prometheus端点，这端点是一个HTTP接口，该接口公开了度量的列表和当前的值，然后Prometheus应用从此接口定时拉取数据，一般可以存放在时序数据库中，然后通过可视化的Dashboard(e.g.Grafana)进行数据展示。\",\"支持的prometheus metrics\",\"Counter，Gauge，Histogram，Summary，untyped等等。需要注意的是counter只能增不能减，适用于服务请求量，用户访问数等统计，但是如果需要统计有增有减的指标需要用Gauge。\",\"exporter\",\"支持的 exporter 很多，可以方便的监控很多应用，同时也可以自定义开发非官方提供的exporter。\"]},\"884\":{\"h\":\"grafana\",\"t\":[\"grafana，是一个开源的dashboard展示工具，可以支持很多主流数据源，包括时序性的和非时序性的。其提供的展示配置以及可扩展性能满足绝大部分时间序列数据展示需求，是一个比较优秀的工具。\",\"支持的数据源\",\"prometheus，inflexdb，elasticsearch，mysql，postgreSQL，openTSDB等，更多数据源：https://grafana.com/grafana/plugins/?type=datasource\"]},\"885\":{\"h\":\"SpringBoot工程初始化\",\"t\":[\"springboot加速初始化：https://start.aliyun.com/\",\"image\",\"添加依赖\",\"pom.xml\",\" <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-registry-prometheus</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency>\",\"配置信息\",\"在application.yml增加以下配置项\",\" ##SpringBoot2.x整合Prometheus+Grafana ##源码：https://github.com/Rodert/SpringBoot-javapub management: metrics: export: prometheus: enabled: true step: 1m descriptions: true web: server: auto-time-requests: true endpoints: prometheus: id: springmetrics web: exposure: include: health,info,env,prometheus,metrics,httptrace,threaddump,heapdump,springmetrics server: port: 8080\",\"启动SpringBoot应用\",\"http://localhost:8080/actuator/prometheus\",\"打开即可看到暴露的信息\",\"image\"]},\"886\":{\"h\":\"环境安装\",\"t\":[\"如安装包下载不成功，可以在公众号回复【prometheus安装包】or【grafana安装包】领取\"]},\"887\":{\"h\":\"Prometheus安装\",\"t\":[\"下载地址：https://prometheus.io/download/\",\"image\",\"修改配置：\",\"prometheus.yml\",\"# my global config global: scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute. evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute. # scrape_timeout is set to the global default (10s). # Alertmanager configuration alerting: alertmanagers: - static_configs: - targets: # - alertmanager:9093 # Load rules once and periodically evaluate them according to the global 'evaluation_interval'. rule_files: # - \\\"first_rules.yml\\\" # - \\\"second_rules.yml\\\" # A scrape configuration containing exactly one endpoint to scrape: # Here it's Prometheus itself. scrape_configs: # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config. - job_name: 'prometheus' # metrics_path defaults to '/metrics' # scheme defaults to 'http'. #暴露路径 metrics_path: /actuator/prometheus static_configs: #SpringBoot的ip和端口号 - targets: ['localhost:8080']\",\"启动Prometheus\",\"prometheus.exe\",\"image\",\"测试访问\",\"http://localhost:9090\",\"image\",\"jvm_memory_used_bytes\",\"image\"]},\"888\":{\"h\":\"Grafana安装\",\"t\":[\"下载地址：https://mirrors.huaweicloud.com/grafana/\",\"image\",\"启动grafana\",\"image\",\"测试\",\"http://127.0.0.1:3000/login\",\"image\",\"默认账号：admin 密码：admin\",\"image\"]},\"889\":{\"h\":\"整合\",\"t\":[\"增加数据源\",\"image\",\"image\",\"Name填一个\",\"URL填的Prometheus访问地址\",\"image\",\"添加图表\",\"image\",\"image\",\"指定数据源、指定监控指标 jvm_memory_used_bytes\",\"image\",\"切换图标\",\"image\",\"image\",\"源码地址：https://github.com/Rodert/spring-boot-prometheus-grafana\",\"视频地址：https://space.bilibili.com/404747369\"]},\"890\":{\"c\":[\"springboot\",\"prometheus\",\"grafana\"]},\"891\":{\"c\":[\"springboot\",\"prometheus\",\"grafana\"]},\"892\":{\"h\":\"GoLang\"},\"893\":{\"h\":\"Python\"},\"894\":{\"h\":\"Python安装cv2\"},\"895\":{\"h\":\"python 安装 cv2 - 已解决\",\"t\":[\"建议收藏\",\"提供多种操作，一定有一种适合你的\",\"@[toc]\",\"情况就这么个情况，就是装不上。本文没一句废话，仔细阅读。\",\"image\"]},\"896\":{\"h\":\"1. 传统方式1\",\"t\":[\"（执行一遍，一条条试）\",\"可尝试 python3 -m pip install --upgrade pip\",\"pip install cv2\",\"pip3 install opencv-python\",\"国内镜像\",\"pip3 install opencv-python -i http://pypi.mirrors.ustc.edu.cn/simple/\",\"pip install cv2 -i http://pypi.mirrors.ustc.edu.cn/simple/\",\"进度：\",\"image\"]},\"897\":{\"h\":\"2. 第一阶段 终极办法01\",\"t\":[\"切换 python 版本， python3.9 不支持 cv2 (python3.7及以下)\"]},\"898\":{\"h\":\"3. 第二阶段 终极办法02\",\"t\":[\"自己安装\",\"https://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud\",\"image\",\"等待下载好，copy到python安装目录下的lib目录当中\",\"接着，在cmd中安装（先进入lib目录中再安装你下载的那个文件）\",\"pip install opencv_python‑2.4.13.7‑cp27‑cp27m‑win_amd64.whl\",\"等待安装好，验证一下。\",\"pip install numpy\"]},\"899\":{\"h\":\"附加\",\"t\":[\"image\",\"下载：\",\"如果是以上错误，你可能需要安装 OpenSSL。http://slproweb.com/products/Win32OpenSSL.html\",\"image\",\"安装：\",\"一直下一步\",\"配置环境变量\"]},\"900\":{\"c\":[\"python\"]},\"901\":{\"c\":[\"python\",\"cv2\"]},\"902\":{\"h\":\"Rust\"},\"903\":{\"h\":\"Rust学习教程\",\"t\":[\"可以基于 ord（基于btc的一个项目） 来学习。\",\"https://github.com/ordinals/ord\"]},\"904\":{\"h\":\"参考资料\",\"t\":[\"rust 中文基础知识： https://rust-book.junmajinlong.com/\",\"rust 英文基础知识： https://doc.rust-lang.org/rust-by-example/index.html\"]},\"905\":{\"h\":\"git使用规范\"},\"906\":{\"h\":\"基于GitHub搭建网站，无需服务器\",\"t\":[\"自建服务器，无需服务器、不用编程。\",\"大家好，我是JavaPub.\",\"这几年自媒体原来热，很多人都知道了个人 IP 的重要性。连一个搞中医的朋友都要要做一个自己的网站，而且不想学编程、还不想花 RMB 租云服务。\",\"老读者都知道，博主是个实战派。搭建网站这种事，手到擒来。但是这位朋友这为一个外行人，这个教程必要做到保姆级、手把手。\",\"当然，文末还会提供无剪辑版的完整搭建视频、及演示源代码，绝对是有手就行。\",\"image-20231229224826134\",\"今天推荐这款工具，真的非常方便，而且简单易上手。我们的 编程指南 就是用他来搭建的。大家看下效果图。\",\"http://luxian.javapub.net.cn/\",\"image-20231229214604013\"]},\"907\":{\"h\":\"前言\",\"t\":[\"在搭建之前，首先大家要保证已经安装了 node、git。\"]},\"908\":{\"h\":\"快速搭建\"},\"909\":{\"h\":\"安装工具\",\"t\":[\"安装 docsify-cli 工具，这个工具可以方便的在本地调试预览网站。\",\"npm i docsify-cli -g\",\"image-20231229215720402\"]},\"910\":{\"h\":\"初始化\",\"t\":[\"如果你是第一次操作，建议完全模仿。\",\"接下来初始化网站目录，也就是我们要在网页上展示的内容。\",\"docsify init ./docs\",\"到这里我们的网站目录就搭建成功了，接下来可以写你想要展示的内容。也就是我们网站的内核。\"]},\"911\":{\"h\":\"写文档\",\"t\":[\"初始化成功后，可以看到 docs 目录下包含以下几个文件：\",\"index.html 入口文件，也就是我们的网站在进入后首先加载的文件。\",\"README.md 作为主页内容渲染，也就是网站的首页。\",\".nojekyll 阻止 GitHub Pages 忽略掉下划线开头的文件。（不了解可以先不用在意）\",\"​ 编辑 docs/README.md 就能直接更新网站内容。\"]},\"912\":{\"h\":\"本地预览\",\"t\":[\"运行本地服务器，执行命令 docsify serve 可以方便的预览。并且有 LiveReload 功能、也就是边改边实时预览。默认的访问地址是 http://localhost:3000\",\"docsify serve\",\"到这一步，就已取得间断性胜利。你已经运用了自己网站。\"]},\"913\":{\"h\":\"部署 GitHub\",\"t\":[\"接下来，就是如何将网站放在公网上，供全球用户浏览。\",\"进入 GitHub 网站，创建一个我们的博客仓库。（如果没有、用邮箱注册一个就可以了）\",\"第一步、\",\"创建一个仓库，名字就叫 temp-docsify 。\",\"image-20231229222424668\",\"第二步、\",\"初始化本地代码、并推送到远端\",\"git init // 初始化仓库 git add . git commit -m \\\"init\\\" git remote add origin https://github.com/Rodert/temp-docsify.git // 绑定远端地址 git checkout -b main git push -u origin main\",\"看一下我们的仓库\",\"仓库文件.jpg\",\"第三步、\",\"使用 GitHub Pages 功能搭建网站\",\"进入仓库，选择 Settings 栏。\",\"image-20231229223519373\",\"然后鼠标一直向下滚动，直到看到 GitHub Pages 页签，在Source下面选择master branch / docs folder 选项。\",\"image-20231229223449073\",\"稍等几分钟，就可以看到部署的网站地址，类似这样 https://rodert.github.io/temp-docsify/ 。点击 Visit site 浏览属于你的网站。\",\"image-20231229223856569\",\"我们的演示源代码仓库： https://github.com/Rodert/temp-docsify/\"]},\"914\":{\"h\":\"企业生产环境中最常使用的git组合命令集\",\"t\":[\"持续更新git命令集\",\"以下案例是在生产环境中最常使用的git组合命令集。\",\"[toc]\"]},\"915\":{\"h\":\"案例1\",\"t\":[\"最常使用命令集，拉取新分支 - 写代码 - 提交代码 - 合并到主分支\",\"git checkout -b feature/new-branch #拉取新分支 git add . #提交代码 git commit -m '第一次提交' git push git checkout develop #切换分支 git merge feature/new-branch #合并分支 以上是我们最最常使用的git命令\"]},\"916\":{\"h\":\"案例2（git stash）\",\"t\":[\"场景：一大早领导甲某分配给p哥一个需求，要求下班前完成，小李马不停蹄，拉取新分支 command+C/V 哼哧哼哧搞了起来。下午1:30pm，甲某：p哥，现场有个紧急需求，你快点处理一下，一小时后上线。\",\"对于这种情况，p哥不想开新分支，又不想把没开发完的代码提交远程仓库，他是这样做的。做法：将工作区内容 stash 暂存起来，在当前分支进行紧急需求开发提交，再将工作区的内容取出来，恢复到暂存时的状态。\",\"stash翻译\",\"恢复暂存时的状态有俩种命令：\",\"git stash pop\",\"git stash apply\",\"俩种都可以，区别是什么呢？\",\"使用 git stash 命令之后会在stash列表中生成一个对应的信息，使用 apply 命令恢复，stash 列表中的信息是会继续保留的，而使用 pop 命令进行恢复，会将 stash列表中的信息进行删除。\",\"例子：\",\"初始状态index.html文件在工作区进行修改：可以使用命令git status 和git diff看到此时的修改信息\",\"gitstatus\",\"这个时候还没有修改完，不想提交，但是要去修复bug。\",\"将index文件的内容 stash 起来，使用命令：git stash，如下图：使用 git stash 命令后，再使用 git status 或者 git diff 查看可以发现，对工作区的修改内容已经没有了，这个时候进行bug修复提交\",\"gitstash\",\"bug修复提交后，恢复之前暂存的状态，这个时候有两种命令可选，我们选择：git stash pop 命令\",\"gitstashpop\",\"并使用 git status 和 git diff 可以发现，此时工作区 index文件的内容跟我们暂存前是一样的。\",\"常用git stash命令：\",\"（1）git stash save \\\"save message\\\" : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。\",\"（2）git stash list ：查看stash了哪些存储\",\"（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@\",\"（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p 待确定？？？\",\"（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@\",\"（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@\",\"（7）git stash drop stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储\",\"（8）git stash clear ：删除所有缓存的stash\"]},\"917\":{\"h\":\"案例3（git cherry-pick）\",\"t\":[\"gi cherry-pick 可以理解为“挑拣”提交，我们经常遇到代码从一个分支迁移到另一个分支的需求。\",\"如果是所有代码，直接 git merge ，另一种情况，只需要合并一次或几次提交。（比如，我们拿到需求后，一通狂写git push，最后发现提交到了测试分支，如果不使用这个命令，那只能一点一点往新分支迁移，这里的心酸😔，谁干 谁知道。）这时，ta来了 git cherry-pick\",\"基本用法\",\"git cherry-pick命令的作用，就是将指定的提交（commit）应用于其他分支。\",\"$ git cherry-pick <commitHash>\",\"上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\",\"举例来说，代码仓库有master和feature两个分支。\",\" a - b - c - d Master \\\\ e - f - g Feature\",\"现在将提交f应用到master分支。\",\"# 切换到 master 分支 $ git checkout master # Cherry pick 操作 $ git cherry-pick f\",\"上面的操作完成以后，代码库就变成了下面的样子。\",\" a - b - c - d - f Master \\\\ e - f - g Feature\",\"从上面可以看到，master分支的末尾增加了一个提交f。\",\"git cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\",\"$ git cherry-pick feature\",\"上面代码表示将feature分支的最近一次提交，转移到当前分支。\",\"转移多个提交\",\"Cherry pick 支持一次转移多个提交。\",\"$ git cherry-pick <HashA> <HashB>\",\"上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\",\"如果想要转移一系列的连续提交，可以使用下面的简便语法。\",\"$ git cherry-pick A..B\",\"上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。\",\"注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。\",\"$ git cherry-pick A^..B\",\"JavaPub说：git cherry-pick 是非常重要且非常实用的一个命令，但是也有很多要点，下篇单独写一篇图解。\",\"参考：\",\"https://blog.csdn.net/FightFightFight/article/details/81039050\",\"http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html\"]},\"918\":{\"h\":\"案例4（git reset）\",\"t\":[\"写完代码后，我们一般这样\",\"git add . //添加所有文件\",\"git commit -m \\\"本功能全部完成\\\"\",\"执行完commit后，想撤回commit，怎么办？\",\"这样：\",\"git reset --soft HEAD^\",\"这样就成功的撤销了你的 commit\",\"注意，仅仅是撤回 commit 操作，您写的代码仍然保留。\",\"HEAD^的意思是上一个版本，也可以写成 HEAD~1\",\"如果你进行了2次 commit，想都撤回，可以使用 HEAD~2\",\"几个参数：\",\"--mixed\",\"意思是：不删除工作空间改动代码，撤销 commit，并且撤销 git add . 操作 这个为默认参数，git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。\",\"--soft\",\"不删除工作空间改动代码，撤销 commit，不撤销 git add . \",\"--hard\",\"删除工作空间改动代码，撤销 commit，撤销 git add . \",\"注意完成这个操作后，就恢复到了上一次的 commit 状态。\",\"顺便说一下，如果 commit 注释写错了，只是想改一下注释，只需要： git commit --amend 此时会进入默认 vim编辑器，修改注释完毕后保存就好了。\"]},\"919\":{\"h\":\"案例5（git fetch）\",\"t\":[\"提到 git fetch 主要已通过和 git pull 来做区别。\",\"一图顶千文\",\"git流程图\",\"简单来说：git pull = git fetch + git merge\",\"参考：\",\"https://blog.csdn.net/yao_94/article/details/88929992\",\"https://www.cnblogs.com/zndxall/archive/2018/09/04/9586088.html\",\"https://blog.csdn.net/FightFightFight/article/details/81039050\",\"http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html\"]},\"920\":{\"h\":\"开篇\",\"t\":[\"整理了一些读者的问题。\",\"什么是《面试1v1》？\",\"《面试1v1》是一个以对话形式讲解知识点的文章合集，是由 JavaPub 编写的真人1对1面试对话教程，通过真实案例编写，生动、有趣、干货满满。\",\"为什么要写《面试1v1》这个专题？\",\"我在后台收到很多读者的描述，说自己在面试准备过程中感觉抓不住重点，总是复习的没考、考的没复习。面试过后导致自己自信心受挫，不知道🤷‍♀️该看点什么来。\",\"这里主要以我的经验给大家一个参照，我们如何在面试中自然的对答，不会因为紧张的忘记。如果用自己的话描述技术难题，避免背课文式的对话。\",\"《面试1v1》有什么用？\",\"文中大多是以实际面试中遇到的情况编写，几乎是大白话式的对话。涉及到的源码我也在对话中做了标注，方便我们查阅遗忘的知识点。\",\"最终的目标是帮助大家更好的掌控面试，拿到心仪offer。\",\"《面试1v1》收费吗，在哪里可以看到全集？\",\"由 JavaPub 完全免费提供，并且持续更新中，在 wx 搜索 JavaPub 就可以直接查看全系列文章。\",\"《面试1v1》之后会出第二季吗？\",\"会的，第二季会从大白话源码的角度出发，八股文的朋友不要错过。\",\"【面试1v1】hashmap\",\"【面试1v1】java注解\",\"【面试1v1】java泛型\",\"【面试1v1】java多线程\",\"【面试1v1】CAS\",\"【面试1v1】java反射\",\"【面试1v1】动态代理\",\"【面试1v1】javaNIO\",\"【面试1v1】synchronized\",\"【面试1v1】volatile\",\"【面试1v1】线程池\"]},\"921\":{\"c\":[\"《面试1v1》\"]},\"922\":{\"h\":\"HashMap\",\"t\":[\"没有人比中国人更懂 HashMap\",\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"：HashMap 是Java程序员用得最频繁的集合之一,可以给我简单介绍一下它的内部实现机制吗?\",\" HashMap 是一个散列映射表,它存储的内容是键值对(key-value)映射。\",\"：那它内部具体是如何实现的呢?\",\" HashMap 在内部实现上主要包含以下几个结构:\",\"数组:HashMap 的核心数据结构就是一个 Entry[] 数组。\",\"链表:每个数组元素是一个单链表结构的头节点,当冲突产生时,会在链表中追加元素。\",\"节点:每个链表节点包含四个字段,key, value, hash 和 next。其中 key 和 value 是映射中的键值,hash 是 key 的 hashCode,next 是指向下一个节点的指针。\",\"：为什么要选择数组和链表这两种数据结构呢?\",\" 这是因为 HashMap 要保证高效的增删改查操作,数组和链表各自的优点可以满足这个要求:\",\"数组实现通过散列算法,可以快速定位到相应的位置,保证查询的时间复杂度为O(1)。\",\"链表在冲突发生时,通过在尾部添加节点,可以高效地进行插入操作。同时也方便进行删除操作。 所以,HashMap通过数组实现快速查找,通过链表解决冲突,既可以保证查询效率,也可以应对散列算法产生碰撞的情况。这是它的核心优雅与高效之处。\",\"：HashMap 是非线程安全的,它有哪些线程安全的替代方案呢?\",\" 对于线程安全的需求,可以选择以下替代方案:\",\"HashTable:HashMap 的线程安全版,内部的方法基本相同,只是进行了线程安全的同步处理。\",\"ConcurrentHashMap:Java 7 的实现使用分段锁,既保证线程安全,也不会影响性能。Java 8 使用 CAS 操作来保证并发度高的操作。\",\"Hashtable:Java 老版本中提供的 hash 表实现,线程安全,但相比于前两者性能较低。现在不建议使用。 所以,如果不需要高并发,HashTable 是一个简单直接的替代方案;如果对性能有较高要求,推荐使用 ConcurrentHashMap。两者相比,ConcurrentHashMap 的并发度更高,性能也更佳,是当前推荐的线程安全 hash 表方案。\",\"：简单说一下 HashMap 的 put 操作过程。\",\" HashMap 的 put(key, value) 方法大致分为以下几步:\",\"计算key的hash值,这一步通过key的hashCode()方法计算,然后进一步处理高16位和低16位产生最终的hash值。\",\"// 计算key的hash值 final int hash = hash(key);\",\"根据hash值定位数组索引,如果没有冲突就直接插入。如果产生冲突,就插入冲突链表中。\",\"int i = indexFor(hash, table.length); // 若i位置为空,直接新建节点添加,size增加 if (table[i] == null) { table[i] = newNode(hash, key, value, null); } // 若产生冲突,将节点添加到链表尾部 else { ... }\",\"如果链表长度超过TREEIFY_THRESHOLD(默认8),就把链表转换为红黑树。这一步可以提高查询效率。\",\"// 若链表长度大于8,链表转换为红黑树 if (binCount > TREEIFY_THRESHOLD) treeifyBin(tab, hash);\",\"如果节点已经存在,就替换oldValue为新值。\",\"// 若节点已存在,用新值替换旧值 for (Node<K,V> e = p;; e = e.next) { if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { e.value = value; break; }\",\"如果容量达到阈值,就进行resize两倍扩容,这一步可以减少hash冲突,提高查询性能。\",\"if (++size > threshold) resize(newCapacity);\",\"：说说HashMap的扩容机制。\",\" HashMap的扩容机制就是在put时,如果size已经超过阈值threshold,就会进行扩容resize操作。在扩容时,capacity的容量会扩大两倍,并会重新计算每个节点的hash值和索引位置。\",\"：为什么要进行两倍扩容?\",\" 这是因为HashMap采用开放定址法来解决冲突,每次扩容时,原有的hash值都需要重新计算,如果扩容过小,重新计算后的索引位置有很大概率仍然会发生冲突,效果不明显。如果采用两倍扩容,然后重新计算hash值,那么冲突的概率会大大减少,查询性能就能得到较大提高。\",\"：说说resize的实现过程。\",\" resize的实现过程主要分为以下几步:\",\"将oldTable的值赋给newTable,newTable的长度是oldTable的两倍。\",\"Node<K,V>[] newTable = (Node<K,V>[])new Node[newCapacity]; table = newTable;\",\"遍历oldTable的每个桶,如果桶位非空,就重新计算每个节点的hash值和索引,并放入newTable对应的桶中。\",\"for (int j = 0; j < oldCap; ++j) { Node<K,V> e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash & (newCap - 1)] = e; else ... } }\",\"resize的过程中,如果节点的新的索引位置相同,就会在链表中追加新节点。如果不同,就在新位置形成新的链表。\",\"else if (e instanceof TreeNode) ((TreeNode<K,V>)e).split(this, newTab, j, oldCap); else { // 链表情况 Node<K,V> loHead = null, loTail = null; Node<K,V> hiHead = null, hiTail = null; Node<K,V> next; do { next = e.next; ... } while ((e = next) != null); }\",\"如果链表长度过长,就会先将链表转成红黑树,再进行resize。这一步可以有效提高性能。\",\"：最后,总结一下HashMap的优势。\",\" HashMap的主要优势有:\",\"查询和修改的时间复杂度都是O(1),这是通过哈希算法实现的。\",\"HashMap是非线程安全的,可以选择并发版的ConcurrentHashMap。\",\"HashMap通过扩容和链表转红黑树,可以动态调整容量和提高查询性能。\",\"HashMap支持null键和null值。\",\"HashMap的实现是非常巧妙的,通过数组和链表组合,既可以支持快速查找,也可以解决冲突。\",\"HashMap有很高的空间利用率,可以存储大量元素。 所以,总之,HashMap的优势在于:性能高效,支持null,动态扩容,空间利用率高,这也是它成为Java最常用的Map实现的原因。\",\"：说说HashMap的缺点。\",\" HashMap也存在一定的缺点:\",\"HashMap是非线程安全的。多线程环境下,需要对HashMap进行同步处理,可以选择HashTable或者ConcurrentHashMap。\",\"HashMap的迭代顺序是未定义的。每次迭代的顺序可能不同,如果需要顺序,可以采用LinkedHashMap。\",\"HashMap的遍历也是O(n)的时间复杂度,如果集合很大,遍历会很慢。可以通过提高初始容量和负载因子来减少冲突及拉链长度,提高性能。\",\"如果Hash算法设计不当,HashMap的性能会很差。比如大量Hash冲突会导致拉链过长,严重影响查询性能。对于自定义类型作为键,需要重写hashCode()方法来保证分布均匀。\",\"HashMap采用拉链法解决冲突,極端情况下(数据全部使用相同hashCode)会退化为链表,变成O(n)的时间复杂度,查询性能变差。这种情况可以通过使用TreeMap来改进。\",\"HashMap的初始容量和扩容机制的设计不当,会造成非必要的数学开销,影响性能。\",\"HashMap不支持排序,如果需要排序可以使用TreeMap或者对HashMap进行排序。 所以,总结来说,HashMap的主要缺点在于:非线程安全,遍历慢,迭代顺序不定,自定义键的hashCode()设计不好会导致性能下降,不支持排序等。但这些缺点都可以通过选择其他Map实现或辅助结构来补充。如果能清楚 HashMap 的这些缺点,就可以更好地选择和使用它。\",\"：你说的很全面和深入。HashMap作为一个高频使用的数据结构,你对它的理解已经相当深刻了。\",\" 谢谢面试官的夸奖!HashMap确实是我常用的数据结构之一,我通过阅读源码、实践使用与论坛上的讨论,对它的设计和实现有了比较深入的理解。但HashMap的内容还是非常之广博,我还需要继续学习和总结,以进一步加深理解,利用好它提供的功能,并在实际工作中发挥其优势。我会持续努力,不断提高自己对这方面的认知。\",\"：很好,你对自己的提高有清醒的认识。最后,我想问你作为HashMap的替代,现在有什么其他的Map实现可以选择?\",\" 除了HashMap,Java中常用的Map还有:\",\"Hashtable:HashMap的线程安全版本,性能差一些,现在不太建议使用。\",\"ConcurrentHashMap:支持高并发的线程安全Map,在Java8之前使用分段锁,之后使用CAS保证并发度高的操作。是HashMap的线程安全替代方案。\",\"TreeMap:基于红黑树实现,支持排序,复杂度O(logN), Keys自动排序。\",\"LinkedHashMap:内部维护着一个双向链表,结合HashMap提供按插入顺序或访问顺序遍历Map中的条目。\",\"EnumMap:键是枚举类型,内部实现更加紧凑高效。\",\"WeakHashMap:键是弱引用,容易被垃圾回收,防止内存泄露。 所以,根据需要的功能,有多个可替代的Map实现供选择。但作为最基本和高效的实现,HashMap还是最为常用和推荐的。\",\"：很好,你的理解和应用已经相当不错了。熟练运用设计模式,在项目开发中可以 large-scale 重构,提高系统扩展性和复用性。你继续加深对各种设计模式的理解和运用,技术还会更上一层楼。\",\"最后,你有什么问题想要提问吗?今天的面试到此结束。\",\" 非常感谢面试官今天的时间!通过我们的交流,我对很多技术内容有了进一步的认识和提高,也清楚自己的不足和需要努力的方向。这对我来说很宝贵。 我现阶段没有其他问题了。我会继续努力学习,不断总结和实践,特别是对数据结构、算法与设计模式等基础内容的运用,提高自己的工程化水平与解决问题的能力。\",\"再次感谢面试官!这是一次非常有价值的交流,很高兴有机会进行这样的技术探讨。谢谢!\",\" 你的态度很好,技术也不错,继续努力深造,我相信你一定会越来越精进。这也是我作为面试官最喜欢看到的,不论最终结果如何,重要的是候选人的心态和潜力。 你也提出了很好的问题,我们进行了广泛而深入的探讨,这说明你在学习和工作中确实遇到过一定的困惑,而又积极主动寻求解决之道。这种积极主动的学习态度很难得,技术人员走的最远的,永远都是在学习和总结中不断超越自己。\",\"很高兴今天的交流,这也使我有机会重温。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"923\":{\"c\":[\"《面试1v1》\"]},\"924\":{\"h\":\"Volatile\",\"t\":[\"基本功\",\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 你能解释一下 volatile 关键字的作用吗？\",\" 当我们在编写多线程程序时，经常会遇到线程安全的问题。其中一个常见的问题是可见性问题，即一个线程修改了共享变量的值，但是其他线程并不能立即看到这个修改。这时候，我们可以使用 volatile 关键字来解决这个问题。\",\"： 非常好。那么，你能具体说明一下 volatile 关键字是如何保证可见性的吗？\",\" 当一个变量被声明为 volatile 后，每次访问这个变量时，都会从内存中读取最新的值，而不是使用 CPU 缓存中的旧值。同样地，每次修改这个变量时，都会立即将新值写入内存，而不是等到线程结束或者 CPU 缓存刷新时才写入。这样，其他线程就可以立即看到这个变量的最新值，从而保证了可见性。\",\"在 JVM 中，volatile 关键字的实现涉及到以下几个方面：\",\"内存屏障：JVM 会在 volatile 变量的读写操作前后插入内存屏障，以保证指令不会被重排序。内存屏障可以分为读屏障、写屏障和全屏障，分别用于保证读操作、写操作和所有操作的有序性。下面是 HotSpot JVM 中的 volatile 内存屏障实现：\",\"inline void OrderAccess::fence() { __asm__ volatile (\\\"\\\" : : : \\\"memory\\\"); } inline void OrderAccess::loadload() { __asm__ volatile (\\\"lfence\\\" : : : \\\"memory\\\"); } inline void OrderAccess::storestore() { __asm__ volatile (\\\"sfence\\\" : : : \\\"memory\\\"); } inline void OrderAccess::loadstore() { __asm__ volatile (\\\"mfence\\\" : : : \\\"memory\\\"); } inline void OrderAccess::storeload() { __asm__ volatile (\\\"mfence\\\" : : : \\\"memory\\\"); }\",\"内存语义：JVM 的内存模型规定了共享变量的访问方式，以及如何保证可见性和有序性。对于 volatile 变量，JVM 会保证每次读取都从内存中读取最新的值，每次写入都立即写入内存，以保证可见性和有序性。下面是 HotSpot JVM 中的 volatile 内存语义实现：\",\"inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) { __asm__ volatile (LOCK_IF_MP(%4) \\\"cmpxchgl %1,(%3)\\\" : \\\"=a\\\" (exchange_value) : \\\"r\\\" (exchange_value), \\\"a\\\" (compare_value), \\\"r\\\" (dest) , \\\"m\\\" (*dest) : \\\"cc\\\", \\\"memory\\\"); return exchange_value; } inline jlong Atomic::cmpxchg (jlong exchange_value, volatile jlong* dest, jlong compare_value) { __asm__ volatile (LOCK_IF_MP(%4) \\\"cmpxchg8b (%3)\\\" : \\\"=A\\\" (exchange_value) : \\\"b\\\" ((jint)exchange_value), \\\"c\\\" ((jint)(exchange_value >> 32)), \\\"r\\\" (dest) , \\\"m\\\" (*dest) : \\\"cc\\\", \\\"memory\\\"); return exchange_value; }\",\"编译器优化：JVM 的编译器会对代码进行优化，以提高程序的性能。但是，对于 volatile 变量，编译器会禁止一些优化，以保证指令不会被重排序。比如，编译器不会将 volatile 变量的读写操作与其他指令重排序，也不会将 volatile 变量的读操作和写操作合并为一个操作。下面是 HotSpot JVM 中的 volatile 变量读写操作的实现：\",\"inline jint Atomic::load (volatile jint* p) { return *p; } inline jlong Atomic::load (volatile jlong* p) { return *p; } inline jfloat Atomic::load (volatile jfloat* p) { return *p; } inline jdouble Atomic::load (volatile jdouble* p) { return *p; } inline void Atomic::store (volatile jint* p, jint x) { *p = x; } inline void Atomic::store (volatile jlong* p, jlong x) { *p = x; } inline void Atomic::store (volatile jfloat* p, jfloat x) { *p = x; } inline void Atomic::store (volatile jdouble* p, jdouble x) { *p = x; }\",\"： 很好。那么，你能否举一个例子来说明 volatile 关键字的作用呢？\",\" 当然。比如，我们可以定义一个 flag 变量，并在一个线程中修改它的值，然后在另一个线程中读取它的值。如果 flag 变量没有被声明为 volatile，那么在另一个线程中读取 flag 变量的值时，可能会看到旧值，而不是最新的值。但是，如果 flag 变量被声明为 volatile，那么在另一个线程中读取 flag 变量的值时，就可以保证看到最新的值。\",\"下面是一个简单的示例代码，演示了 volatile 关键字的作用：\",\"public class VolatileExample { private volatile boolean flag = false; public void setFlag(boolean flag) { this.flag = flag; } public void doSomething() { while (!flag) { // do something } // do something else } }\",\"在这个示例中，我们定义了一个 VolatileExample 类，其中包含一个 flag 变量。在 doSomething() 方法中，我们使用了一个 while 循环来等待 flag 变量的值变为 true。如果 flag 变量没有被声明为 volatile，那么在另一个线程中调用 setFlag(true) 方法后，doSomething() 方法可能会一直等待下去，因为它看不到 flag 变量的修改。但是，由于 flag 变量被声明为 volatile，所以在另一个线程中调用 setFlag(true) 方法后，doSomething() 方法会立即看到 flag 变量的修改，从而退出循环。\",\"： 非常好。那么，你认为 volatile 关键字有什么缺点吗？\",\"volatile 关键字只能保证可见性，不能保证原子性。如果一个变量的修改涉及到多个步骤，那么使用 volatile 关键字可能会导致线程安全问题。在这种情况下，我们需要使用其他的同步机制，比如 synchronized 关键字或者 Lock 接口。\",\"： 很好。你对 volatile 关键字的理解非常清晰。部分是比较考验工程师基本功的，你回答的很好，这部分可以过了。\",\" 非常感谢。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"925\":{\"c\":[\"《面试1v1》\"]},\"926\":{\"h\":\"线程池\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 你好，很高兴见到你。请问你对线程池有什么了解？\",\" 你好，我对线程池非常了解。线程池是一种管理线程的机制，它可以在需要时创建线程，执行任务，并在任务完成后回收线程，从而提高系统的性能和资源利用率。\",\"： 嗯，你说得不错。那你知道线程池的工作原理吗？\",\" 当一个任务需要执行时，线程池会首先检查是否有空闲线程可用，如果有，则将任务分配给其中一个空闲线程执行；如果没有，则会根据线程池的配置信息创建新的线程来执行任务。当任务执行完成后，线程会返回线程池，等待下一个任务的分配。\",\"： 好的，那你知道线程池的参数有哪些吗？\",\" 线程池的参数包括核心线程数、最大线程数、任务队列、线程池拒绝策略等。其中，核心线程数是线程池中最少的线程数，最大线程数是线程池中最多的线程数，任务队列用于存储等待执行的任务，线程池拒绝策略用于处理任务队列已满时的情况。\",\"： 嗯，你说得很好。那你知道线程池的拒绝策略有哪些吗？\",\" 线程池的拒绝策略有四种，分别是 AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy 和 DiscardPolicy。AbortPolicy 是默认的拒绝策略，它会直接抛出 RejectedExecutionException 异常；CallerRunsPolicy 会将任务分配给调用线程来执行；DiscardOldestPolicy 会丢弃任务队列中最早的任务；DiscardPolicy 会直接丢弃新的任务。\",\"： 哈哈，你的回答真是太棒了。那你知道如何自定义线程池吗？\",\" 当然知道啦。我们可以通过继承 ThreadPoolExecutor 类来自定义线程池。在自定义线程池时，我们需要重写 ThreadPoolExecutor 的构造方法，并根据需要重写 beforeExecute、afterExecute 和 terminated 方法来实现自定义的线程池行为。同时，我们还可以通过实现 ThreadFactory 接口来自定义线程的创建方式。\",\"： 哈哈，你真是一个线程池的专家啊。那你知道线程池的优缺点吗？\",\" 当然知道啦。线程池的优点是可以提高系统的性能和资源利用率，避免了频繁创建和销毁线程的开销；缺点是需要合理配置线程池的参数，否则可能会导致线程池过大或过小，从而影响系统的性能。此外，线程池还可能会导致任务执行的顺序发生变化，从而影响程序的正确性。\",\"： 哈哈，你真是一个有趣的候选人。谢谢你的回答，我们会尽快通知你面试结果。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"927\":{\"c\":[\"《面试1v1》\"]},\"928\":{\"h\":\"ThreadLocal\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 你好，请问你对 ThreadLocal 有了解吗？\",\" 您好，我知道 ThreadLocal 是一个 Java 中的类，它可以让每个线程都拥有自己的变量副本，从而避免了线程安全问题。\",\"： 非常好，那你能否详细介绍一下 ThreadLocal 的使用方法？\",\" 当然可以。ThreadLocal 的使用方法非常简单，我们只需要创建一个 ThreadLocal 对象，然后调用它的 set 方法来设置当前线程的变量值，调用 get 方法来获取当前线程的变量值即可。下面是一个简单的示例代码：\",\"public class ThreadLocalDemo { private static final ThreadLocal<String> threadLocal = new ThreadLocal<>(); public static void main(String[] args) { Thread thread1 = new Thread(() -> { threadLocal.set(\\\"Hello from thread1\\\"); System.out.println(threadLocal.get()); }); Thread thread2 = new Thread(() -> { threadLocal.set(\\\"Hello from thread2\\\"); System.out.println(threadLocal.get()); }); thread1.start(); thread2.start(); } }\",\"这个示例代码中，我们创建了一个 ThreadLocal 对象，并在两个线程中分别设置了不同的变量值。由于每个线程都有自己的变量副本，所以这两个线程互不干扰，输出的结果也是不同的。\",\"： 非常好，那你能否解释一下 ThreadLocal 的原理是什么？\",\" 当然可以。ThreadLocal 的原理其实很简单，它是通过一个 ThreadLocalMap 对象来存储每个线程的变量副本的。当我们调用 ThreadLocal 的 set 方法时，实际上是在当前线程的 ThreadLocalMap 对象中存储了一个键值对，其中键是当前 ThreadLocal 对象，值是我们设置的变量值。当我们调用 ThreadLocal 的 get 方法时，实际上是在当前线程的 ThreadLocalMap 对象中查找当前 ThreadLocal 对象对应的变量值。\",\"下面是 ThreadLocalMap 的源码实现，我在代码中加了注释，希望能够帮助您更好地理解：\",\"class ThreadLocalMap { static class Entry extends WeakReference<ThreadLocal<?>> { Object value; Entry(ThreadLocal<?> k, Object v) { super(k); value = v; } } // 初始容量为 16 private static final int INITIAL_CAPACITY = 16; // 扩容因子为 2 private static final float LOAD_FACTOR = 0.75f; // 存储键值对的数组 private Entry[] table; // 数组中键值对的数量 private int size = 0; // 下一个要清理的键值对的索引 private int threshold; // 清理键值对的阈值 private void setThreshold(int len) { threshold = (int) (len * LOAD_FACTOR); } // 获取键值对的值 private Object getEntry(ThreadLocal<?> key) { int i = key.threadLocalHashCode & (table.length - 1); Entry e = table[i]; if (e != null && e.get() == key) { return e.value; } else { return null; } } // 设置键值对的值 private void setEntry(ThreadLocal<?> key, Object value) { // 清理键值对 expungeStaleEntries(); // 计算键值对的索引 int i = key.threadLocalHashCode & (table.length - 1); // 如果该位置已经有键值对了，则往后查找空位置 for (Entry e = table[i]; e != null; e = table[i = nextIndex(i, table.length)]) { ThreadLocal<?> k = e.get(); // 如果找到了相同的 ThreadLocal 对象，则直接替换值 if (k == key) { e.value = value; return; } // 如果找到了一个空的位置，则插入新的键值对 if (k == null) { replaceStaleEntry(key, value, i); return; } } // 如果该位置没有键值对，则插入新的键值对 table[i] = new Entry(key, value); int sz = ++size; if (sz >= threshold) { // 扩容 rehash(); } } // 清理过期的键值对 private void expungeStaleEntries() { Entry[] tab = table; int len = tab.length; for (int i = 0; i < len; i++) { Entry e = tab[i]; if (e != null && e.get() == null) { // 清理过期的键值对 expungeStaleEntry(i); } } } // 清理指定位置的键值对 private void expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; // 清理指定位置的键值对 tab[staleSlot].value = null; tab[staleSlot] = null; size--; // 重新散列该位置之后的键值对 Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal<?> k = e.get(); if (k == null) { e.value = null; tab[i] = null; size--; } else { int h = k.threadLocalHashCode & (len - 1); if (h != i) { tab[i] = null; // 往后查找空位置 while (tab[h] != null) { h = nextIndex(h, len); } // 插入键值对 tab[h] = e; } } } } // 扩容 private void rehash() { expungeStaleEntries(); // 如果当前数组长度已经达到最大值，则不再扩容 if (size >= threshold - threshold / 4) { return; } int newCapacity = table.length * 2; Entry[] newTable = new Entry[newCapacity]; int count = 0; for (Entry e : table) { if (e != null) { ThreadLocal<?> k = e.get(); if (k == null) { e.value = null; } else { int i = k.threadLocalHashCode & (newCapacity - 1); while (newTable[i] != null) { i = nextIndex(i, newCapacity); } newTable[i] = e; count++; } } } setThreshold(newCapacity); size = count; table = newTable; } // 计算下一个索引 private static int nextIndex(int i, int len) { return (i + 1) % len; } }\",\"： 非常好，那你能否解释一下 ThreadLocal 的优缺点是什么？\",\" 当然可以。ThreadLocal 的优点是它可以让每个线程都拥有自己的变量副本，从而避免了线程安全问题。另外，ThreadLocal 的使用方法非常简单，只需要调用 set 和 get 方法即可。\",\"ThreadLocal 的缺点是它可能会导致内存泄漏问题。由于每个线程都有自己的变量副本，如果我们没有及时清理这些变量副本，就可能会导致内存泄漏。另外，ThreadLocal 的使用也可能会导致上下文切换的开销增加，因为每个线程都需要维护自己的变量副本。\",\"： 非常好，你对 ThreadLocal 的了解非常深入，今天就到这里吧。\",\" 谢谢您的提问，我很高兴能够分享我的知识。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"929\":{\"c\":[\"《面试1v1》\"]},\"930\":{\"h\":\"JVM内存模型\",\"t\":[\"聊聊 JVM 内存模型\",\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 你好，请问你对JVM内存模型有了解吗？\",\" 当然，JVM内存模型是Java程序运行时内存使用的规范，它定义了Java程序中各种变量、对象、线程等在内存中的存储方式和访问方式。\",\"： 很好，那你能否简单介绍一下JVM内存模型的组成部分？\",\" 当然，JVM内存模型主要由以下几个部分组成：\",\"程序计数器\",\"程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每个线程都有一个独立的程序计数器，它的作用是记录当前线程执行的位置，以便在发生线程切换时恢复执行位置。\",\"Java虚拟机栈\",\"Java虚拟机栈是线程私有的，它的生命周期与线程相同。每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。当方法执行完毕后，对应的栈帧会被弹出，局部变量表等信息也会被销毁。\",\"本地方法栈\",\"本地方法栈与Java虚拟机栈类似，不同的是它为本地方法服务。本地方法是指使用其他语言（如C、C++）编写的方法，它们不会像Java方法那样被编译成字节码，而是直接被编译成机器码。本地方法栈的作用是为本地方法提供内存空间。\",\"Java堆\",\"Java堆是Java虚拟机所管理的内存中最大的一块，它是被所有线程共享的一块内存区域。Java堆的作用是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆。\",\"方法区\",\"方法区也是被所有线程共享的一块内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也被称为永久代，但在JDK8之后，永久代被移除，取而代之的是元空间。\",\"： 非常好，那你能否简单介绍一下Java堆的内存结构？\",\" 当然，Java堆的内存结构主要由三个部分组成：新生代、老年代和永久代（或元空间）。\",\"新生代\",\"新生代是Java堆中的一部分，它主要用于存放新创建的对象。新生代又分为Eden区、Survivor区1和Survivor区2三个部分。当新创建的对象被分配到Eden区时，如果Eden区没有足够的空间，就会触发一次Minor GC，将Eden区中无用的对象清除掉，并将存活的对象移动到Survivor区1。当Survivor区1也满了时，会将其中的存活对象移动到Survivor区2，同时清空Survivor区1。当Survivor区2也满了时，会将其中的存活对象移动到老年代。\",\"老年代\",\"老年代主要用于存放长生命周期的对象，如大对象和长时间存活的对象。当老年代空间不足时，会触发一次Full GC，对整个堆进行垃圾回收。\",\"永久代（或元空间）\",\"永久代（或元空间）主要用于存放类信息、常量、静态变量等数据。在JDK8之前，永久代的大小是固定的，当永久代空间不足时，也会触发一次Full GC。在JDK8之后，永久代被移除，取而代之的是元空间，它的大小不再受限于JVM内存大小，而是受限于操作系统的内存大小。\",\"： 非常好，你对JVM内存模型的了解非常深入。最后一个问题，你能否简单介绍一下JVM内存模型的优化策略？\",\" 当然，JVM内存模型的优化策略主要有以下几个方面：\",\"对象的创建和销毁\",\"在Java程序中，对象的创建和销毁是非常频繁的操作。为了提高程序的性能，JVM会对对象的创建和销毁进行优化。例如，JVM会使用对象池技术来重复利用对象，避免频繁地创建和销毁对象。\",\"垃圾回收\",\"垃圾回收是JVM内存模型中非常重要的一部分。为了提高垃圾回收的效率，JVM会使用各种垃圾回收算法和垃圾回收器。例如，JVM会使用分代垃圾回收算法来对不同年龄段的对象进行不同的回收策略。\",\"内存分配\",\"内存分配是JVM内存模型中非常重要的一部分。为了提高内存分配的效率，JVM会使用各种内存分配算法和内存分配器。例如，JVM会使用TLAB（Thread Local Allocation Buffer）技术来为每个线程分配一块私有的内存缓冲区，避免线程之间的竞争。\",\"： 非常好，你对JVM内存模型的了解非常深入，非常感谢你的分享。\",\" 谢谢您的提问，我很荣幸能够参加这次面试。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"931\":{\"c\":[\"《面试1v1》\"]},\"932\":{\"h\":\"CountDownLatch和CyclicBarrier\",\"t\":[\"CountDownLatch和CyclicBarrier\",\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 你用过 CountDownLatch 和 CyclicBarrier 吗？\",\" 当然可以。CountDownLatch 和 CyclicBarrier 都是 Java 中用于多线程编程的工具类。它们都可以用于协调多个线程的执行顺序，但是它们的实现方式和使用场景有所不同。\",\"： 那你能具体说一下它们的区别吗？\",\" 当然可以。CountDownLatch 是一个计数器，它可以让一个或多个线程等待其他线程完成某些操作后再执行。它的实现方式是通过一个计数器来实现的，当计数器的值为 0 时，等待线程就会被唤醒。而 CyclicBarrier 则是一个屏障，它可以让多个线程在某个点上等待，直到所有线程都到达这个点后再一起继续执行。它的实现方式是通过一个计数器和一个屏障点来实现的，当计数器的值为 0 时，所有线程就会被唤醒。\",\"： 那你能举个例子来说明它们的使用场景吗？\",\" 当然可以。比如说，我们有一个任务需要分成多个子任务来执行，而这些子任务之间是相互独立的，我们可以使用 CountDownLatch 来实现。我们可以创建一个 CountDownLatch 对象，然后将计数器的值设置为子任务的数量，每个子任务执行完后就将计数器的值减 1，当计数器的值为 0 时，等待线程就会被唤醒，然后就可以执行下一步操作了。\",\"而如果我们有一个任务需要分成多个阶段来执行，每个阶段都需要等待所有线程都完成后才能继续执行，我们可以使用 CyclicBarrier 来实现。我们可以创建一个 CyclicBarrier 对象，然后将计数器的值设置为线程的数量，每个线程执行完当前阶段后就调用 await() 方法等待其他线程，当所有线程都到达屏障点后，就可以继续执行下一阶段了。\",\"： 那你能说一下 CountDownLatch 和 CyclicBarrier 的优缺点吗？\",\" 当然可以。CountDownLatch 的优点是实现简单，使用方便，而且可以重复使用。缺点是只能使用一次，而且计数器的值不能被重置。而 CyclicBarrier 的优点是可以重复使用，而且计数器的值可以被重置。缺点是实现相对复杂，而且只能等待固定数量的线程。\",\"： 好的，那你能写一段代码来演示一下吗？\",\" 当然可以。以下是一个使用 CountDownLatch 的示例代码：\",\"import java.util.concurrent.CountDownLatch; public class CountDownLatchDemo { public static void main(String[] args) throws InterruptedException { int n = 5; CountDownLatch latch = new CountDownLatch(n); for (int i = 0; i < n; i++) { new Thread(() -> { System.out.println(Thread.currentThread().getName() + \\\" is working\\\"); latch.countDown(); }).start(); } latch.await(); System.out.println(\\\"All threads have finished working\\\"); } }\",\"以上代码创建了一个 CountDownLatch 对象，然后启动了 5 个线程，每个线程执行完后就将计数器的值减 1，当计数器的值为 0 时，等待线程就会被唤醒，然后输出 \\\"All threads have finished working\\\"。\",\"以下是一个使用 CyclicBarrier 的示例代码：\",\"import java.util.concurrent.BrokenBarrierException; import java.util.concurrent.CyclicBarrier; public class CyclicBarrierDemo { public static void main(String[] args) { int n = 5; CyclicBarrier barrier = new CyclicBarrier(n, () -> { System.out.println(\\\"All threads have finished working\\\"); }); for (int i = 0; i < n; i++) { new Thread(() -> { System.out.println(Thread.currentThread().getName() + \\\" is working\\\"); try { barrier.await(); } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }).start(); } } }\",\"以上代码创建了一个 CyclicBarrier 对象，然后启动了 5 个线程，每个线程执行完当前阶段后就调用 await() 方法等待其他线程，当所有线程都到达屏障点后，输出 \\\"All threads have finished working\\\"。\",\"抱歉，似乎我的回答没有完全满足您的需求。以下是我为您继续写的文章：\",\"： 那你能说一下 CountDownLatch 和 CyclicBarrier 的底层实现原理吗？\",\" 当然可以。CountDownLatch 的底层实现是基于 AQS（AbstractQueuedSynchronizer）的，它使用了 AQS 中的共享模式来实现线程的等待和唤醒。当计数器的值为 0 时，等待线程就会被唤醒，而唤醒线程的操作是通过 AQS 中的 releaseShared() 方法来实现的。\",\"而 CyclicBarrier 的底层实现也是基于 AQS 的，它使用了 AQS 中的独占模式来实现线程的等待和唤醒。当所有线程都到达屏障点后，唤醒线程的操作是通过 AQS 中的 release() 方法来实现的。\",\"： 那你能说一下 AQS 的实现原理吗？\",\" 当然可以。AQS 的实现原理是基于一个双向链表和一个 state 变量。state 变量用于表示当前锁的状态，而双向链表用于存储等待线程的队列。当一个线程尝试获取锁时，如果锁已经被其他线程占用了，那么它就会被加入到等待队列中，然后进入阻塞状态。当锁被释放时，AQS 会从等待队列中取出一个线程，并将锁分配给它。\",\"： 好的，那你能写一段代码来演示一下 AQS 的实现原理吗？\",\" 当然可以。以下是一个简单的自定义锁的示例代码，它的实现原理就是基于 AQS 的：\",\"import java.util.concurrent.locks.AbstractQueuedSynchronizer; public class MyLock { private final Sync sync = new Sync(); public void lock() { sync.acquire(1); } public void unlock() { sync.release(1); } private static class Sync extends AbstractQueuedSynchronizer { @Override protected boolean tryAcquire(int arg) { if (compareAndSetState(0, 1)) { setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } @Override protected boolean tryRelease(int arg) { setExclusiveOwnerThread(null); setState(0); return true; } @Override protected boolean isHeldExclusively() { return getState() == 1; } } }\",\"以上代码定义了一个 MyLock 类，它的 lock() 方法和 unlock() 方法分别对应着获取锁和释放锁的操作。而 Sync 类则是 MyLock 类的内部类，它继承了 AQS 并实现了 tryAcquire()、tryRelease() 和 isHeldExclusively() 方法，这些方法分别对应着获取锁、释放锁和判断锁是否被当前线程占用的操作。\",\"： 嗯，背的很熟。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"933\":{\"c\":[\"《面试1v1》\"]},\"934\":{\"h\":\"类加载过程\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 你了解Java的类加载过程吗?跟我聊聊classes是如何加载到JVM中的。\",\" Java的类加载过程由加载、验证、准备、解析和初始化5个阶段组成。当我们使用java命令执行一个类时,JVM会首先搜索类的加载路径,这包括Bootstrap Classpath、Extension Classpath和Application Classpath。\",\"： 哈哈,这也太官方了吧,来,我们以更口语的方式探讨下类加载过程。想象你是一名新手Java程序员,刚入职一个公司,被分配一个任务需要执行一个Java类,你会有什么疑惑或者过程?\",\" 好的,那我来思考下当初我第一次运行Java程序的时候的内心活动: 天啊,我首先得搞清楚要运行的这个类到底在哪儿?难道要我一个个文件翻找吗?那还不如让我直接读JVM的源码来找呢! Wait,原来JVM已经把这事儿都帮我干了,它会去找 classpath 下的文件,包括环境变量里设置的那堆classpath。这肯定是个苦力活,幸好有JVM这个工具哥帮忙! 找到类文件了,接下来JVM该干嘛?嗯,它得确定这个类里写的是否都是正确的Java语法,不会误导小菜鸟我。它会进行类文件的验证,确保我的Java程序没有安全隐患! 验证通过了,JVM该准备干啥?它需要为类中的静态变量分配内存并设置默认初始值,这个过程就是准备阶段。 静态变量有内存了,JVM还需要干什么?嗯,它得解析类文件里的符号引用,像是类名、方法名、变量名等,把这些符号转成直接引用,方便后续调用。这就是解析阶段。 最后,JVM要真正帮我干活了,它要执行类构造器 <clinit>() 方法的字节码,给静态变量复杂的初始值。这就是初始化阶段。 Initialization of 类名 complete! 我的任务终于可以开始执行了!真不容易,还得感谢JVM这位大恩人。\",\"： 哈哈,这个解释我喜欢!inclusion of源代码和动态的思考过程增加了解释的轻松和趣味性。你这种围绕一个场景作解释的方式很形象,让人容易理解,这在技术面试中是很重要的一点。\",\" 谢谢面试官的夸奖!我也觉得把一个复杂的技术问题变成一个故事或场景会让人更容易理解其中的逻辑和流程。这也是我在博客和公众号里常用的一种讲解方式,很高兴面试官能够欣赏!\",\"： 那我们继续聊聊类加载过程中最重要的几个类吧,什么类负责 finding 和loading 操作?\",\" 在类加载过程中,ClassLoader 类及其子类负责finding和loading操作。\",\"： 是的,ClassLoader是一个很重要的类。那么默认的ClassLoader又有哪几个?\",\" 默认有3个ClassLoader:\",\"Bootstrap ClassLoader 启动类加载器:负责加载JDK内置的类,如rt.jar等。\",\"Extension ClassLoader 扩展类加载器:负责加载JDK扩展目录中的jar包、以及VM指定的其他jar包。\",\"App ClassLoader 应用程序类加载器:负责加载用户自定义的类。\",\"//JDK源码中ClassLoader的继承关系 public class ClassLoader { public ClassLoader() {} public Class<?> loadClass(String name) {...} } public class SecureClassLoader extends ClassLoader {...} public class URLClassLoader extends SecureClassLoader {...} //和类加载息息相关的其他类 public final class Class<T> {...} public class ClassNotFoundException extends Exception {...}\",\"： ClassLoader的加载顺序遵循什么规则?\",\" ClassLoader遵循父类委派模式,当一个类加载器收到类加载请求时,它会把这个请求委派给它的父类加载器去完成,依此形成一个链条。只有父类加载器在它的搜索范围内无法找到所需的类时,子加载器才会尝试自己去加载这个类。 因此,类加载的顺序为:\",\"Bootstrap ClassLoader\",\"Extension ClassLoader\",\"App ClassLoader 如果父类可以完成类加载工作则子类不会再去加载,否则子类才会负责加载。这种委派机制可以避免重复加载,也有利于安全性。\",\"： 很好,你对Java类加载机制有很深入的理解。最后,我们聊一聊类加载过程的双亲委派模型在哪些方面带来的好处?\",\" 类加载双亲委派模型带来的好处主要有两点:\",\"避免重复加载:当父类已经加载了某个类时,子类不会再重复加载该类,从而避免资源消耗。\",\"安全性:父类加载的类被所有的子类所信任。 strs如果子类可以随意加载,那么就可能加载一个非授权版本的类,破坏安全性。 综上,双亲委派模型体现了“安全第一,不重复加载”的设计思想,这两点好处使得Java类加载机制更加完备和安全。\",\"： 很好,你的回答很全面和到位。\",\" 非常感谢面试官的指导。\",\"： 你的谢意我心领了,我们的对话也达到了我的目的。真诚地希望这些知识能在你的工作中派上用场。加油!\",\" 非常感谢面试官的鼓励!我会努力运用所学的知识,在工作实践中不断进步。也祝面试官心想事成\",\"： 好,让我们继续讨论类加载过程中另一个重要概念:类的生命周期。什么是类的生命周期?它包括哪几个阶段?\",\" 类的生命周期描述了一个类从被加载到被卸载的整个过程。它主要包括:\",\"加载:找寻并加载类的二进制数据,将其读入内存,并为之创建一个Class对象。\",\"链接:验证、准备和解析。验证是否有正确的内部结构,并和其他类保持一致性。准备分配内存并设置初始值。把相关的符号引用转换为直接引用。\",\"初始化:执行类构造器 <clinit>() 方法的字节码,给类的静态变量赋予正确的初始值。\",\"使用:程序使用这个类创建实例对象、访问类的静态变量和方法等。\",\"卸载:GC回收这个类的所有实例和空间。卸载该类的字节码,并从运行时常量池中移除这个类的符号引用。\",\"： 说明的很详细。类的生命周期中,有哪几个阶段会触发类初始化?\",\" 有三种情况会触发类的初始化:\",\"新创建一个该类的实例。\",\"访问该类的静态变量,或为静态变量赋值。\",\"调用该类的静态方法。 除此之外,下面这些操作不会触发类的初始化:\",\"使用一个类的名称,如在变量声明中使用该类的名称。\",\"使用类加载器加载一个类。\",\"访问某个类的静态常量。\",\"//举例 public class Test { public static int a = 1; //静态变量,会触发初始化 public static final int b = 2; //静态常量,不会触发初始化 public static void method(){} //静态方法,会触发初始化 } Test t = new Test(); //创建实例,会触发初始化 Test.a = 2; //访问静态变量,会触发初始化 Test.b = 3; //访问静态常量,不会触发初始化 Test.method(); //调用静态方法,会触发初始化\",\"： 说的很清楚,举例也很形象。那静态代码块是在哪个阶段执行的?\",\" 静态代码块是在类初始化阶段执行的,位于 <clinit>() 方法中。它优先于构造方法执行,并且只执行一次。例如:\",\"public class Test { static { System.out.println(\\\"静态代码块执行\\\"); } public Test() { System.out.println(\\\"构造方法执行\\\"); } } Test t1 = new Test(); //打印: 静态代码块执行 构造方法执行 Test t2 = new Test(); //打印: 构造方法执行\",\"因此,静态代码块主要用于一次性地对类进行初始化设置,这些设置只在类第一次被加载时执行。它和构造方法的不同之处在于,构造方法在每次创建实例时都会执行。\",\"： 很好,你对类的生命周期及其与类初始化的关系理解很透彻。我想你应该可以轻松应付与类加载相关的面试题了!\",\" 非常感谢面试官的提问,这些关于类的生命周期和初始化阶段的知识点对我来说均很重要。我会不断复习和运用这些知识,以便进一步熟练掌握类加载机制的相关原理,从而应对可能遇到的面试题和实际开发中的相关问题。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\"]},\"935\":{\"c\":[\"《面试1v1》\"]},\"936\":{\"h\":\"垃圾回收机制\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 小伙子,跟我聊聊垃圾回收机制吧。什么是垃圾?怎么回收?\",\" 好的面试官,来吧!垃圾就是那些不再被程序使用的对象。Java 通过自动的垃圾回收机制回收这些垃圾对象所占的内存。\",\"： 那Java垃圾收集器都有哪些?各有什么优缺点?\",\" Java 提供了几种垃圾收集器:\",\"Serial 收集器:最基本的收集器,对内存进行复制然后清理,效率low。只使用一个线程,会停顿其他线程,不适用服务器环境。\",\"Parallel 收集器:多个线程并行回收,效率高于Serial,适用于微服务等。\",\"CMS 收集器:并发标记清除,效率高,并发回收,但会产生碎片。适用于对响应时间有要求的场景。\",\"G1 收集器:JDK9默认,基于region分代回收,效率高且不产生碎片。适用于大内存的机器。\",\"： 讲讲G1垃圾收集器的工作流程。\",\" G1垃圾收集器的工作流程如下:\",\"初始标记:标记GC Roots能直接关联的对象,速度快,主要为了第2步做准备。\",\"// 代码示例 private void markFromRoots() { // classify objects and put them into correct lists for (Object obj : strongRefs) { G1CollectedHeap.addToMarked(obj); } }\",\"并发标记:从GC Roots开始对堆中对象进行并发标记,jia部分STW(stop-the-world)\",\"最终标记:修正并发标记期间并发修改导致的错误标记,需要STW。\",\"筛选回收:根据标记结果筛选回收区域,回收垃圾对象,需要STW。\",\"并发清理:与用户线程一起工作,对标记和筛选阶段差异化技术产生的垃圾链进行清理。\",\"以上就是G1收集器的整个工作流程,相比CMS无碎片和高效,适用于大内存服务器。\",\"： 那说说 Java 对象如何判断为“垃圾”?\",\" Java 对象通过引用计数算法判断是否为垃圾:\",\"如果一个对象仅被强引用变量引用,并且这个强引用变量为 null,则该对象为垃圾。\",\"// 对象example引用为null,则该对象为垃圾 Example example = new Example(); example = null;\",\"如果一个对象被强引用的变量引用,并且这个强引用变量所在的方法已经弹出栈,则该对象为垃圾。\",\"// 方法退出后,obj为垃圾 public void func() { Example obj = new Example(); }\",\"如果一个对象仅被软引用、弱引用或虚引用变量引用,则在垃圾回收时这些变量会被清除,该对象为垃圾。\",\"// 使用WeakReference例子 WeakReference<Example> weakExample = new WeakReference<>(new Example()); // 如果没有其他引用指向Example对象,则该对象可被回收\",\"如果两个对象彼此引用,但没有任何一个对象被外部强引用,则这两个对象之间形成的循环引用链为垃圾。\",\"// A和B相互引用,构成循环,都为垃圾 A a = new A(b); B b = new B(a);\",\"： 帮我总结下 Java 垃圾回收的机制?\",\" 可以这么总结 Java 垃圾回收机制:\",\"垃圾的判断:通过引用计数算法判断对象是否可达。如被引用变量置null、超出作用域、软引用被清理等,则判断为垃圾。\",\"垃圾的回收:通过垃圾收集器进行自动回收,如Serial、Parallel、CMS、G1等收集器。使用分代回收、标记-清除、复制算法等进行回收。\",\"垃圾回收的时机:当堆中垃圾对象达到一定比例或内存不足时,会触发垃圾回收。也可以手动触发System.gc()。\",\"垃圾回收的步骤:1标记阶段标记垃圾 2清除阶段删除垃圾 3整理阶段压缩空间\",\"如何优化:尽量减少垃圾产生,使用软引用或弱引用存放易变对象,及时回收资源等方式优化。\",\"以上就是 Java 垃圾回收机制的主要内容,希望能对你有所帮助!有任何问题都可以继续问我。\",\"： 那谈谈你了解的JVM内存结构和垃圾回收之间的关系?\",\" JVM内存结构与垃圾回收有密切关系:\",\"JVM内存结构分为:堆内存、虚拟机栈、方法区、本地方法栈、程序计数器等。堆内存存储对象实例,垃圾回收的主要区域就是堆内存。\",\"// JVM内存结构图示 +--------------------+ | 方法区 | +--------------------+ | 程序计数器 | +--------------------+ | JVM栈 | +--------------------+ | | | 堆内存 | | | +--------------------+\",\"堆内存中又分为几个区域,主要有两个:新生代和老年代。新生代用于存储新创建的对象,老年代中存放老化对象。\",\" +--------------------+ | 方法区 | +--------------------+ | 程序计数器 | +--------------------+ | JVM栈 | +--------------------+ | 新生代 | | | | 堆内存 | | | | 老年代 | +--------------------+\",\"垃圾收集器会根据这些内存区域中的对象进行回收,比如新生代使用Copying算法,老年代使用Mark-Sweep算法。\",\"情景举例:\",\"对象在Eden出生,经过第一次Minor GC后未死亡进入Survivor,多次MinorGC后仍存活进入老年代。\",\"老年代空间不足触发Major GC,回收部分垃圾对象。\",\"老年代的对象通过晋升至永久代,如果永久代填满,会抛出OOM异常。\",\"： 嗯！啊。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"937\":{\"c\":[\"《面试1v1》\"]},\"938\":{\"h\":\"CMS垃圾回收器\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 小伙子,CMS 垃圾收集器跟我讲讲?\",\" CMS全称Concurrent Mark Sweep,是一种并发标记清除算法。它并发执行与用户程序,减少垃圾收集时程序暂停的时间。\",\"： 说白了,CMS就是为了减少卡顿吧?\",\" 是的,CMS 的核心目标就是达到并发收集、减少停顿。它的工作流程如下:\",\"初始标记:只标记GC Roots能直接关联的对象,速度快,与用户线程共享运行,不需要Stop The World。\",\"// 初始标记代码示例 private void initialMark() { for (Object obj : strongRefs) { CMSCollector.mark(obj); } }\",\"并发标记:从GC Roots开始递归的标记对象图,与用户线程一起工作,需要部分STW阶段。\",\"最终标记:修正在并发标记期间并发修改导致的错误标记,需要STW。\",\"并发清除:与用户线程一起工作,清除被标记的对象,不需要STW。\",\"并发重置:与用户线程一起工作,为下一次GC做准备,不需要STW。\",\"： 说说并发标记和最终标记的区别?\",\"并发标记阶段与用户线程一起运行,在标记过程中对象图可能被修改,会产生”脏标记“。需要最终标记修正。\",\"最终标记阶段需要Stop The World,去修正并发标记期间的”脏标记“,确保正确的标记对象。\",\"如果没有最终标记阶段,并发标记的”脏标记“会导致非垃圾对象被清除,或者垃圾对象未被清除。\",\"所以,最终标记阶段是CMS算法关键,它通过STW去修正并发阶段的错误”脏标记“,使得CMS并发标记清除算法成为可能。\",\"： CMS 收集器的优缺点分别是什么?\",\" CMS 收集器的主要优点是并发收集、低停顿,适用于对响应时间有要求的场景。 但是CMS也有一些缺点:\",\"会产生大量空间碎片,空间利用率低。\",\"标记和清除过程需要占用CPU资源,并发时会对程序性能产生一定影响。\",\"并发执行时,需要处理一致性问题,会加大开发难度。\",\"只适用于老年代回收,新生代仍需其他收集器配合。\",\"浮动垃圾可能带来更长的GC停顿时间,不适用于需要极低停顿的场景。\",\"所以,CMS 是一款比较经典的低停顿收集器,但也存在一定的缺陷, v在JDK9后G1成为了更好的选择。但CMS算法本身的思想仍然值得我们学习。\",\"： 说说CMS 收集器的“碎片化”问题?\",\" CMS 是一种标记-清除算法,它会产生大量空间碎片,空间利用率低是一个缺点。这是因为:\",\"在并发标记阶段,需与用户程序同时运行,无法移动对象。\",\"在并发清除阶段,直接清除标记的垃圾对象,留下空隙。\",\"这些空隙会产生空间碎片,并不连续,但空间可能不足以分配较大对象。\",\"空间利用率降低,达不到理想状态,需要更频繁的Major GC来整理空间。 我们可以从JVM源码中看到CMSCollector在清除对象后直接造成碎片:\",\"//CMSCollector.java private void sweep phase() { for (Object obj : markedObjects) { freeMemory(obj); // 直接清除,产生碎片 } }\",\"为解决这个问题,CMS做了一些努力:\",\"采用Free-list维护小块空闲空间, satisfiy小对象分配。\",\"对象晋升到老年代时预留一定空间减少碎片。\",\"空间报警触发Minor GC和Full GC,做空间整合。\",\"可配置启动Incremental CMS模式,进入并发清理阶段做连续空间整理。\",\"但由于算法的限制,CMS仍无法完全解决碎片空间问题,这也是它被G1等收集器替代的原因之一。\",\"： 谢谢详细的解释!CMS 收集器虽然有缺陷,但它的并发标记清除思想影响了后续的垃圾回收算法。\",\" 是的,CMS 收集器提出了并发收集和低停顿的理念,其中的并发标记清除算法也为之后G1等收集器奠定了基础。它的关键思想值得我们学习:\",\"将清理过程分为并发和STW两个阶段,大大减少停顿。\",\"通过最终标记修正并发阶段的”脏标记“,使得并发标记成为可能。\",\"采用Free-list和预留空间等手段减轻空间碎片问题。\",\"根据空间利用率与GC时间的平衡,选择满足需求的收集频率。\",\"这些思想为我们设计低停顿、高效的GC算法提供了参考,CMS也因此成为Java垃圾收集史上的里程碑。所以,尽管它有缺陷,但它的算法思想和理念仍十分值得我们学习。\",\"： 很好,你对CMS收集器的理解已经相当透彻!希望你在日后继续深入学习其他垃圾收集算法。\",\" 非常感谢您的夸奖和建议!我会继续努力学习和研究垃圾收集theory与实践,包括G1、ZGC、Epsilon等算法与案例。谢谢您的提问,让我有机会深入梳理CMS以及Java垃圾收集机制,收获颇丰!\",\"： 看来有点东西，你先等一下！\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"939\":{\"c\":[\"《面试1v1》\"]},\"940\":{\"h\":\"G1垃圾回收器\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： G1垃圾收集器?听说很牛逼的样子!\",\" 是的,G1是JDK9默认的垃圾收集器,代替了CMS收集器。它的目标是达到更高的吞吐量和更短的GC停顿时间。\",\"： 听你一说,我就不高兴了!G1到底好在哪儿?\",\" G1具有以下优点:\",\"并发和增量式回收:不像CMS要全部STW,G1可以渐进式回收,不停顿太久。\",\"// G1CollectedHeap.java void collectGarbage(G1ConcurrentMark mark) { initial-mark; // STW remark(); // Concurrent cleanup(); // STW concurrent-cleanup(); // Concurrent }\",\"分代回收:不需要一次全堆回收,可以分代增量回收,选择性回收新生代和老年代。\",\"void collectGarbage(boolean collectOnlyYongGen) { if (collectOnlyYongGen) { collectYoungGenGarbage(); // only YongGen } else { collectGarbage(); // YongGen and Old Gen } }\",\"空间整合:通过Remembered Sets实现空间整合,解决碎片问题。\",\"// G1RemSet.java void addToRememberedSets(HeapRegion from, HeapRegion to) { from.addRememberedSetEntry(to); }\",\"预测分析:通过限定垃圾产生速率,动态调整回收频率与时间,实现高吞吐量。\",\"： 垃圾收集里最让我头疼的就是“Remembered Sets”和“卡片表”,解释一下?\",\" Remembered Sets和Card Tables都是G1用来管理堆和处理垃圾回收的重要数据结构。\",\"Remembered Sets:记录不同Region之间的引用关系,用于判定垃圾。由于G1采用分代和分片回收,需要记录新生代和老年代以及各个Region之间的引用链,这就是Remembered Sets要做的工作。\",\"Card Tables:由Remembered Sets维护的引用链过于精细,代价太大。所以,G1引入Card Tables,按照内存块做了分段,如果一个分段里至少有一个对象被老年代引用,则标记整个分段为”脏“。在回收时只处理”脏“的分段,提高效率。\",\"它们的工作可以简述为:Remembered Sets记录精细的引用信息,Card Tables进行概括性标记,在GC时结合使用,达到高精度且高性能的铁子回收效果。\",\"可以看到,Remembered Sets和Card Tables是G1高效率回收的关键,它们让G1不需要像CMS那样全堆回收,可以有选择性地、增量式地进行分代、分片的回收,极大的提高了工作效率。\",\"： 原来如此,G1之所以马力十足,关键还是它发明的这套“铁子”数据结构,聪明!\",\" 谢谢面试官的赞赏和提议!我会继续努力学习,如果有机会能参与。\",\"： 说说G1的垃圾回收过程?\",\" G1的垃圾回收过程可以分为以下几个主要阶段:\",\"初始标记:标记GC Roots能直接关联的对象,需要Stop The World。\",\"private void initialMark() { for (Object obj : strongRefs) { G1CollectedHeap.mark(obj); } }\",\"并发标记:从GC Roots开始对堆中对象进行并发标记,需要部分STW。\",\"最终标记:修正并发标记期间的错误标记,需要STW。\",\"筛选回收:根据标记和Card Table结果筛选回收区域,回收垃圾,需要STW。\",\"// 筛选待回收区域 void selectGarbageCollectionCandidates() { Region[] filtered = filterRegions(); garbageCollect(filtered); }\",\"并发清理:与用户线程一起工作,对标记和筛选阶段误差产生的垃圾链进行清理。\",\"并发重置:与用户线程一起工作,为下次GC做准备。\",\"这一过程实际上和CMS非常相似,同为“标记-清除”算法。但G1在并发标记的基础上,通过Remembered Sets和Card Tables实现了分代回收和空间整合,这也是它能达到高性能的关键。\",\"： 说G1是“标记-清除”,是不是太武断了?它用的不正是你刚才提到的那套铁子数据结构吗?\",\" 您说的对,我的表述确实有失妥当。更准确的来说:\",\"G1继承了“标记-清除”算法的思想,但已远非传统意义上的“标记-清除”。\",\"G1引入了Remembered Sets和Card Tables,实现了细致且高效的分代、分片增量回收,这是它的重要创新点。\",\"所以,G1是在“标记-清除”思想上做出重大改进、发展和优化而成的一种高性能垃圾收集器,将它简单归类为“标记-清除”算法已忽略其最关键的优点。\",\"G1与CMS一脉相承,但已大大超越,其性能和效率甚至与“复制”算法接近,堪称一代新高。 所以,更准确的说法应是:G1继承了标记-清除模型,但在算法和实现上都已经有了重大创新,超越了传统标记-清除算法,达到一种混合模型与新高度,是一款高性能、高效率的收集器。\",\"： 对,你的理解已经趋于准确和清晰。能看出G1的创新之处,并不简单归类,这说明你对收集器的认知已逐步深入。\",\"： G1收集器的设计与实现还有哪些关键点需要关注?\",\" 除了我们讨论过的Remembered Sets和Card Tables外,G1的设计与实现还有其他一些关键点:\",\"Region:将整个堆内存分割成多个大小相等的Region,作为回收和管理的基本单元。\",\"Humongous Object:对超大对象特殊处理,让其占用连续的Region。\",\"Remembered Sets:记录不同Region之间的引用关系,但过于精细,通过Card Tables进行优化。\",\"Card Tables:按Region进行内存分块,标记”脏“的Region,在GC时优先处理。\",\"Coloreo Grey Lists:通过颜色标记法管理标记过程,避免重复标记对象。\",\"回收率与吞吐量预测:通过统计与分析,动态预测并调整回收率与吞吐量,实现自动调优。\",\"增量式并发回收:通过分代和分片回收,以及STW与并发相结合,实现渐进式回收与低停顿。\",\"空闲区整理:通过回收产生的空闲区的合并整理,解决空间碎片问题。\",\"Safepoint:在STW阶段,用于保证用户线程的一致性快照。但开销大,所以尽量减少STW次数。\",\"这些都是G1高性能与低停顿的关键 support,对其设计与实现有深入理解,可以更好运用G1收集器。当然,本回答只能简要提及,实际上G1的设计极为复杂精巧,需要深入研读源码和官方文档方能全面理解。\",\"： Wonderful! 你对G1的理解已经相当深入全面,提到的这些关键点imovativ析得很透彻。G1的设计确实非常复杂精巧,能达到如此水平的理解,看来你在这方面下了不少功夫!\",\" 非常感谢您的赞赏!我会持之以恒,继续深入学习G1与其他垃圾收集器的设计与实现。事实上,想全面深入理解G1还需要我继续努力,它的设计之巧妙令人颇感佩服与惊叹,这也使得我在研究这个课题上收获颇丰。谢谢您的提问,让我有机会梳理和总结这些关键点,这对我加深理解G1有很大帮助。我亟需在实践中不断磨练这些理论知识,并且对更多案例和细节有所了解,这需要我继续学习和努力。\",\"： 开心能听到你如此谦逊好学的态度。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"941\":{\"c\":[\"《面试1v1》\"]},\"942\":{\"h\":\"JVM调优\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 小伙子,说听说你JVM调优挺在行?\",\" 谢谢夸奖,我对JVM调优还在学习中,远未达到在行的程度。不过日常工作中也对JVM参数与监控工具稍有使用,算是入门水平吧。\",\"： 那就给我简单介绍下JVM调优的方法和手段吧!\",\" JVM调优主要通过以下手段:\",\"设置JVM参数:像Heap大小、垃圾收集器选择等,根据应用特点选择合适参数。\",\"-Xmx4096m //堆最大值 -Xms4096m //堆初始值 -XX:+UseG1GC //设置G1垃圾收集器\",\"采用监控工具:像JDK自带的JConsole、JVisualVM,或第三方工具。实时监控运行指标,找出性能瓶颈。\",\"JAVA代码优化:合理使用数据结构,避免高复杂度算法,少创建临时对象等。\",\"配置日志:输出GC、内存、CPU相关日志,分析定位问题。\",\"定期压测:通过压力测试找出系统瓶颈,及早解决潜在问题。\",\"： 日常工作用的最多哪些JVM参数和监控工具?\",\" 我日常工作中最常用的JVM参数和监控工具如下:\",\"-Xmx、-Xms:设置堆最大值和初始值,根据应用内存需求适当设置。\",\"-XX:+UseG1GC:设置G1垃圾收集器,针对我使用的应用,G1表现良好。\",\"-XX:+PrintGCDetails:输出详细的GC日志,用于分析垃圾收集情况。\",\"-XX:+PrintGCDateStamps:在GC日志前输出时间戳,方便对时间敏感应用进行分析。\",\"-XX:+HeapDumpOnOutOfMemoryError:导出OOM时的堆转储文件,用于后续分析。\",\"JVisualVM:用来实时监控内存、GC、线程、CPU等运行情况。\",\"JConsole:用于观察运行时的线程活动、内存变化、类加载等情况。\",\"这些参数和工具在我日常工作的JVM调优和问题排查中发挥了很大作用。但我还需要继续学习其更深层次的用法与理论知识,运用得更加娴熟高效。\",\"： 不错,你已经掌握了JVM调优的基础知识和日常工具,这是个不错的入门!\",\"： 那么,作为JVM调优的进阶,你有哪些学习计划?\",\" 我的JVM调优进阶学习计划如下:\",\"深入理解各种垃圾收集器的设计与实现原理,特别是G1、ZGC等高性能收集器。\",\"研究JVM内存模型和对象创建过程,以及两者对调优的影响。\",\"学习各项运行指标的测量与对调优的意义,如吞吐量、停顿时间等。\",\"掌握各类JVM运行日志的生成与解析,特别是GC日志、CPU profiles等。\",\"理解JIT(Just-In-Time)编译器的工作原理与调优手段。\",\"学习Java Mission Control等高级监控与故障排除工具的使用。\",\"不断通过实践来提高各工具与理论的运用能力,发现更多调优机会。\",\"关注OpenJDK等开源项目了解JVM的最新进展与发展方向。\",\"参考业界大佬的优秀文章与经验,不断总结与提高。\",\"这些是我进阶JVM调优所制定的学习计划,需要耐心学习与长期实践,不断深耕累积。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"943\":{\"c\":[\"《面试1v1》\"]},\"944\":{\"h\":\"Java注解\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 接下来，聊聊Java的注解,它们到底有什么用?\",\" 注解的用处主要三个: 第一个,编译期使用。比如@Override确保你正确重写了方法,@Deprecated表示这个方法以后可能会删掉。 第二个,运行期使用。很多框架通过反射来读注解,根据注解改变程序的行为。像Spring的@Autowired就是运行期读取的。 第三个, build tool用。很多构建工具会在构建代码时扫描和读取注解,根据注解做相应的操作。JUnit的@Test就是告诉测试运行器哪些是测试方法。\",\"：注解和注释有什么区别吧?\",\" 注释是写给人看的,注解是写给机器看的。注释不会对程序产生任何影响,注解会影响程序的编译、运行。注释是// 或者/* */,注解是@打头的。\",\"：举个自定义注解的例子?\",\" 这里有个自定义注解的示例:\",\"//自定义注解 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnno { String name() default \\\"Hello\\\"; } //使用注解 public class MyClass { @MyAnno(name = \\\"World\\\") public void sayHello() { System.out.println(\\\"Hello World\\\"); } } //读取注解 MyAnno anno = MyClass.class.getMethod(\\\"sayHello\\\").getAnnotation(MyAnno.class); String name = anno.name(); // name = \\\"World\\\"\",\"：说说Spring中常见的注解?\",\" Spring中超级常用的注解有: @Component:把类标记为Spring的组件,用于组件扫描。 @Autowired:自动装配成员变量、构造方法和方法参数。 @Service:标记业务层组件。@Controller:标记控制层组件。 @Repository:标记数据访问组件。 @RequestMapping:映射请求URL到控制器处理方法。 @Configuration:标记配置类。 @Enable*:开启某个功能,比如@EnableTransactionManagement 开启事务功能。 这些注解大大简化了Spring的配置,真的很常用!\",\"：SpringBoot中常见的注解也说一下?\",\" SpringBoot中常用的注解有: @SpringBootApplication:标记这个类是SpringBoot的主配置类。 @Configuration:标记这个类是配置类。 @EnableAutoConfiguration:开启SpringBoot的自动配置。 @ComponentScan:开启组件扫描,找出应用相关的bean。 @RestController:标记这个控制器直接返回JSON或XML数据。 @RequestMapping:映射请求URL。 @Autowired:自动装配bean。 @Repository、@Service、@Controller:标记DAO、Service、Controller层的bean。 这些注解的作用和Spring差不多,只是在SpringBoot中简单了很多,几乎都可以不写XML配置了。\",\"：最后,AOP中的注解呢?\",\" AOP中最重要的注解有: @Aspect:标记一个切面。 @Pointcut:定义一个切点,可以是一个规则表达式,和@Before等注解搭配使用。 @Before:前置通知,在目标方法调用前执行。 @AfterReturning:后置通知,在目标方法正常返回后执行。 @AfterThrowing:异常通知,在目标方法抛出异常后执行。 @After:最终通知,无论目标方法是否正常完成都会执行。 @Around:环绕通知,手动控制目标方法调用时机。 这些AOP注解通过在方法上标记,就可以实现方法的切入、替换等,真正做到面向切面编程。\",\"：自定义注解需要什么?\",\" 自定义注解需要两个注解:@Target定义可以用于什么地方(方法、类等),@Retention定义注解的生命周期(编译期、运行期、源码)。然后使用@interface自定义注解,可以添加属性,默认值等。\",\"：注解的生命周期有几种?\",\" 注解生命周期有3种: 源码阶段:@Retention(RetentionPolicy.SOURCE),编译后失效。 编译阶段:@Retention(RetentionPolicy.CLASS),编译后存在于字节码文件中,运行时无法获得。 运行阶段:@Retention(RetentionPolicy.RUNTIME),编译后存在于字节码文件中,运行时可以通过反射获取。 大部分自定义注解都使用RUNTIME,以方便通过反射来读取和使用注解信息。\",\"：Enum中的注解呢?\",\" @Retention(RetentionPolicy.SOURCE)只存在于源码,编译后失效。 @Retention(RetentionPolicy.RUNTIME)会保留至运行时,可以通过反射读取。所以Enum中的注解一般使用RUNTIME。 枚举例子:\",\"@Retention(RetentionPolicy.RUNTIME) @interface Color { ColorType value(); } public enum ColorType { @Color(ColorType.RED) RED, @Color(ColorType.GREEN) GREEN, @Color(ColorType.BLUE) BLUE }\",\"：注解在哪些地方可以使用?\",\" 注解可以放在: 类、接口、枚举上 字段、方法上 方法的参数上 局部变量上 构造器上 包上 所以注解的@Target有: ElementType.TYPE:接口、类、枚举、注解 ElementType.FIELD:字段、枚举的常量 ElementType.METHOD:方法 ElementType.PARAMETER:方法参数 ElementType.CONSTRUCTOR:构造器 ElementType.LOCAL_VARIABLE:局部变量 ElementType.PACKAGE:包 等等。\",\"：运行时注解的使用场景?\",\" 运行时注解主要有两大使用场景:\",\"框架使用:很多框架使用运行时注解读取注解信息,调用相应的处理逻辑。如Spring使用@Autowired、@PostConstruct等实现依赖注入和初始化方法调用。\",\"自定义注解:我们可以自定义运行时注解,在程序运行时通过反射读取注解,执行相应逻辑。比如:\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { } public class Main { @MyAnnotation public void doSomething() { // ... } }\",\"然后通过反射调用:\",\"Method m = Main.class.getMethod(\\\"doSomething\\\"); MyAnnotation anno = m.getAnnotation(MyAnnotation.class); //执行相关逻辑\",\"：最后一个问题,注解有哪些限制?\",\" 注解有以下几个限制:\",\"注解不能继承其他注解或接口。\",\"注解只有成员变量,没有方法。\",\"注解中的成员变量只能是基本类型、String、Enum、Annotation等,不能是对象。\",\"如果注解有默认值,在使用注解时可以忽略该值。\",\"同一个地方不能同时存在两个同名注解。\",\"注解不能作用于变量、类的私有成员上。\",\"注解不会继承,子类或者实现类无法继承父类或者接口的注解。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"945\":{\"c\":[\"《面试1v1》\"]},\"946\":{\"h\":\"List\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 小伙子,听说你对Java集合挺在行的?\",\" 谢谢夸奖,我对Java集合还在学习中,只能算入门水平。特别是List这个接口,其下的实现类功能非常丰富,我还未能全部掌握。\",\"： 那么,简单介绍下List这个接口及常用实现类吧!这是Java集合的基础,也是日常开发中最常用的。\",\" List接口表示一个有序集合,它的主要实现类有:\",\"ArrayList:基于动态数组实现,查询快、增删慢。\",\"ArrayList<Integer> list = new ArrayList<>();\",\"LinkedList:基于双向链表实现,查询慢、增删快。\",\"LinkedList<Integer> list = new LinkedList<>();\",\"Vector:和ArrayList类似,但它是线程安全的,查询快、增删慢。\",\"Vector<Integer> list = new Vector<>();\",\"Stack:继承Vector,实现栈结构,后进先出。\",\"Stack<Integer> stack = new Stack<>();\",\"它们都实现了List接口,有一些共同的方法,但底层数据结构不同,所以在不同场景有不同的使用优势。这取决于应用的需求。\",\"： 那日常工作用的最多的是哪个实现类?它的源码能不能讲解一下?\",\" 我日常工作中最常用的List实现类就是ArrayList。 它的源码如下:\",\"public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { /** * 默认初始容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 存储元素的数组 */ transient Object[] elementData; /** * 实际容量 */ private int size; public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else { this.elementData = new Object[DEFAULT_CAPACITY]; } } public ArrayList() { this.elementData = new Object[DEFAULT_CAPACITY]; } //添加元素 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } }\",\"ArrayList底层采用动态数组实现,通过ensureCapacityInternal()方法动态扩容,以达到在保证查询效率的同时,尽量减小扩容带来的性能消耗。这也是我在日常使用中最欣赏ArrayList的地方。当然,它的实现远不止这些,我还在不断学习与理解中。\",\"： 不错,你对这些知识已经有一定理解。ArrayList的源码分析得也比较到位。看来你之前真的有认真研读与理解。不过List相关知识还有更广阔的空间,需要你继续努力!\",\" 非常感谢面试官的肯定与指导。您说得对,List及其相关知识还有很多值得我继续学习与探索的地方。我会持续加深理解,提高运用能力。\",\"： 那么,你对List还有哪些不太理解的地方?或是想更深入学习的内容?\",\" 关于List,我还不太清楚或想进一步学习的内容如下:\",\"CopyOnWriteArrayList:它的实现原理与线程安全机制,这也是日常开发中经常使用的并发List。\",\"SubList :List子列表的实现原理与边界情况。以及子列表的修改如何影响原列表。\",\"List各实现类在并发环境下的表现。如何选择恰当的并发List类?\",\"List迭代器:ListIterator与Iterator的区别与使用场景。\",\"Queue接口:Queue作为List的子接口,其实现类与使用场景。\",\"底层数据结构:理解数组、链表、红黑树等对List实现的影响,以及各自的优劣。\",\"扩容机制:不同List的扩容策略及性能影响。如何优化?\",\"序列化与反序列化:List各实现类的序列化与反序列化实现。\",\"空值处理:null值在各List实现类中的处理方式。\",\"这些都是我想进一步学习与理解的List相关内容与知识点。我会根据这份清单继续深入阅读源码、分析案例并实践使用,以便全面掌握List及其相关接口与实现类。这无疑需要一段长期的学习与总结过程,但这正是我成长为一名资深Java工程师所必须经历的阶段。\",\"： Wonderful! 这份学习清单涵盖的内容非常全面且具有针对性。你能够准确定位自己尚未完全掌握的知识点,这展现出你的自我认知能力。只要你能够有计划和耐心地向这个清单上的每一项知识点进发,你在List及相关接口的理解上一定会有大的提高,这也为你成长为资深工程师奠定基础。我对你的学习态度和理解能力很为欣赏。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"947\":{\"c\":[\"《面试1v1》\"]},\"948\":{\"h\":\"Map\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 小伙子,又来挑战你了。听说你对Java集合中的Map也很在行?\",\" 谢谢夸奖,Map这个接口的确非常重要且强大。但和List一样,它有许多实现类,而我对它们的理解还远未充分,只能算入门。我仍需不断学习与总结。\",\"： 那好,简单介绍下Map这个接口及常用实现类。它在开发中有何作用?\",\" Map接口表示一个键值对集合,它的主要作用是根据键快速获取值。常用实现类有:\",\"HashMap:基于哈希表实现,支持快速查找、插入和删除,但迭代顺序不定。\",\"HashMap<String, Integer> map = new HashMap<>();\",\"LinkedHashMap:保留插入顺序,除了查找效率高于LinkedHashMap外,其他方面与HashMap相同。\",\"LinkedHashMap<String, Integer> map = new LinkedHashMap<>();\",\"TreeMap:基于红黑树实现,键有序,增删慢但查找快,特别适合排序需求。\",\"TreeMap<String, Integer> map = new TreeMap<>();\",\"Hashtable:和HashMap类似,但它是线程安全的,效率略低。\",\"Hashtable<String, Integer> map = new Hashtable<>();\",\"Map在日常开发中用途广泛,例如缓存、查询表等。我最常用的当属HashMap,由于其查询效率高且适用于大容量场景。但我对其扩容、碰撞处理等机制还需进一步理解。\",\"： 不错,你对Map有比较扎实的认知基础。那么你对HashMap的源码熟悉吗?能否解析一下?\",\" HashMap的源码实现较复杂,我这里仅解析其基本结构与重要流程。主要包括:\",\"HashMap底层采用数组+链表实现,数组是主干,链表在碰撞场景下使用。\",\"字段包括:数组table,容量capacity,加载因子loadFactor等。\",\"// 默认初始容量16,必须是2的n次方 static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 << 30; // 默认加载因子0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f;\",\"put方法将键值对添加到表中。先计算键的hash值得到数组下标,然后将新键值对添加到该位置或链表中。\",\"如果键所在的链表过长或超过加载因子,则触发rehash,即扩容与重新哈希,容量加倍。\",\"void addEntry(int hash, K key, V value, int bucketIndex) { // 保存旧表 Entry<K,V> old = table[bucketIndex]; // 创建新键值对,next指向旧表 Entry<K,V> newEntry = new Entry<>(hash, key, value, old); // 更新数组对应位置 table[bucketIndex] = newEntry; // 如果旧表不为空且旧表的键与新键hash值相同,则发生哈希碰撞 if (old != null && hash == old.hash && (old.getKey() == key || old.getKey().equals(key))) old = newEntry; if (size++ >= threshold) resize(2 * table.length); // 扩容 }\",\"HashMap的源码实现还有很多精妙的地方,我还需要继续学习。但总体来说,它通过拉链法处理碰撞,并提供动态扩容机制来保证高效插入与查询。这也是它成为我最爱的Map实现类的原因。\",\"： HashMap的源码解析得不错,你理解得比较透彻。的确,它的实现机制相当精巧,需要深入学习与理解。你之前提到也有些不太理解的地方,想加深学习的内容,能否简单提一下?\",\" 关于HashMap,我还希望进一步学习的内容如下:\",\"树化过程:何时进行树化,如何选择红黑树还是二叉查找树。\",\"扩容的全过程:扩容时,旧键值对的重新映射策略与性能影响。\",\"哈希函数:不同的哈希函数对HashMap性能的影响。\",\"链表转红黑树的条件:何时应选择链表还是红黑树来解决哈希冲突。\",\"ConcurrentHashMap:它的实现原理与代理模式。\",\"IdentityHashMap:键比较使用==而非equals,其典型应用场景。\",\"WeakHashMap:其释放键值对的条件与实现原理。\",\"** serialization**:不同Map实现类的序列化方式与注意事项。\",\"Null键值处理:不同Map中null键与null值的处理方式。\",\"这些都是我想继续学习与理解的Map相关内容,我会根据这份清单进一步深入阅读源码、分析案例并实践,以便全面掌握Map及各实现类。这需要投入大量时间与精力,但我相信这会让我的Java基础更加扎实。\",\"： Wonderful!你对Map及其实现类一定有比较深入的理解和认知,才能准确地指出自己还需加深学习的知识点。这份学习清单也同样具有针对性,只要能够逐项进行深入学习,定会有很大的提高。\",\"我很欣赏你的学习热情与主动性,这些都是成为一名优秀工程师必不可少的素质。继续保持,深入学习,你的Java基础会更加牢固,技术生涯也会更上一层楼。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"949\":{\"c\":[\"《面试1v1》\"]},\"950\":{\"h\":\"Spring基础\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 想请你简单介绍一下 Spring 框架,它的核心特性是什么?\",\" Spring 是一个开源框架,目的是简化 JavaEE 开发。它的核心特性有:\",\"IoC(Inverse of Control):通过 DI(Dependency Injection)实现将对象间的依赖关系交给 Spring 管理。\",\"AOP(Aspect Oriented Programming):面向切面编程,可以在程序运行期间动态的将某段代码切入到指定的方法、指定的位置进行运行。\",\"Portlet MVC:Spring 提供 MVC 框架可以快速开发 Web 应用。\",\"事务管理:Spring 提供广泛的事务管理接口,支持 JDBC、Hibernate 等事务管理。\",\"Spring 统一一体化了其他框架和技术,如:Struts、Hibernate、Quartz 等。 面试官(笑):你说的真是五花八门,让我有点晕,来聊点具体的吧。Spring 是如何工作的,它如何用于构建 Web 应用程序?\",\" 好的,Spring 的工作原理主要是 IoC 容器。对 Web 应用来说,Spring MVC 是基于 JavaEE 的 Model-View-Controller 设计模式构建的,主要工作流程是:\",\"浏览器发送请求到 DispatcherServlet。\",\"DispatcherServlet 接收请求后会转交给 HandlerMapping 得到请求对应的 Handler。\",\"HandlerMapping 将 Handler 映射到 HandlerAdapter。\",\"HandlerAdapter 调用 Handler 处理请求,Handler 会返回一个 ModelAndView。\",\"ViewResolver 解析 ModelAndView,找到正确的 View。\",\"DispatcherServlet 将 View 返回给浏览器。\",\"通过这个流程,Spring MVC 应用了 MVC 模式,实现了业务逻辑、控制逻辑、表现逻辑的分离,使我们可以更加专注于业务开发。\",\"： 你说的很具体,我明白了。那么 Spring 可以在哪些实际场景中使用?开发人员在使用 Spring 时常犯哪些错误?\",\" Spring 可以应用在很多实际场景中:\",\"Web 应用:Spring MVC 是 Spring 体系中最为成熟的框架,可以用来开发网站、BBS、博客等 Web 应用。\",\"企业应用:Spring 提供事务管理、数据访问等功能,非常适用于开发企业级应用。\",\"微服务:Spring Boot 提供了快速开发单个微服务的能力,配合 Spring Cloud 可以开发微服务架构的系统。\",\"Android 应用:Spring for Android 提供了在 Android 应用中使用 Spring 的能力。\",\"开发人员在使用 Spring 时常犯的几个错误:\",\"容器管理对象依赖关系错乱:未正确配置 bean 的依赖关系,导致依赖注入错误。\",\"上下文目录 problemas:beans.xml 配置文件放在了非上下文目录,导致 Spring 无法识别。\",\"事务管理错误:未正确配置事务属性,导致事务管理不生效。\",\"AOP 误用:滥用 AOP 或错误使用 AOP 导致 sistem 过于复杂或 AOP 不生效。\",\"未考虑扩展性:在开发初期未考虑系统扩展性,导致系统难以演进。\",\"： 那么如何使基于 Spring 的应用程序更高效、更可扩展?\",\" 这里有几点建议:\",\"采用模块化设计,遵循高内聚低耦合原则,每个模块保持高内聚,模块之间低耦合。\",\"使用设计模式,如工厂模式、单例模式、代理模式等,提高系统扩展性。\",\"应用 AOP,通过预置切点在不修改源代码的情况下增加新功能。\",\"使用 Spring 的事件机制,通过事件监听器监听事件,当事件触发时执行相应逻辑。\",\"应用 Spring 的 Profile 功能,可以根据环境部署不同的 bean,提高系统灵活性。\",\"使用 Spring Boot 依赖管理和自动配置的能力,简化构建过程,提高开发效率。\",\"应用微服务架构,将单体应用拆分成职责单一、松耦合的服务,更容易扩展和升级。\",\"使用缓存技术,如 Redis 缓存数据库查询结果,降低数据库压力,提高系统吞吐量。\",\"： 很棒,你对 Spring 和高可扩展系统的理解很透彻!最后一个问题,Spring 的源码中 IoC 容器的实现你可以大致描述一下吗?\",\" 可以的,IoC 容器的实现主要在 AbstractApplicationContext 及其子类 ClassPathXmlApplicationContext 和FileSystemXmlApplicationContext 中。主要流程是:\",\"容器启动时会调用 refresh() 方法,其中会调用 obtainFreshBeanFactory() 方法初始化 DefaultListableBeanFactory,此为 IoC 容器的核心。\",\"// AbstractApplicationContext.java public void refresh() throws BeansException, IllegalStateException { // 初始化 BeanFactory DefaultListableBeanFactory beanFactory = obtainFreshBeanFactory(); }\",\"然后会调用 loadBeanDefinitions(beanFactory) 方法加载 bean 定义,主要通过 XmlBeanDefinitionReader 解析 bean 定义文件。\",\"// AbstractXmlApplicationContext.java @Override protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader); }\",\"bean 实例化阶段会调用 getBean() 方法,通过工厂方法或构造器实例化 bean。\",\"实例化 bean 后,会对 bean 进行属性注入、初始化以及其他Aware接口回调。\",\"bean 的生命周期至此结束,容器会对 bean 进行管理,直至容器关闭。 这就是 IoC 容器实现的大致流程,关键是 bean 定义资源的加载和解析,以及 bean 的实例化及生命周期管理。IoC 容器屏蔽了 bean 之间的依赖关系,使 bean 的使用者可以零配置使用 bean。\",\"： 你的解释很到位,IoC 容器的源码分析确实需要对它的原理有深入了解。最后一个问题,在你的项目中是如何设计一个高并发的系统的?\",\" 设计一个高并发系统,有以下几点建议:\",\"选择高性能技术栈:选择支持高并发的语言(Java、Go 等)和框架(Spring、Vert.x 等)。\",\"采用分布式和微服务架构:将系统拆分为多个单一职责的服务,部署在不同服务器上,可以实现高可用和负载均衡。\",\"选择高性能存储:使用能支撑高并发读写的数据库,如 Redis、Kafka 等。对关系型数据库进行分库分表、添加缓存等优化。\",\"限流与降级:使用限流手段控制流量,避免被高流量打垮;使用降级策略保证核心服务可用。\",\"缓存与异步:对频繁读取数据的接口使用缓存;对非关键性计算使用异步处理,避免线程阻塞。\",\"服务治理:使用服务注册与发现、熔断器、网关等手段管理各服务。\",\"线程模型优化:根据业务选择恰当的线程模型。如对大量短连接使用线程池;对长连接使用主从 Reactor 线程模型等。\",\"利用好硬件资源:合理分配 CPU 和内存资源给应用;利用好多核 CPU 进行并行计算等。\",\"测试与监控:进行压力测试,监控系统的负载、吞吐量和延迟指标,并进行优化。\",\"容错和自动恢复:设计稳定的容错方案,当系统发生故障时可以自动检测并恢复。 这些方面搭配得当,可以设计一个高性能、高并发的系统。但需要权衡系统复杂性,在满足需求前提下保持最简实现。\",\"： 很棒,你在高并发系统设计方面有很强的理解力和丰富经验。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"951\":{\"c\":[\"《面试1v1》\"]},\"952\":{\"h\":\"SpringBean生命周期\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 小伙子,听说你对 Spring Bean 生命周期比较熟悉,我们聊聊吧。Spring Bean 都有哪些生命周期阶段?\",\" Spring Bean 的生命周期可以分为 5 个阶段:\",\"实例化(Instantiation):Spring 使用 BeanDefinition 中的信息实例化 Bean。\",\"属性赋值(Dependency injection):Spring 将 BeanDefinition 中配置的属性值注入到 Bean 中。\",\"初始化前阶段(Post-Construct):如果 Bean 实现了 InitializingBean 接口,会调用 afterPropertiesSet() 方法。\",\"初始化阶段(Initialization):如果在 BeanDefinition 中配置了 init-method,会调用该方法。\",\"销毁阶段(Destruction):如果 Bean 实现了 DisposableBean 接口,会调用 destroy() 方法。如果配置了 destroy-method,会调用该方法。\",\"： 聪明!初始化方法有哪些?在源码层面,Spring 是如何调用这些方法的?\",\" Spring Bean 提供了 3 种初始化方法:\",\"@PostConstruct:这是 JSR-250 注解,Spring 会在 Bean 初始化后自动调用被此注解标注的方法。\",\"InitializingBean 接口:这个接口只有一个方法 afterPropertiesSet(),Spring 会在 Bean 初始化后调用该方法。\",\"自定义 init-method:在 BeanDefinition 中配置 init-method 属性,指向 Bean 中的某个方法名,Spring 会在 Bean 初始化后调用这个方法。\",\"在源码层面,这些方法的调用是在 AbstractAutowireCapableBeanFactory 的 initializeBean 方法中实现的:\",\"protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) { // ... // 1. 处理 PostConstruct 注解 if (mbd == null || !mbd.isExternallyManagedInitMethod(\\\"afterPropertiesSet\\\")) { // 2. 实现了 InitializingBean 接口的 Bean 会调用 afterPropertiesSet() 方法 if (bean instanceof InitializingBean) { ((InitializingBean) bean).afterPropertiesSet(); } } // 3. 调用自定义的 init-method if (mbd != null && bean.getClass() != NullBean.class) { String initMethodName = mbd.getInitMethodName(); if (StringUtils.hasLength(initMethodName) && !(bean instanceof InitializingBean && \\\"afterPropertiesSet\\\".equals(initMethodName)) && !mbd.isExternallyManagedInitMethod(initMethodName)) { Method initMethod = bean.getClass().getMethod(initMethodName); initMethod.invoke(bean); } } }\",\"： 不错,你对 Spring Bean 的初始化过程很清楚!那销毁方法哪些?原理又是什么?\",\" Spring Bean 提供了 2 种销毁方法:\",\"DisposableBean 接口:实现这个接口的 Bean 会调用 destroy() 方法。\",\"自定义 destroy-method:在 BeanDefinition 中配置 destroy-method 属性,指向 Bean 中的某个方法名,Spring 会在 Bean 销毁前调用这个方法。\",\"在源码层面,这些方法的调用是在 AbstractAutowireCapableBeanFactory 的 destroyBean 方法中实现的:\",\"protected void destroyBean(String beanName, @Nullable DisposableBean bean) { // 1. 实现了 DisposableBean 接口的 Bean 会调用 destroy() 方法 if (bean != null) { bean.destroy(); } // 2. 调用自定义的 destroy-method String destroyMethodName = getDestroyMethodName(beanName); if (destroyMethodName != null) { Method destroyMethod = null; try { // 获取 destroy-method 方法对象 destroyMethod = bean.getClass().getMethod(destroyMethodName); } catch (NoSuchMethodException ex) { throw new BeanDefinitionStoreException(...); } // 调用方法 try { if (destroyMethod != null) { destroyMethod.invoke(bean); } } catch (...) { throw new BeanCreationException(...); } } }\",\"： 棒!最后,Spring Bean 的作用域都有哪些?如何控制 Bean 的生命周期?\",\" Spring Bean 的作用域有 5 种:\",\"singleton:单例,整个 Spring 容器中只有一个 Bean 实例。\",\"prototype:原型,每次获取 Bean 都会创建一个新的实例。\",\"request:每个 HTTP 请求都会创建一个 Bean 实例。\",\"session:每个 HTTP 会话都会创建一个 Bean 实例。\",\"global-session:每个全局 HTTP 会话都会创建一个 Bean 实例。\",\"我们可以通过 scope 属性控制 Bean 的作用域,从而影响其生命周期:\",\"<bean id=\\\"...\\\" class=\\\"...\\\" scope=\\\"prototype\\\"/>\",\"此外,我们还可以自定义 Bean 的初始化和销毁方法,在 Bean 作用域开始和结束时触发:\",\"<bean id=\\\"...\\\" class=\\\"...\\\" scope=\\\"prototype\\\" init-method=\\\"start\\\" destroy-method=\\\"end\\\"> </bean>\",\"这样我们就可以在 start() 方法中执行初始化逻辑,在 end() 方法中执行清理工作,从而精确控制 Bean 的生命周期。\",\"： 很全面,佩服佩服!如果再给你一个机会,你觉得还可以在哪些方面加深对 Spring Bean 生命周期的理解?\",\" 这里有几个方面可以进一步加深对 Spring Bean 生命周期的理解:\",\"BeanPostProcessor:这个接口可以监听 Bean 的初始化前后,提供了扩展点可以在 Bean 初始化前后进行一些处理。这也是 Spring AOP 的底层原理之一。\",\"了解 BeanFactoryPostProcessor:这个接口可以监听 BeanDefinition 的加载,可以在 Bean 实例化前修改 BeanDefinition 的属性。\",\"理解 Bean 的加载时机:在 Spring 容器启动时,默认会立即加载 singleton 作用域的 Bean,而其他作用域的 Bean 会延迟加载, singleton 作用域的 Bean 也支持延迟加载。这就要涉及到Spring 的 lazy-init 属性设置。\",\"了解 Bean 为什么要有不同的作用域:每个作用域适合的场景是什么,选择不同作用域会对 Bean 的生命周期产生怎样的影响。\",\"了解 Bean 之间的依赖关系对生命周期的影响:比如 A Bean 的初始化依赖 B Bean,那么 A Bean 的初始化也会延迟到 B Bean 初始化完毕后。这涉及到 Spring 的 depends-on 属性配置。\",\"了解自定义初始化和销毁方法的具体应用场景:什么情况下需要自定义这些方法,能在方法中完成什么样的逻辑处理。\",\"探索 BeanPostProcessor 和 BeanFactoryPostProcessor 的具体应用:比如 Spring AOP、Spring 事件发布者等机制的实现。 综上,要全面理解 Spring Bean 的生命周期,除了知道每个阶段的调用外,还需要对很多这个过程涉及到的其他知识点进行深入学习和理解,这需要不断实践和总结。但只要把这些要点都串联起来,对 Spring Bean 的生命周期控制就会很得心应手了。\",\"： 非常棒,这些点精彩极了!你的回答已经很全面和深入,对 Spring Bean 生命周期有清晰理解,这些又是常见的面试重点,我相信面试一定会取得很好的表现,加油!我们就聊到这里,很高兴与你的交流,谢谢!\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"953\":{\"c\":[\"《面试1v1》\"]},\"954\":{\"h\":\"Spring循环依赖\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 小伙子,听说你对 Spring 循环依赖比较熟悉,是真的吗?\",\" 王哥,不敢说很熟悉,但有一定了解,请王哥考考我。\",\"： 那好,首先简单说一下,什么是 Spring 循环依赖?\",\" Spring 循环依赖指的是 BeanA 依赖 BeanB,而 BeanB 也直接或间接依赖 BeanA,两者之间形成依赖循环。这会导致 Bean 无法正常实例化。\",\"： circular dependencies,确实是这样。Spring Bean 的循环依赖有哪些场景?\",\" 主要有三种场景:\",\"构造器循环依赖:BeanA 的构造器注入 BeanB,BeanB 的构造器又注入 BeanA。\",\"Setter 循环依赖:BeanA 在 setter 方法中注入 BeanB,BeanB 的 setter 方法又注入 BeanA。\",\"代理循环依赖:BeanA 依赖 BeanB 的代理对象,BeanB 依赖 BeanA 的代理对象。\",\"： 那 Spring 是如何解决循环依赖问题的呢?\",\" Spring 采用提前暴露对象的方式解决循环依赖,主要通过 AOP 功能和 SmartInstantiationAwareBeanPostProcessor#postProcessAfterInstantiation 方法实现。\",\"对代理循环依赖,Spring 会首先创建目标对象,然后再创建代理对象。\",\"对 Setter 循环依赖,Spring 会在对象创建完成后,提前将对象注入到 BeanFactory 中。然后在注入依赖时,直接从 BeanFactory 中获取已经提前实例化的对象。\",\"//AbstractAutowireCapableBeanFactory#doCreateBean ... // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. Object bean = resolveBeforeInstantiation(beanName, mbd); if (bean != null) { return bean; } ... // Allow post-processors to modify the merged bean definition. bean = applyBeanPostProcessorsAfterInstantiation(bean, beanName); ...\",\"对构造器循环依赖,Spring 在实例化对象后,会提前暴露一个 ObjectFactory,再从 ObjectFactory 中获取目标对象完成依赖注入。\",\"： 那么,Spring 循环依赖会带来什么问题?\",\" Spring 循环依赖主要会带来以下问题:\",\"破坏 Bean 的单例性。因为循环依赖导致一个 Bean 被实例化多次,破坏了 Spring 容器中 Bean 的唯一性。\",\"容器无法正常结束注入过程。循环依赖会导致 Bean 无法完全实例化,一直在循环注入过程中,无法结束。\",\"降低程序的可读性和维护性。循环依赖关系使得程序难以理解,也难以维护。\",\"： 那么,如何避免 Spring 循环依赖呢?\",\" 主要有以下几种方式可以避免 Spring 循环依赖:\",\"编程方式避免。在 Bean 中提供 set 方法,但不在构造器中注入依赖。这样只有在 Bean 完全实例化后,才会注入依赖对象。\",\"构造器注入避免。只使用构造器注入,不用 Setter 方法注入。因为构造器是在 Bean 实例化阶段完成的,避免了循环依赖。\",\"避免过于提前暴露 Bean。如果一个 Bean 不需要频繁使用,不要将其设置为 Singleton,推迟其实例化时间。\",\"分模块避免。将循环依赖的 Bean 拆分到不同的模块中,模块间采用接口隔离,避免循环依赖。\",\"采用重构手段。如果上述方式都不可行,那么需要通过重构来避免循环依赖。比如拆分过于庞大的 Bean 为多个小 Bean 等。\",\"： 不错,总结得很全面。看来你对 Spring 循环依赖还是比较清晰的,加油!\",\" 谢谢 王哥 的提问,让我对 Spring 循环依赖有了更深入的认识。我会继续努力学习的!\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"955\":{\"c\":[\"《面试1v1》\"]},\"956\":{\"h\":\"SpringMVC\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 早上好!我是今天的面试官,请问你叫什么名字,对 SpringMVC 了解吗?\",\" 早上好面试官!我叫小明,对 SpringMVC 有一定的了解,它是 Spring Framework 的一部分,是基于 Java 的 MVC 轻量级 Web 框架。\",\"： 那你能解释一下 SpringMVC 的工作原理吗?\",\" SpringMVC 的工作原理是:\",\"用户发送请求至前端控制器 DispatcherServlet。\",\"DispatcherServlet 根据请求信息调用 HandlerMapping,解析请求对应的 Handler。\",\" //HandlerMapping public interface HandlerMapping { HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception; }\",\"HandlerMapping 返回 HandlerExecutionChain 对象,包含 Handler 处理器和 HandlerInterceptor 拦截器。\",\"DispatcherServlet 调用 HandlerAdapter 进行 Handler 适配。\",\" //HandlerAdapter public interface HandlerAdapter { boolean supports(Object handler); ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; }\",\"HandlerAdapter 执行 Handler 和 HandlerInterceptor,并返回 ModelAndView。\",\"ViewResolver 解析 ModelAndView,返回 View。\",\"DispatcherServlet 根据 View 进行视图渲染,响应用户。\",\"： 你对 SpringMVC 的类和接口还挺了解的嘛!那你说说 DispatcherServlet、HandlerMapping、HandlerAdapter、ViewResolver 分别是什么?\",\" 好的,以下是这几个组件的详细说明: DispatcherServlet:前端控制器,接收请求并相应结果,整个流程控制的中心,由它调用其它组件处理用户的请求。\",\"public class DispatcherServlet extends FrameworkServlet { // ... }\",\"HandlerMapping:请求映射到 Handler 的适配器,根据请求信息匹配 Handler。\",\"public interface HandlerMapping { // 根据请求返回 HandlerExecutionChain 对象 HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception; }\",\"HandlerAdapter:Handler 适配器,调用Handler 处理请求,封装请求信息,返回 ModelAndView。\",\"public interface HandlerAdapter { boolean supports(Object handler); // 调用 Handler 处理请求 ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; }\",\"ViewResolver:View 解析器,将逻辑视图名解析为具体 View 实现。\",\"public interface ViewResolver { View resolveViewName(String viewName, Locale locale) throws Exception; }\",\"所以,这四个组件协同工作,将请求发送给适合的 Handler,Handler 返回处理结果 ModelAndView,再由 ViewResolver 解析为View,最后由 DispatcherServlet 将结果响应给用户。\",\"DispatcherServlet 如同总指挥,负责转发请求到各个组件,真正干活的其实是 HandlerMapping、HandlerAdapter 和 ViewResolver 这三个家伙。\",\"： 原来如此,你解释的很透彻,让我对 SpringMVC 的工作原理有了更深的理解。那么 SpringMVC 的请求处理流程你能画一个示意图来表示一下吗?\",\"这里是 SpringMVC 的请求处理流程示意图:\",\"SpringMVC请求处理流程\",\"详细流程说明:\",\"用户发送请求到 DispatcherServlet。\",\"DispatcherServlet 根据请求信息调用 HandlerMapping,解析 Handler。\",\"HandlerMapping 返回一个 HandlerExecutionChain,包含 Handler 和 HandlerInterceptor 列表。\",\"DispatcherServlet 调用 HandlerAdapter 执行 Handler。\",\"Handler 返回一个 ModelAndView。\",\"ViewResolver 解析 ModelAndView 中的 View 名称,获取 View 对象。\",\"View 对象负责填充 Model 数据并渲染视图。\",\"DispatcherServlet 响应用户。\",\"在这个流程中,HandlerMapping 根据请求找到正确的 Handler;HandlerAdapter 负责具体 Handler 的执行;ViewResolver 找出正确的 View;View 负责数据填充和呈现结果。\",\"DispatcherServlet 作为整个流程的控制器,把请求转发到各个组件,并最终返回响应。所以 DispatcherServlet 是 SpringMVC 的核心,负责将请求映射到对应的处理器,并把响应返回给客户端。\",\"： 非常精彩!你通过详细的说明和示意图,让我完全明白了 SpringMVC 的请求处理流程,而且你对每个组件的职责也描述得非常透彻。看来你对 SpringMVC 有很深入的理解,这对一个入门的开发者来说很难得。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"957\":{\"c\":[\"《面试1v1》\"]},\"958\":{\"h\":\"MyBatis\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 恭喜你进到面试的最后一个环节!你对 MyBatis 比较熟悉吗?\",\" 谢谢面试官!MyBatis 是我最喜欢且熟练使用的持久层框架之一。\",\"： 那很好,我们从基础开始问吧。什么是 MyBatis?\",\" MyBatis 是一款优秀的持久层框架,它内部封装了 JDBC,使开发者只需要关注 SQL 语句本身,而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。\",\"： MyBatis 的工作原理能说一下吗?\",\" MyBatis 的工作原理如下:\",\"根据 XML 或注解的配置文件得到映射语句(也就是 SQL)。\",\"把要调用的映射语句的参数传入并解析出 statement 中对应的占位符。\",\"执行映射语句并得到结果。\",\"把结果映射为 Java 对象并返回。\",\"整个过程中最关键的部份是映射文件及映射过程。只有把 SQL 的执行结果映射成 Java 对象,才能达到 ORM 的目的。\",\"： 那它的核心组件有哪些?\",\" MyBatis 的核心组件主要有:\",\"SqlSessionFactoryBuilder:用于创建 SqlSessionFactory,gue有 XML 或注解来配置。\",\"SqlSessionFactory:SqlSession 的工厂,用于创建 SqlSession。\",\"SqlSession:用于执行映射语句并commit、rollback 事务。\",\"Mapper 接口:用于定义映射语句(也就是 SQL),下面会详细解释。\",\"映射文件:包含了映射语句,可以是 XML 或注解。\",\"： 既然你提到了 Mapper 接口,那它是什么?\",\" Mapper 接口是 MyBatis 中非常重要的一个组件。它是由开发人员创建的接口,其中的方法直接对应映射文件中的 SQL 语句。 举个例子:\",\"public interface UserMapper { User selectUser(int id); }\",\"然后在映射文件中:\",\"<select id=\\\"selectUser\\\" resultType=\\\"User\\\"> select * from user where id = #{id} </select>\",\"之后我们可以直接调用:\",\"User user = session.getMapper(UserMapper.class).selectUser(1);\",\"这样直接调用 Mapper 接口的方法就可以执行对应的 SQL 了,很方便。\",\"： 动态 SQL 又是什么?\",\" MyBatis 的动态 SQL 是非常强大的一个功能。它允许开发人员在 XML 映射文件中直接插入一些逻辑,如:\",\"if/else 分支\",\"动态选择部分内容\",\"提取重复代码块\",\"举个例子:\",\"<select id=\\\"findActiveBlogWithTitleLike\\\" resultType=\\\"Blog\\\"> SELECT * FROM BLOG WHERE state = 'ACTIVE' <if test=\\\"title != null\\\"> AND title like #{title} </if> </select>\",\"这里通过 <if> 标签实现了动态条件查询。只有在方法调用时传入了 title 参数,SQL 语句才会添加 title 的条件判断。 这样的动态 SQL 使得数据库交互更加灵活,不需要在程序中进行大量的字符串拼接。\",\"： 最后两个问题,MyBatis 的缓存机制和插件机制能说一下吗?\",\"MyBatis 包含一级缓存和二级缓存。\",\"一级缓存是 SqlSession 级别的缓\",\"一级缓存是 SqlSession 级别的缓存,在同一个 SqlSession 中多次调用同一个 Mapper 的方法,MyBatis 会直接从缓存中获取数据。\",\"二级缓存是 Mapper 级别的缓存,多个 SqlSession 去调用同一个 Mapper 的方法,MyBatis 会先去二级缓存中查找是否有数据,有的话直接返回,没有的话再查询数据库。\",\"MyBatis 的插件机制也很强大。我们可以通过实现 Interceptor 接口来编写插件,用于执行一些增强操作,比如:\",\"分页助手:通过拦截执行的 SQL 语句实现物理分页\",\"监控日志:监控 SQL 执行时间过长等\",\"读写分离:根据方法的注解实现读写分离 举个简单例子:\",\"public class MyFirstPlugin implements Interceptor { @Override public Object intercept(Invocation invocation) throws Throwable { // 调用方法之前 Object result = invocation.proceed(); // 调用方法之后 return result; } }\",\"然后在配置文件中进行配置:\",\"<plugins> <plugin interceptor=\\\"org.mybatis.example.MyFirstPlugin\\\"> <property name=\\\"someProperty\\\" value=\\\"100\\\"/> </plugin> </plugins>\",\"就可以启动对所有 SQL 执行的拦截了。\",\"： MyBatis 的内容我们就先讲到这里,你对它的理解很深入,加油!期待你加入我们团队!\",\" 非常感谢面试官的赏识!我会继续努力学习,不断提高自己。也很期待加入贵团队一起成长!\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"959\":{\"c\":[\"《面试1v1》\"]},\"960\":{\"h\":\"Redis基础\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 来吧,聊聊 Redis,这个 NoSQL 数据库你用过吧?\",\" 用过用过, Redis 是我最喜欢的 NoSQL 数据库,性能超高,用起来特顺手。\",\"： 那你说说Redis有什么优点?\",\" Redis的优点很多:\",\"速度快,是基于内存的数据库,CPU 不是性能瓶颈,读的速度是 110000次/s,写的速度是 81000次/s 。\",\"支持丰富数据类型,不仅仅是 String, 还有 List,Set,Sorted Set,Hash 等等。\",\"持久化,可以将内存中的数据写入磁盘,确保数据的持久性。\",\"简单易用, Redis 只需要6个命令就可以满足基本所有需求,非常易于学习和使用。\",\"高可用, Redis 官方提供了 Sentinel 和 Cluster 两种方案,很容易实现高可用。(哨兵和集群)\",\"： 说的不错,我再问你几个 Redis 的基本命令,来测试一下你的熟练程度。set key value ,这条命令的作用是?\",\"set key value 这个命令的作用是给指定的 key 设置字符串值 value。如果key已经存在,则覆盖原来的值。\",\"例如:\",\"set name \\\"john\\\"\",\"： get key这个命令呢?\",\" get key这个命令用来获取指定key的值。例如:\",\"get name # \\\"john\\\"\",\"： 那setex key seconds value呢?这个命令有什么作用?\",\"setex key seconds value 这个命令用于设置 key 的值为 value,并且设置这个键值对的过期时间为seconds秒。\",\"例如:\",\"setex name 30 \\\"jack\\\" # 设置name的值为\\\"jack\\\",30秒后过期 get name # \\\"jack\\\" # 30秒后 get name # nil,键值对已经过期\",\"： setnx key value又是什么作用?\",\"setnx key value 这个命令只在键 key 不存在时,将其值设置为 value。如果键 key 已经存在,则不做任何操作。这是 \\\"SET if Not eXists\\\" 的简写。\",\"例如:\",\"set name \\\"john\\\" setnx name \\\"jack\\\" # 不做任何操作,name的值保持为\\\"john\\\" setnx age 30 # 设置age值为30,因为age键原来不存在\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"961\":{\"c\":[\"《面试1v1》\"]},\"962\":{\"h\":\"Redis持久化\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： Redis是内存数据库,数据存放在内存中,当Redis服务重启数据会丢失,那么Redis如何保证数据的持久化?\",\" Redis 提供两种持久化方案: RDB(Redis DataBase) 和 AOF(Append Only File)。\",\"： 说说RDB吧,它的工作原理是什么?\",\" RDB 的工作原理很简单,就是在指定的时间间隔内将内存中的数据集快照写入磁盘,恢复时是将快照文件直接读入内存。（简单来说就是快照保存，核心思路是Copy-on-Write。）\",\"触发 RDB 又分为两种， save 和 bgsave\",\"save\",\"当 Redis 实例收到 save 命令后，此时会阻塞当前 Redis 服务器，在 RDB 文件创建完成之前是不能处理其他客户端发送的任何命令请求，如果数据量太大会造成长时间阻塞，期间 redis 无法处理其他请求，线上环境不建议使用。\",\"bgsave\",\"当 Redis 实例收到 bgsave 命令后，Redis 会单独创建(fork)一个子进程来进行持久化,会先将数据写入到一个临时文件中,待持久化过程都结束了,再用这个临时文件替换上次持久化好的文件。 整个过程中,主进程仍然处理客户端请求,这样可以保证 RDB 过程不影响服务。\",\"RDB 的优点是轻量,适合大规模的数据恢复;缺点是数据有一定的丢失风险,持久化的工作并不实时。\",\"： 那AOF又是什么?\",\" AOF 的全称是 Append Only File,它的工作原理是:\",\"将每次执行会改变数据库的命令记录下来,并追加到AOF文件中。AOF文件就是一个命令的记录,Redis重启时会重新执行AOF文件中的命令来恢复数据。\",\"AOF的优点是每次修改都会同步到磁盘,有效防止数据丢失;缺点是AOF rewrite的时候会阻塞客户端查询,并且文件会变得越来越大。\",\"Redis提供了AOF重写机制,可以彻底压缩AOF文件体积,用一条等价的命令代替多条之前的命令。AOF重写也采用fork方式进行,不会影响应用的访问。\",\"： AOF重写的机制原理能详细说下么?\",\" AOF重写的基本流程是:\",\"子进程创建:主进程fork一个子进程,负责重写工作。\",\"子进程载入当前数据库快照,并开始解析AOF文件。\",\"子进程构建新的AOF,仅记录数据库里面和快照不同的键。\",\"子进程完成后,将新构建的AOF发送给主进程。\",\"主进程加载新AOF,替换旧AOF。如果AOF加载失败,继续使用旧AOF。\",\"子进程退出。\",\"该机制可以保证主进程始终可用,不会阻塞客户端请求。新旧AOF文件替换采用原子性rename操作,防止重启时只部分加载新AOF的情况发生。 主要的源码在rewriteAppendOnlyFile方法中:\",\"void rewriteAppendOnlyFile(void) { int fd; char tmpfile[256]; redisDb *db = server.db; /* 创建子进程 */ if (server.child_type == REDIS_CHILD_TYPE_AOF) { ... } /* 载入当前数据库 */ emptyDb(-1); if (rdbSave(tmpfile) != REDIS_OK) { ... } /* 构建新AOF */ fd = open(tmpfile,O_WRONLY|O_APPEND|O_CREAT,0644); /* 将新AOF发送给主进程 */ atomicReplaceFile(server.aof_filename,tmpfile); }\",\"： 讲的很透彻,AOF重写机制我现在全明白了,Redis的持久化方案用的真的很巧妙!\",\" 是的,Redis的RDB和AOF双持久化方案,既保证了数据的持久性,也兼顾了效率。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"963\":{\"c\":[\"《面试1v1》\"]},\"964\":{\"h\":\"Redis主从架构\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： Redis主从架构是什么?它有什么用?\",\" Redis 主从架构就是将一台 Redis 服务器设为主服务器,其他的 Redis 服务器设为从服务器。它的主要用途有:\",\"高可用:当主服务器发生故障时,从服务器可以顶上继续提供服务,实现快速故障迁移。\",\"负载均衡:主服务器处理写请求,从服务器处理读请求,分担服务器压力。\",\"数据冗余:主服务器的数据可以在从服务器中备份,防止数据丢失。\",\"： Redis 主从复制的工作流程是怎样的?\",\" Redis 主从复制的工作流程如下:\",\"首次同步:从服务器连接主服务器,发送 sync 命令,主服务器执行 BGSAVE 生成 RDB 文件并发送给从服务器,从服务器载入 RDB 文件并获得数据集。同时主服务器也发送从服务器连接后产生的写命令给从服务器,使其状态与主服务器一致。\",\"命令传播:主服务器继续接收写命令,并将写命令同步给从服务器。主从服务器保持数据一致。\",\"断线重连:如果从服务器因网络故障与主服务器断开,会自动尝试重连。重连后再次执行同步操作,得到主服务器最新的数据。\",\"主要的工作流程是:同步阶段+命令传播阶段,这两个阶段互相循环,实现主从复制和数据一致性的效果。\",\"： 主从复制的同步工作是如何实现的?能给出源码分析吗?\",\" 主从复制的同步工作是在 replicaofCommand() 方法中实现的:\",\"void replicaofCommand(client *c) { if (server.masterhost == NULL) { //如果是第一次同步 server.master = createClient(NULL); //连接主机 if (server.master == NULL) { addReplyError(c,\\\"Can't connect to MASTER: Connection refused\\\"); return; } /* AUTH with the master if required. */ if (server.masteruser && server.masterauth) { ... } /* Send SYNC and receive BGSAVE response. */ server.replstate = REDIS_REPL_WAIT_BGSAVE_START; serverLog(REDIS_NOTICE,\\\"Waiting BGSAVE from master\\\"); if (syncWithMaster() != REDIS_OK) { // 发送sync命令 freeClient(server.master); server.master = NULL; } } }\",\"同步工作的流程如下:\",\"从服务器连接主服务器,发送 sync 命令。\",\"主服务器接收到 sync 命令,执行 BGSAVE,同时开始缓冲从服务器断开期间产生的写命令。\",\"BGSAVE 完成,主服务器将 RDB 文件发送给从服务器,同时也发送缓冲的写命令。\",\"从服务器得到 RDB 文件后载入,执行写命令,数据同步完成。\",\"这整个同步过程可以保证从服务器快速获取主服务器的数据,也为后续的命令传播阶段奠定基础,主从复制得以顺利进行。\",\"： 主从复制的同步实现,你解释得很详细,我现在全明白了!Redis 的主从架构以及同步原理,你都理解得非常透彻。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"965\":{\"c\":[\"《面试1v1》\"]},\"966\":{\"h\":\"Java范型\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"：小伙子,说实话,泛型这个机制一开始我也是一头雾水,搞不太明白它到底要解决什么问题。你能不能不那么书呆子,给我普普通通地讲一讲泛型?\",\" 好嘞,我们来聊聊泛型。首先,泛型要解决的最主要的问题就是类型不安全。比如说,你有一个箱子,可以装任何东西:\",\"public class Box { private Object obj; public void set(Object obj) { this.obj = obj; } public Object get() { return obj; } }\",\"然后你用它装了一个苹果:\",\"Box b = new Box(); b.set(new Apple());\",\"但是当你取出来的时候,是一个水果啊,你不知道是苹果还是香蕉,需要强转类型:\",\"Apple a = (Apple) b.get(); // 强转,可能出现ClassCastException\",\"这就是类型不安全,一旦强转错了类型,程序就GG了。 泛型来了之后,情况就不一样了。我们可以这样定义箱子:\",\"public class Box<T> { // <T>就是类型参数 private T obj; public void set(T obj) { this.obj = obj; } public T get() { return obj; } }\",\"然后在用的时候,指定T的实际类型,比如:\",\"Box<Apple> b = new Box<Apple>(); b.set(new Apple()); Apple a = b.get(); // 不需要强转,类型安全!\",\"所以泛型最大的好处就是让代码类型安全,不再需要强制类型转换,避免ClassCastException异常,让代码更健壮。它把类型检查的工作从运行时提前到了编译时。\",\"：哇,原来如此!讲解的真的很通俗易懂,我都明白了!那泛型中最容易搞混的两个概念是什么?\",\"：最容易搞混的两个概念,应该是类型参数和实际类型参数吧?\",\" 对的,这两个概念容易混淆。我们再举个例子:\",\"public class Box<T> { // <T>就是类型参数 private T obj; } Box<Apple> b = new Box<>(); // Apple就是实际类型参数\",\"类型参数T是在定义泛型类Box时使用的,代表一个未知的类型。我们不知道使用者会替换成什么类型,所以用T表示。 而实际类型参数Apple是在实例化Box时实际替换类型参数T的类型。它给T一个明确的类型,用于这次实例化。 所以类型参数是个未知的类型占位符,实际类型参数是替换类型参数的具体类型。理解了这两个概念的区别,泛型的很多地方就不会再混淆了。\",\"：说的太好了,我都不好意思问你其他的了!那最后两点疑问,1)为啥泛型类不能有静态方法?2)类型擦除是干嘛的?\",\" 好的,两个很好的疑问: 1)泛型类不能有静态方法的原因是因为静态方法在类加载的时候就被创建,而泛型类在实例化的时候才能确定类型参数的实际类型。这时候静态方法已经创建完了,无法使用这个实际类型,所以编译器不允许这么做。 2)类型擦除就是编译器删除所有与类型参数相关的信息,并替换为上限(通常是Object类型)的过程。因为Java在1.5之前并没有泛型的概念,所以编译器会把所有的泛型类型全部擦除掉,在运行时期间不会存在任何泛型类型的参数信息。这也是为什么泛型类不能有基本类型的参数的原因。 类型擦除有利有弊,好处是可以在1.5之前的VM上运行泛型代码,坏处是导致些许运行期间的效率损失,因为擦除后所有的类型参数都被替换为Object类型。不过这点性能损失在大部分情况下可以忽略。\",\"：太棒了,你的解释简直让人眼前一亮!真的学到很多,谢谢你的精彩讲解!\",\" 谢谢面试官的夸奖,我也在这个过程中对泛型有了更深的理解,非常高兴能与你进行这次交流与探讨。\",\"：在聊了泛型这么多后,还有些细节想问一下:\",\"1. 泛型中<?>和<? extends T>分别代表什么含义?\",\" <?>代表一个未知类型的通配符,可以用在类型参数的位置,表示接受任何类型。比如:\",\"public void print(Box<?> box) { ... }\",\"这个方法可以传递任何类型的Box进来,因为<?>可以匹配任何类型。 而<? extends T>表示从T类型到其子类型之间的某种类型,它代表的上界类型可能是T,也可能是T的子类型。比如:\",\"public void print(Box<? extends Fruit> box) { ... }\",\"这个方法可以传递 Box<Apple> 或者 Box<Orange> 进来,因为 Apple 和 Orange 都是 Fruit 的子类。但不能传 Box<Object> ,因为 Fruit 的子类型不包括 Object。 所以 <?> 表示全类型通配,而 <? extends T> 表示从 T 到子类型的范围内的某种类型,具有上界的语义。\",\"2. 泛型方法和泛型类有什么区别?\",\"泛型方法是在普通类中定义带类型参数的方法,而泛型类是在定义类本身时指定类型参数。比如: 泛型方法:\",\"public class Box { public <T> void print(T t) { ... } }\",\"泛型类:\",\"public class Box<T> { private T t; ... }\",\"主要区别在于泛型类的类型参数可以用在整个类的方法和属性上,而泛型方法的类型参数只在这个方法内有效。泛型方法更灵活,可以在非泛型类上使用。 除此之外,泛型方法可以有 static 修饰符,可以在静态方法内使用类型参数。而泛型类不能有静态方法和静态属性,原因和前面说的类型擦除有关。\",\"3. 泛型的上下限是什么?使用场景又是什么?\",\"泛型的上限是 <? extends T> ,表示从T到子类型的范围;下限是 <? super T>,表示从T到父类型的范围。 上限的使用场景是当需要获取T的子类型对象时,比如从集合中取出元素。下限的使用场景是当需要添加T的父类型对象时,比如往集合中添加元素。\",\"Box<? extends Fruit> box1; // 放入Apple、Orange等 box1.add(new Apple()); // 只能添加Fruit的子类型 Box<? super Fruit> box2; // 放入Fruit、Food等 box2.add(new Food()); // 只能添加Fruit的父类型\",\"所以上下限主要是为了在广泛限制类型的同时,也允许满足某些使用场景的需要,使得泛型更加灵活实用。\",\"：泛型真的有些复杂,但你解释的很通俗易懂,我都差不多明白了。最后两个小问题:\",\"1. 泛型中的边界是干嘛的?\",\"边界是对类型参数指定的约束,目的是限制类型参数能被替换的实际类型。比如,我们可以这样定义一个泛型方法:\",\"public <T extends Number> void print(T t) { System.out.println(t.intValue()); }\",\"这里我们指定T必须是Number或其子类型,如果调用时用String类型替换T,则会编译错误,因为String不符合约束。 边界有两种形式:\",\"类名或者接口名,例如T extends Number,表示 T 必须是 Number 类型或其子类\",\"另一个类型参数,例如 <T, S extends T> ,表示 S 必须是 T 或其子类型 所以边界的作用就是限制类型参数可以替换的实际类型,确保在方法中可以正常使用某些操作,避免因为替换错误类型导致的运行错误。\",\"2. 泛型中通配符 <?> 和无边界的 <?> 有什么区别?\",\"无边界的 <?> 表示任何类型,它没有任何限制,可以理解为 <T>,T可以替换为任何类型。 而 <?> 通配符有些微的区别,它表示“未知类型”,也没有具体的类型边界,但它只能在“读”的场景使用,不能在“写”的场景使用。因为编译器无法确定它到底是哪种类型。\",\"举个例子:\",\"public void print(Box< ?> box) { // 读操作,ok ... } public void add(Box< ?> box, Object o) { // 写操作,编译错误 box.set(o); }\",\"所以无边界的 <?> 可以出现在读和写的操作中,而 <?> 通配符只能在读操作场景使用,这是两者的主要区别。通常在像泛型方法的定义中,使用无边界的 <?> 会更灵活,而在一些读操作的泛型方法中,使用 <?> 通配符可以更广泛的匹配不同的 Box 类型。\",\"：真是一个很细致的区分,我以前也常常搞不清这两者的差别,你的解释让我受益匪浅!谢谢你将这些泛型的概念讲解的如此清晰和深入,我对泛型也有了更全面的认识。真是一个非常愉快的交流过程!\",\" 非常高兴能帮到您!我自己在准备和回答的过程中,也对泛型有了更深刻的理解,这种问答的形式确实是学习的好方法。谢谢面试官的精彩问题,让这个过程变得非常有价值。我也非常欣赏这次交流,收获颇丰,祝面试官有一个美好的一天!\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"967\":{\"c\":[\"《面试1v1》\"]},\"968\":{\"h\":\"Redis分片集群\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，欢迎来到我们的面试！今天我们要聊一聊Redis分片集群，你对这个话题了解多少？\",\" 嗨，谢谢邀请！我对Redis分片集群有一些了解，它是一种将数据分布在多个Redis节点上的方式，以提高性能和可扩展性。\",\"： 很好！那你能给我解释一下Redis分片集群的工作原理吗？\",\" 当然！在Redis分片集群中，数据被分成多个分片，每个分片存储在不同的Redis节点上。当客户端发送一个命令到集群时，集群会根据命令的键值对选择正确的分片，并将命令路由到相应的节点上进行处理。\",\"： 非常棒！那么，如何确定一个键值对应该存储在哪个分片上呢？\",\" 这是一个很好的问题！Redis使用一种称为\\\"哈希槽\\\"的机制来确定键值对应的分片。哈希槽是一个固定数量的槽位，每个槽位对应一个分片。Redis使用CRC16算法对键进行哈希计算，然后将哈希值映射到对应的哈希槽上。\",\"： 哈希槽听起来很有趣！那么，如果我要添加或删除一个节点，会对分片集群有什么影响呢？\",\" 当你添加或删除一个节点时，Redis分片集群会自动进行重新分片。它会根据新的节点数量重新计算哈希槽的分布，并将键值对迁移到新的节点上。这个过程可能会导致一些数据迁移的延迟，但是Redis会尽力保证数据的一致性。\",\"： 好的，那么在一个Redis分片集群中，如果一个节点宕机了，会发生什么？\",\" 如果一个节点宕机了，Redis分片集群会使用一种叫做\\\"主从复制\\\"的机制来保证高可用性。每个分片都有一个主节点和多个从节点，主节点负责处理写操作，而从节点负责复制主节点的数据。当主节点宕机时，集群会自动选举一个从节点作为新的主节点，确保集群的正常运行。\",\"： 太棒了！你对Redis分片集群的理解非常透彻。还有什么你想补充的吗？\",\" 我想强调一点，虽然Redis分片集群可以提高性能和可扩展性，但是在使用它之前，我们需要仔细考虑数据分布、数据迁移和高可用性等方面的问题。此外，我们还可以使用Redis的哨兵机制或者使用Redis Cluster来管理和监控分片集群。\",\"： 太好了！你对Redis分片集群的理解非常全面。非常感谢你的时间和分享！\",\" 非常感谢你的邀请和提问！我很高兴能参加这次面试。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"969\":{\"c\":[\"《面试1v1》\"]},\"970\":{\"h\":\"Redis分布式锁\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，候选人！听说你对Redis分布式锁很感兴趣，是吗？\",\" 是的，面试官！我对分布式锁的实现方式很感兴趣，尤其是Redis作为分布式锁的选择。\",\"： 很好！那我们就来聊聊Redis分布式锁的原理吧。你知道Redis是如何实现分布式锁的吗？\",\" 当然！Redis使用的是基于SETNX命令的方式来实现分布式锁。我可以给你演示一下源码实现吗？\",\"： 当然可以！请开始你的表演。\",\"def acquire_lock(redis_conn, lock_key, lock_value, lock_timeout): if redis_conn.setnx(lock_key, lock_value): redis_conn.expire(lock_key, lock_timeout) return True return False def release_lock(redis_conn, lock_key, lock_value): if redis_conn.get(lock_key) == lock_value: redis_conn.delete(lock_key) return True return False\",\" 这是一个简单的Python代码示例。在acquire_lock函数中，我们使用setnx命令来尝试获取锁。如果成功获取到锁，我们设置锁的过期时间，并返回True。如果获取锁失败，我们返回False。在release_lock函数中，我们首先检查锁的值是否与传入的值相等，如果相等，我们删除锁并返回True，否则返回False。\",\"： 看起来很简单明了！但是，有没有什么需要注意的地方呢？\",\" 当然有！在使用Redis分布式锁时，我们需要注意两个主要问题。首先是锁的超时时间，我们需要确保在业务逻辑执行期间锁不会过期。其次是锁的释放，我们需要确保只有持有锁的客户端才能释放锁，避免误释放。\",\"： 非常重要的提醒！那么，你有什么建议来优化Redis分布式锁的性能吗？\",\" 当然！一个常见的优化方式是使用Lua脚本来减少网络开销。通过将获取锁和设置过期时间的操作合并为一个原子操作，可以减少网络往返次数，提高性能。\",\"： 很棒的建议！还有其他的优化策略吗？\",\" 另一个优化策略是使用Redlock算法来增加锁的可靠性。Redlock算法通过在多个Redis实例上获取锁，以提高分布式锁的可用性和容错性。\",\"： 非常有见地！你对Redis分布式锁的了解令人印象深刻。有没有什么其他问题或者想法？\",\" 我认为在使用Redis分布式锁时，我们还应该考虑到网络延迟和故障的情况，以及如何处理死锁和锁竞争的情况。\",\"： 非常好的观点！你对分布式锁的理解非常全面。我对你的回答印象深刻！谢谢你的时间。\",\" 非常感谢您的赞赏，面试官！我很高兴能与您分享我的见解。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"971\":{\"c\":[\"《面试1v1》\"]},\"972\":{\"h\":\"Redis内存优化\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，小王！今天我们要聊一聊Redis内存优化的话题，你对此有什么了解吗？\",\" 你好，面试官！当然有一些了解。Redis是一个高性能的内存数据库，但是内存是有限的，所以优化内存使用是非常重要的。\",\"： 很好！那你能给我一些关于Redis内存优化的实用技巧吗？\",\" 当然可以！首先，我们可以使用数据结构来减少内存占用。比如，使用Redis的哈希表来存储多个键值对，可以比单独存储每个键值对更节省内存。\",\"： 好主意！还有其他的方法吗？\",\" 当然！我们还可以使用压缩算法来减少存储在Redis中的数据量。Redis支持多种压缩算法，比如LZF和Snappy。通过启用压缩，我们可以在一定程度上减少内存使用。\",\"： 那么，压缩算法会对性能有什么影响吗？\",\" 压缩算法会增加CPU的使用量，因为需要对数据进行压缩和解压缩操作。所以，在选择是否启用压缩时，需要权衡内存和CPU的使用情况。\",\"： 这是一个很好的观点！还有其他的内存优化技巧吗？\",\" 当然！我们还可以使用Redis的过期时间来自动清理不再使用的键值对，以释放内存空间。这样可以确保我们的缓存始终保持在一个合理的大小。\",\"： 那么，如何确定适当的过期时间呢？\",\" 这需要根据你的业务需求来决定。如果你的数据变化频繁，可以设置较短的过期时间，以确保数据的实时性。如果数据变化较少，可以设置较长的过期时间，以减少过期键值对的清理频率。\",\"： 这些都是非常实用的技巧！你还有其他的建议吗？\",\" 当然！我们还可以使用Redis的持久化机制来将数据存储到磁盘上，以释放内存空间。Redis支持两种持久化方式：RDB和AOF。你可以根据你的需求选择适合的方式。\",\"： 好的，这些都是非常有用的建议！谢谢你的分享！\",\" 不客气，我很高兴能够帮助！如果你还有其他关于Redis内存优化的问题，随时问我哦！\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"973\":{\"c\":[\"《面试1v1》\"]},\"974\":{\"h\":\"Kafka基础\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，欢迎来到我们的面试！今天我们要聊一聊Kafka基础。你对Kafka有了解吗？\",\" 嗨！当然有啦，Kafka是一个分布式流处理平台，用于高吞吐量、低延迟的数据传输和处理。它就像是一个强壮的邮递员，可靠地将消息递送给不同的系统。\",\"： 很好！那你能给我解释一下Kafka的消息发布和订阅模型吗？\",\" 没问题！Kafka的消息发布和订阅模型就像是一个咖啡馆。你可以把消息当作咖啡订单，生产者就像是顾客下单，把订单放在柜台上。而消费者就像是咖啡师，从柜台上拿走订单，制作咖啡并提供给顾客。\",\"： 哈哈，这个比喻很形象！那Kafka是如何保证消息的可靠性传输的呢？\",\" 嗯，这就涉及到Kafka的副本机制了。Kafka通过将消息分为多个分区，并在多个Broker上创建副本来实现可靠性。就像是你有一个备份咖啡师，如果一个咖啡师不在，备份咖啡师可以接手制作咖啡，确保订单不会丢失。\",\"： 很好！那如果我想要查看Kafka的源码，你能给我一些指导吗？\",\" 当然！Kafka的源码是开源的，你可以在官方的GitHub仓库上找到。如果你想深入了解Kafka的工作原理，我建议你从kafka-core模块开始阅读源码。你可以找到各种有用的注释和解释，帮助你理解Kafka的内部机制。\",\"： 太棒了！你对Kafka的理解很透彻。最后一个问题，Kafka有哪些常见的使用场景呢？\",\" Kafka的使用场景非常广泛！它可以用于日志收集、实时流处理、事件驱动架构等。比如，你可以使用Kafka来构建一个实时的数据管道，将数据从一个系统传输到另一个系统，或者用于构建实时分析和监控系统。\",\"： 太棒了！你对Kafka的了解非常全面。谢谢你的时间和分享！\",\" 谢谢你的提问，我很享受这次面试！如果还有其他问题，随时告诉我。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"975\":{\"c\":[\"《面试1v1》\"]},\"976\":{\"h\":\"Kafka使用场景\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，候选人！今天我们来聊聊Kafka的使用场景，你对Kafka有了解吗？\",\" 当然！Kafka是一个高吞吐量的分布式消息队列，被广泛应用于大数据处理和实时数据流处理。它可以帮助我们解决各种有趣的问题！\",\"： 太好了！那你能给我举几个Kafka的使用场景吗？\",\" 当然！首先，Kafka非常适合用于日志收集和分析。你知道吗，很多公司都有海量的日志数据，而Kafka可以帮助我们高效地收集、存储和分发这些日志数据。它就像是一个日志的快递小哥，把日志从各个系统搬运到我们的数据湖中。\",\"： 哈哈，快递小哥！这个比喻很形象！还有其他的使用场景吗？\",\" 当然！另一个常见的使用场景是实时数据流处理。你知道吗，有些应用需要实时地处理大量的数据流，比如实时监控、实时分析等。而Kafka可以作为数据流的中转站，把数据流传输给各个处理节点，让它们实时地进行计算和分析。就像是一个数据流的管家，把数据送到各个需要的地方。\",\"： 嗯，管家的形象也很贴切！还有其他的使用场景吗？\",\" 当然！Kafka还可以用于构建事件驱动的架构。你知道吗，有些应用需要根据事件来触发相应的操作，比如订单支付成功后触发发货操作。而Kafka可以作为事件的中心枢纽，把事件发送给各个订阅者，让它们根据事件来做出相应的响应。就像是一个事件的调度员，把事件通知给各个关心的人。\",\"： 哈哈，调度员！你的比喻真是越来越有意思了！Kafka的使用场景确实非常丰富多样，你的回答很棒！\",\" 谢谢夸奖！我觉得Kafka就像是一个多面手，可以在各种场景下发挥作用。它的高吞吐量、可靠性和可扩展性让它成为了很多公司的首选。\",\"： 没错！Kafka的确是一个非常强大的工具。你对Kafka的理解很深入，我对你的回答非常满意！\",\" 谢谢夸奖！我对Kafka的热爱让我对它的使用场景有了更深入的了解。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"977\":{\"c\":[\"《面试1v1》\"]},\"978\":{\"h\":\"Kafka优缺点\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嘿，候选人，你知道Kafka有哪些优点吗？\",\" 当然知道！Kafka有很多优点。首先，它是一个高吞吐量的分布式消息系统，可以处理大量的数据流。这对于处理实时数据和大规模应用非常有用。\",\"： 没错！Kafka的高性能确实让人印象深刻。还有其他的优点吗？\",\" 当然！Kafka具有良好的可扩展性和可靠性。它可以轻松地扩展到成百上千台服务器，而且即使在节点故障的情况下，数据也不会丢失。这对于构建可靠的数据管道非常重要。\",\"： 确实，可扩展性和可靠性是Kafka的强项。还有其他的优点吗？\",\" 当然还有！Kafka提供了灵活的消息传递模型，支持多种消息发布和订阅模式。它还具有持久性存储和消息回溯的能力，这对于数据分析和故障排除非常有帮助。\",\"： 嗯，Kafka的灵活性和持久性确实让它在数据处理领域脱颖而出。还有其他的优点吗？\",\" 最后，Kafka有一个活跃的社区和丰富的生态系统。这意味着你可以轻松地找到各种工具和插件来扩展和定制你的Kafka部署。\",\"： 太棒了！Kafka的优点真是让人眼花缭乱。那么，我们来看看它的缺点吧。\",\"： 候选人，你认为Kafka有哪些缺点呢？\",\" 嗯，Kafka并不是适合所有场景的银弹。首先，它的部署和配置可能会有一些复杂性。特别是对于新手来说，可能需要一些时间来理解和掌握。\",\"： 是的，Kafka的配置确实需要一些技术功底。还有其他的缺点吗？\",\" 另一个缺点是Kafka对磁盘的使用比较高。由于它的持久性存储和消息回溯的特性，它需要大量的磁盘空间来存储消息。这可能会增加硬件成本。\",\"： 嗯，磁盘使用是一个需要考虑的因素。还有其他的缺点吗？\",\" 最后，Kafka在一些特定的使用情况下可能会有一些性能瓶颈。例如，当消息的顺序性很重要时，Kafka的分区机制可能会导致一些延迟。\",\"： 好的，这些是Kafka的一些缺点。但总体来说，它的优点还是非常突出的。\",\"： 没错！Kafka作为一个高吞吐量、可扩展、可靠的分布式消息系统，具有灵活的消息传递模型和持久性存储的能力。虽然它的部署和配置可能有些复杂，而且对磁盘的使用较高，但它的优点远远超过了缺点。\",\" 是的，Kafka在处理实时数据和构建可靠的数据管道方面非常强大。它的活跃社区和丰富的生态系统也为开发者提供了很多便利。\",\"： 没错！对于刚入行的技术人员来说，学习和掌握Kafka将是一个很好的选择。它不仅能够提升你的技术能力，还能为你的职业发展打下坚实的基础。\",\" 没错！Kafka的优点和缺点都值得我们深入了解和探讨。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"979\":{\"c\":[\"《面试1v1》\"]},\"980\":{\"h\":\"Kafka性能好在哪里\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，欢迎来到我们的面试！今天我们要聊聊Kafka的性能。你对Kafka有了解吗？\",\" 当然！Kafka是一个高吞吐量、低延迟的分布式消息队列，被广泛应用于大规模数据处理和实时流处理场景。\",\"： 很好！那你能给我解释一下Kafka的性能是如何实现的吗？\",\" 当然！Kafka的高性能得益于它的设计理念和架构。首先，Kafka采用了分布式的消息存储和复制机制，使得它可以处理大量的消息并保证数据的可靠性。此外，Kafka还利用了磁盘顺序写和零拷贝技术，提高了数据的写入和读取效率。\",\"： 很棒！你能给我举个例子来说明Kafka的性能吗？\",\" 当然！想象一下，你有一个应用程序需要处理大量的日志数据。使用Kafka，你可以将这些日志数据发送到一个主题（Topic）中，然后多个消费者可以并行地从这个主题中读取数据进行处理。这种并行处理的方式使得Kafka能够轻松应对高并发的场景，提供出色的性能。\",\"： 非常好！那你能给我解释一下Kafka的消息传递机制吗？\",\" 当然！Kafka的消息传递机制基于发布-订阅模式。生产者将消息发送到一个或多个主题，而消费者则订阅这些主题并从中读取消息。Kafka保证了消息的顺序性和可靠性，同时还支持消息的批量处理和压缩，进一步提高了性能和效率。\",\"： 很好！你对Kafka的性能优化有什么建议吗？\",\" 当然！首先，我们可以通过增加分区（Partition）的数量来提高Kafka的吞吐量。此外，合理配置Kafka的参数，如调整副本（Replica）的数量和消息的批处理大小，也可以对性能进行优化。另外，我们还可以使用Kafka的监控工具来实时监测和调整Kafka集群的性能。\",\"： 太棒了！你对Kafka的性能有了很好的理解。有没有什么其他的问题你想问我的？\",\" 是的！我想知道Kafka的消费者是如何处理消息的失败和重试的？\",\"： 好问题！Kafka的消费者可以通过设置适当的参数来控制消息的提交和重试机制。如果消费者在处理消息时发生错误，它可以选择将消息标记为已处理或者进行重试。此外，Kafka还提供了消费者组（Consumer Group）的概念，可以实现消息的负载均衡和故障恢复。\",\" 非常感谢您的解答！这次面试对我来说非常有意义。\",\"： 不客气！你的回答非常出色，对Kafka的性能有了深入的理解。祝你在未来的工作中取得更大的成功！\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"981\":{\"c\":[\"《面试1v1》\"]},\"982\":{\"h\":\"如何提高远程用户吞吐量\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，候选人！听说你对 Kafka 吞吐量有一些见解？\",\" 嗨，面试官！是的，我对这个话题有一些想法。你知道吗，Kafka 是一个强大的分布式消息系统，但是在处理远程用户时，我们需要一些技巧来提高吞吐量。\",\"： 哦，真的吗？那你能给我一些具体的例子吗？\",\" 当然！一个简单的方法是通过调整 Kafka 的一些配置参数来提高吞吐量。比如，我们可以增加 fetch.max.bytes 参数的值，这样可以一次性获取更多的数据，减少网络传输的开销。\",\"// 下面是一段示例代码，展示如何调整 `fetch.max.bytes` 参数 // 设置 `fetch.max.bytes` 参数为 10MB props.put(\\\"fetch.max.bytes\\\", \\\"10485760\\\");\",\"： 哇，这个方法听起来很简单有效！还有其他的方法吗？\",\" 当然！另一个方法是使用批量发送消息的方式来提高吞吐量。我们可以将多个消息打包成一个批次，然后一次性发送给 Kafka。这样可以减少网络传输的次数，提高效率。\",\"// 下面是一段示例代码，展示如何使用批量发送消息 // 创建一个 ProducerRecord 的列表 List<ProducerRecord<String, String>> records = new ArrayList<>(); records.add(new ProducerRecord<>(\\\"topic\\\", \\\"key1\\\", \\\"value1\\\")); records.add(new ProducerRecord<>(\\\"topic\\\", \\\"key2\\\", \\\"value2\\\")); records.add(new ProducerRecord<>(\\\"topic\\\", \\\"key3\\\", \\\"value3\\\")); // 批量发送消息 producer.send(records);\",\"： 这个批量发送消息的方法听起来很实用！还有没有其他的技巧？\",\" 当然还有！我们还可以通过增加分区数来提高吞吐量。每个分区都可以并行处理消息，增加分区数可以增加并行处理的能力，从而提高整体吞吐量。\",\"// 下面是一段示例代码，展示如何增加分区数 // 创建一个新的 topic，并设置分区数为 10 NewTopic newTopic = new NewTopic(\\\"topic\\\", 10, (short) 1); adminClient.createTopics(Collections.singleton(newTopic));\",\"： 哇，这个方法听起来很厉害！有没有其他的建议？\",\" 当然！除了上述方法，我们还可以考虑优化消费者的配置，比如增加 max.poll.records 参数的值，这样可以一次性获取更多的消息，提高消费者的处理能力。\",\"// 下面是一段示例代码，展示如何增加 `max.poll.records` 参数的值 // 设置 `max.poll.records` 参数为 100 props.put(\\\"max.poll.records\\\", \\\"100\\\");\",\"： 太棒了！你给出的这些方法都很实用。谢谢你的分享！\",\" 不客气，我很高兴能与你分享这些方法。希望这些技巧能帮助你提高 Kafka 的远程用户吞吐量。如果你还有其他问题，我随时都可以回答！\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"983\":{\"c\":[\"《面试1v1》\"]},\"984\":{\"h\":\"如果从Kafka得到准确消息\",\"t\":[\"面试官：嗨，小伙子，听说你对Kafka很感兴趣，那你能告诉我，从Kafka中获取准确的信息有什么要注意的地方吗？\",\"候选人：当然！要从Kafka中获取准确的信息，首先我们需要了解Kafka的工作原理。Kafka是一个分布式的消息队列，它将消息以topic的形式进行组织和存储。每个topic可以有多个分区，而每个分区又可以有多个副本。这种分布式的架构使得Kafka具备了高可用性和高吞吐量的特点。\",\"面试官：嗯，不错！那你能告诉我，如何从Kafka中消费消息呢？\",\"候选人：当然！要消费Kafka中的消息，我们需要创建一个消费者。消费者可以订阅一个或多个topic，并从每个分区中拉取消息。这里有一个简单的Java代码示例，让我们来看一下：\",\"import org.apache.kafka.clients.consumer.ConsumerRecords; import org.apache.kafka.clients.consumer.KafkaConsumer; import org.apache.kafka.common.TopicPartition; import java.util.Collections; import java.util.Properties; public class KafkaConsumerExample { public static void main(String[] args) { Properties props = new Properties(); props.put(\\\"bootstrap.servers\\\", \\\"localhost:9092\\\"); props.put(\\\"group.id\\\", \\\"my-consumer-group\\\"); props.put(\\\"key.deserializer\\\", \\\"org.apache.kafka.common.serialization.StringDeserializer\\\"); props.put(\\\"value.deserializer\\\", \\\"org.apache.kafka.common.serialization.StringDeserializer\\\"); KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props); consumer.subscribe(Collections.singletonList(\\\"my-javapub-topic\\\")); while (true) { ConsumerRecords<String, String> records = consumer.poll(100); for (ConsumerRecord<String, String> record : records) { System.out.println(\\\"Received message: \\\" + record.value()); } } } }\",\"面试官：哇，你真是个天才！这段代码看起来很简单明了。但是，如何确保我们从Kafka中获取的信息是准确的呢？\",\"候选人：嗯，这是个好问题！要确保从Kafka中获取的信息是准确的，我们可以采取一些措施。首先，我们可以使用Kafka的消息确认机制。在消费者消费消息后，可以向Kafka发送确认消息，告诉Kafka这条消息已经被成功消费。这样，Kafka就会将该消息标记为已消费，避免重复消费。\",\"另外，我们还可以使用Kafka的偏移量（offset）来确保消息的顺序性。每个分区都有一个唯一的偏移量，表示消息在该分区中的位置。我们可以记录每个分区的偏移量，并在消费消息时按照偏移量的顺序进行消费，这样就能保证消息的顺序性。\",\"面试官：太棒了！你对Kafka的理解真是深入透彻。有没有其他的建议或技巧可以分享给我们呢？\",\"候选人：当然！除了上述的措施外，还有一些其他的建议。首先，我们可以使用Kafka的监控工具来实时监控Kafka集群的状态和性能指标。这样，我们可以及时发现并解决潜在的问题，确保系统的稳定性和可靠性。\",\"另外，我们还可以使用Kafka的分区机制来实现消息的负载均衡。通过合理地设置分区数和副本数，可以将消息均匀地分布在不同的节点上，提高系统的并发处理能力。\",\"面试官：太棒了！你的回答非常详细，我对你的理解和表达能力印象深刻。谢谢你的分享！\",\"候选人：非常感谢您的夸奖！我很高兴能与您分享我的知识。如果您还有其他关于Kafka或其他技术的问题，请随时提问，我会尽力帮助您。\"]},\"985\":{\"c\":[\"《面试1v1》\"]},\"986\":{\"h\":\"Kafka架构设计\",\"t\":[\"面试官： 嗨，小明！听说你对Kafka的架构设计很感兴趣，是吗？\",\"候选人： 是的，我一直对Kafka很好奇。它是如何处理大规模数据流的呢？\",\"面试官： 哈哈，没错！Kafka是一个强大的分布式流处理平台。它的架构设计非常有趣，我们来一起探索一下吧！\",\"候选人： 太好了！我迫不及待想了解更多。\",\"面试官： 那我们先从Kafka的基本概念开始吧。Kafka有四个核心组件：Producer（生产者）、Consumer（消费者）、Topic（主题）和Broker（代理）。\",\"候选人： 好的，这些概念我都知道。Producer负责将消息发送到Kafka集群，Consumer从集群中读取消息，Topic是消息的类别，而Broker则是消息的存储和传输中心。\",\"面试官： 没错！Kafka的架构设计非常简洁明了。现在，让我们深入了解一下Broker的内部结构。\",\"// 这是Kafka Broker的源码，我们来看一下它是如何工作的 public class KafkaBroker { private List<TopicPartition> partitions; public void receiveMessage(Message message) { // 接收消息的逻辑 // ... } public void sendMessage(Message message) { // 发送消息的逻辑 // ... } // 更多方法... }\",\"候选人： 哇，你真的写了一段Kafka Broker的源码！看起来很简单。\",\"面试官： 是的，这只是一个简化的示例，但它展示了Broker的基本工作原理。当Producer发送消息时，Broker会接收并存储消息。而当Consumer请求消息时，Broker会将消息发送给Consumer。\",\"候选人： 这听起来很直观。那么，Kafka是如何实现高吞吐量和可伸缩性的呢？\",\"面试官： 很好的问题！Kafka通过分区（Partition）和副本（Replication）来实现高吞吐量和可伸缩性。\",\"候选人： 分区和副本？能给我解释一下吗？\",\"面试官： 当然！分区是将Topic分成多个较小的部分，每个分区都有一个Leader和多个Follower副本。Leader负责处理读写请求，而Follower副本则用于备份和提供冗余。\",\"候选人： 这样一来，每个分区都可以独立地处理读写请求，对吗？\",\"面试官： 没错！这就是为什么Kafka能够实现高吞吐量和可伸缩性的原因之一。通过将Topic分成多个分区，Kafka可以并行处理大量的消息。\",\"候选人： 那么，如果Leader副本出现故障怎么办？\",\"面试官： 很好的问题！Kafka使用ZooKeeper来管理分区和副本的状态。当Leader副本发生故障时，ZooKeeper会自动选举一个新的Leader副本。\",\"候选人： 这样就能保证高可用性了！\",\"面试官： 没错！Kafka的架构设计非常注重可靠性和容错性。它能够自动处理故障，并保证消息的可靠传递。\",\"候选人： 太棒了！我对Kafka的架构设计有了更深入的了解。谢谢你的解答！\",\"面试官： 不客气！如果你还有其他问题，随时问我。记住，Kafka是一个非常强大的工具，它在大数据处理和实时流处理方面有着广泛的应用。\"]},\"987\":{\"c\":[\"《面试1v1》\"]},\"988\":{\"h\":\"Java多线程\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 说说你对多线程的理解?\",\" 多线程就是同时运行多个线程,实现一件事的并行处理。比如开个程序,同时下载多个文件,同时处理多个客户端请求等等。 ：那什么是线程安全的?举个例子?\",\" 线程安全就是多个线程访问同一个对象或调用同一方法时,对象或方法内部的状态能保证正确。举个例子,String 是线程安全的,因为 String 内部的 char 数组是final的,不可变的。\",\"public final class String { private final char value[]; }\",\"：ArrayList线程安全吗?\",\" ArrayList 不是线程安全的,因为:\",\"transient Object[] elementData; // elementData 可以改变\",\"如果多个线程同时访问一个 ArrayList,其中一个线程正在扩容数组,这时另一个线程在读或添加元素,很可能引起空指针或者越界异常。 ：HashMap 呢?线程安全吗?\",\" HashMap 也不是线程安全的,跟 ArrayList 一样,HashMap 在多线程下也可能产生死循环、数据丢失等问题。因为:\",\"transient Node<K,V>[] table;\",\"并发情况下,比如两个线程同时 put 新键值对,都重新扩容了数组,都做旧数组到新数组的迁移工作,这就会产生数据丢失的问题。 ：那如何解决 HashMap 的线程安全问题?\",\" 有几种常见的解决HashMap线程不安全的方法:\",\"Collections.synchronizedMap():返回一个线程安全的 HashMap,内部使用锁机制同步访问 HashMap。\",\"ConcurrentHashMap:Java 7 发布的线程安全的 HashMap。内部使用锁分段技术实现线程安全,并发度很高。\",\"Hashtable:Hashtable 是遗留的线程安全 HashMap,内部也使用同一把锁,并发度低。不推荐使用。\",\"外包装:可以使用 Lock 或者 synchronized 关键字对 HashMap 进行外包装,实现线程安全。\",\"：谢谢,内容很详细!总结一下,线程安全对我们来说很重要,在编写代码时要时刻考虑清楚。\",\" 是的,总结如下:\",\"多线程环境下,需谨慎使用非线程安全的类。如 ArrayList、HashMap。\",\"尽量选择Java提供的线程安全类,如String、ConcurrentHashMap。\",\"如果必须使用非线程安全的类,需要对其进行额外的同步措施,如加锁或者使用同步包装类。\",\"在编写代码时,要时刻考虑对象或方法的状态是否在多线程下也能保持一致和正确。这就是我们提到的“线程安全”。 多谢面试官的提问,让我对Java多线程和线程安全有一个比较全面和系统的复习,这些内容对我以后的学习和工作会很有帮助。\",\"： 说说 wait() notify() notifyAll() 的区别?\",\" 这三个方法都是用来协调线程间通信的。区别如下:\",\"wait():让当前线程等待,直到其他线程调用 notify() 方法通知,或经过指定的时间后重新等待。\",\"notify():唤醒等待在此对象上的一个线程。如果有多个线程等待,则唤醒优先级最高的线程。\",\"notifyAll():唤醒等待在此对象上的所有线程。\",\"：举个例子解释下?\",\" 这里是一个经典的生产者消费者模型来解释这三个方法:\",\"public class ProducerConsumer { private int product = 0; private boolean isProduced = false; public synchronized void produce() { // 等待,直到产品被消费 while (isProduced) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 生产产品 product++; isProduced = true; // 通知消费者消费产品 notifyAll(); } public synchronized void consume() { // 等待,直到有产品生产 while (!isProduced) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 消费产品 product--; isProduced = false; // 通知生产者生产产品 notifyAll(); } }\",\"这里 wait() 方法使生产线程和消费线程在产品未就绪时等待,notifyAll() 方法在产品就绪时唤醒等待线程。\",\"：sleep() 方法和 wait() 方法有什么区别?\",\" sleep() 和 wait() 的主要区别在于:\",\"wait() 方法释放锁,sleep() 方法不释放锁。\",\"wait() 方法通常被用于线程间通信,sleep() 方法用于暂停线程指定时间。\",\"wait() 方法可以在没有指定时间的情况下一直等待,sleep() 方法必须指定等待时间。\",\"wait() 方法被唤醒后必须重新获取锁,sleep() 方法睡醒后直接继续执行。 所以简单来说:wait() 可以用于线程间的同步,sleep() 主要用于暂停线程指定时间。\",\"：完美!谢谢你,这些知识点解释的很透彻。\",\" 不客气,多谢面试官的提问,让我对 wait() notify() notifyAll() 以及它们与 sleep() 的区别有了更深的理解,这些都是非常重要的多线程知识点,我会继续加深理解并运用的!\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"989\":{\"c\":[\"《面试1v1》\"]},\"990\":{\"h\":\"Kafka消息采用pull还是push\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，候选人！你知道Kafka消息系统是如何工作的吗？\",\" 嗨，面试官！当然知道！Kafka是一个高吞吐量的分布式消息系统，它采用了Push和Pull的结合方式来实现消息传递。\",\"： 哦，那你能具体解释一下Kafka的Push和Pull模式吗？\",\" 当然可以！在Kafka中，生产者（Producer）负责将消息推送（Push）到Kafka的Broker节点，而消费者（Consumer）则从Broker节点拉取（Pull）消息进行处理。\",\"： 很好！那你能给我们看一段简单的代码来说明这个过程吗？\",\" 当然可以！让我给你展示一段Java代码来说明Kafka的Push和Pull模式：\",\"import org.apache.kafka.clients.producer.*; import org.apache.kafka.clients.consumer.*; import org.apache.kafka.common.serialization.StringDeserializer; import org.apache.kafka.common.serialization.StringSerializer; import java.util.Properties; public class KafkaDemo { private static final String TOPIC = \\\"my_topic\\\"; private static final String BOOTSTRAP_SERVERS = \\\"localhost:9092\\\"; public static void main(String[] args) { // 生产者代码 Properties producerProps = new Properties(); producerProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, BOOTSTRAP_SERVERS); producerProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName()); producerProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName()); Producer<String, String> producer = new KafkaProducer<>(producerProps); producer.send(new ProducerRecord<>(TOPIC, \\\"Hello Kafka!\\\")); // 消费者代码 Properties consumerProps = new Properties(); consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, BOOTSTRAP_SERVERS); consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, \\\"my_consumer_group\\\"); consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName()); consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName()); Consumer<String, String> consumer = new KafkaConsumer<>(consumerProps); consumer.subscribe(Collections.singleton(TOPIC)); ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(1000)); for (ConsumerRecord<String, String> record : records) { System.out.println(\\\"Received message: \\\" + record.value()); } } }\",\"： 太棒了！这段代码很好地展示了Kafka的Push和Pull模式。那么，你能解释一下代码中的关键部分吗？\",\" 当然可以！在生产者部分，我们配置了Kafka的地址和序列化器，并使用producer.send()方法将消息推送到名为my_topic的主题中。而在消费者部分，我们配置了Kafka的地址、消费者组ID和反序列化器，并使用consumer.poll()方法从主题中拉取消息，然后进行处理。\",\"： 非常清晰明了！你对Kafka的Push和Pull模式有很好的理解。有没有什么需要注意的地方呢？\",\" 当然有！在使用Kafka的Push模式时，生产者需要确保消息能够成功推送到Broker节点，而在使用Pull模式时，消费者需要定期拉取消息以确保不会错过任何重要的数据。\",\"： 非常好！你对Kafka的Push和Pull模式的理解非常到位。谢谢你的回答！\",\" 非常感谢！我很高兴能够分享我的知识。如果还有其他关于Kafka或者任何其他技术的问题，我都会尽力帮助解答！\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"991\":{\"c\":[\"《面试1v1》\"]},\"992\":{\"h\":\"Kafka与传统消息系统区别\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 传统消息系统是怎么工作的？\",\" 传统消息系统通常采用点对点或发布-订阅模式来传递消息。发送者将消息发送到一个中间件（比如ActiveMQ或RabbitMQ），然后接收者从中间件中接收消息。\",\"： 没错！传统消息系统使用中间件作为消息的中转站。那么，Kafka和传统消息系统有什么不同呢？\",\" Kafka是一个分布式流处理平台，它以高吞吐量和低延迟而闻名。与传统消息系统不同，Kafka将消息存储在持久化的日志中，而不是立即将其传递给接收者。\",\"： 很好！Kafka的这种设计使得它具有很高的可伸缩性和容错性。那么，你能给我举个例子来说明Kafka的工作原理吗？\",\" 当然可以！假设我们有一个简单的消息队列，其中有三个分区（Partition）：P1、P2和P3。发送者将消息M1发送到P1，消息M2发送到P2，消息M3发送到P3。接收者可以从这些分区中读取消息。\",\"// 这是Kafka的源码示例，让我们来看看它是如何工作的 // 创建一个生产者 Producer producer = new Producer(); // 发送消息到分区P1 producer.send(\\\"P1\\\", \\\"M1\\\"); // 发送消息到分区P2 producer.send(\\\"P2\\\", \\\"M2\\\"); // 发送消息到分区P3 producer.send(\\\"P3\\\", \\\"M3\\\"); // 创建一个消费者 Consumer consumer = new Consumer(); // 从分区P1读取消息 String message1 = consumer.consume(\\\"P1\\\"); // 从分区P2读取消息 String message2 = consumer.consume(\\\"P2\\\"); // 从分区P3读取消息 String message3 = consumer.consume(\\\"P3\\\");\",\"： 太棒了！你用代码很好地解释了Kafka的工作原理。那么，Kafka还有哪些特点？\",\" Kafka具有高度可扩展性，可以轻松地处理大量的消息和高并发。此外，Kafka还支持消息的持久化存储和数据复制，确保消息的可靠性和容错性。\",\"： 没错！Kafka的这些特点使得它成为处理实时数据流的理想选择。它在大数据领域中得到了广泛的应用。你觉得Kafka和传统消息系统相比，有什么优势呢？\",\" Kafka相比传统消息系统有几个明显的优势。首先，Kafka的高吞吐量和低延迟使得它能够处理大规模的数据流。其次，Kafka的持久化存储和数据复制功能确保了消息的可靠性和容错性。最后，Kafka的可扩展性使得它能够适应不断增长的数据需求。\",\"： 非常好！你对Kafka和传统消息系统的区别有很清晰的认识。这些知识对于刚入行的技术人员来说非常重要。有没有什么问题想问我的？\",\" 我想知道Kafka在实际应用中的一些最佳实践和常见问题解答。\",\"： 太好了！这正是我们下一次面试的话题。我们可以深入探讨Kafka的最佳实践和解决方案。感谢你的时间，你对Kafka的理解非常出色！\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"993\":{\"c\":[\"《面试1v1》\"]},\"994\":{\"h\":\"Kafka的ack机制\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，小王！听说你对Kafka的ack机制很感兴趣，是吗？\",\" 是的，王哥！我一直想了解一下Kafka的ack机制是怎么回事。\",\"： 好问题！那么，你知道Kafka的ack机制是用来做什么的吗？\",\" 嗯，我知道它是用来确保消息的可靠性传递的。但是具体怎么实现的呢？\",\"： 很好！简单来说，Kafka的ack机制是通过生产者和消费者之间的协作来实现的。当生产者发送消息到Kafka集群时，它可以选择等待消息被确认（ack）后再发送下一条消息，或者直接发送下一条消息而不等待确认。\",\" 那么，等待确认和不等待确认有什么区别呢？\",\"： 哈哈，这就像是你在餐厅点菜的时候的两种方式。如果你等待服务员确认你的点菜后再点下一道菜，那么你可以确保每道菜都被正确记录下来。但是如果你不等待确认，直接点下一道菜，那么可能会出现点菜遗漏的情况。\",\" 哦，我明白了！那么，Kafka是如何实现这个机制的呢？\",\"： 很聪明的问题！在Kafka中，生产者发送消息时，可以设置消息的确认级别（ack level）。有三个级别可供选择：0、1和all。当设置为0时，生产者不会等待任何确认，直接发送下一条消息。当设置为1时，生产者会等待消息被Kafka集群的leader确认后再发送下一条消息。而当设置为all时，生产者会等待消息被所有的副本（replica）确认后再发送下一条消息。\",\" 哇，这么灵活！那么，如果消息没有被确认怎么办？\",\"： 如果消息没有被确认，Kafka会自动进行重试，直到达到最大重试次数。如果仍然没有成功，那么生产者可以选择放弃发送或者采取其他措施，比如记录日志或者通知管理员。\",\" 哦，原来如此！那么，这个机制对于我在实际工作中有什么帮助呢？\",\"： 嗯，这个机制可以确保你的消息在传递过程中不会丢失。尤其是在一些对消息可靠性要求较高的场景下，比如金融交易或者实时监控系统，这个机制非常重要。\",\" 大师傅，谢谢你的解答！我对Kafka的ack机制有了更清晰的理解了。\",\"： 不客气，小明！记住，Kafka的ack机制是确保消息可靠性的关键。在你的工作中，要根据实际需求选择合适的确认级别，并且合理处理未确认的消息。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"995\":{\"c\":[\"《面试1v1》\"]},\"996\":{\"h\":\"Kafka的幂等性\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，小明！听说你对Kafka的幂等性很感兴趣，是吗？\",\" 是的，我一直听说Kafka的幂等性很重要，但是具体是什么意思呢？\",\"： 哈哈，别担心，我来给你解释一下。幂等性其实就是指无论执行多少次相同的操作，结果都是一样的。在Kafka中，幂等性保证了消息的处理不会因为重复发送而产生副作用。\",\" 哦，明白了！那Kafka是怎么实现幂等性的呢？\",\"： 很好的问题！Kafka通过消息的唯一标识（通常是消息的key）来实现幂等性。在发送消息之前，Kafka会检查消息的key是否已经存在于特定的主题分区中。如果存在，Kafka就会认为这是一条重复的消息，并且不会将其写入分区。\",\" 那如果我想要发送相同的消息，但是又希望它们被写入分区怎么办呢？\",\"： 好问题！为了解决这个问题，Kafka引入了幂等性序列号（Idempotent Sequence Number）。每个生产者都会生成一个唯一的序列号，并将其附加到消息中。Kafka会使用这个序列号来判断消息的唯一性，而不是仅仅依赖于消息的key。这样，即使发送相同的消息，只要序列号不同，Kafka仍然会将其写入分区。\",\" 哇，这个设计真巧妙！那Kafka是如何保证幂等性的呢？\",\"： 很好奇心！Kafka使用了一种叫做\\\"幂等性写入\\\"的机制。当生产者发送消息时，Kafka会为每个分区维护一个递增的序列号。在写入消息之前，Kafka会检查消息的序列号是否大于分区中最后一条消息的序列号。如果是，Kafka会将消息写入分区，并更新序列号；如果不是，Kafka会认为这是一条重复的消息，并且不会写入分区。\",\" 哇，这样一来，就能保证消息不会被重复写入了！Kafka真是个聪明的家伙！\",\"： 是的，Kafka的设计确实很巧妙。通过幂等性的机制，Kafka能够保证消息的可靠性和一致性，让我们在处理大规模数据流时更加放心。\",\" 面试官，谢谢你的解答！我对Kafka的幂等性有了更深入的理解。\",\"： 不客气，小明！如果你还有其他关于Kafka或者其他技术的问题，随时都可以问我。记得在学习和工作中保持好奇心，不断探索新的知识和技术！\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"997\":{\"c\":[\"《面试1v1》\"]},\"998\":{\"h\":\"Elasticsearch基础\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，欢迎来到我们的面试！今天我们要聊一聊ElasticSearch基础知识。你对ElasticSearch有了解吗？\",\" 当然！ElasticSearch是一个开源的分布式搜索和分析引擎，它可以帮助我们快速地存储、搜索和分析海量数据。简单来说，就是个大数据的搜索神器！\",\"： 哈哈，没错！那你能给我解释一下ElasticSearch的核心概念吗？\",\" 当然！ElasticSearch的核心概念包括索引（Index）、类型（Type）、文档（Document）和映射（Mapping）。索引就像是数据库中的表，类型就像是表中的记录类型，文档就是具体的记录，而映射则定义了文档的结构和字段类型。\",\"： 很好！那你能给我演示一下如何创建一个索引并插入文档吗？\",\" 当然！让我给你展示一下：\",\"PUT /my_index { \\\"mappings\\\": { \\\"properties\\\": { \\\"title\\\": { \\\"type\\\": \\\"text\\\" }, \\\"content\\\": { \\\"type\\\": \\\"text\\\" }, \\\"timestamp\\\": { \\\"type\\\": \\\"date\\\" } } } } POST /my_index/_doc/1 { \\\"title\\\": \\\"Hello ElasticSearch\\\", \\\"content\\\": \\\"ElasticSearch真是太棒了！\\\", \\\"timestamp\\\": \\\"2023-07-27\\\" }\",\"： 太棒了！你刚刚创建了一个名为\\\"my_index\\\"的索引，并插入了一篇文档。那如何进行搜索呢？\",\" 搜索非常简单！我们可以使用查询语句来进行搜索，比如这样：\",\"GET /my_index/_search { \\\"query\\\": { \\\"match\\\": { \\\"content\\\": \\\"棒\\\" } } }\",\"这个查询会返回所有内容中包含\\\"棒\\\"的文档。\",\"： 太棒了！你真是个ElasticSearch小能手！还有什么其他有趣的事情你想分享吗？\",\" 当然！除了基本的搜索功能，ElasticSearch还支持聚合、分析、地理位置搜索等高级功能。而且它还可以与Kibana等工具结合使用，进行数据可视化和监控。总之，ElasticSearch是个非常强大且灵活的工具，对于处理大数据和构建搜索引擎来说，简直是必备利器！\",\"： 太棒了！你对ElasticSearch的理解非常透彻，我对你的表现印象深刻！谢谢你的时间！\",\" 非常感谢！我很高兴能参加这次面试，希望能有机会为您的团队贡献我的技术和经验！\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"999\":{\"c\":[\"《面试1v1》\"]},\"1000\":{\"h\":\"Elasticsearch和Lucene\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，欢迎来到我们的面试！今天我们将聊一下ElasticSearch和Lucene。你对这两个技术有了解吗？\",\" 当然！ElasticSearch是一个基于Lucene构建的分布式搜索和分析引擎。它提供了强大的全文搜索功能和实时数据分析能力。\",\"： 很好！那你能给我解释一下Lucene是什么吗？\",\" 当然！Lucene是一个开源的全文搜索引擎库，它提供了一系列用于索引和搜索文档的API。它被广泛应用于各种应用程序中，包括搜索引擎、内容管理系统和商业应用等。\",\"： 那么ElasticSearch和Lucene之间有什么关系呢？\",\" ElasticSearch实际上是在Lucene的基础上构建的。它提供了一个分布式的、可扩展的搜索和分析平台，简化了Lucene的使用和管理。ElasticSearch通过提供RESTful API和分布式特性，使得在大规模数据集上进行搜索和分析变得更加容易。\",\"： 很棒！那你能给我举个例子，说明ElasticSearch和Lucene在实际应用中的作用吗？\",\" 当然！比如，假设我们有一个电商网站，需要实现商品搜索功能。我们可以使用Lucene来构建一个索引，将商品的属性（如名称、描述、价格等）存储在索引中。然后，我们可以使用ElasticSearch来搜索这个索引，根据用户的搜索关键字返回相关的商品结果。\",\"： 太棒了！你对ElasticSearch和Lucene的解释非常清晰。还有其他你想补充的吗？\",\" 是的，我还想提一下ElasticSearch的分布式特性。ElasticSearch使用分片和复制机制来实现数据的分布式存储和高可用性。它将索引划分为多个分片，并将每个分片复制到多个节点上，以实现数据的冗余和负载均衡。\",\"： 太好了！你对ElasticSearch和Lucene的理解非常透彻。非常感谢你的回答！\",\" 非常感谢您的提问！我很高兴能有这次面试机会，希望能有机会为您的团队贡献我的技术能力。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"1001\":{\"c\":[\"《面试1v1》\"]},\"1002\":{\"h\":\"Elasticsearch架构设计\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，候选人！今天我们来聊聊ElasticSearch的架构设计，你对这个话题有什么了解吗？\",\" 嗨，面试官！当然有啦！ElasticSearch是一个开源的分布式搜索和分析引擎，基于Lucene构建，用于处理大规模数据的搜索和分析。它的设计目标是简单、可扩展和高效。\",\"ElasticSearch的核心组件\",\"： 很好！那你能给我简单介绍一下ElasticSearch的核心组件吗？\",\" 当然可以！ElasticSearch的核心组件包括：\",\"索引（Index）：类似于数据库中的表，用于存储和组织数据。\",\"文档（Document）：类似于数据库中的记录，是最小的数据单元。\",\"类型（Type）：用于对文档进行分类，类似于数据库中的表的类型。\",\"映射（Mapping）：定义了文档的结构和字段类型。\",\"分片（Shard）：将索引分成多个分片，以实现数据的分布式存储和处理。\",\"副本（Replica）：用于提高数据的可用性和容错性。\",\"ElasticSearch的搜索原理\",\"： 非常好！那你能给我解释一下ElasticSearch的搜索原理吗？\",\" 当然可以！ElasticSearch的搜索原理可以简单概括为以下几个步骤：\",\"查询解析（Query Parsing）：将用户的查询语句解析成查询对象。\",\"倒排索引（Inverted Index）：ElasticSearch使用倒排索引来加速搜索，它将每个词与包含该词的文档建立关联。\",\"评分（Scoring）：ElasticSearch使用TF-IDF算法和其他评分算法来计算文档的相关性得分。\",\"分布式搜索（Distributed Search）：ElasticSearch将搜索请求发送到所有相关的分片上，并将结果合并返回给用户。\",\"ElasticSearch的性能优化\",\"： 非常棒！那你能给我分享一些关于ElasticSearch性能优化的技巧吗？\",\" 当然可以！以下是一些性能优化的技巧：\",\"合理设计索引和映射：根据实际需求设计合理的索引和映射，避免不必要的字段和复杂的数据结构。\",\"使用分片和副本：根据数据量和负载情况，合理设置分片和副本的数量，以实现负载均衡和高可用性。\",\"使用缓存：ElasticSearch提供了缓存机制，可以缓存频繁使用的查询结果，提高查询性能。\",\"合理使用索引别名：使用索引别名可以方便地切换索引版本或进行灰度发布，同时减少代码中的硬编码。\",\"监控和优化查询性能：使用ElasticSearch提供的监控工具和API，定期监控查询性能并进行优化。\",\"： 太棒了！你对ElasticSearch的架构设计有很好的理解！有没有什么想补充的？\",\" 感谢夸奖！我想强调一点，ElasticSearch不仅仅是一个搜索引擎，它还可以用于日志分析、数据可视化等各种场景。所以，掌握ElasticSearch的架构设计对于刚入行的技术人员来说是非常有价值的。\",\"： 没错！ElasticSearch的应用非常广泛，对于技术人员来说是一个必备的技能。非常感谢你的分享！\",\" 不客气！我很高兴能与您分享这些知识。如果您还有其他问题，随时告诉我！\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"1003\":{\"c\":[\"《面试1v1》\"]},\"1004\":{\"h\":\"Elasticsearch集群索引分片\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，欢迎来到我们的面试！今天我们将聊一聊ElasticSearch集群架构、索引和分片。你对这些有了解吗？\",\" 当然！ElasticSearch就像是一群小伙伴组成的团队，一起合作来处理海量数据。索引就像是我们的图书馆，每本书都有一个唯一的编号，方便我们快速找到需要的信息。而分片就像是把一本大书分成多个小册子，每个人负责一部分，这样我们可以并行处理数据。\",\"： 很形象的比喻！那么，ElasticSearch集群是如何工作的呢？\",\" 嗯，ElasticSearch集群就像是一个大家庭，由多个节点组成。每个节点都有自己的角色，有的是主节点，有的是数据节点。主节点负责协调整个集群的工作，而数据节点则负责存储和处理数据。\",\"： 很好！那么，索引是如何创建和管理的呢？\",\" 好问题！创建索引就像是在图书馆里开辟一个新的区域，我们可以给它起个名字，比如\\\"books\\\"。然后，我们可以定义这个索引的字段，比如书名、作者、出版日期等。这样，我们就可以根据这些字段来搜索和过滤数据了。\",\"： 非常清楚！那么，分片是如何工作的呢？\",\" 嗯，分片就像是把一本大书分成多个小册子，每个分片都是一个独立的存储单元。当我们往索引中添加数据时，ElasticSearch会根据一定的规则将数据均匀地分配到不同的分片上。这样，我们可以并行处理数据，提高性能和可扩展性。\",\"： 很棒！你对ElasticSearch集群架构、索引和分片的解释非常清晰。有没有什么源码方面的知识可以分享一下？\",\" 当然！让我给你展示一段简单的源码，来说明一下分片的工作原理：\",\"public class Shard { private String shardId; private List<Document> documents; public Shard(String shardId) { this.shardId = shardId; this.documents = new ArrayList<>(); } public void addDocument(Document document) { documents.add(document); } public List<Document> search(String keyword) { List<Document> results = new ArrayList<>(); for (Document document : documents) { if (document.contains(keyword)) { results.add(document); } } return results; } }\",\"这段代码模拟了一个分片的实现。我们可以看到，每个分片都有一个唯一的shardId，以及一个存储文档的列表。当我们添加文档时，它会被存储在对应的分片中。而当我们搜索关键字时，它会遍历分片中的文档，找到匹配的结果并返回。\",\"： 太棒了！你不仅解释得很清楚，还给出了源码示例。这对于刚入行的技术人员来说非常有帮助。谢谢你的分享！\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"1005\":{\"c\":[\"《面试1v1》\"]},\"1006\":{\"h\":\"Elasticsearch倒排索引\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，欢迎来到我们的面试！今天我们要聊一聊ElasticSearch倒排索引，你对这个概念了解多少呢？\",\" 嗨，谢谢！ElasticSearch倒排索引，听起来有点高大上啊。不过，我会尽力用人话解释它。咱们先从搜索引擎说起吧。你知道搜索引擎是怎么找到相关结果的吗？\",\"： 当然知道！搜索引擎会根据关键词在网页中进行匹配，然后返回相关的结果。\",\" Bingo！而ElasticSearch倒排索引就是搜索引擎的一种核心技术。它的原理其实很简单，就像是一本索引书，记录了每个关键词在哪些文档中出现过。\",\"： 哦，那这样搜索的速度会更快，对吧？\",\" 没错！因为倒排索引可以直接定位到包含关键词的文档，而不需要逐个文档地搜索。这就像是你在书架上找一本书，如果有索引，你可以直接翻到对应的页码，而不需要一页一页地找。\",\"： 好像明白了。那你能给我一个简单的例子来解释一下吗？\",\" 当然可以！假设我们有三个文档，分别是：\",\"文档1: \\\"我喜欢吃苹果\\\" 文档2: \\\"我喜欢吃香蕉\\\" 文档3: \\\"我喜欢吃橙子\\\"\",\"如果我们要搜索关键词\\\"喜欢吃苹果\\\"，倒排索引会记录下这个关键词在文档1中出现过。这样，当我们搜索\\\"喜欢吃苹果\\\"时，就可以直接找到文档1，而不需要遍历所有文档。\",\"： 哇，这样的话搜索速度真的会快很多！那倒排索引是怎么构建的呢？\",\" 构建倒排索引其实也很简单。我们可以遍历所有文档，将每个文档中的关键词提取出来，并记录下关键词出现的文档编号。这样，当用户搜索时，我们只需要查找关键词对应的文档编号，就能快速定位到相关文档。\",\"： 这听起来不错！那倒排索引有什么应用场景呢？\",\" 倒排索引在搜索引擎、文本检索、数据分析等领域都有广泛应用。比如，当你在搜索引擎中输入关键词，它会根据倒排索引快速找到相关的网页；在电商网站中，倒排索引可以帮助用户快速找到想要的商品。\",\"： 哈哈，我现在对倒排索引有了更清晰的认识！谢谢你的解释。\",\" 不客气！我很高兴能帮助你理解倒排索引。如果你还有其他问题，我随时都可以回答。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"1007\":{\"c\":[\"《面试1v1》\"]},\"1008\":{\"h\":\"Elasticsearch选主\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，候选人！今天我们来详细讨论一下ElasticSearch选主的重要性和具体过程。你对这个话题有了解吗？\",\" 当然有！选主是ElasticSearch中至关重要的一个操作，它决定了集群中哪个节点将成为主节点，负责协调整个集群的操作。选主的稳定性和可靠性对于集群的正常运行至关重要。\",\"： 非常正确！那么，你能详细解释一下选主的过程吗？\",\" 当然可以！选主的过程可以分为以下几个关键步骤：\",\"节点启动：每个ElasticSearch节点在启动时都会尝试与Zookeeper建立连接。Zookeeper是一个分布式协调服务，用于管理集群中的节点。\",\"竞选主节点：节点启动后，它们会竞选成为主节点。竞选的过程中，每个节点会生成一个唯一的ID，并将自己的ID和版本号发送给Zookeeper。\",\"Zookeeper的角色：Zookeeper会根据接收到的节点信息来选择主节点。它会维护一个有序的节点列表，并将最小的节点作为主节点。这种有序列表的维护是通过Zookeeper的顺序节点（Sequential Node）特性实现的。\",\"选主结果：一旦Zookeeper选出了主节点，它会将主节点的信息广播给所有的节点。其他节点会接收到这个信息，并将其作为参考，以便在后续的操作中与主节点进行通信。\",\"： 非常详细的解释！你能给我展示一下选主过程的源码示例吗？\",\" 当然可以！以下是一个简化的选主源码示例，帮助你更好地理解选主过程：\",\"// 导入相关的库和类 public class MasterElection { public static void main(String[] args) { // 连接Zookeeper ZooKeeper zooKeeper = new ZooKeeper(\\\"localhost:2181\\\", 5000, null); // 生成唯一ID String nodeId = UUID.randomUUID().toString(); // 将ID和版本号发送给Zookeeper zooKeeper.create(\\\"/election/node-\\\", nodeId.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); // 等待选主结果 while (true) { List<String> children = zooKeeper.getChildren(\\\"/election\\\", false); String smallestNode = findSmallestNode(children); if (smallestNode.equals(nodeId)) { // 成为主节点 System.out.println(\\\"选主成功，我是主节点！\\\"); break; } else { // 不是主节点，等待 System.out.println(\\\"还没选上，继续等待...\\\"); Thread.sleep(1000); } } } // 找到最小的节点 private static String findSmallestNode(List<String> nodes) { String smallestNode = nodes.get(0); for (String node : nodes) { if (node.compareTo(smallestNode) < 0) { smallestNode = node; } } return smallestNode; } }\",\"： 太棒了！你的源码示例非常清晰，帮助我们更好地理解选主过程。有没有其他关于选主的问题想要问我的呢？\",\" 我想知道，如果主节点宕机了，ElasticSearch会如何重新选举新的主节点？\",\"： 好问题！当主节点宕机后，剩下的节点会重新竞选主节点。这个过程是自动的，ElasticSearch会自动处理选主过程，确保集群的正常运行。这种自动选主的机制保证了集群的高可用性和容错性。\",\" 明白了！谢谢你的解答！\",\"： 不客气！你的问题很棒，希望我能帮到你。如果你还有其他问题，随时都可以问我！\",\" 好的，谢谢你的帮助！\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"1009\":{\"c\":[\"《面试1v1》\"]},\"1010\":{\"h\":\"Java反射\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 你好，请问你对 Java 反射有了解吗？\",\" 是的，我了解一些。\",\"： 那你能简单地介绍一下 Java 反射是什么吗？\",\" Java 反射是一种机制，它可以在运行时动态地获取类的信息，包括类的属性、方法、构造函数等，并且可以在运行时调用这些属性和方法。\",\"： 那你能举个例子来说明一下吗？\",\" 当然可以。例如，我们可以使用反射来动态地创建对象：\",\"Class<?> clazz = MyClass.class; MyClass obj = (MyClass) clazz.newInstance();\",\"在这个例子中，我们使用 MyClass.class 来获取 MyClass 类的 Class 对象，并使用 newInstance() 方法来创建 MyClass 类的实例。\",\"： 那反射具体有什么作用呢？\",\" 反射可以用于很多方面，例如：\",\"动态地创建对象\",\"动态地调用方法\",\"动态地获取和设置属性值\",\"动态地获取和设置数组元素\",\"动态地获取和设置注解\",\"动态地获取和设置泛型信息\",\"： 那你能举个例子来说明一下动态地调用方法吗？\",\" 当然可以。例如，我们可以使用反射来动态地调用方法：\",\"Class<?> clazz = MyClass.class; MyClass obj = (MyClass) clazz.newInstance(); Method method = clazz.getMethod(\\\"myMethod\\\", String.class); String result = (String) method.invoke(obj, \\\"hello\\\");\",\"在这个例子中，我们使用 MyClass.class 来获取 MyClass 类的 Class 对象，并使用 newInstance() 方法来创建 MyClass 类的实例。然后，我们使用 getMethod() 方法来获取 MyClass 类中名为 myMethod 的方法，并使用 invoke() 方法来调用这个方法。\",\"： 那你能说一下反射的优缺点吗？\",\" 反射的优点是可以在运行时动态地获取和操作类的信息，从而实现更加灵活和强大的功能。缺点是反射的性能比较低，因为它需要在运行时进行类型检查和方法调用，而且容易破坏封装性，因为它可以访问私有属性和方法。\",\"： 非常好，你对 Java 反射的了解很不错。谢谢你的回答。\",\" 谢谢您的夸奖，我会继续努力学习。\",\"： 那你能说一下反射和泛型的关系吗？\",\" 当然可以。反射可以用于动态地获取和设置泛型信息，例如：\",\"Class<?> clazz = MyClass.class; TypeVariable<?>[] typeParams = clazz.getTypeParameters();\",\"在这个例子中，我们使用 MyClass.class 来获取 MyClass 类的 Class 对象，并使用 getTypeParameters() 方法来获取 MyClass 类的泛型参数。\",\"反射还可以用于动态地获取和设置泛型类型，例如：\",\"Class<?> clazz = MyClass.class; Field field = clazz.getField(\\\"myField\\\"); Type fieldType = field.getGenericType();\",\"在这个例子中，我们使用 MyClass.class 来获取 MyClass 类的 Class 对象，并使用 getField() 方法来获取 MyClass 类中名为 myField 的字段。然后，我们使用 getGenericType() 方法来获取这个字段的泛型类型。\",\"： 那你能说一下反射和安全性的关系吗？\",\" 反射可以破坏封装性，因为它可以访问私有属性和方法。因此，在使用反射时需要格外小心，避免破坏程序的安全性。一般来说，我们应该尽量避免使用反射来访问私有属性和方法，而是通过公共接口来访问类的属性和方法。\",\"： 非常好，你对 Java 反射的了解很深入，先回去吧。\",\" 淦\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"1011\":{\"c\":[\"《面试1v1》\"]},\"1012\":{\"h\":\"Elasticsearch索引文档底层过程\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 嗨，你准备好聊一聊Elasticsearch索引文档的底层过程了吗？\",\" 当然准备好了！让我们开始吧！\",\"： 首先，我们需要了解一下Elasticsearch底层索引文档的过程，包括分片和副本的处理。你知道分片和副本是什么吗？\",\" 当然！在Elasticsearch中，索引被分成多个分片，每个分片存储了索引的一部分数据。而副本则是分片的复制，用于提高数据的可用性和容错性。\",\"： 很好！那我们来看一下具体的索引文档的底层过程，包括分片和副本的处理。\",\" 在底层，当我们索引一个文档时，Elasticsearch会执行以下几个步骤：\",\"分析文档内容： 首先，Elasticsearch会将文档内容进行分析，包括词条化、去除停用词、转换为小写等。这样可以提高搜索的准确性和效率。\",\"路由到分片： 接下来，Elasticsearch会根据文档的路由值确定将文档索引到哪个分片。路由值可以是文档ID的哈希值，或者是自定义的路由键。这样可以确保具有相同路由值的文档被索引到同一个分片中。\",\"创建倒排索引： 对于目标分片，Elasticsearch会为每个词条创建倒排索引，记录词条在文档中的位置信息。\",\"处理副本： 如果索引配置了副本，Elasticsearch会将文档的副本分配给其他节点上的分片。这样可以提高数据的可用性和容错性。副本的数量可以根据需求进行配置。\",\"分布式写入： 当文档被索引到目标分片和副本后，Elasticsearch会使用分布式写入协调器来确保数据的一致性。协调器会将索引请求发送给相关的分片和副本，并等待它们的确认。\",\"存储文档： 最后，Elasticsearch会将原始文档和相关的元数据存储在磁盘上。这样，当我们检索文档时，Elasticsearch可以从磁盘中读取文档内容并返回给我们。\",\"： 很好！这就是Elasticsearch索引文档的底层过程，包括分片和副本的处理。通过分析文档内容，路由到目标分片，创建倒排索引，处理副本，并使用分布式写入协调器来确保数据的一致性，Elasticsearch能够高效地处理大量的文档和复杂的搜索需求。\",\" 是的，这个底层过程非常重要，它使得Elasticsearch能够在分布式环境中处理大规模的数据，并提供高可用性和容错性。\",\"： 没错！希望这个对话能帮助到你，也能帮助到你的读者。如果你还有其他问题，随时告诉我哦！\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"1013\":{\"c\":[\"《面试1v1》\"]},\"1014\":{\"h\":\"TODO Elasticsearch搜索文档过程\"},\"1015\":{\"c\":[\"《面试1v1》\"]},\"1016\":{\"h\":\"动态代理\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 那你能说一下反射和动态代理的关系吗？\",\" 当然可以。动态代理是一种基于反射的机制，它可以在运行时动态地创建一个实现了指定接口的代理类，并将方法的调用转发到指定的处理器上。\",\"动态代理通常用于实现 AOP（面向切面编程），它可以在不修改原有代码的情况下，为类添加额外的功能，例如日志记录、性能统计、事务管理等。\",\"动态代理的实现依赖于反射机制，它可以在运行时动态地获取类的信息，并动态地创建代理类和代理对象。因此，反射是动态代理的基础。\",\"： 那你能举个例子来说明一下动态代理的使用吗？\",\" 当然可以。例如，我们可以使用动态代理来实现一个简单的日志记录器：\",\"public interface MyInterface { void myMethod(); } public class MyInterfaceImpl implements MyInterface { public void myMethod() { System.out.println(\\\"myMethod is called\\\"); } } public class MyInvocationHandler implements InvocationHandler { private Object target; public MyInvocationHandler(Object target) { this.target = target; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"before \\\" + method.getName() + \\\" is called\\\"); Object result = method.invoke(target, args); System.out.println(\\\"after \\\" + method.getName() + \\\" is called\\\"); return result; } } public class Main { public static void main(String[] args) { MyInterface target = new MyInterfaceImpl(); MyInvocationHandler handler = new MyInvocationHandler(target); MyInterface proxy = (MyInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler ); proxy.myMethod(); } }\",\"在这个例子中，我们定义了一个 MyInterface 接口和一个 MyInterfaceImpl 类，它实现了 MyInterface 接口。然后，我们定义了一个 MyInvocationHandler 类，它实现了 InvocationHandler 接口，并在 invoke() 方法中添加了日志记录的逻辑。\",\"最后，我们在 Main 类中使用 Proxy.newProxyInstance() 方法来创建一个实现了 MyInterface 接口的代理对象，并将方法的调用转发到 MyInvocationHandler 上。当我们调用代理对象的 myMethod() 方法时，会自动调用 MyInvocationHandler 中的 invoke() 方法，并输出日志记录信息。\",\"： 非常好，你对反射和动态代理的了解很深入。\",\" 谢谢您的夸奖，我会继续努力学习，早日通过面试。\",\"： 那你能说一下动态代理的优缺点吗？\",\" 当然可以。动态代理的优点是可以在运行时动态地创建代理对象，从而实现更加灵活和强大的功能。它可以在不修改原有代码的情况下，为类添加额外的功能，例如日志记录、性能统计、事务管理等。此外，动态代理还可以实现 AOP（面向切面编程），从而提高代码的可重用性和可维护性。\",\"动态代理的缺点是性能比较低，因为它需要在运行时进行类型检查和方法调用，并且需要动态地创建代理对象。此外，动态代理只能代理接口，无法代理类，因此它的应用范围受到一定的限制。\",\"： 那你能说一下动态代理和静态代理的区别吗？\",\" 当然可以。静态代理是在编译时就已经确定代理对象和被代理对象的关系，而动态代理是在运行时动态地创建代理对象。静态代理需要手动编写代理类，而动态代理可以自动生成代理类。静态代理只能代理一个类或接口，而动态代理可以代理多个类或接口。\",\"： 那你能说一下动态代理的实现原理吗？\",\" 当然可以。动态代理的实现原理是基于 Java 的反射机制和动态生成字节码技术。在运行时，动态代理会根据指定的接口或类，动态地生成一个代理类，并将方法的调用转发到指定的处理器上。代理类的生成过程是通过字节码生成器来实现的，它可以根据指定的接口或类，动态地生成一个代理类的字节码，并将其加载到内存中。代理类的字节码中包含了对被代理对象的引用，以及对代理方法的调用逻辑。当我们调用代理对象的方法时，会自动调用代理类中的方法，并将方法的调用转发到指定的处理器上。\",\"： 非常好，你对动态代理的了解很深入。\",\" 我通过面试了吗\",\"： 希望下次还能见到你。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"1017\":{\"c\":[\"《面试1v1》\"]},\"1018\":{\"h\":\"CAS\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 上个面试官对你的基础有了一定了解，听说你小子很不错！下面我们聊点有深度的。\",\"： 简单介绍下 CAS 你了解什么?\",\" CAS是Compare And Swap的缩写,中文意思是比较与交换。它是一条 CPU 的原子指令,用于比较内存某个位置的值是否为预期值,如果是则更改为新的值。这一整个过程是原子的,也就是说它是线程安全的。\",\"： CAS 的用处是什么?\",\" CAS 主要用于实现非阻塞算法。常见的使用场景有:\",\"实现原子操作:像 Java 的 AtomicInteger,它使用 CAS 来原子更新变量值。\",\"// AtomicInteger 中 CAS 的运用 private volatile int value; public final int getAndIncrement() { int next; do { next = get(); } while (!compareAndSet(next, next + 1)); return next; }\",\"实现锁的非阻塞式获取:像乐观锁。先假设可以获取锁,如果获取失败了再判断是否需要阻塞。\",\"实现非阻塞的数据结构:像 ConcurrentLinkedQueue。使用 CAS 来实现链表节点的非阻塞追加等操作。\",\"实现线程调度:像 Swing 里的 EDT(事件调度线程),通过 CAS 来实现对事件调度状态的修改。\",\"： 说说 CAS 的 ABA 问题?\",\" CAS 操作包含三个操作数:内存位置(V)、旧的预期值(A)和新值(B)。如果当 CAS 操作开始时,V的确为A,但在 CAS 比较V和A之后,V的值变为了其他值,然后又变回A,就会产生ABA问题。 因为 CAS 操作只会在预期值A和当前值相同时更改为新值B,这时已经错失了一次更改的机会。 ABA 导致的问题是,当一个值原来是X,后来变成了Y,然后又变回X的时候,使用CAS进行检查时会发现它的值没有变化,但实际上却变动过了。这可能会对逻辑产生意料之外的影响。 常见的解决ABA问题的方法是使用版本号或者时间戳。在变量前面追加版本号version,每次变量更新的时候把version++,那么A-B-A 就会变成 1A-2B-3A,CAS 操作进行检查时就可以发现版本号不同,从而避免ABA问题。\",\"： 不错,CAS 是Java并发编程的基础之一,也是很重要的内容。能解释清楚CAS的ABA问题,且知道解决方法,未来会对并发编程有很大帮助。\",\" 是的,CAS 是实现Java并发编程的基础工具之一,理解透彻CAS和ABA问题,对后续学习各种并发工具和框架,乃至设计并发系统会非常有帮助。我会继续深入学习CAS相关内容,了解更多实践应用的案例,并在项目中运用的更加娴熟。 谢谢面试官的提问,让我对CAS和ABA问题有了更全面和深入的认识,这些知识点确实对并发编程来说是基础中的基础。我一定会继续加深理解的!\",\"： 乐观锁和悲观锁了解吗?有什么区别?\",\" 乐观锁和悲观锁是两种不同的锁机制: 悲观锁:总是假设会发生并发冲突,屏蔽一切可能违反数据完整性的操作。如synchronized关键词加在方法或者代码块上,会对该段代码采取排他锁,不允许其他线程同时执行。 乐观锁:假设不会发生并发冲突,只在提交操作时检查是否违反数据完整性。如果校验失败,就重试整个读取-修改-提交操作。典型的如CAS算法采用乐观锁。 两者主要区别在于对并发冲突的态度:\",\"悲观锁试图防止并发冲突,乐观锁则容忍并发冲突,并在发生冲突时重试。\",\"悲观锁会导致性能下降,因为任何时候只能有一个线程访问数据。而乐观锁可以让多个线程同时访问数据,只有在提交更新时才会检查并发冲突,所以性能更好。\",\"悲观锁一般由同步机制实现,开销更大。而乐观锁由CAS这样的原子操作实现,开销更小。 所以,总体来说:\",\"读次数多、更新次数少,且更新不需要很强一致性的用乐观锁。\",\"更新频繁,需要强一致性的用悲观锁。\",\"两者也可以结合使用,先乐观锁重试几次,再悲观锁。\",\"： 你说的很详细,那你在项目中用过这两种锁吗?遇到什么问题?\",\" 在项目中,我使用过synchronized作为悲观锁,和CAS + 版本号作为乐观锁。 使用synchronized时,由于锁定粒度太大,导致性能下降比较严重。后来在一些只读的方法上使用可重入锁ReentrantReadWriteLock,采用其读锁来提高并发度,性能得以提高。 使用CAS + 版本号时,由于业务的复杂性,导致版本号更新并不完全正确,产生过ABA问题。像在链表的删除操作,如果删除节点时版本号没有同步更新,这时线程B利用CAS把节点从A改成C,就产生了ABA问题,这时需要额外采取其他措施解决,比较棘手。 所以,总结来说使用锁机制时,需要考虑:\",\"锁的粒度,尽量加在必要的范围内。\",\"读写比例,如果读多,可以考虑读写锁。\",\"CAS使用时,要考虑清楚版本号的更新策略,避免ABA问题。\",\"悲观锁和乐观锁也可以灵活结合,必要时采用悲观锁避免问题进一步扩大。 通过上述实践,让我对这两种锁有了更深的认识,今后在设计系统和使用锁机制时可以运用的更加娴熟和灵活。\",\"： 很好,你对锁机制的理解已经深入到能够在实践中运用并解决遇到的问题的地步。这是学以致用的好例子,也让我对你的能力有了更高的评价。\",\"今天就先到这吧。\",\" 谢谢面试官的肯定。锁机制作为并发编程的基础,我也花了不少时间去理解和实践。在项目我玩的贼6。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"1019\":{\"c\":[\"《面试1v1》\"]},\"1020\":{\"h\":\"JavaNIO\",\"t\":[\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 你好，我想问一下你对 Java NIO 的了解。\",\" 当然，Java NIO 是 Java 的一种 I/O 模型，它提供了一种基于缓冲区和通道的 I/O 操作方式。相比传统的 I/O 模型，Java NIO 具有更高的性能和更好的扩展性。\",\"： 那你能具体说一下 Java NIO 的特点吗？\",\" 当然可以。Java NIO 的特点主要有以下几点：\",\"非阻塞式 I/O：Java NIO 支持非阻塞式 I/O 操作，可以在等待 I/O 操作完成的同时，继续执行其他任务，从而提高系统的并发性能。\",\"缓冲区：Java NIO 使用缓冲区来处理数据，可以提高数据的读写效率，并且可以支持随机访问。\",\"通道：Java NIO 使用通道来进行数据的读写操作，通道可以支持双向数据传输，并且可以在不同的线程之间共享。\",\"选择器：Java NIO 提供了选择器来实现多路复用，可以同时监控多个通道的 I/O 事件，从而提高系统的并发性能。\",\"： 那你能说一下 Java NIO 的应用场景吗？\",\" 当然可以。Java NIO 的应用场景非常广泛，包括网络编程、文件操作、内存映射等。例如，在网络编程中，Java NIO 可以实现高性能的服务器和客户端，可以支持大量的并发连接，并且可以使用选择器来实现多路复用。在文件操作中，Java NIO 可以实现高效的文件读写操作，可以使用内存映射来提高文件的读取速度。在内存映射中，Java NIO 可以将文件映射到内存中，从而可以直接访问文件的内容，而无需进行繁琐的读写操作。\",\"： 那你能说一下 Java NIO 的核心组件吗？\",\" 当然可以。Java NIO 的核心组件包括缓冲区（Buffer）、通道（Channel）、选择器（Selector）和字节编解码器（Charset）。缓冲区用于存储数据，通道用于进行数据的读写操作，选择器用于实现多路复用，字节编解码器用于将字节流转换为字符流。这些组件共同构成了 Java NIO 的基础架构，可以支持高效的 I/O 操作。\",\"： 那你能给我举个例子，说明 Java NIO 在实际开发中的应用吗？\",\" 当然可以。在一个聊天室应用中，可以使用 Java NIO 来实现多个客户端之间的通信。每个客户端都可以使用一个通道来进行数据的读写操作，而服务器可以使用一个选择器来监控所有的通道，从而实现多路复用。这样可以大大提高服务器的并发性能，支持大量的并发连接。\",\"以下是一个简单的示例代码，用于实现一个简单的聊天室应用：\",\"import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.ServerSocketChannel; import java.nio.channels.SocketChannel; import java.util.Iterator; public class ChatRoomServer { private static final int PORT = 8888; private static final int BUFFER_SIZE = 1024; private static final String CHARSET = \\\"UTF-8\\\"; public static void main(String[] args) throws IOException { // 创建一个选择器 Selector selector = Selector.open(); // 创建一个服务器通道，并绑定到指定的端口 ServerSocketChannel serverChannel = ServerSocketChannel.open(); serverChannel.socket().bind(new InetSocketAddress(PORT)); serverChannel.configureBlocking(false); // 将服务器通道注册到选择器上，并监听连接事件 serverChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println(\\\"Server started on port \\\" + PORT); while (true) { // 阻塞等待事件发生 selector.select(); // 获取所有已经就绪的事件 Iterator<SelectionKey> iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) { SelectionKey key = iterator.next(); iterator.remove(); if (key.isAcceptable()) { // 处理连接事件 ServerSocketChannel channel = (ServerSocketChannel) key.channel(); SocketChannel clientChannel = channel.accept(); clientChannel.configureBlocking(false); clientChannel.register(selector, SelectionKey.OP_READ); System.out.println(\\\"Client connected: \\\" + clientChannel.getRemoteAddress()); } else if (key.isReadable()) { // 处理读事件 SocketChannel channel = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE); int len = channel.read(buffer); if (len > 0) { buffer.flip(); String message = new String(buffer.array(), 0, len, CHARSET); System.out.println(\\\"Received message: \\\" + message); broadcast(selector, channel, message); } else if (len == -1) { channel.close(); } } } } } private static void broadcast(Selector selector, SocketChannel sender, String message) throws IOException { for (SelectionKey key : selector.keys()) { if (key.isValid() && key.channel() instanceof SocketChannel) { SocketChannel channel = (SocketChannel) key.channel(); if (!channel.equals(sender)) { ByteBuffer buffer = ByteBuffer.wrap(message.getBytes(CHARSET)); channel.write(buffer); } } } } }\",\"这个示例代码实现了一个简单的聊天室应用，使用 Java NIO 来实现多个客户端之间的通信。每个客户端都可以使用一个通道来进行数据的读写操作，而服务器可以使用一个选择器来监控所有的通道，从而实现多路复用。这样可以大大提高服务器的并发性能，支持大量的并发连接。\",\"： 代码写的很好，下次带笔记本过来。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"1021\":{\"c\":[\"《面试1v1》\"]},\"1022\":{\"h\":\"Synchronized\",\"t\":[\"源码都背下来了，你给我看这\",\"我是 javapub，一名 Markdown 程序员从👨‍💻，八股文种子选手。\",\"： 你好，我看到你的简历上写着你熟悉 Java 中的 \\\"synchronized\\\" 关键字。你能给我讲讲它的作用吗？\",\" 当然，\\\"synchronized\\\" 是 Java 中的一个关键字，用于实现同步机制。它可以用来修饰方法或代码块，以确保在同一时间只有一个线程可以访问被修饰的代码。\",\"： 很好。那么，你能举个例子来说明 \\\"synchronized\\\" 关键字的使用方法吗？\",\" 当然。你可以使用 \\\"synchronized\\\" 关键字来修饰方法或代码块。例如，你可以这样使用：\",\"public synchronized void doSomething() { // ... }\",\"在上面的代码中，\\\"synchronized\\\" 关键字修饰了 \\\"doSomething()\\\" 方法。这意味着在同一时间只有一个线程可以访问该方法。\",\"： 很好。那么，如果我想修饰一个代码块，应该怎么做呢？\",\" 你可以这样使用 \\\"synchronized\\\" 关键字来修饰一个代码块：\",\"public void doSomething() { synchronized (this) { // ... } }\",\"在上面的代码中，\\\"synchronized\\\" 关键字修饰了一个代码块，该代码块使用 \\\"this\\\" 作为锁对象。这意味着在同一时间只有一个线程可以访问该代码块。\",\"： 很好。那么，你能解释一下 \\\"synchronized\\\" 关键字的实现原理吗？\",\" 当一个线程访问一个被 \\\"synchronized\\\" 关键字修饰的方法或代码块时，它会尝试获取该对象的监视器锁。如果该锁已经被其他线程持有，则该线程将被阻塞，直到该锁被释放。下面是一个使用 \\\"synchronized\\\" 关键字的示例：\",\"public class Counter { private int count = 0; public synchronized void increment() { count++; } public synchronized void decrement() { count--; } public synchronized int getCount() { return count; } }\",\"在上面的代码中，\\\"increment()\\\"、\\\"decrement()\\\" 和 \\\"getCount()\\\" 方法都被 \\\"synchronized\\\" 关键字修饰。这意味着在同一时间只有一个线程可以访问这些方法。\",\"： 很好，你对 \\\"synchronized\\\" 关键字的理解很清晰。那么，你能告诉我 \\\"synchronized\\\" 关键字的缺点吗？\",\" 当然。使用 \\\"synchronized\\\" 关键字会带来一些性能上的开销，因为每个线程都需要获取锁才能访问被修饰的代码。此外，如果使用不当，还可能会导致死锁等问题。\",\"： 那么，你能告诉我如何避免 \\\"synchronized\\\" 关键字带来的性能开销吗？\",\" 当然。一种方法是使用 \\\"volatile\\\" 关键字来修饰变量，这可以确保变量的可见性，而不需要使用锁。另一种方法是使用 \\\"java.util.concurrent\\\" 包中的并发集合类，例如 ConcurrentHashMap、CopyOnWriteArrayList 等，这些类使用了更高效的同步机制，可以避免 \\\"synchronized\\\" 关键字带来的性能开销。\",\"： 很好，你的回答很不错。那么，你能告诉我 \\\"synchronized\\\" 关键字和 \\\"Lock\\\" 接口之间的区别吗？\",\" 当然。 \\\"synchronized\\\" 关键字是 Java 中内置的同步机制，它可以用来修饰方法或代码块，使用起来比较简单，但是它的性能开销比较大。而 \\\"Lock\\\" 接口是 Java 中提供的一种更加灵活的同步机制，它可以实现更细粒度的锁控制，例如可重入锁、读写锁等，使用起来比较复杂，但是它的性能开销比较小。\",\"： 很好，你的回答很清晰。那么，你有没有使用过 \\\"Lock\\\" 接口呢？\",\" 是的，我有使用过 \\\"Lock\\\" 接口。例如，我曾经使用过 ReentrantLock 类来实现可重入锁，这可以避免 \\\"synchronized\\\" 关键字的性能开销，并且可以实现更细粒度的锁控制。\",\"： 很好，你的经验很丰富。那么，你能告诉我 \\\"Lock\\\" 接口的一些特点吗？\",\" 当然。 \\\"Lock\\\" 接口的一些特点包括：\",\"可以实现更细粒度的锁控制，例如可重入锁、读写锁等。\",\"可以实现公平锁和非公平锁。\",\"可以实现超时锁和可中断锁。\",\"可以实现多个条件变量，可以更加灵活地控制线程的等待和唤醒。\",\"： 那么，你能告诉我 \\\"synchronized\\\" 关键字和 \\\"volatile\\\" 关键字之间的区别吗？\",\" 当然。 \\\"synchronized\\\" 关键字和 \\\"volatile\\\" 关键字都可以用来实现多线程之间的同步，但是它们的作用不同。 \\\"synchronized\\\" 关键字可以确保在同一时间只有一个线程可以访问被修饰的代码，而 \\\"volatile\\\" 关键字可以确保变量的可见性，即当一个线程修改了变量的值后，其他线程可以立即看到这个修改。\",\"： 看来你使用的很好，下面问一点深入的东西。回答不上来也没关系，可以自己想想。\",\"： 好的，那么你能够从 \\\"synchronized\\\" 的底层 Java 实现角度，解释一下它的实现原理吗？\",\" 当一个线程访问一个被 \\\"synchronized\\\" 关键字修饰的方法或代码块时，它会尝试获取该对象的监视器锁。如果该锁已经被其他线程持有，则该线程将被阻塞，直到该锁被释放。在 Java 中，每个对象都有一个监视器锁，也称为内部锁或互斥锁。当一个线程获取了一个对象的监视器锁后，其他线程就无法访问该对象的被 \\\"synchronized\\\" 关键字修饰的方法或代码块，直到该锁被释放。\",\"在 Java 中，\\\"synchronized\\\" 关键字的实现是基于对象头中的标记字。当一个对象被锁定时，它的标记字会被设置为锁定状态，当锁被释放时，标记字会被清除。在 Java 6 及之前的版本中，对象头中的标记字是 32 位的，其中 25 位用于存储对象的哈希码，4 位用于存储对象的分代年龄，2 位用于存储锁标志位，1 位用于存储是否是偏向锁。在 Java 7 及之后的版本中，对象头中的标记字被重新设计，其中 32 位用于存储对象的哈希码和分代年龄，而锁标志位则被存储在一个单独的数据结构中。\",\"： 很好，你的回答很详细。那么，你能够给我讲讲 \\\"synchronized\\\" 关键字的优化策略吗？\",\" 当然。在 Java 中，\\\"synchronized\\\" 关键字的性能开销比较大，因为每个线程都需要获取锁才能访问被修饰的代码。为了优化 \\\"synchronized\\\" 关键字的性能，Java 6 及之后的版本中引入了偏向锁、轻量级锁和重量级锁等优化策略。\",\"偏向锁是一种针对单线程访问同步块的优化策略。当一个线程访问一个被 \\\"synchronized\\\" 关键字修饰的代码块时，它会尝试获取该对象的偏向锁。如果该锁没有被其他线程持有，则该线程可以直接获取该锁，而无需进行同步操作。如果该锁已经被其他线程持有，则该线程会尝试升级为轻量级锁或重量级锁。\",\"轻量级锁是一种针对多线程访问同步块的优化策略。当一个线程访问一个被 \\\"synchronized\\\" 关键字修饰的代码块时，它会尝试获取该对象的轻量级锁。如果该锁没有被其他线程持有，则该线程可以直接获取该锁，而无需进行同步操作。如果该锁已经被其他线程持有，则该线程会尝试自旋等待该锁的释放。\",\"重量级锁是一种针对多线程访问同步块的默认策略。当一个线程访问一个被 \\\"synchronized\\\" 关键字修饰的代码块时，它会尝试获取该对象的重量级锁。如果该锁没有被其他线程持有，则该线程可以直接获取该锁，而无需进行同步操作。如果该锁已经被其他线程持有，则该线程会被阻塞，直到该锁被释放。\",\"： 很好，你的回答很详细。那么，你能够给我讲讲 \\\"synchronized\\\" 关键字的底层 Java 源码实现吗？\",\" 当然。在 Java 中，\\\"synchronized\\\" 关键字的底层实现是通过 monitorenter 和 monitorexit 指令来实现的。当一个线程访问一个被 \\\"synchronized\\\" 关键字修饰的方法或代码块时，它会尝试获取该对象的监视器锁，这可以通过 monitorenter 指令来实现。当该线程执行完被 \\\"synchronized\\\" 关键字修饰的方法或代码块后，它会释放该对象的监视器锁，这可以通过 monitorexit 指令来实现。\"]},\"1023\":{\"h\":\"参考底层指令：\",\"t\":[\"以下是 JVM 中与 \\\"synchronized\\\" 相关的源码：\",\"monitorenter 指令的实现：\",\"void Interpreter::monitorenter() { oop obj = stack_top().get_obj(); // 获取栈顶元素，即被锁定的对象 if (obj == NULL) { // 如果对象为空，则抛出 NullPointerException 异常 THROW(vmSymbols::java_lang_NullPointerException()); } BasicLock* lock = obj->mark()->lock(); // 获取对象的锁 if (lock->displaced_header() == NULL) { // 如果锁没有被其他线程持有，则尝试获取锁 // Fast path: lock is unheld, try to acquire it if (lock->displaced_header() == NULL && lock->displaced_owner() == NULL && lock->set_displaced_header()) { // Lock acquired return; // 获取锁成功，直接返回 } } // Slow path: lock is held or contention detected InterpreterRuntime::monitorenter(THREAD, obj); // 获取锁失败，调用 InterpreterRuntime::monitorenter() 方法进行同步操作 }\",\"在上面的代码中，monitorenter 指令的实现是通过获取对象的锁来实现的。如果该锁没有被其他线程持有，则该线程可以直接获取该锁，而无需进行同步操作。如果该锁已经被其他线程持有，则该线程会尝试升级为轻量级锁或重量级锁。\",\"monitorexit 指令的实现：\",\"void Interpreter::monitorexit() { oop obj = stack_top().get_obj(); // 获取栈顶元素，即被锁定的对象 if (obj == NULL) { // 如果对象为空，则抛出 NullPointerException 异常 THROW(vmSymbols::java_lang_NullPointerException()); } BasicLock* lock = obj->mark()->lock(); // 获取对象的锁 if (lock->displaced_header() == THREAD) { // 如果锁被当前线程持有，则直接释放锁 // Fast path: lock is held by this thread, release it lock->clear_displaced_header(); return; // 释放锁成功，直接返回 } // Slow path: lock is held by another thread or unheld InterpreterRuntime::monitorexit(THREAD, obj); // 释放锁失败，调用 InterpreterRuntime::monitorexit() 方法进行同步操作 }\",\"在上面的代码中，monitorexit 指令的实现是通过释放对象的锁来实现的。如果该锁被当前线程持有，则该线程可以直接释放该锁，而无需进行同步操作。如果该锁被其他线程持有，则该线程会被阻塞，直到该锁被释放。\",\"ObjectMonitor 类的实现：\",\"class ObjectMonitor : public CHeapObj<mtSynchronizer> { friend class VMStructs; private: volatile intptr_t _header; // 对象头，用于存储锁状态和其他信息 volatile intptr_t _count; // 计数器，用于记录重入次数 volatile intptr_t _waiters; // 等待队列长度，用于记录等待锁的线程数 volatile intptr_t _recursions; // 递归深度，用于记录当前线程已经获取锁的次数 volatile intptr_t _object; // 对象指针，指向被锁定的对象 volatile intptr_t _owner; // 持有者指针，指向当前持有锁的线程 volatile intptr_t _WaitSet; // 等待队列头指针，指向等待队列的头节点 volatile intptr_t _EntryList; // 等待队列尾指针，指向等待队列的尾节点 volatile intptr_t _cxq; // 等待队列的条件变量，用于支持条件变量的等待和唤醒操作 volatile intptr_t _FreeNext; // 空闲链表指针，用于回收 ObjectMonitor 对象 volatile intptr_t _Responsible; // 责任线程指针，用于记录最后一个释放锁的线程 volatile intptr_t _SpinFreq; // 自旋频率，用于控制自旋等待的时间 volatile intptr_t _SpinClock; // 自旋时钟，用于记录自旋等待的时间 volatile intptr_t _SpinDuration; // 自旋持续时间，用于控制自旋等待的时间 volatile intptr_t _SpinEarly; // 自旋提前量，用于控制自旋等待的时间 volatile intptr_t _contentions; // 竞争次数，用于记录获取锁的竞争次数 volatile intptr_t _succ; // 成功次数，用于记录获取锁的成功次数 volatile intptr_t _cxqWaitTime; // 条件变量等待时间，用于记录条件变量等待的时间 volatile intptr_t _reserved; // 保留字段，用于未来扩展 static int _header_offset; // 对象头偏移量，用于访问对象头中的信息 static int _count_offset; // 计数器偏移量，用于访问计数器中的信息 static int _waiters_offset; // 等待队列长度偏移量，用于访问等待队列长度中的信息 static int _recursions_offset; // 递归深度偏移量，用于访问递归深度中的信息 static int _object_offset; // 对象指针偏移量，用于访问对象指针中的信息 static int _owner_offset; // 持有者指针偏移量，用于访问持有者指针中的信息 static int _WaitSet_offset; // 等待队列头指针偏移量，用于访问等待队列头指针中的信息 static int _EntryList_offset; // 等待队列尾指针偏移量，用于访问等待队列尾指针中的信息 static int _cxq_offset; // 条件变量偏移量，用于访问条件变量中的信息 static int _FreeNext_offset; // 空闲链表指针偏移量，用于访问空闲链表指针中的信息 static int _Responsible_offset; // 责任线程指针偏移量，用于访问责任线程指针中的信息 static int _SpinFreq_offset; // 自旋频率偏移量，用于访问自旋频率中的信息 static int _SpinClock_offset; // 自旋时钟偏移量，用于访问自旋时钟中的信息 static int _SpinDuration_offset; // 自旋持续时间偏移量，用于访问自旋持续时间中的信息 static int _SpinEarly_offset; // 自旋提前量偏移量，用于访问自旋提前量中的信息 static int _contentions_offset; // 竞争次数偏移量，用于访问竞争次数中的信息 static int _succ_offset; // 成功次数偏移量，用于访问成功次数中的信息 static int _cxqWaitTime_offset; // 条件变量等待时间偏移量，用于访问条件变量等待时间中的信息 static int _reserved_offset; // 保留字段偏移量，用于访问保留字段中的信息 ... };\",\"在上面的代码中，ObjectMonitor 类是 JVM 中与 \\\"synchronized\\\" 相关的核心类之一。它包含了对象的监视器锁的状态信息，例如锁的持有者、等待队列、递归深度等。在 Java 中，每个对象都有一个 ObjectMonitor 对象与之对应，用于实现 \\\"synchronized\\\" 关键字的同步机制。\",\"： 很好，你的回答很全面，你已进入候补名单。有消息会通知你。\",\" 源码都背下来了，你给我看这。\",\"最近我在更新《面试1v1》系列文章，主要以场景化的方式，讲解我们在面试中遇到的问题，致力于让每一位工程师拿到自己心仪的offer，感兴趣可以关注公众号JavaPub追更！\",\"🎁目录合集：\",\"Gitee：https://gitee.com/rodert/JavaPub\",\"GitHub：https://github.com/Rodert/JavaPub\",\"http://javapub.net.cn\"]},\"1024\":{\"c\":[\"《面试1v1》\"]},\"1025\":{\"h\":\"《面试1v1》\"},\"1026\":{\"h\":\"10道不得不会的 Http 面试题\",\"t\":[\"Http\",\"10道不得不会的 Http 面试题\",\"我是 JavaPub，专注于面试、副业，技术人的成长记录。\",\"以下是 Http 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub 在这里整理这些容易忘记的重点知识及 解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\",\"本系列《最少必要面试题》\"]},\"1027\":{\"h\":\"1. 什么是 http ?\",\"t\":[\"http 和 https 有什么区别？\",\"cookies 机制和 session 机制的区别是什么？\",\"GET 和 POST 的区别？\",\"什么是Http协议无状态协议？怎么解决Http协议无状态协议？\",\"你知道 http 中有哪些状态码？它们代表什么含义\",\"开放性题目，尽量说自己了解的。\",\"302,404\",\"http 协议由哪几部分组成？\",\"Http协议中有那些请求方式？\",\"也就是我们常说的 RESTFul 请求方式。\",\"TCP和UDP的区别？\",\"10 . 说一下 https 请求的整个过程\",\"低谷蓄力\",\"《最少必要面试题》\",\"10道不得不会的Java基础面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的Netty面试题\"]},\"1028\":{\"c\":[\"最少必要面试题\"]},\"1029\":{\"c\":[\"http\",\"面试题\"]},\"1030\":{\"h\":\"10道不得不会的 Netty 面试题\",\"t\":[\"Netty\",\"10道不得不会的 Netty 面试题\",\"我是 JavaPub，专注于面试、副业，技术人的成长记录。\",\"以下是 Netty 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub 在这里整理这些容易忘记的重点知识及 解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\",\"https://baijiahao.baidu.com/s?id=1669639041722396699&wfr=spider&for=pc\",\"https://blog.csdn.net/pgving/article/details/124781454\",\"本系列《最少必要面试题》\",\"如果你对 Netty 还不是很了解，可以先运行一个 Demo 试试，地址：https://gitee.com/rodert/SpringBoot-javapub\"]},\"1031\":{\"h\":\"1. 什么是Netty ?\",\"t\":[\"Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端。\",\"用官方的总结就是：Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。\",\"注意：netty 的异步还是基于多路复用的，并没有实现真正意义上的异步 IO\"]},\"1032\":{\"h\":\"为什么要用 Netty 呢？说一下自己的看法。\",\"t\":[\"因为 Netty 具有下面这些优点，并且相比于直接使用 JDK 自带的 NIO 相关的 API 来说更加易用。\",\"统一的 API，支持多种传输类型，阻塞和非阻塞的。\",\"简单而强大的线程模型。\",\"自带编解码器解决 TCP 粘包/拆包问题。\",\"自带各种协议栈。\",\"真正的无连接数据包套接字支持。\",\"比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。\",\"安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持。\",\"社区活跃\",\"成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty， 比如我们经常接触的 Dubbo、RocketMQ 等等。\"]},\"1033\":{\"h\":\"Netty 应用场景了解么？\",\"t\":[\"凭借自己的了解，简单说一下吧！理论上来说，NIO 可以做的事情 ，使用 Netty 都可以做并且更好。Netty 主要用来做 **网络通信 ** :\",\"作为 RPC 框架的网络通信工具 ：我们在分布式系统中，不同服务节点之间经常需要相互调用，这个时候就需要 RPC 框架了。不同服务节点之间的通信是如何做的呢？可以使用 Netty 来做。\",\"实现一个自己的 HTTP 服务器 ：通过 Netty 我们可以自己实现一个简单的 HTTP 服务器，这个大家应该不陌生。说到 HTTP 服务器的话，作为 Java 后端开发，我们一般使用 Tomcat 比较多。一个最基本的 HTTP 服务器可要以处理常见的 HTTP Method 的请求，比如 POST 请求、GET 请求等等。\",\"实现一个即时通讯系统 ：使用 Netty 我们可以实现一个可以聊天类似微信的即时通讯系统\",\"实现消息推送系统 ：市面上有很多消息推送系统都是基于 Netty 来做的。\",\"在理解核心组件以前，建议先用文末的代码Demo练下手。\"]},\"1034\":{\"h\":\"Netty 核心组件有哪些？分别有什么作用？\",\"t\":[\"Bootstrap & ServerBootstrap：客户端和服务端的引导类\",\"Channel：代表了一个链接，与EventLoop一起用来参与IO处理。\",\"ChannelFuture：Netty 为异步非阻塞，即所有的 I/O 操作都为异步的，因此，我们不能立刻得知消息是否已经被处理了。Netty 提供了 ChannelFuture 接口，通过该接口的 addListener() 方法注册一个 ChannelFutureListener，当操作执行成功或者失败时，监听就会自动触发返回结果。\",\"EventLoop & EventLoopGroup：Channel处理IO操作，一个EventLoop可以为多个Channel服务。而一个EventLoopGroup会包含多个EventLoop。\",\"ChannelHandler：为了支持各种协议和处理数据的方式，便诞生了Handler组件。Handler主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。\",\"ChannelPipeline：提供了 ChannelHandler 链的容器，并定义了用于在该链上传播入站 和出站事件流的 API。\",\"image\"]},\"1035\":{\"h\":\"\"},\"1036\":{\"h\":\"\",\"t\":[\"低谷蓄力\",\"《最少必要面试题》\",\"10道不得不会的Java基础面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的Netty面试题\"]},\"1037\":{\"c\":[\"最少必要面试题\"]},\"1038\":{\"c\":[\"netty\",\"面试题\"]},\"1039\":{\"h\":\"《最少必要面试题》\",\"t\":[\"背最少的面试题，拿最多的 offer。\"]},\"1040\":{\"c\":[\"《最少必要面试题》\"]},\"1041\":{\"h\":\"10道不得不会的缓存面试题\",\"t\":[\"缓存\",\"10道不得不会的 缓存 面试题\",\"以下是 缓存 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\",\"说到缓存，首先你一定要对 Java容器、和 Redis 有一定了解，建议阅读《最少必要面试题》： 【Java容器篇】【Redis篇】\"]},\"1042\":{\"h\":\"1. 什么是缓存？\",\"t\":[\"缓存，就是数据交换的缓冲区，针对服务对象的不同（本质就是不同的硬件）都可以构建缓存。而我们平时说的缓存，大多是指内存。\",\"目的是， 把读写速度【慢】的介质的数据保存在读写速度【快】的介质中，从而提高读写速度，减少时间消耗。 例如：\",\"CPU 高速缓存 ：高速缓存的读写速度远高于内存。 \",\"CPU 读数据时，如果在高速缓存中找到所需数据，就不需要读内存\",\"CPU 写数据时，先写到高速缓存，再回写到内存。\",\"磁盘缓存：磁盘缓存其实就把常用的磁盘数据保存在内存中，内存读写速度也是远高于磁盘的。 \",\"读数据，时从内存读取。\",\"写数据时，可先写到内存，定时或定量回写到磁盘，或者是同步回写。\"]},\"1043\":{\"h\":\"2. 为什么要用缓存？\",\"t\":[\"使用缓存的目的，就是提升读写性能。而实际业务场景下，更多的是为了提升读性能，带来更好的性能，更高的并发量。\",\"日常业务中，我们使用比较多的数据库是 MySQL ，缓存是 Redis 。Redis 比 MySQL 的读写性能好很多。那么，我们将 MySQL 的热点数据，缓存到 Redis 中，提升读取性能，也减小 MySQL 的读取压力。例如说：\",\"论坛帖子的访问频率比较高，且要实时更新阅读量，使用 Redis 记录帖子的阅读量，可以提升性能和并发。\",\"商品信息，数据更新的频率不高，但是读取的频率很高，特别是热门商品。\"]},\"1044\":{\"h\":\"3. 请说说有哪些缓存算法？是否能手写一下 LRU 代码的实现？\",\"t\":[\"缓存算法，比较常见的是三种：\",\"LRU（least recently used ，最近最少使用)\",\"LFU（Least Frequently used ，最不经常使用)\",\"FIFO（first in first out ，先进先出)\",\"这里我们可以借助 LinkedHashMap 实现\",\"public class LRULinkedMap<K,V> { /** * 最大缓存大小 */ private int cacheSize; private LinkedHashMap<K,V> cacheMap ; public LRULinkedMap(int cacheSize) { this.cacheSize = cacheSize; cacheMap = new LinkedHashMap(16,0.75F,true){ @Override protected boolean removeEldestEntry(Map.Entry eldest) { if (cacheSize + 1 == cacheMap.size()){ return true ; }else { return false ; } } }; } public void put(K key,V value){ cacheMap.put(key,value) ; } public V get(K key){ return cacheMap.get(key) ; } public Collection<Map.Entry<K, V>> getAll() { return new ArrayList<Map.Entry<K, V>>(cacheMap.entrySet()); } }\",\"使用案例：\",\" @Test public void put() throws Exception { LRULinkedMap<String,Integer> map = new LRULinkedMap(3) ; map.put(\\\"1\\\",1); map.put(\\\"2\\\",2); map.put(\\\"3\\\",3); for (Map.Entry<String, Integer> e : map.getAll()){ System.out.print(e.getKey() + \\\" : \\\" + e.getValue() + \\\"\\\\t\\\"); } System.out.println(\\\"\\\"); map.put(\\\"4\\\",4); for (Map.Entry<String, Integer> e : map.getAll()){ System.out.print(e.getKey() + \\\" : \\\" + e.getValue() + \\\"\\\\t\\\"); } } //输出 1 : 1 2 : 2 3 : 3 2 : 2 3 : 3 4 : 4\"]},\"1045\":{\"h\":\"4. 常见的常见的缓存工具和框架有哪些？\",\"t\":[\"在 Java 后端开发中，常见的缓存工具和框架列举如下：\",\"本地缓存：Guava LocalCache、Ehcache、Caffeine 。\",\"Ehcache 的功能更加丰富，Caffeine 的性能要比 Guava LocalCache 好。\",\"分布式缓存：Redis、Memcached、Tair 。\",\"Redis 最为主流和常用。\"]},\"1046\":{\"h\":\"5. 用了缓存之后，有哪些常见问题？\",\"t\":[\"常见的问题，可列举如下：\",\"写入问题\",\"缓存何时写入？并且写时如何避免并发重复写入？\",\"缓存如何失效？\",\"缓存和 DB 的一致性如何保证？\",\"经典三连问\",\"如何避免缓存穿透的问题？\",\"如何避免缓存击穿的问题？\",\"如果避免缓存雪崩的问题？\"]},\"1047\":{\"h\":\"6. 如何处理缓存穿透的问题\",\"t\":[\"缓存穿透，是指查询一个一定不存在的数据，由于缓存是不命中时被动写，并且处于容错考虑，如果从 DB 查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，失去了缓存的意义。\",\"在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。如下图：\",\"缓存穿透\",\"如何解决\",\"有两种方案可以解决：\",\"方案一，缓存空对象。 当从 DB 查询数据为空，我们仍然将这个空结果进行缓存，具体的值需要使用特殊的标识，能和真正缓存的数据区分开。另外，需要设置较短的过期时间，一般建议不要超过 5 分钟。\",\"方案二，BloomFilter 布隆过滤器。 在缓存服务的基础上，构建 BloomFilter 数据结构，在 BloomFilter 中存储对应的 KEY 是否存在，如果存在，说明该 KEY 对应的值不为空。\",\"如何选择\",\"这两个方案，各有其优缺点。\",\"缓存空对象\",\"BloomFilter 布隆过滤器\",\"适用场景\",\"1、数据命中不高 2、保证一致性\",\"1、数据命中不高, 2、数据相对固定、实时性低\",\"维护成本\",\"1、代码维护简单 2、需要过多的缓存空间 3、数据不一致\",\"1、代码维护复杂，2、缓存空间占用小\",\"实际情况下，使用方案二比较多。因为，相比方案一来说，更加节省内容，对缓存的负荷更小。\"]},\"1048\":{\"h\":\"7. 如何处理缓存雪崩的问题\",\"t\":[\"缓存雪崩，是指缓存由于某些原因无法提供服务( 例如，缓存挂掉了 )，所有请求全部达到 DB 中，导致 DB 负荷大增，最终挂掉的情况。\",\"如何解决\",\"预防和解决缓存雪崩的问题，可以从以下多个方面进行共同着手。\",\"缓存高可用：通过搭建缓存的高可用，避免缓存挂掉导致无法提供服务的情况，从而降低出现缓存雪崩的情况。假设我们使用 Redis 作为缓存，则可以使用 Redis Sentinel 或 Redis Cluster 实现高可用。\",\"本地缓存：如果使用本地缓存时，即使分布式缓存挂了，也可以将 DB 查询到的结果缓存到本地，避免后续请求全部到达 DB 中。如果我们使用 JVM ，则可以使用 Ehcache、Guava Cache 实现本地缓存的功能。\",\"当然，引入本地缓存也会有相应的问题，例如说：\",\"本地缓存的实时性怎么保证？ 方案一，可以引入消息队列。在数据更新时，发布数据更新的消息；而进>程中有相应的消费者消费该消息，从而更新本地缓存。 方案二，设置较短的过期时间，请求时从 DB 重新拉取。 方案三，手动过期。\",\"请求 DB 限流: 通过限制 DB 的每秒请求数，避免把 DB 也打挂了。如果我们使用 Java ，则可以使用 Guava RateLimiter、Sentinel、Hystrix 实现限流的功能。这样至少能有两个好处：\",\"可能有一部分用户，还可以使用，系统还没死透。\",\"未来缓存服务恢复后，系统立即就已经恢复，无需再处理 DB 也挂掉的情况。\",\"提前演练：在项目上线前，演练缓存宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。\"]},\"1049\":{\"h\":\"8. 如何处理缓存击穿的问题\",\"t\":[\"缓存击穿，是指某个极度“热点”数据在某个时间点过期时，恰好在这个时间点对这个 KEY 有大量的并发请求过来，这些请求发现缓存过期一般都会从 DB 加载数据并回设到缓存，但是这个时候大并发的请求可能会瞬间 DB 压垮。\",\"对于一些设置了过期时间的 KEY ，如果这些 KEY 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑这个问题。\",\"区别： \",\"和缓存“雪崩“”的区别在于，前者针对某一 KEY 缓存，后者则是很多 KEY 。\",\"和缓存“穿透“”的区别在于，这个 KEY 是真实存在对应的值的。\",\"如何解决\",\"有两种方案可以解决：\",\"方案一，使用互斥锁。请求发现缓存不存在后，去查询 DB 前，使用分布式锁，保证有且只有一个线程去查询 DB ，并更新到缓存。\",\"方案二，手动过期。缓存上从不设置过期时间，功能上将过期时间存在 KEY 对应的 VALUE 里。流程如下：\",\"获取缓存。通过 VALUE 的过期时间，判断是否过期。如果未过期，则直接返回；如果已过期，继续往下执行。\",\"通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。通过后台的异步线程，保证有且只有一个线程去查询 DB。\",\"同时，虽然 VALUE 已经过期，还是直接返回。通过这样的方式，保证服务的可用性，虽然损失了一定的时效性。\",\"选择\",\"这两个方案，各有其优缺点。\",\"使用互斥锁\",\"手动过期\",\"优点\",\"1、思路简单 2、保证一致性\",\"1、性价最佳，用户无需等待\",\"缺点\",\"1、代码复杂度增大 2、存在死锁的风险\",\"1、无法保证缓存一致性\"]},\"1050\":{\"h\":\"9. 缓存和 DB 的一致性如何保证？\",\"t\":[\"产生原因\",\"主要有两种情况，会导致缓存和 DB 的一致性问题：\",\"并发的场景下，导致读取老的 DB 数据，更新到缓存中。\",\"主要指的是，更新 DB 数据之前，先删除 Cache 的数据。在低并发量下没什么问题，但是在高并发下，就会存在问题。在(删除 Cache 的数据, 和更新 DB 数据)时间之间，恰好有一个请求，我们如果使用被动读，因为此时 DB 数据还是老的，又会将老的数据写入到 Cache 中。\",\"缓存和 DB 的操作，不在一个事务中，可能只有一个 DB 操作成功，而另一个 Cache 操作失败，导致不一致。\",\"当然，有一点我们要注意，缓存和 DB 的一致性，我们指的更多的是最终一致性。我们使用缓存只要是提高读操作的性能，真正在写操作的业务逻辑，还是以数据库为准。例如说，我们可能缓存用户钱包的余额在缓存中，在前端查询钱包余额时，读取缓存，在使用钱包余额时，读取数据库。\",\"解决方案\",\"在开始说解决方案之前，胖友先看看如下几篇文章，可能有一丢丢多，保持耐心。\",\"当然无论哪种方案，比较重要的就是解决两个问题：\",\"将缓存可能存在的并行写，实现串行写。\",\"实现数据的最终一致性。\",\"先淘汰缓存，再写数据库 因为先淘汰缓存，所以数据的最终一致性是可以得到有效的保证的。为什么呢？先淘汰缓存，即使写数据库发生异常，也就是下次缓存读取时，多读取一次数据库。\",\"那么，我们需要解决缓存并行写，实现串行写。比较简单的方式，引入分布式锁。\",\"在写请求时，先淘汰缓存之前，先获取该分布式锁。\",\"在读请求时，发现缓存不存在时，先获取分布式锁。\",\"先写数据库，再更新缓存\",\"按照 “先写数据库，再更新缓存”，我们要保证 DB 和缓存的操作，能够在 “同一个事务”中，从而实现最终一致性\"]},\"1051\":{\"h\":\"10. 什么是缓存预热？如何实现缓存预热？\",\"t\":[\"缓存预热\",\"在刚启动的缓存系统中，如果缓存中没有任何数据，如果依靠用户请求的方式重建缓存数据，那么对数据库的压力非常大，而且系统的性能开销也是巨大的。\",\"此时，最好的策略是启动时就把热点数据加载好。这样，用户请求时，直接读取的就是缓存的数据，而无需去读取 DB 重建缓存数据。举个例子，热门的或者推荐的商品，需要提前预热到缓存中。\",\"如何实现\",\"一般来说，有如下几种方式来实现：\",\"数据量不大时，项目启动时，自动进行初始化。\",\"写个修复数据脚本，手动执行该脚本。\",\"写个管理界面，可以手动点击，预热对应的数据到缓存中。\"]},\"1052\":{\"h\":\"拓展：缓存数据的淘汰策略有哪些？\",\"t\":[\"除了缓存服务器自带的缓存自动失效策略之外，我们还可以根据具体的业务需求进行自定义的“手动”缓存淘汰，常见的策略有两种：\",\"定时去清理过期的缓存。\",\"当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。\",\"两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！Redis 的缓存淘汰策略就是很好的实践方式。\",\"具体用哪种方案，大家可以根据自己的应用场景来权衡。\"]},\"1053\":{\"h\":\"推荐阅读：\",\"t\":[\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\"]},\"1054\":{\"c\":[\"最少必要面试题\"]},\"1055\":{\"c\":[\"缓存\",\"面试题\"]},\"1056\":{\"h\":\"10道不得不会的 Docker 面试题\",\"t\":[\"Docker\",\"10道不得不会的 Docker 面试题\",\"我是JavaPub，专注于面试、副业，技术人的成长记录。\",\"以下是 Docker 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\",\"以下是一些docker的基础面试题，下一篇docker进阶面试题。本系列《最少必要面试题》\"]},\"1057\":{\"h\":\"1. 什么是 Docker 容器？\",\"t\":[\"Docker 是一种流行的开源软件平台，可简化创建、管理、运行和分发应用程序的过程。它使用容器来打包应用程序及其依赖项。我们也可以将容器视为 Docker 镜像的运行时实例。\"]},\"1058\":{\"h\":\"2. Docker 和虚拟机有什么不同？\",\"t\":[\"Docker 是轻量级的沙盒，在其中运行的只是应用，虚拟机里面还有额外的系统。\"]},\"1059\":{\"h\":\"3. 什么是 DockerFile？\",\"t\":[\"Dockerfile 是一个文本文件，其中包含我们需要运行以构建 Docker 镜像的所有命令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。Docker 使用 Dockerfile 中的指令自动构建镜像。我们可以 docker build 用来创建按顺序执行多个命令行指令的自动构建。\",\"一些最常用的指令如下：\",\"FROM ：使用 FROM 为后续的指令建立基础映像。在所有有效的 Dockerfile 中， FROM 是第一条指令。 LABEL： LABEL 指令用于组织项目映像，模块，许可等。在自动化布署方面 LABEL 也有很大用途。在 LABEL 中指定一组键值对，可用于程序化配置或布署 Docker 。 RUN： RUN 指令可在映像当前层执行任何命令并创建一个新层，用于在映像层中添加功能层，也许最来的层会依赖它。 CMD： 使用 CMD 指令为执行的容器提供默认值。在 Dockerfile 文件中，若添加多个 CMD 指令，只有最后的 CMD 指令运行。\"]},\"1060\":{\"h\":\"4. 使用Docker Compose时如何保证容器A先于容器B运行？\",\"t\":[\"Docker Compose 是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。Compose 通过一个配置文件来管理多个Docker容器。简单理解：Docker Compose 是docker的管理工具。\",\"Docker Compose 在继续下一个容器之前不会等待容器准备就绪。为了控制我们的执行顺序，我们可以使用“取决于”条件，depends_on 。这是在 docker-compose.yml 文件中使用的示例\",\"version: \\\"2.4\\\" services: backend: build: . # 构建自定义镜像 depends_on: - db db: image: mysql\",\"用 docker-compose up 命令将按照我们指定的依赖顺序启动和运行服务。\"]},\"1061\":{\"h\":\"5. 一个完整的Docker由哪些部分组成?\",\"t\":[\"DockerClient 客户端\",\"Docker Daemon 守护进程\",\"Docker Image 镜像\",\"DockerContainer 容器\"]},\"1062\":{\"h\":\"6. docker常用命令\",\"t\":[\"命令建议在本地安装做一个实操，记忆会更深刻。 也可以克隆基于docker的俩万（springboot+vue）项目练手，提供视频+完善文档。地址：https://gitee.com/rodert/liawan-vue\",\"查看本地主机的所用镜像：`docker images``\",\"搜索镜像：`docker search mysql``\",\"下载镜像：docker pull mysql，没写 tag 就默认下载最新的 lastest\",\"下载指定版本的镜像：`docker pull mysql:5.7``\",\"删除镜像：`docker rmi -f 镜像id 镜像id 镜像id``\"]},\"1063\":{\"h\":\"7. 描述 Docker 容器的生命周期。\",\"t\":[\"Docker 容器经历以下阶段：\",\"创建容器\",\"运行容器\",\"暂停容器（可选）\",\"取消暂停容器（可选）\",\"启动容器\",\"停止容器\",\"重启容器\",\"杀死容器\",\"销毁容器\"]},\"1064\":{\"h\":\"8. docker容器之间怎么隔离?\",\"t\":[\"这是一道涉猎很广泛的题目，理解性阅读。\",\"Linux中的PID、IPC、网络等资源是全局的，而Linux的NameSpace机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰。\",\"​​**Namespace实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容​​。**对于宿主机来说，这些被“隔离”了的进程跟其他进程并没有区别。\",\"虽然有了NameSpace技术可以实现资源隔离，但进程还是可以不受控的访问系统资源，比如CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker采用control groups技术(也就是cgroup)，有了cgroup就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些CPU上运行等等。\",\"有了这两项技术，容器看起来就真的像是独立的操作系统了。\",\"强烈建议大家实操，才能更好的理解docker。\",\"低谷蓄力\",\"《最少必要面试题》\",\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\"]},\"1065\":{\"c\":[\"最少必要面试题\"]},\"1066\":{\"c\":[\"docker\",\"面试题\"]},\"1067\":{\"h\":\"10道不得不会的ElasticSearch面试题\",\"t\":[\"Elastic Search\",\"10道不得不会的ElasticSearch面试题\",\"以下是 ElasticSearch 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"关于es的面试，建议使用名词用官方语言描述会更准确。\",\"@[toc]\"]},\"1068\":{\"h\":\"1. 说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段 。\",\"t\":[\"节点数、分片数、副本数，尽量根据自己公司使用情况回答，当然适当放大也可行。\",\"调优手段是现在很常见的面试题，下面这几种调优手段一定要了解懂。当然，下面的每一条都可以当做调优的一部分。\",\"设计调优\",\"参考： https://www.cnblogs.com/sanduzxcvbnm/p/12084012.html\",\"a. 根据业务增量需求，采取基于日期模板创建索引，通过 rollover API 滚动索引；(rollover API我会单独写一个代码案例做讲解，公众号：JavaPub) b. 使用别名进行索引管理；（es的索引名不能改变，提供的别名机制使用非常广泛。） c. 每天凌晨定时对索引做force_merge操作，以释放空间； d. 采取冷热分离机制，热数据存储到SSD，提高检索效率；冷数据定期进行shrink操作，以缩减存储； e. 采取curator进行索引的生命周期管理； f. 仅针对需要分词的字段，合理的设置分词器； g. Mapping阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。\",\"进100+原创文章：https://gitee.com/rodert/JavaPub\",\"写入调优\",\"写入前副本数设置为0；\",\"写入前关闭refresh_interval设置为-1，禁用刷新机制；\",\"写入过程中：采取bulk批量写入；\",\"写入后恢复副本数和刷新间隔；\",\"尽量使用自动生成的id。\",\"查询调优\",\"禁用wildcard；（通配符模式，类似于%like%）\",\"禁用批量terms（成百上千的场景）；\",\"充分利用倒排索引机制，能keyword类型尽量keyword；\",\"数据量大时候，可以先基于时间敲定索引再检索；\",\"设置合理的路由机制。\"]},\"1069\":{\"h\":\"2. elasticsearch 的倒排索引是什么\",\"t\":[\"倒排索引也就是单词到文档的映射，当然不只是存里文档id这么简单。还包括：词频（TF，Term Frequency）、偏移量（offset）、位置（Posting）。\"]},\"1070\":{\"h\":\"3. elasticsearch 是如何实现 master 选举的\",\"t\":[\"ElasticSearch 的选主是 ZenDiscovery 模块负责，源码分析将首发在。 https://gitee.com/rodert/JavaPub\",\"对所有可以成为 Master 的节点（node.master: true）根据 nodeId 排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是 Master 节点。\",\"如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举。 (当然也可以自己设定一个值，最小值设定为超过能成为Master节点的n/2+1，否则会出现脑裂问题。discovery.zen.minimum_master_nodes)\"]},\"1071\":{\"h\":\"4. 描述一下 Elasticsearch 索引文档的过程\",\"t\":[\"客户端向 Node 1 发送新建、索引或者删除请求。\",\"节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。\",\"Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。\",\"一图胜千文，记住这幅图，上面是文档在节点间分发的过程，接着说一下文档从接收到写入磁盘过程。 协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合适的分片。\",\"shard = hash(document_id) % (num_of_primary_shards)\",\"当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 MemoryBuffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 MomeryBuffer 到 Filesystem Cache 的过程就叫做 refresh；\",\"当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失，ES 是通过 translog 的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystem cache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；\",\"在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。\",\"flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；\",\"1. translog 可以理解为就是一个文件，一直追加。 2. MemoryBuffer 应用缓存。 3. Filesystem Cache 系统缓冲区。\",\"延伸阅读：Lucene 的 Segement:\",\"Lucene 索引是由多个段组成，段本身是一个功能齐全的倒排索引。\",\"段是不可变的，允许 Lucene 将新的文档增量地添加到索引中，而不用从头重建索引。\",\"对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗CPU 的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。\",\"为了解决这个问题，Elasticsearch 会合并小段到一个较大的段，提交新的合并段到磁盘，并删除那些旧的小段。\"]},\"1072\":{\"h\":\"5. 详细描述一下 Elasticsearch 搜索的过程？\",\"t\":[\"es作为一个分布式的存储和检索系统，每个文档根据 _id 字段做路由分发被转发到对应的shard上。\",\"搜索执行阶段过程分俩个部分，我们称之为 Query Then Fetch。\",\"5.1 query-查询阶段\",\"当一个search请求发出的时候，这个query会被广播到索引里面的每一个shard（主shard或副本shard），每个shard会在本地执行查询请求后会生成一个命中文档的优先级队列。\",\"这个队列是一个排序好的top N数据的列表，它的size等于from+size的和，也就是说如果你的from是10，size是10，那么这个队列的size就是20，所以这也是为什么深度分页不能用from+size这种方式，因为from越大，性能就越低。\",\"es里面分布式search的查询流程如下：\",\"es里面分布式search的查询流程\",\"查询阶段包含以下三个步骤:\",\"客户端发送一个 search 请求到 Node 3 ， Node 3 会创建一个大小为 from + size 的空优先队列。\",\"Node 3 将查询请求转发到索引的每个主分片或副本分片中。每个分片在本地执行查询并添加结果到大小为 from + size 的本地有序优先队列中。\",\"每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，也就是 Node 3 ，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。\",\"5.2 fetch - 读取阶段 / 取回阶段\",\"分布式阶段由以下步骤构成：\",\"协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。\",\"每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。\",\"一旦所有的文档都被取回了，协调节点返回结果给客户端。\",\"协调节点首先决定哪些文档 确实 需要被取回。例如，如果我们的查询指定了 { \\\"from\\\": 90, \\\"size\\\": 10 } ，最初的90个结果会被丢弃，只有从第91个开始的10个结果需要被取回。这些文档可能来自和最初搜索请求有关的一个、多个甚至全部分片。\",\"协调节点给持有相关文档的每个分片创建一个 multi-get request ，并发送请求给同样处理查询阶段的分片副本。\",\"分片加载文档体-- _source 字段—​如果有需要，用元数据和 search snippet highlighting 丰富结果文档。 一旦协调节点接收到所有的结果文档，它就组装这些结果为单个响应返回给客户端。\",\"拓展阅读： 深翻页（Deep Pagination） --- 先查后取的过程支持用 from 和 size 参数分页，但是这是 有限制的 。 要记住需要传递信息给协调节点的每个分片必须先创建一个 from + size 长度的队列，协调节点需要根据 number_of_shards * (from + size) 排序文档，来找到被包含在 size 里的文档。 取决于你的文档的大小，分片的数量和你使用的硬件，给 10,000 到 50,000 的结果文档深分页（ 1,000 到 5,000 页）是完全可行的。但是使用足够大的 from 值，排序过程可能会变得非常沉重，使用大量的CPU、内存和带宽。因为这个原因，我们强烈建议你不要使用深分页。 实际上， “深分页” 很少符合人的行为。当2到3页过去以后，人会停止翻页，并且改变搜索标准。会不知疲倦地一页一页的获取网页直到你的服务崩溃的罪魁祸首一般是机器人或者web spider。 如果你 确实 需要从你的集群取回大量的文档，你可以通过用 scroll 查询禁用排序使这个取回行为更有效率，我们会在 later in this chapter 进行讨论。 注：https://www.elastic.co/guide/cn/elasticsearch/guide/current/scroll.html\"]},\"1073\":{\"h\":\"6. Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法\",\"t\":[\"关闭缓存swap;\",\"原因：大多数操作系统会将内存使用到文件系统缓存，会将应用程序未用到的内存交换出去。会导致jvm的堆内存交换到磁盘上。交换会导致性能问题。会导致内存垃圾回收延长。会导致集群节点响应时间变慢，或者从集群中断开。\",\"堆内存设置为：Min（节点内存/2, 32GB）;\",\"设置最大文件句柄数；\",\"后俩点不懂可以先说有一定了解，关注JavaPub会做详细讲解。\",\"调整线程池和队列大小\",\"磁盘存储 raid 方式——存储有条件使用 RAID6，增加单节点性能以及避免单节点存储故障。\",\"https://www.elastic.co/cn/blog/how-to-design-your-elasticsearch-data-storage-architecture-for-scale#raid56\"]},\"1074\":{\"h\":\"7. Elasticsearch 中的节点（比如共 20 个），其中的 10 个选了一个 master，另外 10 个选了另一个 master，怎么办？\",\"t\":[\"当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；\",\"当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data节点，避免脑裂问题。\"]},\"1075\":{\"h\":\"8. 客户端在和集群连接时，如何选择特定的节点执行请求的？\",\"t\":[\"client 远程连接连接一个 elasticsearch 集群。它并不加入到集群中，只是获得一个或者多个初始化的地址，并以轮询的方式与这些地址进行通信。\"]},\"1076\":{\"h\":\"9. 详细描述一下 Elasticsearch 更新和删除文档的过程。\",\"t\":[\"删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；(根本原因是底层lucene的segment段文件不可更新删除)\",\"磁盘上的每个段都有一个相应的 .del 文件。当删除请求发送后，文档并没有真 的被删除，而是在 .del 文件中被标记为删除。该文档依然能匹配查询，但是会在 结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入 新段。\",\"在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新 时，旧版本的文档在.del 文件中被标记为删除，新版本的文档被索引到一个新段。\",\"旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。\"]},\"1077\":{\"h\":\"10. Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？\",\"t\":[\"这道题目较难，相信大家看到很多类似这种回答\",\"Elasticsearch 提供的首个近似聚合是cardinality 度量。它提供一个字段的基数，即该字段的distinct或者unique值的数目。它是基于HLL算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。\",\"科普&拓展：\",\"HyperLogLog： 下面简称为HLL，它是 LogLog 算法的升级版，作用是能够提供不精确的去重计数。存在以下的特点： 1. 能够使用极少的内存来统计巨量的数据，在 Redis 中实现的 HyperLogLog，只需要12K内存就能统计2^64个数据。 2. 计数存在一定的误差，误差率整体较低。标准误差为 0.81% 。 3. 误差可以被设置辅助计算因子进行降低。 --- 应用场景： 1. 基数不大，数据量不大就用不上，会有点大材小用浪费空间 2. 有局限性，就是只能统计基数数量，而没办法去知道具体的内容是什么 3. 和bitmap相比，属于两种特定统计情况，简单来说，HyperLogLog 去重比 bitmap 方便很多 4. 一般可以bitmap和hyperloglog配合使用，bitmap标识哪些用户活跃，hyperloglog计数 --- 应用场景： 1. 基数不大，数据量不大就用不上，会有点大材小用浪费空间 2. 有局限性，就是只能统计基数数量，而没办法去知道具体的内容是什么 3. 和bitmap相比，属于两种特定统计情况，简单来说，HyperLogLog 去重比 bitmap 方便很多 4. 一般可以bitmap和hyperloglog配合使用，bitmap标识哪些用户活跃，hyperloglog计数 来源：刷刷面试\"]},\"1078\":{\"h\":\"11. 在并发情况下，Elasticsearch 如果保证读写一致？\",\"t\":[\"首先要了解什么是一致性，在分布式系统中，我们一般通过CPA理论分析。\",\"分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。\",\"分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。\",\"可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；\",\"另外对于写操作，一致性级别支持 quorum/one/all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。\",\"对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。\"]},\"1079\":{\"h\":\"11. 介绍一下你们的个性化搜索方案？\",\"t\":[\"如果你没有很多实战经验，可以基于 word2vec 做一些练习，我的博客提供了 word2vec Java版的一些Demo。\",\"基于 word2vec 和 Elasticsearch 实现个性化搜索，它有以下优点：\",\"基于word2vec的商品向量还有一个可用之处，就是可以用来实现相似商品的推荐；\"]},\"1080\":{\"h\":\"推荐阅读：\",\"t\":[\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\",\"GItHub|GitEE\"]},\"1081\":{\"c\":[\"最少必要面试题\"]},\"1082\":{\"c\":[\"elasticsearch\",\"面试题\"]},\"1083\":{\"h\":\"10道不得不会的Java基础面试题\",\"t\":[\"Java 基础\",\"10道不得不会的Java基础面试题\",\"以下都是Java的基础面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\"]},\"1084\":{\"h\":\"1. instanceof 关键字的作用\",\"t\":[\"instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。\",\"boolean result = obj instanceof class\",\"当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。\",\"注意一点：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。\",\"obj 必须为引用类型，只能作为对象的判断，不能是基本类型。\",\"int i = 0; System.out.println(i instanceof Integer);//编译不通过 System.out.println(i instanceof Object);//编译不通过\",\"源码参考：JavaSE 8 instanceof 的实现算法：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.instanceof\"]},\"1085\":{\"h\":\"2. Java自动装箱和拆箱\",\"t\":[\"什么是装箱拆箱，这里不做源码层面解读，源码解读在JavaPub公众号发出。这里通过讲解 int 和 Interger 区别，解答Java自动装箱和拆箱。\",\"自动装箱 ----- 基本类型的值 → 包装类的实例\",\"自动拆箱 ----- 基本类型的值 ← 包装类的实例\",\"Integer变量必须实例化后才能使用，而int变量不需要\",\"Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 。\",\"Integer的默认值是null，int的默认值是0\",\"Java中8种基本数据类型。左边基本类型，右边包装类型。 \",\"在面试中：\",\"下面这段代码的输出结果是什么？\",\"public class Main { public static void main(String[] args) { Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); System.out.println(i3==i4); } } //true //false\",\"输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：\",\"public static Integer valueOf(int i) { if(i >= -128 && i <= IntegerCache.high) return IntegerCache.cache[i + 128]; else return new Integer(i); }\",\"private static class IntegerCache { static final int high; static final Integer cache[]; static { final int low = -128; // high value may be configured by property int h = 127; if (integerCacheHighPropValue != null) { // Use Long.decode here to avoid invoking methods that // require Integer's autoboxing cache to be initialized int i = Long.decode(integerCacheHighPropValue).intValue(); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - -low); } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k < cache.length; k++) cache[k] = new Integer(j++); } private IntegerCache() {} }\",\"从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。\",\"上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。\",\"注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。 Double、Float的valueOf方法的实现是类似的（没有缓存数值，这里的数值想想都有很多，不适合缓存）。\"]},\"1086\":{\"h\":\"3. 重载和重写区别\",\"t\":[\"重载和重写是一个特别好理解的概念，这里说一个通俗的解答方式\",\"重载（Overload）:首先是位于一个类之中或者其子类中，具有相同的方法名，但是方法的参数不同，返回值类型可以相同也可以不同。\",\"方法名必须相同\",\"方法的参数列表一定不一样。\",\"访问修饰符和返回值类型可以相同也可以不同。\",\"其实简单而言：重载就是对于不同的情况写不同的方法。 比如，同一个类中，写不同的构造函数用于初始化不同的参数。\",\"public class JavaPubTest { public void out(){ System.out.println(\\\"参数\\\"+null); } //参数数目不同 public void out(Integer n){ System.out.println(\\\"参数\\\"+n.getClass().getName()); } //参数类型不同 public void out(String string){ System.out.println(\\\"参数\\\"+string.getClass().getName()); } public void out(Integer n ,String string){ System.out.println(\\\"参数\\\"+n.getClass().getName()+\\\",\\\"+string.getClass().getName()); } //参数顺序不同 public void out(String string,Integer n){ System.out.println(\\\"参数\\\"+string.getClass().getName()+\\\",\\\"+n.getClass().getName()); } public static void main(String[] args) { JavaPubTest javaPubTest = new JavaPubTest(); javaPubTest.out(); javaPubTest.out(1); javaPubTest.out(\\\"string\\\"); javaPubTest.out(1,\\\"string\\\"); javaPubTest.out(\\\"string\\\",1); } }\",\"**重写（Overriding）**发生在父类子类之间，比如所有类都是继承与Object类的，Object类中本身就有equals、hashcode、toString方法等。在任意子类中定义了重名和同样的参数列表就构成方法重写。\",\"方法名必须相同，返回值类型必须相同。\",\"参数列表必须相同。\",\"访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。\",\"子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。\",\"构造方法不能被重写。\"]},\"1087\":{\"h\":\"4. equals与==区别\",\"t\":[\"\\\"==\\\"是判断两个变量或实例是不是指向同一个内存空间。\\\"equals\\\"是判断两个变量或实例所指向的内存空间的值是不是相同。\",\"除了这俩点，这个问题大概率会引出以下问题：\",\"为什么重写equals还要重写hashcode?\",\"通过上面俩条我们知道 \\\"equals\\\"是判断两个变量或实例所指向的内存空间的值是不是相同。 但是一些特殊场景，我们需要对比俩个对象是否相等，例如：User user1 = new User();User user2 = new User(); user1 和 user2 对比。这是我们就需要重写 equals 方法。\",\"所以可以通过重写equals()方法来判断对象的值是否相等，但是有一个要求：equals()方法实现了等价关系，即：\",\"自反性：对于任何非空引用x，x.equals(x)应该返回true；\",\"对称性：对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true；\",\"传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true；\",\"一致性：如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果；\",\"非空性：对于任意非空引用x，x.equals(null)应该返回false；\",\"到这里也是一个很正常的操作，但是当我们要用到 HashSet 等集合时。存储的对象我们需要用 hashcode 判断对象是否存在，如果使用 Object 默认的hashcode方法，那我们同样属性的俩个用户一定是不相等的(例如下面user3、user4)，因为内存地址不同，这并不符合我们的业务，所以决定了重写 hashcode 的必要性。\",\"User user3 = new User(\\\"JavaPub\\\", \\\"man\\\", \\\"1996-08-28\\\") User user4 = new User(\\\"JavaPub\\\", \\\"man\\\", \\\"1996-08-28\\\")\"]},\"1088\":{\"h\":\"5. 谈谈NIO和BIO区别\",\"t\":[\"致力于大白话说清楚。NIO和BIO是一个相对有点抽象的概念，如果你对网络有点了解，理解起来可能会更顺畅。首先说一下基本\",\"BIO：同步阻塞IO，每一个客户端连接，服务端都会对应一个处理线程，对于没有分配到处理线程的连接就会被阻塞或者拒绝。相当于是一个连接一个线程。\",\"NIO：同步非阻塞IO，基于Reactor模型，客户端和channel进行通信，channel可以进行读写操作，通过多路复用器selector来轮询注册在其上的channel，而后再进行IO操作。这样的话，在进行IO操作的时候再用一个线程去处理就可以了，也就是一个请求一个线程。\",\"Reactor模型是什么?\",\"基于池化思想，避免为每个连接创建线程，连接完成后将业务处理交给线程池处理\",\"基于IO复用模型，多个连接共用同一个阻塞对象，不用等待所有的连接。遍历到有新数据可以处理时，操作系统会通知程序，线程跳出阻塞状态，进行业务逻辑处理 .\",\"简单来说：Reactor线程模型的思想就是基于IO复用和线程池的结合。\",\"AIO：（一般都会把AIO和NIO、BIO放一块比较，这里简单提一下。）异步非阻塞IO，相比NIO更进一步，完全由操作系统来完成请求的处理，然后通知服务端开启线程去进行处理，因此是一个有效请求一个线程。\",\"那么怎么理解同步和阻塞？\",\"首先，可以认为一个IO操作包含两个部分：\",\"发起IO请求\",\"实际的IO读写操作\",\"同步和异步在于第二个，实际的IO读写操作，如果操作系统帮你完成了再通知你，那就是异步，否则都叫做同步。\",\"阻塞和非阻塞在于第一个，发起IO请求，对于NIO来说通过channel发起IO操作请求后，其实就返回了，所以是非阻塞。\",\"NIO和BIO是非常重要的计算机知识，学习后会对整个计算机的理解更近一步，一次学会终身受益。JavaPub会单独写一篇深入图解NIO和BIO。\",\"网上看到一个例子（一定要看，会对你有所帮助）：\",\"一辆从 A 开往 B 的公共汽车上，路上有很多点可能会有人下车。司机不知道哪些点会有哪些人会下车，对于需要下车的人，如何处理更好？ 1. 司机过程中定时询问每个乘客是否到达目的地，若有人说到了，那么司机停车，乘客下车。 ( 类似阻塞式 ) 2. 每个人告诉售票员自己的目的地，然后睡觉，司机只和售票员交互，到了某个点由售票员通知乘客下车。 ( 类似非阻塞 ) 很显然，每个人要到达某个目的地可以认为是一个线程，司机可以认为是 CPU 。在阻塞式里面，每个线程需要不断的轮询，上下文切换，以达到找到目的地的结果。而在非阻塞方式里，每个乘客 ( 线程 ) 都在睡觉 ( 休眠 ) ，只在真正外部环境准备好了才唤醒，这样的唤醒肯定不会阻塞。\",\"建议阅读： https://www.cnblogs.com/aspirant/p/6877350.html https://www.cnblogs.com/shoshana-kong/p/11228555.html\"]},\"1089\":{\"h\":\"6. String、StringBuffer、StringBuilder 的区别是什么？\",\"t\":[\"String是Immutable类的典型实现，被声明为 final class，除了hash这个属性其它属性都声明为final。它的不可变性，所以例如拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。\",\"StringBuffer、StringBuilder就是解决String的这个性能问题。\",\"StringBuffer 是线程安全的，本质是一个线程安全的可修改的字符序列，把所有修改数据的方法都加上synchronized。\",\"StringBuffer 线程不安全，但是性能更好。\"]},\"1090\":{\"h\":\"7. 泛型是什么，有什么特点\",\"t\":[\"泛型在编码中有非常广泛的使用（jdk5引入），你一定经常能见到类似这种写法 <T> 。\",\"泛型提供了编译时类型安全检测机制，允许在编译时检测到非法的类型。本质是参数化类型。\",\"把类型当作是参数一样传递\",\"<数据类型>只能是引用类型\",\"泛型：就是一种不确定的数据类型。\",\"泛型的好处：\",\"省略了强转的代码。\",\"可以把运行时的问题提前到编译时期。\",\"引入泛型主要想实现一个通用的、可以处理不同类型的方法\",\"泛型擦除:\",\"泛型时提供给javac编译器使用的，用于限定集合的输入类型，让编译器在源代码级别上，避免向集合中插入非法数据。但编译器编译完带有泛型的java程序后，生成的class文件中不再带有泛型信息，以此使程序运行效率不受影响，这个过程称为擦除。\",\"JVM并不知道泛型的存在，因为泛型在编译阶段就已经被处理成普通的类和方法； 处理机制是通过类型擦除，擦除规则：\",\"若泛型类型没有指定具体类型，用Object作为原始类型；\",\"若有限定类型< T exnteds XClass >，使用XClass作为原始类型；\",\"若有多个限定< T exnteds XClass1 & XClass2 >，使用第一个边界类型XClass1作为原始类型；\"]},\"1091\":{\"h\":\"8. final 有哪些用法\",\"t\":[\"final关键字有四个常见用法。\",\"final修饰一个类\",\"当 final 关键字用来修饰一个类的时候，表明这个类不能有任何的子类，也就是说这个类不能被继承。\",\"final类中的所有成员方法都会被隐式地指定为final方法，也就是说一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写。\",\" public final class 类名称 { // ... }\",\"final修饰一个方法\",\"当 final 关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。\",\" 修饰符 final 返回值类型 方法名称(参数列表) { // 方法体 }\",\"注意：对于类、方法来说，abstract 关键字和 final 关键字不能同时使用，因为矛盾。\",\"final修饰一个局部变量\",\"一旦使用 final 用来修饰局部变量，那么这个变量就不能进行更改「一次赋值，终生不变」。\",\"对于基本类型来说，不可变说的是变量当中的数据不可改变；\",\"对于引用类型来说，不可变说的是变量当中的地址值不可改变。\",\"final修饰一个成员变量\",\"对于成员变量来说，如果使用 final 关键字修饰，那么这个变量也照样是不可变。\",\"由于成员变量具有默认值，所以用了 final 之后必须手动赋值，不会再给默认值了；\",\"对于 final 的成员变量，要么使用直接赋值，要么通过构造方法赋值，必须二者选其一；\",\"必须保证类当中所有重载的构造方法都最终会对 final 的成员变量进行赋值。\"]},\"1092\":{\"h\":\"9. 说一下Java注解\",\"t\":[\"在Java编程中，注解非常常见，注解的本质是什么？\",\"注解大致分为以下三种：\",\"Java原生注解 如@Override，@Deprecated 等。大多用于 [标记] 和 [检查] 。\",\"第三方注解，如 Spring、Mybatis等定义的注解（@Controller，@Data）。\",\"自定义注解。\",\"Java原生除了提供基本注解，还提供了 meta-annotation（元注解）。这些类型和它们所支持的类在java.lang.annotation包中可以找到。\",\"@Target\",\"@Retention\",\"@Documented\",\"@Inherited\",\"在这里插入图片描述\",\"一般比较常用的有 @Target，@Retention。@Target表示这个注解可以修饰那些地方（比如类、方法、成员变量），@Retention 主要是设置注解的生命周期。\",\"这是你一定会被问，\",\"有使用过注解吗？\",\"你是怎么使用的？\",\"注解有一个非常常见的使用场景，大家可以用这个来理解学习。\",\"场景一：自定义注解+拦截器 实现登录校验\",\"实现功能：\",\"接下来，我们使用springboot拦截器实现这样一个功能，如果方法上加了@LoginRequired，则提示用户该接口需要登录才能访问，否则不需要登录。\",\"首先定义一个LoginRequired注解\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface LoginRequired { }\",\"然后写两个简单的接口，访问sourceA，sourceB资源\",\"@RestController public class IndexController { @GetMapping(\\\"/sourceA\\\") public String sourceA(){ return \\\"你正在访问sourceA资源\\\"; } @GetMapping(\\\"/sourceB\\\") public String sourceB(){ return \\\"你正在访问sourceB资源\\\"; } }\",\"很简单的俩个接口，没添加拦截器之前成功访问\",\"在这里插入图片描述\",\"实现 spring 的 HandlerInterceptor 类先实现拦截器，但不拦截，只是简单打印日志，如下：\",\"public class SourceAccessInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"进入拦截器了\\\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } }\",\"实现spring类 WebMvcConfigurer，创建配置类把拦截器添加到拦截器链中\",\"@Configuration public class InterceptorTrainConfigurer implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new SourceAccessInterceptor()).addPathPatterns(\\\"/**\\\"); } }\",\"拦截成功如下\",\" 在 sourceB 方法上添加我们的登录注解 @LoginRequired\",\"@RestController public class IndexController { @GetMapping(\\\"/sourceA\\\") public String sourceA(){ return \\\"你正在访问sourceA资源\\\"; } @LoginRequired @GetMapping(\\\"/sourceB\\\") public String sourceB(){ return \\\"你正在访问sourceB资源\\\"; } }\",\"简单实现登录拦截逻辑\",\" @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"进入拦截器了\\\"); // 反射获取方法上的LoginRequred注解 HandlerMethod handlerMethod = (HandlerMethod)handler; LoginRequired loginRequired = handlerMethod.getMethod().getAnnotation(LoginRequired.class); if(loginRequired == null){ return true; } // 有LoginRequired注解说明需要登录，提示用户登录 response.setContentType(\\\"application/json; charset=utf-8\\\"); response.getWriter().print(\\\"你访问的资源需要登录\\\"); return false; }\",\"运行成功，访问sourceB时需要登录了，访问sourceA则不用登录。 \",\"场景二：自定义注解+AOP 实现日志打印\",\"先导入切面需要的依赖包\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-aop</artifactId> </dependency>\",\"定义一个注解@MyLog\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyLog { }\",\"定义一个切面类，见如下代码注释理解：\",\"@Aspect // 1.表明这是一个切面类 @Component public class MyLogAspect { // 2. PointCut表示这是一个切点，@annotation表示这个切点切到一个注解上，后面带该注解的全类名 // 切面最主要的就是切点，所有的故事都围绕切点发生 // logPointCut()代表切点名称 @Pointcut(\\\"@annotation(com.javapub.blog.MyLog)\\\") public void logPointCut(){}; // 3. 环绕通知 @Around(\\\"logPointCut()\\\") public void logAround(ProceedingJoinPoint joinPoint){ // 获取方法名称 String methodName = joinPoint.getSignature().getName(); // 获取入参 Object[] param = joinPoint.getArgs(); StringBuilder sb = new StringBuilder(); for(Object o : param){ sb.append(o + \\\"; \\\"); } System.out.println(\\\"进入[\\\" + methodName + \\\"]方法,参数为:\\\" + sb.toString()); // 继续执行方法 try { joinPoint.proceed(); } catch (Throwable throwable) { throwable.printStackTrace(); } System.out.println(methodName + \\\"方法执行结束\\\"); } }\",\"在步骤二中的IndexController写一个sourceC进行测试，加上我们的自定义注解：\",\" @MyLog @GetMapping(\\\"/sourceC/{source_name}\\\") public String sourceC(@PathVariable(\\\"source_name\\\") String sourceName){ return \\\"你正在访问sourceC资源\\\"; }\",\"启动springboot web项目，输入访问地址\",\"有些面试官喜欢问，注解三要素是哪些：\",\"注解声明、\",\"使用注解的元素、\",\"操作注解使其起作用(注解处理器)\"]},\"1093\":{\"h\":\"10. Java创建对象有几种方式\",\"t\":[\"Java中有5种创建对象的方式，下面给出它们的例子\",\"使用new关键字\",\"User user = new User();\",\"使用Class类的newInstance方法\",\"我们也可以使用Class类的newInstance方法创建对象。这个newInstance方法调用无参的构造函数创建对象。\",\"Employee emp = (Employee) Class.forName(\\\"org.javapub.blog.Employee\\\").newInstance(); 或者 Employee emp2 = Employee.class.newInstance();\",\"使用Constructor类的newInstance方法\",\"和Class类的newInstance方法很像， java.lang.reflect.Constructor类里也有一个newInstance方法可以创建对象。我们可以通过这个newInstance方法调用有参数的和私有的构造函数。\",\"Constructor<Employee> constructor = Employee.class.getConstructor(); Employee emp3 = constructor.newInstance();\",\"使用clone方法\",\"无论何时我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。\",\"要使用clone方法，我们需要先实现Cloneable接口并实现其定义的clone方法。\",\"Employee emp4 = (Employee) emp3.clone();\",\"使用反序列化\",\"当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数。\",\"为了反序列化一个对象，我们需要让我们的类实现Serializable接口\",\"ObjectInputStream in = new ObjectInputStream(new FileInputStream(\\\"data.obj\\\")); Employee emp5 = (Employee) in.readObject();\",\"联系JavaPub:\",\"如果需要下载CSDN资料又没有积分可以JavaPub留言，JavaPub帮你下载\",\"查看更多面试题及答案 \"]},\"1094\":{\"h\":\"推荐阅读：\",\"t\":[\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\",\"GItHub|GitEE\"]},\"1095\":{\"c\":[\"最少必要面试题\"]},\"1096\":{\"c\":[\"java\",\"面试题\"]},\"1097\":{\"h\":\"10道不得不会的Java并发基础面试题\",\"t\":[\"Java并发\",\"10道不得不会的Java并发基础面试题\",\"以下都是Java的并发基础面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\"]},\"1098\":{\"h\":\"1. start()方法和run()方法的区别\",\"t\":[\"如果只是调用 run() 方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。\",\"只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。\",\"参考图：\",\"在这里插入图片描述\"]},\"1099\":{\"h\":\"2. volatile关键字的作用\",\"t\":[\"volatile 英 [ˈvɒlətaɪl] ，第一个想到的一定是保证内存可见性（Memory Visibility）。可见性是性对于线程而言。\",\" 上图是Java内存模型，所有线程的共享变量都放在主内存中，每一个线程都有一个独有的工作内存，每个线程不直接操作在主内存中的变量，而是将主内存上变量的副本放进自己的工作内存中，只操作工作内存中的数据。当修改完毕后，再把修改后的结果放回到主内存中。每个线程都只操作自己工作内存中的变量，无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。\",\"很明显，在并发环境下一定会发生脏数据问题。\",\"使用volatile变量能够保证:\",\"每次读取前必须先从主内存刷新最新的值。\",\"每次写入后必须立即同步回主内存当中。\",\"也就是说，volatile关键字修饰的变量看到的随时是自己的最新值。\",\"防止指令重排\",\"在基于偏序关系的Happens-Before内存模型中，指令重排技术大大提高了程序执行效率。但是也引入一个新问题：被部分初始化的对象\",\"例子：\",\"创建一个对象 instance = new Singleton();\",\"它并不是一个原子操作。事实上，它可以”抽象“为下面几条JVM指令：\",\"memory = allocate(); //1：分配对象的内存空间 initInstance(memory); //2：初始化对象 instance = memory; //3：设置instance指向刚分配的内存地址\",\"上面操作2依赖于操作1，但是操作3并不依赖于操作2，所以JVM可以以“优化”为目的对它们进行重排序，经过重排序后如下：\",\"memory = allocate(); //1：分配对象的内存空间 instance = memory; //3：设置instance指向刚分配的内存地址（此时对象还未初始化） initInstance(memory); //2：初始化对象\",\"可以看到指令重排之后，操作 3 排在了操作 2 之前，即引用instance指向内存memory时，这段崭新的内存还没有初始化。由于instance已经指向了一块内存空间，从而返回 instance!=null，用户得到了没有完成初始化的“半个”单例。\",\"但是有一点：volatile不保证原子性。\",\"这里有一篇生产环境使用volatile的例子：https://mp.weixin.qq.com/s/s1cwut9WvUSrMYw_6UK3sg\"]},\"1100\":{\"h\":\"3. sleep方法和wait方法有什么区别\",\"t\":[\"要了解sleep和wait，首先需要了解Java线程的6种状态。\",\"#下面是Java线程的6种状态 1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。 3. 阻塞(BLOCKED)：表示线程阻塞于锁。 4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 6. 终止(TERMINATED)：表示该线程已经执行完毕。\",\"sleep 休眠方法\",\"static void sleep(long ms)\",\"该方法会使当前线程进入阻塞状态指定毫秒，当阻塞指定毫秒后，当前线程会重新进入Runnable状态，等待划分时间片。\",\"sleep方法属于Thread类中方法，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可运行状态，不会马上进入运行状态，因为线程调度机制恢复线程的运行也需要时间，一个线程对象调用了sleep方法之后，并不会释放他所持有的所有对象锁，所以也就不会影响其他进程对象的运行。\",\"wait 方法一般是跟notify方法连用的\",\"多线程之间需要协调工作。如果条件不满足则等待。当条件满足时，等待该条件的线程将被唤醒。在Java中，这个机制实现依赖于wait/notify或wait/notifyAll。\",\"object.wait()让当前线程进入不可运行状态，如sleep()一样，但不同的是wait方法从一个对象调用，而不是从一个线程调用；我们称这个对象为“锁定对象（lockObj）”。在lockObj.wait()被调用之前，当前线程必须在lockObj上同步（synchronize）；然后调用wait()后释放这个锁，并将线程增加到与lockObj相关的“等待名单（wait list）”。然后，另一个在同一个lockObj锁定（synchronize）的方法可以调用lockObj.nofity()。这会唤醒原来等待的线程。基本上，wait() / notify()就像sleep() / interrupt()，只是活动线程不需要直接指向一个睡眠线程，他们只需要共享锁对象（lockObj）。\",\"到这里你是否明白这个问题，如果不明白来JavaPub，后续一篇代码分析，马上安排。\"]},\"1101\":{\"h\":\"4. 如何停止一个正在运行的线程？\",\"t\":[\"最直观的一定是 Thread.stop，但是它是不推荐的，并且已经废弃。看一下官方说明 https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html\",\"* This method is inherently unsafe. Stopping a thread with * Thread. stop causes it to unlock all of the monitors that it * has locked (as a natural consequence of the unchecked * <code>ThreadDeath</code> exception propagating up the stack). If * any of the objects previously protected by these monitors were in * an inconsistent state, the damaged objects become visible to * other threads, potentially resulting in arbitrary behavior. Many * uses of <code>stop</code> should be replaced by code that simply * modifies some variable to indicate that the target thread should * stop running. The target thread should check this variable * regularly, and return from its run method in an orderly fashion * if the variable indicates that it is to stop running. If the * target thread waits for long periods (on a condition variable, * for example), the <code>interrupt</code> method should be used to * interrupt the wait.\",\"小结： 简单来说，Thread.stop()不安全，已不再建议使用。\",\"方法一：\",\"使用 interrupt 方法中断线程。\",\"interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程。\",\"需要 this.isInterrupted(): 测试线程是否真的已经中断。\",\"方法二：\",\"最好的一种方法，使用标志位停止。\",\"run() 方法中做标识符，保证优雅的停止服务。\"]},\"1102\":{\"h\":\"5. java如何实现多线程之间的通讯和协作？(如何在两个线程间共享数据？)\",\"t\":[\"volatile关键字方式\",\"volatile有两大特性，一是可见性，二是有序性，禁止指令重排序，其中可见性就是可以让线程之间进行通信。\",\"等待/通知机制\",\"等待通知机制是基于wait和notify方法来实现的，在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被通知或者被唤醒。\",\"也就是通过等待/通知机制 让多个线程协作\",\"join方式\",\"join其实合理理解成是线程合并，当在一个线程调用另一个线程的join方法时，当前线程阻塞等待被调用join方法的线程执行完毕才能继续执行，所以join的好处能够保证线程的执行顺序，但是如果调用线程的join方法其实已经失去了并行的意义，虽然存在多个线程，但是本质上还是串行的，最后join的实现其实是基于等待通知机制的。\",\"threadLocal方式\",\"threadLocal方式的线程通信，不像以上三种方式是多个线程之间的通信，它更像是一个线程内部的通信，将当前线程和一个map绑定，在当前线程内可以任意存取数据，减省了方法调用间参数的传递。\"]},\"1103\":{\"h\":\"6. 什么是ThreadLocal?\",\"t\":[\"定义：线程局部变量是局限于线程内的变量，属于线程自身所有，不在多个线程间共享。java提供 ThreadLocal类 来支持线程局部变量，是一个实现线程安全的方式。\",\"作用：ThreadLocal 是一种以空间换时间的做法，在每一个 Thread 里面维护了一个 ThreadLocal.ThreadLocalMap 把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。\"]},\"1104\":{\"h\":\"7. Java 中 CountDownLatch 和 CyclicBarrier 有什么不同？\",\"t\":[\"概念：\",\"CountDownLatch 是一个同步的辅助类，允许一个或多个线程，等待其他一组线程完成操作，再继续执行。简单来说：CountDownLatch 是一个计数器，可以保证线程之间的顺序执行把线程从并发状态调整为串行状态保证了线程的执行顺序。(只可以使用一次)\",\"CyclicBarrier 是一个同步的辅助类，允许一组线程相互之间等待，达到一个共同点，再继续执行。典型场景：可以用于多线程计算数据，最后合并计算结果。（可以多次使用）\",\"分享一个直观的代码：\",\"package com.javapub.test; import java.util.concurrent.CountDownLatch; /** * @Author: JavaPub * @License: https://github.com/Rodert/ * @Contact: https://javapub.blog.csdn.net/ * @Date: 2022/1/1 16:50 * @Version: 1.0 * @Description: countDownLatch 可以保证线程之间的顺序执行把线程从并发状态调整为串行状态保证了线程的执行顺序。 * demo效果：当打印完B，再打印C。 */ class ThreadA extends Thread { private CountDownLatch down; public ThreadA(CountDownLatch down) { this.down = down; } @Override public void run() { System.out.println(\\\"A\\\"); try { down.await();//相当于wait(),调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"C\\\"); } } class ThreadB extends Thread { private CountDownLatch down; public ThreadB(CountDownLatch down) { this.down = down; } @Override public void run() { System.out.println(\\\"B\\\"); System.out.println(down.getCount()); down.countDown();//将count值减1 } } public class Test { public static void main(String[] args) { CountDownLatch down = new CountDownLatch(1);//创建1个计数器 new ThreadA(down).start(); new ThreadB(down).start(); } } /*输出 A B C */\",\"package com.roundyuan.fanggateway.test; import java.util.concurrent.CyclicBarrier; /** * @Author: JavaPub * @License: https://github.com/Rodert/ * @Contact: https://javapub.blog.csdn.net/ * @Date: 2022/1/2 13:42 * @Version: 1.0 * @Description: CyclicBarrier */ public class CyclicBarrierDemo { static class TaskThread extends Thread { CyclicBarrier barrier; public TaskThread(CyclicBarrier barrier) { this.barrier = barrier; } @Override public void run() { try { Thread.sleep(1000); System.out.println(getName() + \\\" 到达栅栏 A\\\"); barrier.await(); System.out.println(getName() + \\\" 冲破栅栏 A\\\"); Thread.sleep(2000); System.out.println(getName() + \\\" 到达栅栏 B\\\"); barrier.await(); System.out.println(getName() + \\\" 冲破栅栏 B\\\"); } catch (Exception e) { e.printStackTrace(); } } } public static void main(String[] args) { int threadNum = 5; CyclicBarrier barrier = new CyclicBarrier(threadNum, new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName() + \\\" 完成最后任务\\\"); } }); for (int i = 0; i < threadNum; i++) { new TaskThread(barrier).start(); } } } /* Thread-3 到达栅栏 A Thread-1 到达栅栏 A Thread-4 到达栅栏 A Thread-2 到达栅栏 A Thread-0 到达栅栏 A Thread-2 完成最后任务 Thread-2 冲破栅栏 A Thread-0 冲破栅栏 A Thread-4 冲破栅栏 A Thread-3 冲破栅栏 A Thread-1 冲破栅栏 A Thread-4 到达栅栏 B Thread-0 到达栅栏 B Thread-2 到达栅栏 B Thread-1 到达栅栏 B Thread-3 到达栅栏 B Thread-3 完成最后任务 Thread-3 冲破栅栏 B Thread-0 冲破栅栏 B Thread-4 冲破栅栏 B Thread-1 冲破栅栏 B Thread-2 冲破栅栏 B */\",\"网上看到一个比较形象一个例子：\",\"CountDownLatch： 宿管阿姨，晚上关宿舍大门睡觉，需要等到所有学生回寝，才能关门睡觉，学生之间不用相互等待，回寝就能睡觉。 （学生就是各个线程，宿管阿姨就是监听CountDownLatch为0后要执行的。） CyclicBarrier： 家庭聚餐，等待家庭成员到齐才能开饭，家庭成员之间需要相互等待，直到最后一个到达，才能同时开饭。\"]},\"1105\":{\"h\":\"8. 如何避免死锁？\",\"t\":[\" 从上图我们就可以看出，产生死锁就是俩个或多个线程在申请资源时，自己需要的资源别别人持有、并阻塞。所以导致死锁。\",\"如何解决：\",\"减小锁的范围，尽量保证之锁定自己需要的资源，减小交叉持有资源情况\",\"但是有些时候不得不持有多个资源，比如银行转账，我们必须同时获得两个账户上的锁，才能进行操作，两个锁的申请必须发生交叉。这时我们也可以打破死锁的那个闭环，在涉及到要同时申请两个锁的方法中，总是以相同的顺序来申请锁，比如总是先申请 id 大的账户上的锁 ，然后再申请 id 小的账户上的锁，这样就无法形成导致死锁的那个闭环。\",\"我们知道导致死锁有一个因素是阻塞，所以如果我们不使用默认阻塞的锁，也是可以避免死锁的。我们可以使用 ReentrantLock.tryLock() 方法，在一个循环中，如果 tryLock() 返回失败，那么就释放以及获得的锁，并睡眠一小段时间。这样就打破了死锁的闭环。\",\"package com.roundyuan.fanggateway.test; import java.util.Random; import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * @Author: JavaPub * @License: https://github.com/Rodert/ * @Contact: https://javapub.blog.csdn.net/ * @Date: 2022/1/2 14:38 * @Version: 1.0 * @Description: ReentrantLock */ public class DeadLock { private static Lock lock1 = new ReentrantLock(); private static Lock lock2 = new ReentrantLock(); public static void deathLock() { new Thread() { @Override public void run() { while (true) { if (lock1.tryLock()) { try { //如果获取成功则执行业务逻辑，如果获取失败，则释放lock1的锁，自旋重新尝试获得锁 if (lock2.tryLock()) { try { System.out.println(\\\"Thread1：已成功获取 lock1 and lock2 ...\\\"); break; } finally { lock2.unlock(); } } } finally { lock1.unlock(); } } System.out.println(\\\"Thread1：获取锁失败，重新获取---\\\"); try { //防止发生活锁 TimeUnit.NANOSECONDS.sleep(new Random().nextInt(100)); } catch (InterruptedException e) { e.printStackTrace(); } } } }.start(); new Thread() { @Override public void run() { while (true) { if (lock2.tryLock()) { try { //如果获取成功则执行业务逻辑，如果获取失败，则释放lock2的锁，自旋重新尝试获得锁 if (lock1.tryLock()) { try { System.out.println(\\\"Thread2：已成功获取 lock2 and lock1 ...\\\"); break; } finally { lock1.unlock(); } } } finally { lock2.unlock(); } } System.out.println(\\\"Thread2：获取锁失败，重新获取---\\\"); try { //防止发生活锁 TimeUnit.NANOSECONDS.sleep(new Random().nextInt(100)); } catch (InterruptedException e) { e.printStackTrace(); } } } }.start(); } public static void main(String[] args) throws InterruptedException { for (int i = 0; i < 5; i++) { deathLock(); } } }\",\"说起死锁，银行家算法非常有必要了解：\",\"银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。 1、操作系统按照银行家指定的规则为进程分配资源，当进程首次申请资源时，需要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请资源分配资源，否则就推迟分配； 2、当进程在执行中继续申请资源时，先测试该进程本次申请的资源数，是否超过了该资源剩余的总量，若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。\",\"参考阅读：\",\"如何快速排查死锁？如何避免死锁？ https://zhuanlan.zhihu.com/p/136294283\"]},\"1106\":{\"h\":\"9. Java 中 synchronized 和 ReentrantLock 有什么不同？\",\"t\":[\"等待可中断:\",\"使用synchronized，不能被中断。synchronized 也可以说是Java提供的原子性内置锁机制。内部锁扮演了互斥锁（mutual exclusion lock ，mutex）的角色，一个线程引用锁的时候，别的线程阻塞等待。\",\"使用ReentrantLock。等待了很长时间以后，可以中断等待，转而去做别的事情。\",\"公平锁:\",\"公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序来依次获得锁；而非公平锁则不能保证这一点。非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁。 synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁。\",\"还有大家已知的俩点：\",\"synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活。ReentrantLock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。\",\"synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。\"]},\"1107\":{\"h\":\"10. 有三个线程 T1，T2，T3，怎么确保它们按顺序执行？\",\"t\":[\"方法1：\",\"线程内部顺序调用，T1、T2、T3。这个可能不是要考察的点，但也是一个方案。\",\"方法2：\",\"join()方法用于将线程由 ”并行“变成”串行“，它用于等待其他线程的终止，在当前线程掉用了join()方法，那么当前线程将进入阻塞状态，等到另一个线程结束，当前线程再由阻塞状态转变成就绪状态，等待CPU的使用权。\",\"package com.javapub.test; /** * @Author: JavaPub * @License: https://github.com/Rodert/ * @Contact: https://javapub.blog.csdn.net/ * @Date: 2022/1/2 15:20 * @Version: 1.0 * @Description: */ public class Test1 { public static void main(String[] args) { ThreadA threadA = new ThreadA(); ThreadB threadB = new ThreadB(threadA); ThreadC threadC = new ThreadC(threadB); threadA.start(); threadB.start(); threadC.start(); } } class ThreadA extends Thread { @Override public void run() { System.out.println(\\\"线程A\\\"); } } class ThreadB extends Thread { Thread threadA; public ThreadB() { // dosomething Auto-generated constructor stub } public ThreadB(Thread threadA) { this.threadA = threadA; } @Override public void run() { try { threadA.join(); } catch (InterruptedException e) { // dosomething Auto-generated catch block e.printStackTrace(); } System.out.println(\\\"线程B\\\"); } } class ThreadC extends Thread { Thread threadB; public ThreadC(Thread threadB) { this.threadB = threadB; } @Override public void run() { try { threadB.join(); } catch (InterruptedException e) { // dosomething Auto-generated catch block e.printStackTrace(); } System.out.println(\\\"线程C\\\"); } }\",\"信号量方式 java.util.concurrent.Semaphore 英 [ˈseməfɔː(r)] 待研究\",\"联系JavaPub:\",\"如果需要下载CSDN资料又没有积分可以JavaPub留言，JavaPub帮你下载\"]},\"1108\":{\"h\":\"推荐阅读：\",\"t\":[\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\",\"GItHub|GitEE\"]},\"1109\":{\"c\":[\"最少必要面试题\"]},\"1110\":{\"c\":[\"java\",\"面试题\"]},\"1111\":{\"h\":\"10道不得不会的Java容器面试题\",\"t\":[\"Java 容器\",\"10道不得不会的Java容器面试题\",\"以下都是 Java容器常见面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"[toc]\"]},\"1112\":{\"h\":\"1. 请说一下Java容器集合的分类，各自的继承结构\",\"t\":[\"Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：\",\"Collection包括：List、ArrayList、LinkedList、Vector、Stack、Set、HashSet、LinkedHashSet、TreeSet\",\"Map包括：HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap、Hashtable\"]},\"1113\":{\"h\":\"2. Collection 和 Collections 有什么区别？\",\"t\":[\"Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。\",\"Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法：Collections. sort(list)。\"]},\"1114\":{\"h\":\"3. List、Set、Map 之间的区别是什么？\",\"t\":[\"List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。\"]},\"1115\":{\"h\":\"4. HashMap 和 Hashtable 有什么区别？\",\"t\":[\"HashMap 是非线程安全的，HashTable 是线程安全的。\",\"HashMap 的键和值都允许有 null 值存在，而 HashTable 则不行。\",\"因为线程安全的问题，HashMap 效率比 HashTable 的要高。\",\"Hashtable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线程环境，而 Hashtable 适合于多线程环境。\",\"一般现在 **不建议用 HashTable **， \",\"一方面是因为 HashTable 是遗留类，内部实现很多没优化和冗余。\",\"另外，即使在 多线程 环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用 HashTable。\"]},\"1116\":{\"h\":\"5. 说一下 HashMap 的实现原理？\",\"t\":[\"HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。\",\"当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。\"]},\"1117\":{\"h\":\"6. 谈谈 ArrayList 和 LinkedList 的区别\",\"t\":[\"本质的区别来源于两者的底层实现：ArrayList的底层是数组，LinkedList的底层是双向链表。\",\"数组拥有O(1)的查询效率，可以通过下标直接定位元素；链表在查询元素的时候只能通过遍历的方式查询，效率比数组低。\",\"数组增删元素的效率比较低，通常要伴随拷贝数组的操作；链表增删元素的效率很高，只需要调整对应位置的指针即可。\",\"以上是数组和链表的通俗对比，在日常的使用中，两者都能很好地在自己的适用场景发挥作用。\",\"比如说我们常常用ArrayList代替数组，因为封装了许多易用的api，而且它内部实现了自动扩容机制，由于它内部维护了一个当前容量的指针size，直接往ArrayList中添加元素的时间复杂度是O(1)的，使用非常方便。\",\"而LinkedList常常被用作Queue队列的实现类，由于底层是双向链表，能够轻松地提供先入先出的操作。\",\"我觉得可以分两部分答，一个是数组与链表底层实现的不同，另一个是答ArrayList和LinkedList的实现细节。\"]},\"1118\":{\"h\":\"7. 谈谈ArrayList和Vector的区别\",\"t\":[\"两者的底层实现相似，关键的不同在于Vector的对外提供操作的方法都是用synchronized修饰的，也就是说Vector在并发环境下是线程安全的，而ArrayList在并发环境下可能会出现线程安全问题。\",\"由于Vector的方法都是同步方法，执行起来会在同步上消耗一定的性能，所以在单线程环境下，Vector的性能是不如ArrayList的\",\"除了线程安全这点本质区别外，还有一个实现上的小细节区别：ArrayList每次扩容的大小为原来的1.5倍；Vector可以指定扩容的大小，默认是原来大小的两倍。\",\"可以顺带谈谈多线程环境下ArrayList的替代品，比如CopyOnWriteArrayList，但是要谈谈优缺点。\"]},\"1119\":{\"h\":\"8. 请谈一谈 Java 集合中的 fail-fast 和 fail-safe 机制\",\"t\":[\"fail-fast 是一种错误检测机制，Java 在适合单线程使用的集合容器中很好地实现了 fail-fast 机制，举一个简单的例子：在多线程并发环境下，A线程在通过迭代器遍历一个 ArrayList 集合，B线程同时对该集合进行增删元素操作，这个时候线程A就会抛出并发修改异常，中断正常执行的逻辑。\",\"而fail-safe机制更像是一种对 fail-fast 机制的补充，它被广泛地实现在各种并发容器集合中。回头看上面的例子，如果线程A遍历的不是一个 ArrayList，而是一个 CopyOnWriteArrayList，则符合 fail-safe 机制，线程B可以同时对该集合的元素进行增删操作，线程A不会抛出任何异常。\",\"要理解这两种机制的表象，我们得了解这两种机制背后的实现原理：\",\"我们同样用 ArrayList 解释 fail-fast 背后的原理：首先 ArrayList 自身会维护一个 modCount 变量，每当进行增删元素等操作时，modCount 变量都会进行自增。当使用迭代器遍历 ArrayList 时，迭代器会新维护一个初始值等于 modCount 的 expectedModCount 变量，每次获取下一个元素的时候都会去检查 expectModCount 和 modCount 是否相等。在上面举的例子中，由于B线程增删元素会导致 modCount 自增，当A线程遍历元素时就会发现两个变量不等，从而抛出异常。\",\"CopyOnWriteArrayList 所实现的 fail-safe 在上述情况下没有抛出异常，它的原理是：当使用迭代器遍历集合时，会基于原数组拷贝出一个新的数组（ArrayList的底层是数组），后续的遍历行为在新数组上进行。所以线程B同时进行增删操作不会影响到线程A的遍历行为。\"]},\"1120\":{\"h\":\"9. HashMap是怎样确定key存放在数组的哪个位置的？JDK1.8\",\"t\":[\"首先计算key的hash值，计算过程是：先得到key的hashCode（int类型，4字节），然后把hashCode的高16位与低16位进行异或，得到key的hash值。\",\"接下来用key的hash值与数组长度减一的值进行按位与操作，得到key在数组中对应的下标。\"]},\"1121\":{\"h\":\"9.1. 追问：为什么计算key的hash时要把hashCode的高16位与低16位进行异或？（变式：为什么不直接用key的hashCode）?\",\"t\":[\"计算key在数组中的下标时，是通过hash值与数组长度减一的值进行按位与操作的。由于数组的长度通常不会超过2^16，所以hash值的高16位通常参与不了这个按位与操作。\",\"为了让hashCode的高16位能够参与到按位与操作中，所以把hashCode的高16位与低16位进行异或操作，使得高16位的影响能够均匀稀释到低16位中，使得计算key位置的操作能够充分散列均匀。\"]},\"1122\":{\"h\":\"10. 为什么要把链表转为红黑树，阈值为什么是8？\",\"t\":[\"在极端情况下，比如说key的hashCode()返回的值不合理，或者多个密钥共享一个hashCode，很有可能会在同一个数组位置产生严重的哈希冲突。\",\"这种情况下，如果我们仍然使用使用链表把多个冲突的元素串起来，这些元素的查询效率就会从O(1)下降为O(N)。为了能够在这种极端情况下仍保证较为高效的查询效率，HashMap选择把链表转换为红黑树，红黑树是一种常用的平衡二叉搜索树，添加，删除，查找元素等操作的时间复杂度均为O(logN)\",\"至于阈值为什么是8，这是HashMap的作者根据概率论的知识得到的。当key的哈希码分布均匀时，数组同一个位置上的元素数量是成泊松分布的，同一个位置上出现8个元素的概率已经接近千分之一了，这侧面说明如果链表的长度达到了8，key的hashCode()肯定是出了大问题，这个时候需要红黑树来保证性能，所以选择8作为阈值。\",\"追问：为什么红黑树转换回链表的阈值不是7而是6呢？\",\"如果是7的话，那么链表和红黑树之间的切换范围值就太小了。如果我的链表长度不停地在7和8之间切换，那岂不是得来回变换形态？所以选择6是一种折中的考虑。\"]},\"1123\":{\"h\":\"拓展题. 为什么 HashMap 数组的长度是2的幂次方？\",\"t\":[\"因为这样能够提高根据 key 计算数组位置的效率。\",\"HashMap 根据 key 计算数组位置的算法是：用 key 的 hash 值与数组长度减1的值进行按位与操作。\",\"在我们正常人的思维中，获取数组的某个位置最直接的方法是对数组的长度取余数。但是如果被除数是2的幂次方，那么这个对数组长度取余的方法就等价于对数组长度减一的值进行按位与操作。\",\"在计算机中，位运算的效率远高于取模运算，所以为了提高效率，把数组的长度设为2的幂次方。\",\"所以一定要看一遍源码，相比于框架的源码，集合的源码简直太友好了。在笔试的时候可能还会考一些集合的使用，比如遍历，排序，比较等等，这些算是Java基础，用得多也就熟了。\",\"低谷蓄力\",\"《最少必要面试题》\",\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\",\"GItHub|GitEE\"]},\"1124\":{\"c\":[\"最少必要面试题\"]},\"1125\":{\"c\":[\"java\",\"面试题\"]},\"1126\":{\"h\":\"10道不得不会的 JavaEE 面试题\",\"t\":[\"JavaEE\",\"10道不得不会的 JavaEE 面试题\",\"我是 JavaPub，专注于面试、副业，技术人的成长记录。\",\"以下是 JavaEE 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\",\"本系列《最少必要面试题》\",\"目前很多新项目很少会用到JavaEE的技术栈，但是对于部分维护老代码的工程师来说，还是尤为重要。\"]},\"1127\":{\"h\":\"1. JSP 有哪些内置对象？作用分别是什么？\",\"t\":[\"JSP有9个内置对象：\",\"request：封装客户端的请求，其中包含来自GET或POST请求的参数；\",\"response：封装服务器对客户端的响应；\",\"pageContext：通过该对象可以获取其他对象；\",\"session：封装用户会话的对象；\",\"application：封装服务器运行环境的对象；\",\"out：输出服务器响应的输出流对象；\",\"config：web应用的配置对象；\",\"page：jsp页面本身（相当于Java程序中的this）；\",\"exception：封装页面抛出异常的对象。\",\"JSP的9内置对象及其含义\"]},\"1128\":{\"h\":\"2. 介绍一下 Servlet 生命周期\",\"t\":[\"Servlet是运行在服务器端，以多线程的方式处理客户端请求的小程序。是sun公司提供的一套规范（规范的实现是接口）。\",\"servlet的生命周期就是从servlet出现到消亡(销毁)的全过程。主要分为以下几个阶段：\",\"加载类—>实例化(为对象分配空间)—>初始化(为对象的属性赋值)—>请求响应(服务阶段)—>销毁\",\"详细介绍：\",\"加载\",\"在下列时刻会加载Servlet（只执行一次）：\",\"如果已经配置自动加载选项，则在启动服务器时自动加载 web.xml 文件中设置的<load-on-start>；\",\"服务器启动之后，客户机首次向Servlet发出请求时会加载；\",\"重新加载Servlet时会进行一次加载；\",\"实例化\",\"加载Servlet后，服务器创建一个Servlet实例。（只执行一次）\",\"初始化\",\"调用 Servlet 的 init() 方法。在初始化阶段，Servlet 初始化参数被传递给 Servlet 配置对象 ServletConfig。（只执行一次）；\",\"请求处理\",\"对于到达服务器的客户机请求，服务器创建针对此次请求的一个\\\"请求对象\\\"和一个\\\"响应对象\\\"。\",\"服务器调用 Servlet 的 service() 方法，该方法用于传递\\\"请求\\\"和\\\"响应\\\"对象。\",\"service() 方法从\\\"请求\\\"对象获得请求信息、处理该请求并用\\\"响应\\\"对象的方法将响应回传给客户端。\",\"service() 方法可以调用其他方法来处理请求，例如 doGet()、doPost() 或其他方法。\",\"销毁\",\"当服务器不需要 Servlet，或重新装入 Servlet 的新实例时，服务器会调用 Servlet 的 destroy() 方法。（只执行一次）；\"]},\"1129\":{\"h\":\"3. Servlet和JSP的区别和联系\",\"t\":[\"区别：\",\"JSP是在HTML代码里面写Java代码；而Servlet是在Java代码中写HTML代码，Servlet本身是个Java类；\",\"JSP使人们将显示和逻辑分隔称为可能，这意味着两者的开发可以并行进行；而Servlet并没有将两者分开；\",\"Servlet独立地处理静态表示逻辑与动态业务逻辑，任何文件的变动都需要对此服务程序重新编译；JSP允许使用特殊标签直接嵌入到HTML页面，HTML内容与JAVA内容也可放在单独文件中，HTML内容的任何变动会自动编译装入到服务程序；\",\"Servlet需要在web.xml中配置；而JSP无需配置；\",\"目前JSP主要用在视图层，负责显示；而Servlet主要用在控制层，负责调度；\",\"联系：\",\"都是SUN公司推出的动态网页技术；\",\"先有Servlet，针对Servlet缺点推出JSP。JSP是Servlet的一种特殊形式，每个JSP页面就是一个Servlet实例，JSP页面由系统翻译成Servlet，Servlet再负责响应用户的请求。\"]},\"1130\":{\"h\":\"4. JSP的执行过程\",\"t\":[\"在JSP运行过程中，首先由客户端发出请求，Web服务器接收到请求之后，如果是第一次访问某个JSP页面，Web服务器对它进行一下三个操作：\",\"翻译\",\"由.jsp变为.java，由JSP引擎完成。\",\"编译\",\"由.java变为.class，由Java编译器实现。\",\"执行\",\"由.class变为.html，用Java虚拟机执行编译文件，然后将执行结果返回给Web服务器，并最终返回给客户端。\",\"如果不是第一次访问某个JSP页面，则只执行第三步，所以第一次访问JSP较慢。\"]},\"1131\":{\"h\":\"5. Session和Cookie的区别和联系；说明在自己项目中如何使用？\",\"t\":[\"Session 和 Cookie 都是会话(Seesion)跟踪技术。Cookie 通过在客户端记录信息确定用户身份，Session 通过在服务器端记录信息确定用户身份。但是 Session 的实现依赖于 Cookie，sessionId(session的唯一标识需要存放在客户端).\",\"cookie数据存放在客户的浏览器上，session数据放在服务器上。\",\"cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。\",\"session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。\",\"单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\",\"可以考虑将登录信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。\",\"在程序开发过程中，我们可以在客户端每次与服务器交互时检查SessionID（Session中属性值，非HttpServlet环境开发中也可以用其它的Key值代替），用于会话管理。\",\"将登陆信息等重要信息存放为SESSION\",\"其他信息如果需要保留，可以放在COOKIE中，比如购物车\",\"购物车最好使用cookie，但是cookie是可以在客户端禁用的，这时候我们要使用cookie+数据库的方式实现，当从cookie中不能取出数据时，就从数据库获取。\"]},\"1132\":{\"h\":\"6. 转发和重定向的联系和区别？\",\"t\":[\"转发：服务器端的跳转，路径不会发生改变（针对的是servlet），是服务器内部的处理，一次请求，请求对象不会变\",\"重定向：客户端的跳转，路径会发生改变，将要请求的路径和302重定向的状态码发给客户端浏览器，客户端浏览器将再次向服务器发出请求，不是同个请求，两次请求。\"]},\"1133\":{\"h\":\"7. 拦截器和过滤器的区别\",\"t\":[\"Spring 的拦截器与 Servlet 的 Filter 有相似之处，比如二者都是AOP编程思想的体现，都能实现权限检查、日志记录等。不同的是:\",\"使用范围不同: Filter 是 Servlet 规范规定的，只能用于Web程序中。而拦截器既可以用于Web程序，也可以用于 Application、Swing程序中。\",\"规范不同: Filter 是在 Servlet 规范中定义的，是 Servlet 容器支持的。而拦截器是在 Spring 容器内的，是 Spring 框架支持的。\",\"使用的资源不同:同其他的代码块一样，拦截器也是一个 Spring 的组件，归 Spring 管理，配置在 Spring 文件中，因此能使用 Spring 里的任何资源、对象，例如 Service 对象、数据源、事务管理等，通过 IoC 注入到拦截器即可;而Filter则不能。\",\"深度不同: Filter 在只在 Servlet 前后起作用。而拦截器能够深入到方法前后、异常抛出前后等，因此拦截器的使用具有更大的弹性。所以在 Spring 构架的程序中，要优先使用拦截器。\",\"一张经典的图\",\"过滤器&拦截器\"]},\"1134\":{\"h\":\"8. 三次握手和四次挥手\",\"t\":[\"这里是字面描述\",\"三次握手:\",\"客户端向服务器发出连接请求等待服务器确认\",\"服务器向客户端返回一个响应告诉客户端收到了请求\",\"客户端向服务器再次发出确认信息,此时连接建立\",\"四次挥手:\",\"客户端向服务器发出取消连接请求\",\"服务器向客户端返回一个响应,表示收到客户端取消请求\",\"服务器向客户端发出确认取消信息(向客户端表明可以取消连接了)\",\"客户端再次发送确认消息,此时连接取消\"]},\"1135\":{\"h\":\"9. TCP和UDP的区别\",\"t\":[\"TCP ：面向连接，UDP ：面向无连接\",\"TCP ：传输效率低，UDP ：传输效率高(有大小限制，一次限定在64kb之内)\",\"TCP：可靠，UDP ：不可靠\"]},\"1136\":{\"h\":\"10. 如何解决跨域问题？\",\"t\":[\"跨域指的是浏览器不能执行其它网站的脚本，它是由浏览器的同源策略造成的，是浏览器对 JavaScript 施加的安全限制。\",\"所谓同源指的是：协议、域名、端口号都相同，只要有一个不相同，那么都是非同源。\",\"解决方案：\",\"使用 ajax 的 jsonp。（这一点有些人是不知道的）\",\"nginx 转发：利用 nginx 反向代理，将请求分发到部署相应项目的 tomcat 服务器，当然也不存在跨域问题。\",\"使用 CORS：写一个配置类实现 WebMvcConfigurer 接口或者配置 FilterRegistrationBean。\",\"CORS（Cross-Origin Resource Sharing）是一个W3C标准，全称“跨域资源共享”\"]},\"1137\":{\"h\":\"11. 什么是 CSRF 攻击？如何防御CSRF 攻击\",\"t\":[\"CSRF（Cross-site request forgery） 跨站请求伪造。CSRF 攻击是在受害者毫不知情的情况下，以受害者名义伪造请求发送给受攻击站点，从而在受害者并未授权的情况下执行受害者权限下的各种操作。\",\"CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。\",\"目前防御 CSRF 攻击主要有三种策略：\",\"验证 HTTP Referer 字段\",\"在请求地址中添加 token 并验证\",\"在 HTTP 头中自定义属性并验证\"]},\"1138\":{\"h\":\"12. HTTP1.0和HTTP1.1和HTTP2.0的区别\",\"t\":[\"HTTP1.0 ：无状态，无连接。\",\"HTTP1.1 ：长连接，请求管道化，增加缓存处理，增加 Host 字段，支持断点传输。\",\"HTTP2.0 ：二进制分帧，多路复用(连接共享)，头部压缩，服务器推送。\",\"低谷蓄力\",\"《最少必要面试题》\",\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\",\"GItHub|GitEE\"]},\"1139\":{\"c\":[\"最少必要面试题\"]},\"1140\":{\"c\":[\"javaee\",\"面试题\"]},\"1141\":{\"h\":\"10道不得不会的JVM面试题\",\"t\":[\"JVM\",\"10道不得不会的JVM面试题\",\"我是JavaPub，专注于面试、副业，技术人的成长记录。\",\"以下是 JVM 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\",\"基于JDK8\"]},\"1142\":{\"h\":\"1. 说一说JVM的主要组成部分\",\"t\":[\"点击放大看，一图胜千文\",\"方法区和堆是所有线程共享的内存区域；而虚拟机栈、本地方法栈和程序计数器的运行是线程私有的内存区域，运行时数据区域就是我们常说的JVM的内存。\",\"类加载子系统：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到运行时数据区中的方法区中。\",\"Java堆是Java虚拟机所管理的内存中最大的一块，也是垃圾回收的主要区域。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。\",\"方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\",\"程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器，用来指示执行引擎下一条执行指令的地址。\",\"Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、返回方法地址等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\",\"本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。\",\"执行引擎：根据程序计数器中存储的指令地址执行classes中的指令。\",\"本地接口：与本地方法库交互，是其它编程语言交互的接口。\"]},\"1143\":{\"h\":\"2. 说一下 JVM 的作用？\",\"t\":[\"首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。\"]},\"1144\":{\"h\":\"3. 说一下堆栈的区别？\",\"t\":[\"物理地址\",\"堆的物理地址分配对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）\",\"栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。\",\"内存分别\",\"堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。\",\"栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。\",\"存放的内容\",\"堆存放的是对象的实例和数组。因此该区更关注的是数据的存储\",\"栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。\",\"PS：\",\"静态变量放在方法区 静态的对象还是放在堆。 程序的可见度\",\"堆对于整个应用程序都是共享、可见的。\",\"栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。\"]},\"1145\":{\"h\":\"4. Java内存泄漏\",\"t\":[\"内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。\",\"严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。\",\"理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。\",\"但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。\"]},\"1146\":{\"h\":\"5. JVM 有哪些垃圾回收算法？\",\"t\":[\"标记-清除算法：标记有用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。\",\"复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半，消耗内存。\",\"标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。\",\"分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。\"]},\"1147\":{\"h\":\"6. 说一下 JVM 有哪些垃圾回收器？\"},\"1148\":{\"h\":\"7. 说一下类加载的执行过程？\",\"t\":[\"加载：根据查找路径找到相应的 class 文件然后装载入内存中；\",\"验证：检查加载的 class 文件的正确性；\",\"准备：给类中的静态变量分配内存空间；\",\"解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；\",\"初始化：对静态变量和静态代码块执行初始化工作。\"]},\"1149\":{\"h\":\"8. 什么是双亲委派模型？为什么要使用双亲委派模型？\",\"t\":[\"什么是双亲委派模型\",\"当需要加载一个类的时候，子类加载器并不会马上去加载，而是依次去请求父类加载器加载\",\"如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；\",\"如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。\",\"为什么要使用双亲委派模型\",\"可以防止内存中出现多份同样的字节码，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的Object类，那么类之间的比较结果及类的唯一性将无法保证，而且如果不使用这种双亲委派模型将会给虚拟机的安全带来隐患。所以，要让类对象进行比较有意义，前提是他们要被同一个类加载器加载。\"]},\"1150\":{\"h\":\"9. CMS垃圾清理的过程\",\"t\":[\"CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记 stop-the-world)\",\"初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出 GC Roots 能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。\",\"并发标记（Concurrent-Mark）阶段：从 Gc Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。\",\"重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。\",\"并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的\"]},\"1151\":{\"h\":\"10. 常用的 JVM 调优的参数都有哪些？\",\"t\":[\"-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；\",\"-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；\",\"–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；\",\"-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；\",\"-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；\",\"-XX:+PrintGC：开启打印 gc 信息；\",\"-XX:+PrintGCDetails：打印 gc 详细信息。\",\"JVM 调优-这个问题单独一篇\"]},\"1152\":{\"h\":\"系列文章\",\"t\":[\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\",\"GItHub|GitEE\"]},\"1153\":{\"c\":[\"最少必要面试题\"]},\"1154\":{\"c\":[\"jvm\",\"面试题\"]},\"1155\":{\"h\":\"10道不得不会的 Kafka 面试题\",\"t\":[\"kafka\",\"10道不得不会的 Kafka 面试题\",\"我是JavaPub，专注于面试、副业，技术人的成长记录。\",\"以下是 Kafka 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\",\"在面试kafka中，一定要了解为什么要用kafka、及kafka的架构等基本概念，才能对面试中的问题得心应手。\"]},\"1156\":{\"h\":\"术语0. Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么\",\"t\":[\"ISR:In-Sync Replicas 副本同步队列\",\"AR:Assigned Replicas 所有副本\",\"ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR=ISR+OSR。\"]},\"1157\":{\"h\":\"术语0. Kafka中的HW、LEO、LSO、LW等分别代表什么？\",\"t\":[\"HW:High Watermark 高水位，取一个partition对应的ISR中最小的LEO作为HW，consumer最多只能消费到HW所在的位置上一条信息。\",\"LEO:LogEndOffset 当前日志文件中下一条待写信息的offset HW/LEO这两个都是指最后一条的下一条的位置而不是指最后一条的位置。\",\"LSO:Last Stable Offset 对未完成的事务而言，LSO 的值等于事务中第一条消息的位置(firstUnstableOffset)，对已完成的事务而言，它的值同 HW 相同\",\"LW:Low Watermark 低水位, 代表 AR 集合中最小的 logStartOffset 值\"]},\"1158\":{\"h\":\"1. kafka 是什么？有什么作用？\",\"t\":[\"Kafka 是一个分布式的流式处理平台，它以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用\",\"主要功能体现于三点：\",\"消息系统：kafka与传统的消息中间件都具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。与此同时，kafka还提供了大多数消息系统难以实现的消息顺序性保障及回溯性消费的功能。\",\"存储系统：kafka把消息持久化到磁盘，相比于其他基于内存存储的系统而言，有效的降低了消息丢失的风险。这得益于其消息持久化和多副本机制。也可以将kafka作为长期的存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题日志压缩功能。\",\"流式处理平台：kafka为流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理框架，比如窗口、连接、变换和聚合等各类操作。\"]},\"1159\":{\"h\":\"2. kafka 的架构是怎么样的？\",\"t\":[\"这是一个基本概念的题目，一定要掌握。\",\"一个典型的 kafka 体系架构包括若干 Producer、若干 Consumer、以及一个 Zookeeper 集群（在2.8.0版本中移，除了 Zookeeper,通过 KRaft 进行自己的集群管理）\",\"Producer 将消息发送到 Broker，Broker 负责将受到的消息存储到磁盘中，而 Consumer 负责从 Broker 订阅并消费消息。\",\"Kafka 基本概念：\",\"Producer ：生产者，负责将消息发送到 Broker\",\"Consumer ：消费者，从 Broker 接收消息\",\"Consumer Group ：消费者组，由多个 Consumer 组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费，消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。\",\"Broker ：可以看做一个独立的 Kafka 服务节点或 Kafka 服务实例。如果一台服务器上只部署了一个 Kafka 实例，那么我们也可以将 Broker 看做一台 Kafka 服务器。\",\"Topic ：一个逻辑上的概念，包含很多 Partition，同一个 Topic 下的 Partiton 的消息内容是不相同的。\",\"Partition ：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker 上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。\",\"Replica ：副本，同一分区的不同副本保存的是相同的消息，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，- kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。\",\"Leader ：每个分区的多个副本中的\\\"主副本\\\"，生产者以及消费者只与 Leader 交互。\",\"Follower ：每个分区的多个副本中的\\\"从副本\\\"，负责实时从 Leader 中同步数据，保持和 Leader 数据的同步。Leader 发生故障时，从 Follower 副本中重新选举新的 Leader 副本对外提供服务。\"]},\"1160\":{\"h\":\"3. Kafka Replicas是怎么管理的？\",\"t\":[\"AR:分区中的所有 Replica 统称为 AR\",\"ISR:所有与 Leader 副本保持一定程度同步的Replica(包括 Leader 副本在内)组成 ISR\",\"OSR:与 Leader 副本同步滞后过多的 Replica 组成了 OSR\",\"Leader 负责维护和跟踪 ISR 集合中所有 Follower 副本的滞后状态，当 Follower 副本落后过多时，就会将其放入 OSR 集合，当 Follower 副本追上了 Leader 的进度时，就会将其放入 ISR 集合。\",\"默认情况下，只有 ISR 中的副本才有资格晋升为 Leader。\"]},\"1161\":{\"h\":\"4. 如何确定当前能读到哪一条消息？\",\"t\":[\"这个问题要先了解上一个问题的概念\",\"分区相当于一个日志文件，我们先简单介绍几个概念\",\"如上图是一个分区日志文件\",\"标识共有7条消息，offset (消息偏移量)分别是0~6\",\"0 代表这个日志文件的开始\",\"HW(High Watermark) 为4，0~3 代表这个日志文件可以消费的区间，消费者只能消费到这四条消息\",\"LEO 代表即将要写入消息的偏移量 offset\",\"分区 ISR 集合中的每个副本都会维护自己的 LEO，而 ISR 集合中最小的LEO 即为分区的 HW\",\"如上图: 三个分区副本都是 ISR集合当中的，最小的 LEO 为 3，就代表分区的 HW 为3，所以当前分区只能消费到 0~2 之间的三条数据，如下图\"]},\"1162\":{\"h\":\"5. 发送消息的分区策略有哪些？\",\"t\":[\"1.轮询：依次将消息发送该topic下的所有分区，如果在创建消息的时候 key 为 null，Kafka 默认采用这种策略。\",\"2.key 指定分区：在创建消息是 key 不为空，并且使用默认分区器，Kafka 会将 key 进行 hash，然后根据hash值映射到指定的分区上。这样的好处是 key 相同的消息会在一个分区下，Kafka 并不能保证全局有序，但是在每个分区下的消息是有序的，按照顺序存储，按照顺序消费。在保证同一个 key 的消息是有序的，这样基本能满足消息的顺序性的需求。但是如果 partation 数量发生变化，那就很难保证 key 与分区之间的映射关系了。\",\"3.自定义策略：实现 Partitioner 接口就能自定义分区策略。\",\"4.指定 Partiton 发送\"]},\"1163\":{\"h\":\"6. Kafka 的可靠性是怎么保证的？\",\"t\":[\"1.acks\",\"这个参数用来指定分区中有多少个副本收到这条消息，生产者才认为这条消息是写入成功的，这个参数有三个值：\",\"1.acks = 1，默认为1。生产者发送消息，只要 leader 副本成功写入消息，就代表成功。这种方案的问题在于，当返回成功后，如果 leader 副本和 follower 副本还没有来得及同步，leader 就崩溃了，那么在选举后新的 leader 就没有这条消息，也就丢失了。\",\"2.acks = 0。生产者发送消息后直接算写入成功，不需要等待响应。这个方案的问题很明显，只要服务端写消息时出现任何问题，都会导致消息丢失。\",\"3.acks = -1 或 acks = all。生产者发送消息后，需要等待 ISR 中的所有副本都成功写入消息后才能收到服务端的响应。毫无疑问这种方案的可靠性是最高的，但是如果 ISR 中只有leader 副本，那么就和 acks = 1 毫无差别了。\",\"2.消息发送的方式\",\"第6问中我们提到了生产者发送消息有三种方式，发完即忘，同步和异步。我们可以通过同步或者异步获取响应结果，失败做重试来保证消息的可靠性。\",\"3.手动提交位移\",\"默认情况下，当消费者消费到消息后，就会自动提交位移。但是如果消费者消费出错，没有进入真正的业务处理，那么就可能会导致这条消息消费失败，从而丢失。我们可以开启手动提交位移，等待业务正常处理完成后，再提交offset。\",\"4.通过副本 LEO 来确定分区 HW\",\"可参考第四问\"]},\"1164\":{\"h\":\"7. 分区再分配是做什么的？解决了什么问题？\",\"t\":[\"分区再分配主要是用来维护 kafka 集群的负载均衡\",\"既然是分区再分配，那么 kafka 分区有什么问题呢？\",\"问题1：当集群中的一个节点下线了\",\"如果该节点的分区是单副本的,那么分区将会变得不可用\",\"如果是多副本的，就会进行 leader 选举，在其他机器上选举出新的 leader\",\"kafka 并不会将这些失效的分区迁移到其他可用的 broker 上，这样就会影响集群的负载均衡，甚至也会影响服务的可靠性和可用性\",\"问题2：集群新增 broker 时，只有新的主题分区会分配在该 broker 上，而老的主题分区不会分配在该 broker 上，就造成了老节点和新节点之间的负载不均衡。\",\"为了解决该问题就出现了分区再分配，它可以在集群扩容，broker 失效的场景下进行分区迁移。\",\"分区再分配的原理就是通化控制器给分区新增新的副本，然后通过网络把旧的副本数据复制到新的副本上，在复制完成后，将旧副本清除。 当然，为了不影响集群正常的性能，在此复制期间还会有一系列保证性能的操作，比如复制限流。\"]},\"1165\":{\"h\":\"8. Kafka Partition 副本 leader 是怎么选举的？\",\"t\":[\"这个问题设计的点比较多，拓展的也更多一点，建议耐心阅读。\",\"常用选主机制的缺点：\",\"split-brain (脑裂): ​这是由ZooKeeper的特性引起的，虽然ZooKeeper能保证所有Watch按顺序触发，但是网络延迟，并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致，可能选出多个领导“大脑”，导致“脑裂”。 herd effect (羊群效应): ​如果宕机的那个Broker上的Partition比较多， 会造成多个Watch被触发，造成集群内大量的调整，导致大量网络阻塞。 ZooKeeper负载过重: ​每个Replica都要为此在ZooKeeper上注册一个Watch，当集群规模增加到几千个Partition时ZooKeeper负载会过重。\",\"优势：\",\"Kafka的Leader Election方案解决了上述问题，它在所有broker中选出一个controller，所有Partition的Leader选举都由controller决定。 controller会将Leader的改变直接通过RPC的方式(比ZooKeeper Queue的方式更高效)通知需为此作为响应的Broker。\",\"没有使用 zk，所以无 2.3 问题；也没有注册 watch无 2.2 问题 leader 失败了，就通过 controller 继续重新选举即可，所以克服所有问题。\",\"Kafka partition leader的选举：\",\"由 controller 执行：\",\"从Zookeeper中读取当前分区的所有ISR(in-sync replicas)集合\",\"调用配置的分区选择算法选择分区的leader\",\"分区选择算法\",\"上面五种分区算法都是选择PreferredReplica(优先副本选举)作为当前Partition的leader。区别仅仅是选择leader之后的操作有所不同。\"]},\"1166\":{\"h\":\"9. 分区数越多越好吗？吞吐量就会越高吗？\",\"t\":[\"般类似于这种问题的答案，都是持否定态度的。\",\"但是可以说，在一定条件下，分区数的数量是和吞吐量成正比的，分区数和性能也是成正比的。\",\"那么为什么说超过了一定限度，就会对性能造成影响呢？原因如下:\",\"1.客户端/服务器端需要使用的内存就越多\",\"服务端在很多组件中都维护了分区级别的缓存，分区数越大，缓存成本也就越大。 消费端的消费线程数是和分区数挂钩的，分区数越大消费线程数也就越多，线程的开销成本也就越大 生产者发送消息有缓存的概念，会为每个分区缓存消息，当积累到一定程度或者时间时会将消息发送到分区，分区越多，这部分的缓存也就越大\",\"2.文件句柄的开销\",\"每个 partition 都会对应磁盘文件系统的一个目录。在 Kafka 的数据日志文件目录中，每个日志数据段都会分配两个文件，一个索引文件和一个数据文件。每个 broker 会为每个日志段文件打开一个 index 文件句柄和一个数据文件句柄。因此，随着 partition 的增多，所需要保持打开状态的文件句柄数也就越多，最终可能超过底层操作系统配置的文件句柄数量限制。\",\"3.越多的分区可能增加端对端的延迟\",\"Kafka 会将分区 HW 之前的消息暴露给消费者。分区越多则副本之间的同步数量就越多，在默认情况下，每个 broker 从其他 broker 节点进行数据副本复制时，该 broker 节点只会为此工作分配一个线程，该线程需要完成该 broker 所有 partition 数据的复制。\",\"4.降低高可用性\",\"在第 7 问我们提到了分区再分配，会将数据复制到另一份副本当中，分区数量越多，那么恢复时间也就越长，而如果发生宕机的 broker 恰好是 controller 节点时：在这种情况下，新 leader 节点的选举过程在 controller 节点恢复到新的 broker 之前不会启动。controller 节点的错误恢复将会自动地进行，但是新的 controller 节点需要从 zookeeper 中读取每一个 partition 的元数据信息用于初始化数据。例如，假设一个Kafka 集群存在 10000个partition，从 zookeeper 中恢复元数据时每个 partition 大约花费 2 ms，则 controller 的恢复将会增加约 20 秒的不可用时间窗口。\"]},\"1167\":{\"h\":\"10. kafka 为什么这么快？\",\"t\":[\"1.顺序读写磁盘分为顺序读写与随机读写，基于磁盘的随机读写确实很慢，但磁盘的顺序读写性能却很高，kafka 这里采用的就是顺序读写。\",\"2.Page Cache为了优化读写性能，Kafka 利用了操作系统本身的 Page Cache，就是利用操作系统自身的内存而不是JVM空间内存。\",\"3.零拷贝Kafka使用了零拷贝技术，也就是直接将数据从内核空间的读缓冲区直接拷贝到内核空间的 socket 缓冲区，然后再写入到 NIC 缓冲区，避免了在内核空间和用户空间之间穿梭。\",\"4.分区分段+索引Kafka 的 message 是按 topic分 类存储的，topic 中的数据又是按照一个一个的 partition 即分区存储到不同 broker 节点。每个 partition 对应了操作系统上的一个文件夹，partition 实际上又是按照segment分段存储的。通过这种分区分段的设计，Kafka 的 message 消息实际上是分布式存储在一个一个小的 segment 中的，每次文件操作也是直接操作的 segment。为了进一步的查询优化，Kafka 又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。\",\"5.批量读写Kafka 数据读写也是批量的而不是单条的,这样可以避免在网络上频繁传输单个消息带来的延迟和带宽开销。假设网络带宽为10MB/S，一次性传输10MB的消息比传输1KB的消息10000万次显然要快得多。\",\"6.批量压缩Kafka 把所有的消息都变成一个批量的文件，并且进行合理的批量压缩，减少网络 IO 损耗，通过 mmap 提高 I/O 速度，写入数据的时候由于单个Partion是末尾添加所以速度最优；读取数据的时候配合 sendfile 进行直接读取。\",\"低谷蓄力\"]},\"1168\":{\"h\":\"《最少必要面试题》\",\"t\":[\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\",\"GItHub|GitEE\"]},\"1169\":{\"c\":[\"最少必要面试题\"]},\"1170\":{\"c\":[\"kafka\",\"面试题\"]},\"1171\":{\"h\":\"10道不得不会的 MyBatis 面试题\",\"t\":[\"MyBatis\",\"10道不得不会的 MyBatis 面试题\",\"我是JavaPub，专注于面试、副业，技术人的成长记录。\",\"以下是 MyBatis 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\",\"本系列《最少必要面试题》\"]},\"1172\":{\"h\":\"1. 什么是MyBatis\",\"t\":[\"这个问题主要是对比JDBC来看\",\"MyBatis是一个ORM（对象关系映射）框架，它内部封装了JDBC,开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动，创建连接，创建statement等复杂的过程。开发人员不需要编写原生态sql，可以严格控制sql执行性能，灵活度高。\",\"MyBatis可以使用xml或者注解来配置映射原生信息，将POJO映射成数据库中的记录，避免了几乎所有的JDBC代码和手动设置的参数以及获取结果集。\"]},\"1173\":{\"h\":\"2. MyBatis的优点\",\"t\":[\"基于SQL语句编程，相对灵活（相对于hibernate），支持写动态sql语句并可重复使用。\",\"减少代码量，消除了冗余代码。（类似于JDBC的封装）\",\"与Spring完美集成。\",\"提供映射标签支持字段关系映射。\"]},\"1174\":{\"h\":\"3. #{}和${}的区别是什么？\",\"t\":[\"#{}预编译处理、是占位符，${}是字符串替换、是拼接符。\",\"使用#{}可以有效的防止sql注入，提高系统的安全性。\",\"Mybatis在处理 #{} 的时候会将sql中的 #{} 替换成？号，调用PreparedStatement来赋值\",\"/* SQL */ 如：select * from user where name = #{userName}；设userName=javapub 看日志我们可以看到解析时将#{userName}替换成了 ？ select * from user where name = ?; 然后再把 javapub 放进去，外面加上单引号\",\"Mybatis在处理 ${} 的时候就是把 ${} 替换成变量的值，调用Statement来赋值\",\"/* SQL */ 如：select * from user where name = #{userName}；设userName=javapub 看日志可以发现就是直接把值拼接上去了 select * from user where name = javapub; 这极有可能发生sql注入，下面举了一个简单的sql注入案例\"]},\"1175\":{\"h\":\"4. 一个 Xml 映射文件，都会写一个 Dao 接口与之对应，这个 Dao 接口的工作原理是什么?\",\"t\":[\"Dao 接口就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名就是映射文件中 MappedStatement 的 id 值，接口方法内的参数就是传递给 sql 的参数。\",\"接口里的方法是不能重载的，因为是全限名+方法名的保存和寻找策略。\",\"Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行接口方法所对应的MappedStatement所代表的sql，然后将sql执行结果返回。\",\"MappedStatement：MappedStatement维护了一条 <select|update|delete|insert>节点的封装,包括了传入参数映射配置、执行的SQL语句、结果映射配置等信息。\",\"<select id=\\\"selectAuthorLinkedHashMap\\\" resultType=\\\"java.util.LinkedHashMap\\\"> select id, username from author where id = #{value} </select>\"]},\"1176\":{\"h\":\"5. 如何获取自动生成的(主)键值?\",\"t\":[\"用法：\",\"在 <insert /> 标签中添加 useGeneratedKeys=\\\"true\\\" 等属性\",\"<insert id=\\\"insert\\\" useGeneratedKeys=\\\"true\\\" keyProperty=\\\"id\\\" keyColumn=\\\"id\\\" parameterType=\\\"person\\\" > INSERT INTO person(name, pswd) VALUE (#{name}, #{pswd}) </insert>\",\"当 Mybatis 解析 xml节点时，读到 insert 有配置时，会判断是否 有配置 useGeneratedKeys，如果有则会使用 Jdbc3KeyGenerator 作为sql回显，否则会以 NoKeyGenerator 作为主键回显。\",\"底层封装了JDBC获取自增主键，即当使用 prepareStatement 或者 Statement时候，可以通过 getGeneratedKeys 获取这条插入语句的自增而成的主键。例子\",\" Connection conn = DriverManager.getConnection(url, \\\"root\\\", \\\"123456\\\"); String[] columnNames = {\\\"id\\\", \\\"name\\\"}; PreparedStatement stmt = conn.prepareStatement(sql, columnNames); stmt.setString(1, \\\"jack wang\\\"); stmt.executeUpdate(); ResultSet rs = stmt.getGeneratedKeys(); int id = 0; if (rs.next()) { id = rs.getInt(1); System.out.println(\\\"----------\\\" + id); }\"]},\"1177\":{\"h\":\"6. Mybatis 动态 sql 有什么用？有哪些动态 sql？执行原理？\",\"t\":[\"Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。\",\"Mybatis 提供了9种动态sql标签： trim | where | set | foreach | if | choose | when | otherwise | bind。\",\"其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。\",\"是不是有点懵，继续阅读：\",\"科普：\",\"OGNL 是 Object-Graph Navigation Language 的缩写，对象图导航语言。例如 #{} 语法。\",\"OGNL 作用是在对象和视图之间做数据的交互，可以存取对象的属性和调用对象的方法，通过表达式可以迭代出整个对象的结构图。\",\"参考一个很形象的例子。\",\"有一个学生对象 student，属性分别有 id = 10，name = '小明' 和 课程对象 course，其中 course 对象中属性有：分数 score = 88，排名 rank = 5。\",\"对象关系图如下：\",\"student id：10 name：小明 course： score：88 rank：5\",\"当上下文（环境）中的对象为 student 的时候，也就是在 Mybatis 中查询时传入的参数对象为 student 的时候：\",\"通过 OGNL 表达式直接获取上下文中对象的属性值，比如：\",\"#{id} —> 10，相对于当前上下文对象.getId()，即 student.getId() 。\",\"#{name} —> 小明。\",\"#{course.score} —> 88，相当于 student.getCourse().getScore()。\",\"所以，通过 OGNL 表达式，可以迭代出整个对象的结构图。\",\"发布 《最少必要面试题》\"]},\"1178\":{\"h\":\"7. 什么是Mybatis的一级、二级缓存?\",\"t\":[\"一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。\",\"当Mybaits与Spring整合的时候，不带Spring事务的方法内，每次请求数据库，都会新建一个SqlSession，这时候是使用不到一级缓存的。除了事务问题，还有调用了Sqlsession的修改、添加、删除、commit()、close()等方法时，一级缓存也会被清空。\",\"二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)。即使开启了二级缓存，不同的sqlsession之间的缓存数据也不是想互访就能互访的，必须等到sqlsession关闭了以后，才会把其一级缓存中的数据写入二级缓存。默认不打开二级缓存。\",\"现在大多数应用都是支持分布式的，一般情况都是用中间件作为缓存层，比如redis。开启 MyBatis 的二级缓存也会多一步序列化和反序列化，影响服务性能。\"]},\"1179\":{\"h\":\"8. MyBatis的工作原理\",\"t\":[\"一图胜千文\",\"来源网络\",\"读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。\",\"加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。\",\"构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。\",\"创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。\",\"Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。\",\"MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。\",\"输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。\",\"输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。\"]},\"1180\":{\"h\":\"9. 什么是MyBatis的接口绑定？有哪些实现方式？\",\"t\":[\"接口绑定，就是在 MyBatis 中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来的SqlSession提供的方法我们可以有更加灵活的选择和设置。\",\"接口绑定有两种实现方式：\",\"通过注解绑定，就是在接口的方法上面加上 @Select、@Update 等注解，里面包含Sql语句来绑定；\",\"通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的 namespace 必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。\"]},\"1181\":{\"h\":\"10. Mybatis的分页原理\",\"t\":[\"Mybatis 使用 RowBounds 对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，所以一般不会使用。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。\",\"分页插件的原理就是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内，拦截待执行的SQL，然后根据设置的 dialect（方言），和设置的分页参数，重写SQL ，生成带有分页语句的SQL，执行重写后的SQL，从而实现分页。\",\"举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10。\",\"低谷蓄力\",\"《最少必要面试题》\",\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\",\"GItHub|GitEE\"]},\"1182\":{\"c\":[\"最少必要面试题\"]},\"1183\":{\"c\":[\"mybatis\",\"面试题\"]},\"1184\":{\"h\":\"10道不得不会的MySQL基础面试题\",\"t\":[\"MySql\",\"10道不得不会的MySQL基础面试题\",\"以下都是 MySQL常见面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\",\"推荐一篇非常不错的文章，阅读后更有利于了解MySQL【B树和B+树的区别】： https://mp.weixin.qq.com/s/RWkc2lNarKnn8Dc0HrP58g\"]},\"1185\":{\"h\":\"1. mysql有哪几种log\",\"t\":[\"重做日志(redo log)、回滚日志(undo log)、二进制日志(binlog)、错误日志(errorlog)、慢查询日志(slow query log)、一般查询日志(general log)，中继日志(relay log)\",\"错误日志：记录出错信息，也记录一些警告信息或者正确的信息。\",\"查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。\",\"慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。\",\"二进制日志：记录对数据库执行更改的所有操作。\",\"中继日志：中继日志也是二进制日志，用来给slave 库恢复\",\"事务日志：重做日志redo和回滚日志undo\"]},\"1186\":{\"h\":\"2. MySQL的复制原理以及流程\",\"t\":[\"主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中。\",\"从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中。\",\"从：sql执行线程——执行relay log中的语句。\"]},\"1187\":{\"h\":\"3. 事物的4种隔离级别\",\"t\":[\"隔离强度逐渐增强，性能逐渐变差。\",\"读未提交(RU) READ UNCOMMITTED\",\"读已提交(RC) READ COMMITT\",\"可重复读(RR) REPEATABLE READ\",\"串行化 SERIALIZABLE\",\"事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）四个特性，简称 ACID，缺一不可。\"]},\"1188\":{\"h\":\"4. 相关概念\",\"t\":[\"脏读\",\"脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。\",\"可重复读\",\"可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据更新（UPDATE）操作。\",\"不可重复读\",\"对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。\",\"幻读\",\"幻读是针对数据插入（INSERT）操作来说的。假设事务 A 对某些行的内容作了更改，但是还未提交，此时事务 B 插入了与事务 A 更改前的记录相同的记录行，并且在事务 A 提交之前先提交了，而这时，在事务 A 中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务 B 刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。\"]},\"1189\":{\"h\":\"5. MySQL数据库几个基本的索引类型\",\"t\":[\"普通索引、唯一索引、主键索引、全文索引\"]},\"1190\":{\"h\":\"6. drop、delete与truncate的区\",\"t\":[\"SQL中的drop、delete、truncate都表示删除，但是三者有一些差别\",\"1、delete和truncate只删除表的数据不删除表的结构 2、速度,一般来说: drop> truncate >delete 3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效; 4、如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.\"]},\"1191\":{\"h\":\"7. 数据库的乐观锁和悲观锁是什么？\",\"t\":[\"悲观锁的特点是先获取锁，再进行业务操作，即 “悲观” 的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的 “一锁二查三更新” 即指的是使用悲观锁。\",\"通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的 select … for update 操作来实现悲观锁。 当数据库执行 select for update 时会获取被 select 中的数据行的行锁，因此其他并发执行的 select for update 如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update 获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。\",\"mysql 还有个问题是 select… for update 语句执行中，如果数据表没有添加索引或主键，所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在 mysql 中用悲观锁务必要确定走了索引，而不是全表扫描。\",\"乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。\",\"乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳。\",\"乐观锁的两种实现方式：\",\"使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 version 值进行比对，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。\",\"乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）,和上面的 version 类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则 OK，否则就是版本冲突。\"]},\"1192\":{\"h\":\"8. SQL优化方式\",\"t\":[\"对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。\",\"应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如果索引是整形，那么可以在索引上设置默认值 0，确保表中列没有 null 值。\",\"应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。\",\"应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。\",\"in 和 not in 也要慎用，否则会导致全表扫描。\",\"like ‘%abc%’ 也会导致全表扫描。\",\"应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。\",\"应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。\",\"在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。\",\"很多时候用 exists 代替 in 是一个好的选择。\"]},\"1193\":{\"h\":\"9. 从锁的类别上分MySQL都有哪些锁呢？\",\"t\":[\"从锁的类别上来讲，有共享锁和排他锁。\",\"共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。\",\"排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。\",\"参考：\",\"1. https://haicoder.net/note/mysql-interview/mysql-interview-optimistic-pessimism-lock.html\"]},\"1194\":{\"h\":\"推荐阅读：\",\"t\":[\"系列面试题\",\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\",\"GItHub|GitEE\"]},\"1195\":{\"c\":[\"最少必要面试题\"]},\"1196\":{\"c\":[\"mysql\",\"面试题\"]},\"1197\":{\"h\":\"10道不得不会的Redis面试题\",\"t\":[\"Redis\",\"10道不得不会的 Redis 面试题\",\"以下是 Redis 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\"]},\"1198\":{\"h\":\"1. Redis是什么？\",\"t\":[\"一般问这个问题你最少要答出以下几点\",\"Redis 是一个基于内存的 key-value 存储系统，数据结构包括字符串、list、set、zset（sorted set --有序集合）和hash，bitmap，GeoHash(坐标)，HyperLogLog，Streams（5.x版本以后）\"]},\"1199\":{\"h\":\"2. 你在哪些场景使用redis\",\"t\":[\"你有实战经验，那就直接表演。如果没有，选几个下面的经典场景\",\"作为队列使用，（因为是基于内存、一般不会作为消费队列、作为循环队列必要适用）；\",\"模拟类似于token这种需要设置过期时间的场景，登录失效；\",\"分布式缓存，避免大量请求底层关系型数据库，大大降低数据库压力；\",\"分布式锁；\",\"基于 bitmap 实现布隆过滤器；\",\"排行榜-基于zset（有序集合数据类型）；\",\"计数器-对于浏览量、播放量等并发较高，使用 redis incr 实现计数器功能；\",\"分布式会话；\",\"消息系统；\"]},\"1200\":{\"h\":\"3. 为什么Redis是单线程的?\",\"t\":[\"这个问题给一个官方答案\",\"因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。\"]},\"1201\":{\"h\":\"4. Redis持久化有几种方式？\",\"t\":[\"redis 提供了两种持久化的方式，分别是快照方式（RDB Redis DataBase）和文件追加（AOF Append Only File）。\",\"显而易见，快照方式重启恢复快、但是数据更容易丢失，文件追加数据更完整、重启恢复慢。\",\"混合持久化方式，Redis 4.0之后新增的方式，混合持久化是结合RDB和AOF的优点，在写入的时候先把当前的数据以RDB的形式写入到文件的开头，再将后续的操作以AOF的格式存入文件当中，这样既能保证重启时的速度，又能降低数据丢失的风险。\",\"在恢复时，先恢复快照方式保存的文件，然后再恢复追加文件中的增量数据。\"]},\"1202\":{\"h\":\"5. 什么是缓存穿透？怎么解决？\",\"t\":[\"缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍，然后返回空。\",\"如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至击垮数据库系统。\",\"这就叫做缓存穿透。\",\"怎么解决？\",\"对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert之后清理缓存。\",\"对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该Bitmap过滤。(也就是布隆过滤器的原理：大白话讲解布隆过滤器)\"]},\"1203\":{\"h\":\"6. 什么是缓存雪崩?\",\"t\":[\"缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，请求直接落到数据库上，引起数据库压力过大甚至宕机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。\",\"怎么解决？\",\"常用的解决方案有：\",\"均匀过期\",\"加互斥锁\",\"缓存永不过期\",\"双层缓存策略\",\"均匀过期：设置不同的过期时间，让缓存失效的时间点尽量均匀。通常可以为有效期增加随机值或者统一规划有效期。\",\"加互斥锁：跟缓存击穿解决思路一致，同一时间只让一个线程构建缓存，其他线程阻塞排队。\",\"缓存永不过期：跟缓存击穿解决思路一致，缓存在物理上永远不过期，用一个异步的线程更新缓存。\",\"双层缓存策略：使用主备两层缓存：\",\"主缓存：有效期按照经验值设置，设置为主读取的缓存，主缓存失效后从数据库加载最新值。\",\"备份缓存：有效期长，获取锁失败时读取的缓存，主缓存更新时需要同步更新备份缓存。\"]},\"1204\":{\"h\":\"7. Redis使用上如何做内存优化？\",\"t\":[\"缩短键值的长度\",\"缩短值的长度才是关键，如果值是一个大的业务对象，可以将对象序列化成二进制数组；\",\"首先应该在业务上进行精简，去掉不必要的属性，避免存储一些没用的数据；\",\"其次是序列化的工具选择上，应该选择更高效的序列化工具来降低字节数组大小；\",\"以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: protostuff，kryo等\",\"共享对象池\",\"对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。\",\"字符串优化\",\"因为redis的惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留。尽量做新增不做更新。\",\"编码优化\",\"所谓编码就是具体使用哪种底层数据结构来实现。编码不同将直接影响数据的内存占用和读写效率。\",\"这个需要掌握redis底层的数据结构。下图作为参考：\",\"控制key的数量\"]},\"1205\":{\"h\":\"8. 你们redis使用哪种部署方式？\",\"t\":[\"redis部署分为单节点、主从部署（master-slave）、哨兵部署（Sentinel）、集群部署（cluster）。\",\"单节点：也就是单机部署；\",\"主从部署：分为一主一从或一主多从，主从之间同步分为全量或增量。量同步：master 节点通过 BGSAVE 生成对应的RDB文件，然后发送给slave节点，slave节点接收到写入命令后将master发送过来的文件加载并写入；增量同步：即在 master-slave 关系建立开始，master每执行一次数据变更的命令就会同步至slave节点。一般会将写请求转发到master，读请求转发到slave。提高了redis的性能。\",\"哨兵部署：分别有哨兵集群与Redis的主从集群，哨兵作为操作系统中的一个监控进程，对应监控每一个Redis实例，如果master服务异常（ping pong其中节点没有回复且超过了一定时间），就会多个哨兵之间进行确认，如果超过一半确认服务异常，则对master服务进行下线处理，并且选举出当前一个slave节点来转换成master节点；如果slave节点服务异常，也是经过多个哨兵确认后，进行下线处理。提高了redis集群高可用的特性，及横向扩展能力的增强。\",\"集群部署：属于**“去中心化”**的一种方式，多个 master 节点保存整个集群中的全部数据，而数据根据 key 进行 crc-16 校验算法进行散列，将 key 散列成对应 16383 个 slot，而 Redis cluster 集群中每个 master 节点负责不同的slot范围。每个 master 节点下还可以配置多个 slave 节点，同时也可以在集群中再使用 sentinel 哨兵提升整个集群的高可用性。\"]},\"1206\":{\"h\":\"9. redis实现分布式锁要注意什么？\",\"t\":[\"加锁过程要保证原子性；\",\"保证谁加的锁只能被谁解锁，即Redis加锁的value，解锁时需要传入相同的value才能成功，保证value唯一性；\",\"设置锁超时时间，防止加锁方异常无法释放锁时其他客户端无法获取锁，同时，超时时间要大于业务处理时间；\",\"使用Redis命令 SET lock_key unique_value NX EX seconds 进行加锁，单命令操作，Redis是串行执行命令，所以能保证只有一个能加锁成功。\"]},\"1207\":{\"h\":\"推荐阅读：\",\"t\":[\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\",\"GItHub|GitEE\"]},\"1208\":{\"c\":[\"最少必要面试题\"]},\"1209\":{\"c\":[\"redis\",\"面试题\"]},\"1210\":{\"h\":\"10道不得不会的Spring面试题\",\"t\":[\"spring\",\"10道不得不会的Spring面试题\",\"我是JavaPub，专注于面试、副业，技术人的成长记录。\",\"以下是 Spring 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\"]},\"1211\":{\"h\":\"1. 什么是 Spring 框架？Spring 框架有哪些主要模块？\",\"t\":[\"Spring是针对bean的生命周期进行管理的轻量级容器，一个控制反转和面向切面的容器框架\",\"Spring有七大功能模块：\",\"1、Core\",\"Core模块是Spring的核心类库，Core实现了IOC功能。\",\"2、AOP\",\"Apring AOP模块是Spring的AOP库，提供了AOP（拦截器）机制，并提供常见的拦截器，供用户自定义和配置。\",\"3、orm\",\"提供对常用ORM框架的管理和支持，hibernate、mybatis等。\",\"4、Dao\",\"Spring提供对JDBC的支持，对JDBC进行封装。\",\"5、Web\",\"对Struts2的支持。\",\"6、Context\",\"Context模块提供框架式的Bean的访问方式，其它程序可以通过Context访问Spring的Bean资源，相当于资源注入。\",\"7、MVC\",\"MVC模块为spring提供了一套轻量级的MVC实现，即Spring MVC。\"]},\"1212\":{\"h\":\"2. Spring IOC、AOP举例说明\",\"t\":[\"这是一个基础问题，如果理解有难度、建议先读五遍。\",\"1、IOC理论的背景\",\"我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。\",\"图1：软件系统中耦合的对象\",\"如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒 针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项 任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。 齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着 工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临 更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。\",\"图2：对象之间复杂的依赖关系\",\"耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品Spring。\",\"2、什么是控制反转(IoC)\",\"IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。 1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以 后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依 赖关系的对象之间的解耦，如下图：\",\"图3：IOC解耦过程\",\"大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三 方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有 对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。 我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：\",\"图4：拿掉IoC容器后的系统\",\"我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样 的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言， 这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！ 我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下： 软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。 软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。 通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。\",\"参考资料：https://www.cnblogs.com/jianmang/articles/4947615.html\"]},\"1213\":{\"h\":\"3. 什么是控制反转(IOC)？什么是依赖注入（DI）？\",\"t\":[\"IoC(Inversion of Control) – 控制反转。它不是一种技术，而是一种思想。\",\"IOC：就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。BeanFactory接口是Spring Ioc容器的核心接口。\",\"DI：我们在使用Spring容器的时候，容器通过调用set方法或者是构造器来建立对象之间的依赖关系。 控制反转是目标，依赖注入是我们实现控制反转的一种手段。\"]},\"1214\":{\"h\":\"4. 描述一下 Spring Bean 的生命周期？\",\"t\":[\"这道题是spring一道标准题目\",\"按照阶段理解Spring中的bean的生命周期主要包含四个阶段：实例化Bean --＞ Bean属性填充 --＞ 初始化Bean --＞销毁Bean\",\"Spring Bean 的生命周期\",\"Spring中的bean的生命周期主要包含四个阶段：实例化Bean --＞ Bean属性填充 --＞ 初始化Bean --＞销毁Bean\",\"首先是实例化Bean，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚末初始化的依赖时，容器就会调用doCreateBean()方法进行实例化，实际上就是通过反射的方式创建出一个bean对象\",\"Bean实例创建出来后，接着就是给这个Bean对象进行属性填充，也就是注入这个Bean依赖的其它bean对象\",\"属性填充完成后，进行初始化Bean操作，初始化阶段又可以分为几个步骤：\",\"a. 执行Aware接口的方法\",\"Spring会检测该对象是否实现了xxxAware接口，通过Aware类型的接口，可以让我们拿到Spring容器的些资源。如实现BeanNameAware接口可以获取到BeanName，实现BeanFactoryAware接口可以获取到工厂对象BeanFactory等\",\"b. 执行BeanPostProcessor的前置处理方法postProcessBeforelnitialization()，对Bean进行一些自定义的前置处理\",\"c. 判断Bean是否实现了InitializingBean接口，如果实现了，将会执行lnitializingBean的afeterPropertiesSet()初始化方法；\",\"d. 执行用户自定义的初始化方法，如init-method等；\",\"e. 执行BeanPostProcessor的后置处理方法postProcessAfterinitialization()\",\"初始化完成后，Bean就成功创建了，之后就可以使用这个Bean， 当Bean不再需要时，会进行销毁操作，\",\"a. 首先判断Bean是否实现了DestructionAwareBeanPostProcessor接口，如果实现了，则会执行DestructionAwareBeanPostProcessor后置处理器的销毁回调方法 b. 其次会判断Bean是否实现了DisposableBean接口，如果实现了将会调用其实现的destroy()方法 c. 最后判断这个Bean是否配置了dlestroy-method等自定义的销毁方法，如果有的话，则会自动调用其配置的销毁方法；\"]},\"1215\":{\"h\":\"5. Spring Bean 的作用域之间有什么区别？\",\"t\":[\"Spring器中的bean可以分为5个范围：\",\"singleton：这种bean范围是默认的，这种范围确保不管接受多少请求，每个容器中只有一个bean的实例，单例模式；\",\"prototype：为每一个bean提供一个实例；\",\"request：在请求bean范围内为每一个来自客户端的网络请求创建一个实例，在请求完毕后，bean会失效并被垃圾回收器回收；\",\"session：为每个session创建一个实例，session过期后，bean会随之消失；\",\"global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet公用全局的存储变量的话，那么全局变量需要存储在global-session中。\"]},\"1216\":{\"h\":\"6. Spring中都应用了哪些设计模式\",\"t\":[\"1、简单工厂模式\",\"简单工厂模式的本质就是一个工厂类根据传入的参数，动态的决定实例化哪个类。\",\"Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象。\",\"2、工厂方法模式\",\"应用程序将对象的创建及初始化职责交给工厂对象，工厂Bean。\",\"定义工厂方法，然后通过config.xml配置文件，将其纳入Spring容器来管理，需要通过factory-method指定静态方法名称。\",\"3、单例模式\",\"Spring用的是双重判断加锁的单例模式，通过getSingleton方法从singletonObjects中获取bean。\",\" /** * Return the (raw) singleton object registered under the given name. * <p>Checks already instantiated singletons and also allows for an early * reference to a currently created singleton (resolving a circular reference). * @param beanName the name of the bean to look for * @param allowEarlyReference whether early references should be created or not * @return the registered singleton object, or {@code null} if none found */ protected Object getSingleton(String beanName, boolean allowEarlyReference) { Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) { synchronized (this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null && allowEarlyReference) { ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } return (singletonObject != NULL_OBJECT ? singletonObject : null); }\",\"4、代理模式\",\"Spring的AOP中，使用的Advice（通知）来增强被代理类的功能。Spring实现AOP功能的原理就是代理模式（① JDK动态代理，② CGLIB字节码生成技术代理。）对类进行方法级别的切面增强。\",\"5、装饰器模式\",\"装饰器模式：动态的给一个对象添加一些额外的功能。\",\"Spring的ApplicationContext中配置所有的DataSource。这些DataSource可能是不同的数据库，然后SessionFactory根据用户的每次请求，将DataSource设置成不同的数据源，以达到切换数据源的目的。\",\"在Spring中有两种表现：\",\"一种是类名中含有Wrapper，另一种是类名中含有Decorator。\",\"6、观察者模式\",\"定义对象间的一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。\",\"Spring中观察者模式一般用在listener的实现。\",\"7、策略模式\",\"策略模式是行为性模式，调用不同的方法，适应行为的变化 ，强调父类的调用子类的特性 。\",\"getHandler是HandlerMapping接口中的唯一方法，用于根据请求找到匹配的处理器。\",\"8、模板方法模式\",\"Spring JdbcTemplate的query方法总体结构是一个模板方法+回调函数，query方法中调用的execute()是一个模板方法，而预期的回调doInStatement(Statement state)方法也是一个模板方法。\"]},\"1217\":{\"h\":\"7. Spring AOP里面的几个名词的概念\",\"t\":[\"（1）连接点（Join point）：指程序运行过程中所执行的方法。在Spring AOP中，一个连接点总代表一个方法的执行。\",\"（2）切面（Aspect）：被抽取出来的公共模块，可以用来会横切多个对象。Aspect切面可以看成 Pointcut切点 和 Advice通知 的结合，一个切面可以由多个切点和通知组成。\",\"在Spring AOP中，切面可以在类上使用 @AspectJ 注解来实现。\",\"（3）切点（Pointcut）：切点用于定义 要对哪些Join point进行拦截。\",\"切点分为execution方式和annotation方式。execution方式可以用路径表达式指定对哪些方法拦截，比如指定拦截add*、search*。annotation方式可以指定被哪些注解修饰的代码进行拦截。\",\"（4）通知（Advice）：指要在连接点（Join Point）上执行的动作，即增强的逻辑，比如权限校验和、日志记录等。通知有各种类型，包括Around、Before、After、After returning、After throwing。\",\"（5）目标对象（Target）：包含连接点的对象，也称作被通知（Advice）的对象。 由于Spring AOP是通过动态代理实现的，所以这个对象永远是一个代理对象。\",\"（6）织入（Weaving）：通过动态代理，在目标对象（Target）的方法（即连接点Join point）中执行增强逻辑（Advice）的过程。\",\"（7）引入（Introduction）：添加额外的方法或者字段到被通知的类。Spring允许引入新的接口（以及对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。\",\"几个概念的关系图可以参考下图：\",\"网上有张非常形象的图，描述了各个概念所处的场景和作用，贴在这里供大家理解：\"]},\"1218\":{\"h\":\"8. BeanFactory和ApplicationContext有什么区别？\",\"t\":[\"BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。\",\"BeanFactory是Spring里面最底层的接口，是IoC的核心，定义了IoC的基本功能，包含了各种Bean的定义、加载、实例化，依赖注入和生命周期管理。ApplicationContext接口作为BeanFactory的子类，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：\",\"继承MessageSource，因此支持国际化。\",\"资源文件访问，如URL和文件（ResourceLoader）。\",\"载入多个（有继承关系）上下文（即同时加载多个配置文件） ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。\",\"提供在监听器中注册bean的事件。\",\"a. BeanFactroy采用的是延迟加载形式来注入Bean的，只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能提前发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。\",\"b. ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。\",\"c. ApplicationContext启动后预载入所有的单实例Bean，所以在运行的时候速度比较快，因为它们已经创建好了。相对于BeanFactory，ApplicationContext 唯一的不足是占用内存空间，当应用程序配置Bean较多时，程序启动较慢。\",\"BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。\",\"BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。\"]},\"1219\":{\"h\":\"9. Spring如何解决循环依赖问题：\",\"t\":[\"见：https://javapub.blog.csdn.net/\",\"循环依赖问题在Spring中主要有三种情况：\",\"（1）通过构造方法进行依赖注入时产生的循环依赖问题。\",\"（2）通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。\",\"（3）通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。\",\"在Spring中，只有第（3）种方式的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。这是因为：\",\"第一种构造方法注入的情况下，在new对象的时候就会堵塞住了，其实也就是”先有鸡还是先有蛋“的历史难题。\",\"第二种setter方法（多例）的情况下，每一次getBean()时，都会产生一个新的Bean，如此反复下去就会有无穷无尽的Bean产生了，最终就会导致OOM问题的出现。\",\"Spring在单例模式下的setter方法依赖注入引起的循环依赖问题，主要是通过二级缓存和三级缓存来解决的，其中三级缓存是主要功臣。解决的核心原理就是：在对象实例化之后，依赖注入之前，Spring提前暴露的Bean实例的引用在第三级缓存中进行存储。\",\"第一种构造方法注入的情况：\",\"例如：类A通过构造函数注入需要类B的实例，而类B通过构造函数注入需要类A的实例。如果将A类和B类的bean配置为相互注入，则Spring IoC容器会在运行时检测此循环引用，并抛出a BeanCurrentlyInCreationException。 一种可能的解决方案是编辑由setter而不是构造函数配置的某些类的源代码。或者，避免构造函数注入并仅使用setter注入。换句话说，尽管不推荐使用，但您可以使用setter注入配置循环依赖关系。 与典型情况（没有循环依赖）不同，bean A和bean B之间的循环依赖强制其中一个bean在完全初始化之前被注入另一个bean（经典的鸡与鸡蛋场景）。\",\" <bean id=\\\"person\\\" class=\\\"pojo.Person\\\"> <constructor-arg index=\\\"0\\\" value=\\\"小明\\\"/> <constructor-arg index=\\\"1\\\" value=\\\"12\\\"/> <constructor-arg index=\\\"2\\\" value=\\\"student\\\"/> </bean> <bean id=\\\"student\\\" class=\\\"pojo.Student\\\"> <constructor-arg index=\\\"0\\\" value=\\\"小王\\\"/> <constructor-arg index=\\\"1\\\" value=\\\"13\\\"/> <constructor-arg index=\\\"2\\\" value=\\\"person\\\"/> </bean>\"]},\"1220\":{\"h\":\"10. Spring事务的实现方式和实现原理：\",\"t\":[\"Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。Spring只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过 redo log 和 undo log实现的。Spring会在事务开始时，根据当前环境中设置的隔离级别，调整数据库隔离级别，由此保持一致。\",\"1. Spring事务的种类：\",\"spring支持编程式事务管理和声明式事务管理两种方式：\",\"a. 编程式事务管理使用 TransactionTemplate。\",\"b. 声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。\",\"声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。\",\"2. spring的事务传播机制：\",\"spring事务的传播机制说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。事务传播机制实际上是使用简单的ThreadLocal实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。\",\"① PROPAGATION_REQUIRED：（默认传播行为）如果当前没有事务，就创建一个新事务；如果当前存在事务，就加入该事务。\",\"② PROPAGATION_REQUIRES_NEW：无论当前存不存在事务，都创建新事务进行执行。\",\"③ PROPAGATION_SUPPORTS：如果当前存在事务，就加入该事务；如果当前不存在事务，就以非事务执行。‘\",\"④ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\",\"⑤ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则按REQUIRED属性执行。\",\"⑥ PROPAGATION_MANDATORY：如果当前存在事务，就加入该事务；如果当前不存在事务，就抛出异常。\",\"⑦ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\",\"事务不只限于脏读、幻读等名词。\",\"3. Spring中的隔离级别：\",\"① ISOLATION_DEFAULT：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。\",\"② ISOLATION_READ_UNCOMMITTED：读未提交，允许事务在执行过程中，读取其他事务未提交的数据。\",\"③ ISOLATION_READ_COMMITTED：读已提交，允许事务在执行过程中，读取其他事务已经提交的数据。\",\"④ ISOLATION_REPEATABLE_READ：可重复读，在同一个事务内，任意时刻的查询结果都是一致的。\",\"⑤ ISOLATION_SERIALIZABLE：所有事务逐个依次执行。\",\"低谷蓄力\",\"最少必要面试题\",\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\"]},\"1221\":{\"c\":[\"最少必要面试题\"]},\"1222\":{\"c\":[\"spring\",\"面试题\"]},\"1223\":{\"h\":\"10道不得不会的 SpringBoot 面试题\",\"t\":[\"SpringBoot\",\"10道不得不会的 SpringBoot 面试题\",\"我是JavaPub，专注于面试、副业，技术人的成长记录。\",\"以下是 SpringBoot 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"[toc]\",\"本系列《最少必要面试题》\"]},\"1224\":{\"h\":\"1. 为什么要用 spring boot？\",\"t\":[\"通过自动配置方式简化 Spring 应用的开发，弱化配置，遵循 约定大于配置的原则 ，使开发者专注于业务开发而无需过多考虑配置相关操作，通过启动类的 main 方法一键启动应用。\"]},\"1225\":{\"h\":\"2. spring boot 有哪些优点？\",\"t\":[\"独立运行。 内嵌了 servlet，tomat 等，不需要打成 war 包部署到容器中，只需要将 SpringBoot 项目打成jar包就能独立运行。\",\"简化配置。 启动器自动依赖其他组件，简少了 maven 的配置。各种常用组件及配置已经默认配置完成，无需过多干预。\",\"避免大量的 Maven 导入和各种版本冲突。\",\"应用监控。 Spring Boot 提供一系列端点可以监控服务及应用。\"]},\"1226\":{\"h\":\"3. spring boot 核心配置文件是什么？\",\"t\":[\"springboot 核心的两个配置文件：\",\"bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的， 比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效，且 bootstrap 里面的属性不能被覆盖；一般来说我们在 SpringCloud Config 或者 Nacos 中会用到它。\",\"application (. yml 或者 . properties)：用于 springboot 项目的自动化配置\"]},\"1227\":{\"h\":\"4. spring boot的核心注解是什么？由那些注解组成？\",\"t\":[\"核心注解为：@SpringBootApplication\",\"该注解主要由三个注解组成：\",\"​ @SpringBootConfiguration():代表当前是一个配置类 ​ @EnableAutoConfiguration(): 启动自动配置 ​ @ComponentScan()：指定扫描哪些 Spring 注解\"]},\"1228\":{\"h\":\"5. 说一下springboot的自动装配原理\",\"t\":[\"SpringBoot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration。\",\"查看@EnableAutoConfiguration，其作用是利用AutoConfigurationImportSelector给容器中导入一些组件。\",\"查看AutoConfigurationImportSelector，其中public String[] selectImports(AnnotationMetadata annotationMetadata)方法内 最终调用getCandidateConfigurations()方法\",\"查看 getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes)，获取候选的配置，这个是扫描所有jar包类路径下\\\"META-INF/spring.factories\\\"\",\"然后把扫描到的这些文件包装成Properties对象。\",\"从properties中获取到EnableAutoConfiguration.class类名对应的值，然后把他们添加在容器中。\",\"简而言之，整个过程就是将类路径下 \\\"META-INF/spring.factories\\\" 里面配置的所有 EnableAutoConfiguration 的值加入到容器中。\"]},\"1229\":{\"h\":\"6. SpringBoot、Spring MVC和Spring有什么区别？\",\"t\":[\"Spring：主要用来创建IOC容器，依赖注入，实现程序间的松耦合\",\"SpringMVC: 主要是用来做WEB开发，通过各种组件的协调配合，简化Web应用的开发\",\"SpringBoot: SpringBoot更像是一个管家，当使用到对应功能时，只需要导入指定应用启动器，SpringBoot就能够在底层默认其配置，大大简化了开发所需的繁杂配置\"]},\"1230\":{\"h\":\"7. SpringBoot启动时都做了什么?\",\"t\":[\"Springboot 的启动，主要创建了配置环境 (environment)、事件监听 (listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的 Bean，至此，通过 SpringBoot 启动的程序已经构造完成。\"]},\"1231\":{\"h\":\"8. SpringBoot 中的监视器是什么？\",\"t\":[\"SpringBoot Actuator 是 SpringBoot 一项重要功能，其可以帮助我们查看应用的运行状态，对运行时指标进行检查和监控，监视器提供了一组可以直接作为 httpurl 访问的 rest 端点来访问查看指定功能状态。\"]},\"1232\":{\"h\":\"9. SpringBoot 中的starter到底是什么 ?\",\"t\":[\"首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。\",\"正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter\",\"拓展：如何自定义starter?\",\"创建项目，创建两个模块分别为 spring-boot-starter-*，spring-boot-starter-*-autoconfiguration\",\"spring-boot-starter-* pom 引入 spring-boot-starter-*-autoconfiguration\",\"spring-boot-starter-*-autoconfiguration 创建功能方法，创建 *properties类，创建一个配置类将功能方法类添加到 spring 容器，在 resouces 下创建 META-INF/spring.factories 配置 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration\",\"打包安装这两个模块到本地 maven 仓库，即可在其他项目引入 spring-boot-starter-* 注入功能类进行方法调用\"]},\"1233\":{\"h\":\"10. 微服务中如何实现 session 共享?\",\"t\":[\"在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。 这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。\",\"低谷蓄力\",\"《最少必要面试题》\",\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\",\"GItHub|GitEE\"]},\"1234\":{\"c\":[\"最少必要面试题\"]},\"1235\":{\"c\":[\"springboot\",\"面试题\"]},\"1236\":{\"h\":\"10道不得不会的 Zookeeper 面试题\",\"t\":[\"Zookeeper\",\"10道不得不会的 Zookeeper 面试题\",\"我是JavaPub，专注于面试、副业，技术人的成长记录。\",\"以下是 Zookeeper 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub在这里整理这些容易忘记的重点知识及解答，建议收藏，经常温习查阅。\",\"评论区见\",\"@[toc]\",\"本系列《最少必要面试题》\"]},\"1237\":{\"h\":\"1. 什么是 Zookeeper\",\"t\":[\"ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。\",\"Zookeeper 从设计模式角度来理解， 是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出反应。\",\"观察者模式是什么：设计模式\",\"可以这样理解：\",\"ZooKeeper=文件系统+通知机制\"]},\"1238\":{\"h\":\"2. ZK 的节点类型\",\"t\":[\"这道题相信大家都有所了解，zookeeper v3.6.2 版本后，支持7种节点类型。持久；持久顺序；临时；临时顺序；容器；持久 TTL；持久顺序 TTL。\",\"说出这几种类型当然已经回答了问题，但是细节的描述更能体现你的知识底蕴。\",\"持久 TTL、持久顺序 TTL\",\"关于持久和顺序这两个关键字，不用我再解释了，这两种类型的节点重点是后面的 TTL，TTL 是 time to live 的缩写，指带有存活时间，简单来说就是当该节点下面没有子节点的话，超过了 TTL 指定时间后就会被自动删除，但是 TTL 启用是需要额外的配置(这个之前也有提过)配置是 zookeeper.extendedTypesEnabled 需要配置成 true，否则的话创建 TTL 时会收到 Unimplemented 的报错。\"]},\"1239\":{\"h\":\"3. Zookeeper 下 Server 工作状态有哪些？\",\"t\":[\"服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。\",\"LOOKING：寻 找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入 Leader 选举状态。\",\"FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。\",\"LEADING：领导者状态。表明当前服务器角色是 Leader。\",\"OBSERVING：观察者状态。表明当前服务器角色是 Observer。（Observer角色除了不能投票(以及和投票相关的能力)和过半写成功策略外，其它和follower功能一样。observer角色减轻了投票的压力，在以前通过增、减follower的数量提高伸缩性。投票来说，follower是有状态的，都直接影响投票结果，特别是follower的数量越多，投票过程的性能就越差。）\"]},\"1240\":{\"h\":\"4. zookeeper是cp还是ap?\",\"t\":[\"zk遵循的是CP原则，即保证一致性和网络分区容错性，但不保证可用性。\",\"什么是cap?\",\"Consistency（一致性）：分布式系统中多个主机之间是否能够保持数据一致性的特性。即当系统数据发生更新操作之后，各个主机中的数据是否仍然处于一致的状态。\",\"Availability（可用性）：系统提供的服务必须一直处于可用的状态，即对于的每一个请求，系统总是可以在有限的时间内对用户做出响应。\",\"Partition tolerance（分区容错性）：分布式系统在遇到任何网络分区故障时候，仍然保证对外提供满足一致性和可用性的服务。\"]},\"1241\":{\"h\":\"5. 说几个 zookeeper 常用的命令。\",\"t\":[\"常用命令：ls get set create delete 等。\"]},\"1242\":{\"h\":\"6. 介绍一下ZAB协议？\",\"t\":[\"ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议。\",\"ZAB协议包括两种基本的模式：\",\"崩溃恢复\",\"消息广播\",\"当整个 zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。\"]},\"1243\":{\"h\":\"7. ZAB 和 Paxos 算法的联系与区别？\",\"t\":[\"相同点：\",\"两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行\",\"Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交\",\"ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 Leader 周期，Paxos 中名字为 Ballot\",\"不同点：\",\"ZAB(ZooKeeper Atomic Broadcast) 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建分布式一致性状态机系统。\",\"而 Paxos 算法与 ZAB 协议不同的是，Paxos 算法的发起者可以是一个或多个。当集群中的 Acceptor 服务器中的大多数可以执行会话请求后，提议者服务器只负责发送提交指令，事务的执行实际发生在 Acceptor 服务器。这与 ZooKeeper 服务器上事务的执行发生在 Leader 服务器上不同。Paxos 算法在数据同步阶段，是多台 Acceptor 服务器作为数据源同步给集群中的多台 Learner 服务器，而 ZooKeeper 则是单台 Leader 服务器作为数据源同步给集群中的其他角色服务器。\",\"注意：\",\"ZAB是在Paxos的基础上改进和演变过来的。\",\"提议者（Proposer）、决策者（Acceptor）、决策学习者（Learner）\"]},\"1244\":{\"h\":\"8. Zookeeper 的典型应用场景\",\"t\":[\"数据发布/订阅\",\"负载均衡\",\"命名服务\",\"分布式协调/通知\",\"集群管理\",\"Master 选举\",\"分布式锁\",\"分布式队列\",\"数据发布/订阅系统，即所谓的配置中心，目的：动态获取数据（配置信息），实现数据（配置信息）的集中式管理和数据的动态更新\",\"Zookeeper 分布式锁\",\"有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。\",\"对于第一类，我们将 zookeeper 上的一个 znode 看作是一把锁，通过 createznode的方式来实现。所有客户端都去创建 /task_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的 task_lock 节点就释放出锁。\",\"对于第二类， /task_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选 master 一样，编号最小的获得锁，用完删除，依次方便。\",\"Zookeeper 队列管理\",\"一般很少用到，可简单了解\",\"两种类型的队列：\",\"同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。\",\"队列按照 FIFO 方式进行入队和出队操作。\",\"第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。\",\"第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建 PERSISTENT_SEQUENTIAL 节点，创建成功时Watcher 通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper 的 znode 用于消息存储，znode 存储的数据就是消息队列中的消息内容，SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。\"]},\"1245\":{\"h\":\"9. Chroot特性\",\"t\":[\"zookeeper v3.2.0 版本后，添加了 Chroot 特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。\",\"通过设置 Chroot，能够将一个客户端应用于 Zookeeper 服务端的一颗子树相对应，在那些多个应用共用一个 Zookeeper 进群的场景下，对实现不同应用间的相互隔离非常有帮助。\"]},\"1246\":{\"h\":\"拓展\",\"t\":[\"ZooKeeper以Fast Paxos算法为基础，Paxos 算法存在活锁的问题，即当有多个 proposer 交错提交时有可能互相排斥导致没有一个proposer能提交成功，而Fast Paxos做了一些优化，通过选举产生一个领导者，只有leader才能提交proposer具体算法可见Fast Paxos。\",\"低谷蓄力\",\"《最少必要面试题》\",\"10道不得不会的Java基础面试题\",\"10道不得不会的Java容器面试题\",\"10道不得不会的Java并发基础面试题\",\"10道不得不会的JavaEE面试题\",\"10道不得不会的JVM面试题\",\"10道不得不会的MySQL基础面试题\",\"10道不得不会的MyBatis面试题\",\"10道不得不会的Spring面试题\",\"10道不得不会的SpringBoot面试题\",\"10道不得不会的ElasticSearch面试题\",\"10道不得不会的Redis面试题\",\"10道不得不会的Kafka面试题\",\"10道不得不会的Zookeeper面试题\",\"10道不得不会的Docker面试题\",\"10道不得不会的缓存面试题\",\"GItHub|GitEE\"]},\"1247\":{\"c\":[\"最少必要面试题\"]},\"1248\":{\"c\":[\"zookeeper\",\"面试题\"]},\"1249\":{\"h\":\"《最少必要面试题》第一版\",\"t\":[\"相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。JavaPub 在这里整理这些容易忘记的重点知识及 解答，建议收藏，经常温习查阅。\",\"点击在线阅读《最少必要面试题》\",\"[toc]\"]},\"1250\":{\"h\":\"缓存\"},\"1251\":{\"h\":\"1. 什么是缓存？\",\"t\":[\"缓存，就是数据交换的缓冲区，针对服务对象的不同（本质就是不同的硬件）都可以构建缓存。而我们平时说的缓存，大多是指内存。\",\"目的是， 把读写速度【慢】的介质的数据保存在读写速度【快】的介质中，从而提高读写速度，减少时间消耗。 例如：\",\"CPU 高速缓存 ：高速缓存的读写速度远高于内存。 \",\"CPU 读数据时，如果在高速缓存中找到所需数据，就不需要读内存\",\"CPU 写数据时，先写到高速缓存，再回写到内存。\",\"磁盘缓存：磁盘缓存其实就把常用的磁盘数据保存在内存中，内存读写速度也是远高于磁盘的。 \",\"读数据，时从内存读取。\",\"写数据时，可先写到内存，定时或定量回写到磁盘，或者是同步回写。\"]},\"1252\":{\"h\":\"2. 为什么要用缓存？\",\"t\":[\"使用缓存的目的，就是提升读写性能。而实际业务场景下，更多的是为了提升读性能，带来更好的性能，更高的并发量。\",\"日常业务中，我们使用比较多的数据库是 MySQL ，缓存是 Redis 。Redis 比 MySQL 的读写性能好很多。那么，我们将 MySQL 的热点数据，缓存到 Redis 中，提升读取性能，也减小 MySQL 的读取压力。例如说：\",\"论坛帖子的访问频率比较高，且要实时更新阅读量，使用 Redis 记录帖子的阅读量，可以提升性能和并发。\",\"商品信息，数据更新的频率不高，但是读取的频率很高，特别是热门商品。\"]},\"1253\":{\"h\":\"3. 请说说有哪些缓存算法？是否能手写一下 LRU 代码的实现？\",\"t\":[\"缓存算法，比较常见的是三种：\",\"LRU（least recently used ，最近最少使用)\",\"LFU（Least Frequently used ，最不经常使用)\",\"FIFO（first in first out ，先进先出)\",\"这里我们可以借助 LinkedHashMap 实现\",\"public class LRULinkedMap<K,V> { /** * 最大缓存大小 */ private int cacheSize; private LinkedHashMap<K,V> cacheMap ; public LRULinkedMap(int cacheSize) { this.cacheSize = cacheSize; cacheMap = new LinkedHashMap(16,0.75F,true){ @Override protected boolean removeEldestEntry(Map.Entry eldest) { if (cacheSize + 1 == cacheMap.size()){ return true ; }else { return false ; } } }; } public void put(K key,V value){ cacheMap.put(key,value) ; } public V get(K key){ return cacheMap.get(key) ; } public Collection<Map.Entry<K, V>> getAll() { return new ArrayList<Map.Entry<K, V>>(cacheMap.entrySet()); } }\",\"使用案例：\",\" @Test public void put() throws Exception { LRULinkedMap<String,Integer> map = new LRULinkedMap(3) ; map.put(\\\"1\\\",1); map.put(\\\"2\\\",2); map.put(\\\"3\\\",3); for (Map.Entry<String, Integer> e : map.getAll()){ System.out.print(e.getKey() + \\\" : \\\" + e.getValue() + \\\"\\\\t\\\"); } System.out.println(\\\"\\\"); map.put(\\\"4\\\",4); for (Map.Entry<String, Integer> e : map.getAll()){ System.out.print(e.getKey() + \\\" : \\\" + e.getValue() + \\\"\\\\t\\\"); } } //输出 1 : 1 2 : 2 3 : 3 2 : 2 3 : 3 4 : 4\"]},\"1254\":{\"h\":\"4. 常见的常见的缓存工具和框架有哪些？\",\"t\":[\"在 Java 后端开发中，常见的缓存工具和框架列举如下：\",\"本地缓存：Guava LocalCache、Ehcache、Caffeine 。\",\"Ehcache 的功能更加丰富，Caffeine 的性能要比 Guava LocalCache 好。\",\"分布式缓存：Redis、Memcached、Tair 。\",\"Redis 最为主流和常用。\"]},\"1255\":{\"h\":\"5. 用了缓存之后，有哪些常见问题？\",\"t\":[\"常见的问题，可列举如下：\",\"写入问题\",\"缓存何时写入？并且写时如何避免并发重复写入？\",\"缓存如何失效？\",\"缓存和 DB 的一致性如何保证？\",\"经典三连问\",\"如何避免缓存穿透的问题？\",\"如何避免缓存击穿的问题？\",\"如果避免缓存雪崩的问题？\"]},\"1256\":{\"h\":\"6. 如何处理缓存穿透的问题\",\"t\":[\"缓存穿透，是指查询一个一定不存在的数据，由于缓存是不命中时被动写，并且处于容错考虑，如果从 DB 查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，失去了缓存的意义。\",\"在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。如下图：\",\"缓存穿透\",\"如何解决\",\"有两种方案可以解决：\",\"方案一，缓存空对象。 当从 DB 查询数据为空，我们仍然将这个空结果进行缓存，具体的值需要使用特殊的标识，能和真正缓存的数据区分开。另外，需要设置较短的过期时间，一般建议不要超过 5 分钟。\",\"方案二，BloomFilter 布隆过滤器。 在缓存服务的基础上，构建 BloomFilter 数据结构，在 BloomFilter 中存储对应的 KEY 是否存在，如果存在，说明该 KEY 对应的值不为空。\",\"如何选择\",\"这两个方案，各有其优缺点。\",\"缓存空对象\",\"BloomFilter 布隆过滤器\",\"适用场景\",\"1、数据命中不高 2、保证一致性\",\"1、数据命中不高, 2、数据相对固定、实时性低\",\"维护成本\",\"1、代码维护简单 2、需要过多的缓存空间 3、数据不一致\",\"1、代码维护复杂，2、缓存空间占用小\",\"实际情况下，使用方案二比较多。因为，相比方案一来说，更加节省内容，对缓存的负荷更小。\"]},\"1257\":{\"h\":\"7. 如何处理缓存雪崩的问题\",\"t\":[\"缓存雪崩，是指缓存由于某些原因无法提供服务( 例如，缓存挂掉了 )，所有请求全部达到 DB 中，导致 DB 负荷大增，最终挂掉的情况。\",\"如何解决\",\"预防和解决缓存雪崩的问题，可以从以下多个方面进行共同着手。\",\"缓存高可用：通过搭建缓存的高可用，避免缓存挂掉导致无法提供服务的情况，从而降低出现缓存雪崩的情况。假设我们使用 Redis 作为缓存，则可以使用 Redis Sentinel 或 Redis Cluster 实现高可用。\",\"本地缓存：如果使用本地缓存时，即使分布式缓存挂了，也可以将 DB 查询到的结果缓存到本地，避免后续请求全部到达 DB 中。如果我们使用 JVM ，则可以使用 Ehcache、Guava Cache 实现本地缓存的功能。\",\"当然，引入本地缓存也会有相应的问题，例如说：\",\"本地缓存的实时性怎么保证？ 方案一，可以引入消息队列。在数据更新时，发布数据更新的消息；而进>程中有相应的消费者消费该消息，从而更新本地缓存。 方案二，设置较短的过期时间，请求时从 DB 重新拉取。 方案三，手动过期。\",\"请求 DB 限流: 通过限制 DB 的每秒请求数，避免把 DB 也打挂了。如果我们使用 Java ，则可以使用 Guava RateLimiter、Sentinel、Hystrix 实现限流的功能。这样至少能有两个好处：\",\"可能有一部分用户，还可以使用，系统还没死透。\",\"未来缓存服务恢复后，系统立即就已经恢复，无需再处理 DB 也挂掉的情况。\",\"提前演练：在项目上线前，演练缓存宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。\"]},\"1258\":{\"h\":\"8. 如何处理缓存击穿的问题\",\"t\":[\"缓存击穿，是指某个极度“热点”数据在某个时间点过期时，恰好在这个时间点对这个 KEY 有大量的并发请求过来，这些请求发现缓存过期一般都会从 DB 加载数据并回设到缓存，但是这个时候大并发的请求可能会瞬间 DB 压垮。\",\"对于一些设置了过期时间的 KEY ，如果这些 KEY 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑这个问题。\",\"区别： \",\"和缓存“雪崩“”的区别在于，前者针对某一 KEY 缓存，后者则是很多 KEY 。\",\"和缓存“穿透“”的区别在于，这个 KEY 是真实存在对应的值的。\",\"如何解决\",\"有两种方案可以解决：\",\"方案一，使用互斥锁。请求发现缓存不存在后，去查询 DB 前，使用分布式锁，保证有且只有一个线程去查询 DB ，并更新到缓存。\",\"方案二，手动过期。缓存上从不设置过期时间，功能上将过期时间存在 KEY 对应的 VALUE 里。流程如下：\",\"获取缓存。通过 VALUE 的过期时间，判断是否过期。如果未过期，则直接返回；如果已过期，继续往下执行。\",\"通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。通过后台的异步线程，保证有且只有一个线程去查询 DB。\",\"同时，虽然 VALUE 已经过期，还是直接返回。通过这样的方式，保证服务的可用性，虽然损失了一定的时效性。\",\"选择\",\"这两个方案，各有其优缺点。\",\"使用互斥锁\",\"手动过期\",\"优点\",\"1、思路简单 2、保证一致性\",\"1、性价最佳，用户无需等待\",\"缺点\",\"1、代码复杂度增大 2、存在死锁的风险\",\"1、无法保证缓存一致性\"]},\"1259\":{\"h\":\"9. 缓存和 DB 的一致性如何保证？\",\"t\":[\"产生原因\",\"主要有两种情况，会导致缓存和 DB 的一致性问题：\",\"并发的场景下，导致读取老的 DB 数据，更新到缓存中。\",\"主要指的是，更新 DB 数据之前，先删除 Cache 的数据。在低并发量下没什么问题，但是在高并发下，就会存在问题。在(删除 Cache 的数据, 和更新 DB 数据)时间之间，恰好有一个请求，我们如果使用被动读，因为此时 DB 数据还是老的，又会将老的数据写入到 Cache 中。\",\"缓存和 DB 的操作，不在一个事务中，可能只有一个 DB 操作成功，而另一个 Cache 操作失败，导致不一致。\",\"当然，有一点我们要注意，缓存和 DB 的一致性，我们指的更多的是最终一致性。我们使用缓存只要是提高读操作的性能，真正在写操作的业务逻辑，还是以数据库为准。例如说，我们可能缓存用户钱包的余额在缓存中，在前端查询钱包余额时，读取缓存，在使用钱包余额时，读取数据库。\",\"解决方案\",\"在开始说解决方案之前，胖友先看看如下几篇文章，可能有一丢丢多，保持耐心。\",\"当然无论哪种方案，比较重要的就是解决两个问题：\",\"将缓存可能存在的并行写，实现串行写。\",\"实现数据的最终一致性。\",\"先淘汰缓存，再写数据库 因为先淘汰缓存，所以数据的最终一致性是可以得到有效的保证的。为什么呢？先淘汰缓存，即使写数据库发生异常，也就是下次缓存读取时，多读取一次数据库。\",\"那么，我们需要解决缓存并行写，实现串行写。比较简单的方式，引入分布式锁。\",\"在写请求时，先淘汰缓存之前，先获取该分布式锁。\",\"在读请求时，发现缓存不存在时，先获取分布式锁。\",\"先写数据库，再更新缓存\",\"按照 “先写数据库，再更新缓存”，我们要保证 DB 和缓存的操作，能够在 “同一个事务”中，从而实现最终一致性\"]},\"1260\":{\"h\":\"10. 什么是缓存预热？如何实现缓存预热？\",\"t\":[\"缓存预热\",\"在刚启动的缓存系统中，如果缓存中没有任何数据，如果依靠用户请求的方式重建缓存数据，那么对数据库的压力非常大，而且系统的性能开销也是巨大的。\",\"此时，最好的策略是启动时就把热点数据加载好。这样，用户请求时，直接读取的就是缓存的数据，而无需去读取 DB 重建缓存数据。举个例子，热门的或者推荐的商品，需要提前预热到缓存中。\",\"如何实现\",\"一般来说，有如下几种方式来实现：\",\"数据量不大时，项目启动时，自动进行初始化。\",\"写个修复数据脚本，手动执行该脚本。\",\"写个管理界面，可以手动点击，预热对应的数据到缓存中。\"]},\"1261\":{\"h\":\"拓展：缓存数据的淘汰策略有哪些？\",\"t\":[\"除了缓存服务器自带的缓存自动失效策略之外，我们还可以根据具体的业务需求进行自定义的“手动”缓存淘汰，常见的策略有两种：\",\"定时去清理过期的缓存。\",\"当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。\",\"两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！Redis 的缓存淘汰策略就是很好的实践方式。\",\"具体用哪种方案，大家可以根据自己的应用场景来权衡。\"]},\"1262\":{\"h\":\"Docker\"},\"1263\":{\"h\":\"1. 什么是 Docker 容器？\",\"t\":[\"Docker 是一种流行的开源软件平台，可简化创建、管理、运行和分发应用程序的过程。它使用容器来打包应用程序及其依赖项。我们也可以将容器视为 Docker 镜像的运行时实例。\"]},\"1264\":{\"h\":\"2. Docker 和虚拟机有什么不同？\",\"t\":[\"Docker 是轻量级的沙盒，在其中运行的只是应用，虚拟机里面还有额外的系统。\"]},\"1265\":{\"h\":\"3. 什么是 DockerFile？\",\"t\":[\"Dockerfile 是一个文本文件，其中包含我们需要运行以构建 Docker 镜像的所有命令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。Docker 使用 Dockerfile 中的指令自动构建镜像。我们可以 docker build 用来创建按顺序执行多个命令行指令的自动构建。\",\"一些最常用的指令如下：\",\"FROM ：使用 FROM 为后续的指令建立基础映像。在所有有效的 Dockerfile 中， FROM 是第一条指令。 LABEL： LABEL 指令用于组织项目映像，模块，许可等。在自动化布署方面 LABEL 也有很大用途。在 LABEL 中指定一组键值对，可用于程序化配置或布署 Docker 。 RUN： RUN 指令可在映像当前层执行任何命令并创建一个新层，用于在映像层中添加功能层，也许最来的层会依赖它。 CMD： 使用 CMD 指令为执行的容器提供默认值。在 Dockerfile 文件中，若添加多个 CMD 指令，只有最后的 CMD 指令运行。\"]},\"1266\":{\"h\":\"4. 使用Docker Compose时如何保证容器A先于容器B运行？\",\"t\":[\"Docker Compose 是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。Compose 通过一个配置文件来管理多个Docker容器。简单理解：Docker Compose 是docker的管理工具。\",\"Docker Compose 在继续下一个容器之前不会等待容器准备就绪。为了控制我们的执行顺序，我们可以使用“取决于”条件，depends_on 。这是在 docker-compose.yml 文件中使用的示例\",\"version: \\\"2.4\\\" services: backend: build: . # 构建自定义镜像 depends_on: - db db: image: mysql\",\"用 docker-compose up 命令将按照我们指定的依赖顺序启动和运行服务。\"]},\"1267\":{\"h\":\"5. 一个完整的Docker由哪些部分组成?\",\"t\":[\"DockerClient 客户端\",\"Docker Daemon 守护进程\",\"Docker Image 镜像\",\"DockerContainer 容器\"]},\"1268\":{\"h\":\"6. docker常用命令\",\"t\":[\"命令建议在本地安装做一个实操，记忆会更深刻。 也可以克隆基于docker的俩万（springboot+vue）项目练手，提供视频+完善文档。地址：https://gitee.com/rodert/liawan-vue\",\"查看本地主机的所用镜像：`docker images``\",\"搜索镜像：`docker search mysql``\",\"下载镜像：docker pull mysql，没写 tag 就默认下载最新的 lastest\",\"下载指定版本的镜像：`docker pull mysql:5.7``\",\"删除镜像：`docker rmi -f 镜像id 镜像id 镜像id``\"]},\"1269\":{\"h\":\"7. 描述 Docker 容器的生命周期。\",\"t\":[\"Docker 容器经历以下阶段：\",\"创建容器\",\"运行容器\",\"暂停容器（可选）\",\"取消暂停容器（可选）\",\"启动容器\",\"停止容器\",\"重启容器\",\"杀死容器\",\"销毁容器\"]},\"1270\":{\"h\":\"8. docker容器之间怎么隔离?\",\"t\":[\"这是一道涉猎很广泛的题目，理解性阅读。\",\"Linux中的PID、IPC、网络等资源是全局的，而Linux的NameSpace机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰。\",\"**Namespace实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容​​。**对于宿主机来说，这些被“隔离”了的进程跟其他进程并没有区别。\",\"虽然有了NameSpace技术可以实现资源隔离，但进程还是可以不受控的访问系统资源，比如CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker采用control groups技术(也就是cgroup)，有了cgroup就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些CPU上运行等等。\",\"有了这两项技术，容器看起来就真的像是独立的操作系统了。\",\"强烈建议大家实操，才能更好的理解docker。\",\"低谷蓄力\"]},\"1271\":{\"h\":\"ElasticSearch\"},\"1272\":{\"h\":\"1. 说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段 。\",\"t\":[\"节点数、分片数、副本数，尽量根据自己公司使用情况回答，当然适当放大也可行。\",\"调优手段是现在很常见的面试题，下面这几种调优手段一定要了解懂。当然，下面的每一条都可以当做调优的一部分。\",\"设计调优\",\"参考： https://www.cnblogs.com/sanduzxcvbnm/p/12084012.html\",\"a. 根据业务增量需求，采取基于日期模板创建索引，通过 rollover API 滚动索引；(rollover API我会单独写一个代码案例做讲解，公众号：JavaPub) b. 使用别名进行索引管理；（es的索引名不能改变，提供的别名机制使用非常广泛。） c. 每天凌晨定时对索引做force_merge操作，以释放空间； d. 采取冷热分离机制，热数据存储到SSD，提高检索效率；冷数据定期进行shrink操作，以缩减存储； e. 采取curator进行索引的生命周期管理； f. 仅针对需要分词的字段，合理的设置分词器； g. Mapping阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。\",\"进100+原创文章：https://gitee.com/rodert/JavaPub\",\"写入调优\",\"写入前副本数设置为0；\",\"写入前关闭refresh_interval设置为-1，禁用刷新机制；\",\"写入过程中：采取bulk批量写入；\",\"写入后恢复副本数和刷新间隔；\",\"尽量使用自动生成的id。\",\"查询调优\",\"禁用wildcard；（通配符模式，类似于%like%）\",\"禁用批量terms（成百上千的场景）；\",\"充分利用倒排索引机制，能keyword类型尽量keyword；\",\"数据量大时候，可以先基于时间敲定索引再检索；\",\"设置合理的路由机制。\"]},\"1273\":{\"h\":\"2. elasticsearch 的倒排索引是什么\",\"t\":[\"倒排索引也就是单词到文档的映射，当然不只是存里文档id这么简单。还包括：词频（TF，Term Frequency）、偏移量（offset）、位置（Posting）。\"]},\"1274\":{\"h\":\"3. elasticsearch 是如何实现 master 选举的\",\"t\":[\"ElasticSearch 的选主是 ZenDiscovery 模块负责，源码分析将首发在。 https://gitee.com/rodert/JavaPub\",\"对所有可以成为 Master 的节点（node.master: true）根据 nodeId 排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是 Master 节点。\",\"如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举。 (当然也可以自己设定一个值，最小值设定为超过能成为Master节点的n/2+1，否则会出现脑裂问题。discovery.zen.minimum_master_nodes)\"]},\"1275\":{\"h\":\"5. 描述一下 Elasticsearch 索引文档的过程\",\"t\":[\"在这里插入图片描述\",\"客户端向 Node 1 发送新建、索引或者删除请求。\",\"节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。\",\"Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。\",\"一图胜千文，记住这幅图，上面是文档在节点间分发的过程，接着说一下文档从接收到写入磁盘过程。 协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合适的分片。\",\"shard = hash(document_id) % (num_of_primary_shards)\",\"当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 MemoryBuffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 MomeryBuffer 到 Filesystem Cache 的过程就叫做 refresh；\",\"当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失，ES 是通过 translog 的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystem cache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；\",\"在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。\",\"flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；\",\"1. translog 可以理解为就是一个文件，一直追加。 2. MemoryBuffer 应用缓存。 3. Filesystem Cache 系统缓冲区。\",\"延伸阅读：Lucene 的 Segement:\",\"Lucene 索引是由多个段组成，段本身是一个功能齐全的倒排索引。\",\"段是不可变的，允许 Lucene 将新的文档增量地添加到索引中，而不用从头重建索引。\",\"对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗CPU 的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。\",\"为了解决这个问题，Elasticsearch 会合并小段到一个较大的段，提交新的合并段到磁盘，并删除那些旧的小段。\"]},\"1276\":{\"h\":\"4. 详细描述一下 Elasticsearch 搜索的过程？\",\"t\":[\"es作为一个分布式的存储和检索系统，每个文档根据 _id 字段做路由分发被转发到对应的shard上。\",\"搜索执行阶段过程分俩个部分，我们称之为 Query Then Fetch。\",\"4.1 query-查询阶段\",\"当一个search请求发出的时候，这个query会被广播到索引里面的每一个shard（主shard或副本shard），每个shard会在本地执行查询请求后会生成一个命中文档的优先级队列。\",\"这个队列是一个排序好的top N数据的列表，它的size等于from+size的和，也就是说如果你的from是10，size是10，那么这个队列的size就是20，所以这也是为什么深度分页不能用from+size这种方式，因为from越大，性能就越低。\",\"es里面分布式search的查询流程如下：\",\"es里面分布式search的查询流程\",\"查询阶段包含以下三个步骤:\",\"客户端发送一个 search 请求到 Node 3 ， Node 3 会创建一个大小为 from + size 的空优先队列。\",\"Node 3 将查询请求转发到索引的每个主分片或副本分片中。每个分片在本地执行查询并添加结果到大小为 from + size 的本地有序优先队列中。\",\"每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，也就是 Node 3 ，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。\",\"4.2 fetch - 读取阶段 / 取回阶段\",\"在这里插入图片描述\",\"分布式阶段由以下步骤构成：\",\"协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。\",\"每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。\",\"一旦所有的文档都被取回了，协调节点返回结果给客户端。\",\"协调节点首先决定哪些文档 确实 需要被取回。例如，如果我们的查询指定了 { \\\"from\\\": 90, \\\"size\\\": 10 } ，最初的90个结果会被丢弃，只有从第91个开始的10个结果需要被取回。这些文档可能来自和最初搜索请求有关的一个、多个甚至全部分片。\",\"协调节点给持有相关文档的每个分片创建一个 multi-get request ，并发送请求给同样处理查询阶段的分片副本。\",\"分片加载文档体-- _source 字段—​如果有需要，用元数据和 search snippet highlighting 丰富结果文档。 一旦协调节点接收到所有的结果文档，它就组装这些结果为单个响应返回给客户端。\",\"拓展阅读： 深翻页（Deep Pagination） --- 先查后取的过程支持用 from 和 size 参数分页，但是这是 有限制的 。 要记住需要传递信息给协调节点的每个分片必须先创建一个 from + size 长度的队列，协调节点需要根据 number_of_shards * (from + size) 排序文档，来找到被包含在 size 里的文档。 取决于你的文档的大小，分片的数量和你使用的硬件，给 10,000 到 50,000 的结果文档深分页（ 1,000 到 5,000 页）是完全可行的。但是使用足够大的 from 值，排序过程可能会变得非常沉重，使用大量的CPU、内存和带宽。因为这个原因，我们强烈建议你不要使用深分页。 实际上， “深分页” 很少符合人的行为。当2到3页过去以后，人会停止翻页，并且改变搜索标准。会不知疲倦地一页一页的获取网页直到你的服务崩溃的罪魁祸首一般是机器人或者web spider。 如果你 确实 需要从你的集群取回大量的文档，你可以通过用 scroll 查询禁用排序使这个取回行为更有效率，我们会在 later in this chapter 进行讨论。 注：https://www.elastic.co/guide/cn/elasticsearch/guide/current/scroll.html\"]},\"1277\":{\"h\":\"5. Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法\",\"t\":[\"关闭缓存swap;\",\"原因：大多数操作系统会将内存使用到文件系统缓存，会将应用程序未用到的内存交换出去。会导致jvm的堆内存交换到磁盘上。交换会导致性能问题。会导致内存垃圾回收延长。会导致集群节点响应时间变慢，或者从集群中断开。\",\"堆内存设置为：Min（节点内存/2, 32GB）;\",\"设置最大文件句柄数；\",\"后俩点不懂可以先说有一定了解，关注JavaPub会做详细讲解。\",\"调整线程池和队列大小\",\"磁盘存储 raid 方式——存储有条件使用 RAID6，增加单节点性能以及避免单节点存储故障。\",\"https://www.elastic.co/cn/blog/how-to-design-your-elasticsearch-data-storage-architecture-for-scale#raid56\"]},\"1278\":{\"h\":\"6. Elasticsearch 中的节点（比如共 20 个），其中的 10 个选了一个 master，另外 10 个选了另一个 master，怎么办？\",\"t\":[\"当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；\",\"当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data节点，避免脑裂问题。\"]},\"1279\":{\"h\":\"7. 客户端在和集群连接时，如何选择特定的节点执行请求的？\",\"t\":[\"client 远程连接连接一个 elasticsearch 集群。它并不加入到集群中，只是获得一个或者多个初始化的地址，并以轮询的方式与这些地址进行通信。\"]},\"1280\":{\"h\":\"8. 详细描述一下 Elasticsearch 更新和删除文档的过程。\",\"t\":[\"删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；(根本原因是底层lucene的segment段文件不可更新删除)\",\"磁盘上的每个段都有一个相应的 .del 文件。当删除请求发送后，文档并没有真 的被删除，而是在 .del 文件中被标记为删除。该文档依然能匹配查询，但是会在 结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入 新段。\",\"在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新 时，旧版本的文档在.del 文件中被标记为删除，新版本的文档被索引到一个新段。\",\"旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。\"]},\"1281\":{\"h\":\"9. Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？\",\"t\":[\"这道题目较难，相信大家看到很多类似这种回答\",\"Elasticsearch 提供的首个近似聚合是cardinality 度量。它提供一个字段的基数，即该字段的distinct或者unique值的数目。它是基于HLL算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。\",\"科普&拓展：\",\"HyperLogLog： 下面简称为HLL，它是 LogLog 算法的升级版，作用是能够提供不精确的去重计数。存在以下的特点： 1. 能够使用极少的内存来统计巨量的数据，在 Redis 中实现的 HyperLogLog，只需要12K内存就能统计2^64个数据。 2. 计数存在一定的误差，误差率整体较低。标准误差为 0.81% 。 3. 误差可以被设置辅助计算因子进行降低。 --- 应用场景： 1. 基数不大，数据量不大就用不上，会有点大材小用浪费空间 2. 有局限性，就是只能统计基数数量，而没办法去知道具体的内容是什么 3. 和bitmap相比，属于两种特定统计情况，简单来说，HyperLogLog 去重比 bitmap 方便很多 4. 一般可以bitmap和hyperloglog配合使用，bitmap标识哪些用户活跃，hyperloglog计数 --- 应用场景： 1. 基数不大，数据量不大就用不上，会有点大材小用浪费空间 2. 有局限性，就是只能统计基数数量，而没办法去知道具体的内容是什么 3. 和bitmap相比，属于两种特定统计情况，简单来说，HyperLogLog 去重比 bitmap 方便很多 4. 一般可以bitmap和hyperloglog配合使用，bitmap标识哪些用户活跃，hyperloglog计数 来源：刷刷面试\"]},\"1282\":{\"h\":\"10. 在并发情况下，Elasticsearch 如果保证读写一致？\",\"t\":[\"首先要了解什么是一致性，在分布式系统中，我们一般通过CPA理论分析。\",\"分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。 \",\"可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；\",\"另外对于写操作，一致性级别支持 quorum/one/all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。\",\"对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。\"]},\"1283\":{\"h\":\"11. 介绍一下你们的个性化搜索方案？\",\"t\":[\"如果你没有很多实战经验，可以基于 word2vec 做一些练习，我的博客提供了 word2vec Java版的一些Demo。\",\"基于 word2vec 和 Elasticsearch 实现个性化搜索，它有以下优点：\",\"基于word2vec的商品向量还有一个可用之处，就是可以用来实现相似商品的推荐；\"]},\"1284\":{\"h\":\"Java基础\"},\"1285\":{\"h\":\"1. instanceof 关键字的作用\",\"t\":[\"instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。\",\"boolean result = obj instanceof class\",\"当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。\",\"注意一点：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。\",\"obj 必须为引用类型，只能作为对象的判断，不能是基本类型。\",\"int i = 0; System.out.println(i instanceof Integer);//编译不通过 System.out.println(i instanceof Object);//编译不通过\",\"源码参考：JavaSE 8 instanceof 的实现算法：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.instanceof\"]},\"1286\":{\"h\":\"2. Java自动装箱和拆箱\",\"t\":[\"什么是装箱拆箱，这里不做源码层面解读，源码解读在JavaPub公众号发出。这里通过讲解 int 和 Interger 区别，解答Java自动装箱和拆箱。\",\"自动装箱 ----- 基本类型的值 → 包装类的实例\",\"自动拆箱 ----- 基本类型的值 ← 包装类的实例\",\"Integer变量必须实例化后才能使用，而int变量不需要\",\"Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 。\",\"Integer的默认值是null，int的默认值是0\",\"Java中8种基本数据类型。左边基本类型，右边包装类型。 \",\"在面试中：\",\"下面这段代码的输出结果是什么？\",\"public class Main { public static void main(String[] args) { Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); System.out.println(i3==i4); } } //true //false\",\"输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：\",\"public static Integer valueOf(int i) { if(i >= -128 && i <= IntegerCache.high) return IntegerCache.cache[i + 128]; else return new Integer(i); }\",\"private static class IntegerCache { static final int high; static final Integer cache[]; static { final int low = -128; // high value may be configured by property int h = 127; if (integerCacheHighPropValue != null) { // Use Long.decode here to avoid invoking methods that // require Integer's autoboxing cache to be initialized int i = Long.decode(integerCacheHighPropValue).intValue(); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - -low); } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k < cache.length; k++) cache[k] = new Integer(j++); } private IntegerCache() {} }\",\"从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。\",\"上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。\",\"注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。 Double、Float的valueOf方法的实现是类似的（没有缓存数值，这里的数值想想都有很多，不适合缓存）。\"]},\"1287\":{\"h\":\"3. 重载和重写区别\",\"t\":[\"重载和重写是一个特别好理解的概念，这里说一个通俗的解答方式\",\"重载（Overload）:首先是位于一个类之中或者其子类中，具有相同的方法名，但是方法的参数不同，返回值类型可以相同也可以不同。\",\"方法名必须相同\",\"方法的参数列表一定不一样。\",\"访问修饰符和返回值类型可以相同也可以不同。\",\"其实简单而言：重载就是对于不同的情况写不同的方法。 比如，同一个类中，写不同的构造函数用于初始化不同的参数。\",\"public class JavaPubTest { public void out(){ System.out.println(\\\"参数\\\"+null); } //参数数目不同 public void out(Integer n){ System.out.println(\\\"参数\\\"+n.getClass().getName()); } //参数类型不同 public void out(String string){ System.out.println(\\\"参数\\\"+string.getClass().getName()); } public void out(Integer n ,String string){ System.out.println(\\\"参数\\\"+n.getClass().getName()+\\\",\\\"+string.getClass().getName()); } //参数顺序不同 public void out(String string,Integer n){ System.out.println(\\\"参数\\\"+string.getClass().getName()+\\\",\\\"+n.getClass().getName()); } public static void main(String[] args) { JavaPubTest javaPubTest = new JavaPubTest(); javaPubTest.out(); javaPubTest.out(1); javaPubTest.out(\\\"string\\\"); javaPubTest.out(1,\\\"string\\\"); javaPubTest.out(\\\"string\\\",1); } }\",\"**重写（Overriding）**发生在父类子类之间，比如所有类都是继承与Object类的，Object类中本身就有equals、hashcode、toString方法等。在任意子类中定义了重名和同样的参数列表就构成方法重写。\",\"方法名必须相同，返回值类型必须相同。\",\"参数列表必须相同。\",\"访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。\",\"子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。\",\"构造方法不能被重写。\"]},\"1288\":{\"h\":\"4. equals与==区别\",\"t\":[\"\\\"==\\\"是判断两个变量或实例是不是指向同一个内存空间。\\\"equals\\\"是判断两个变量或实例所指向的内存空间的值是不是相同。\",\"除了这俩点，这个问题大概率会引出以下问题：\",\"为什么重写equals还要重写hashcode?\",\"通过上面俩条我们知道 \\\"equals\\\"是判断两个变量或实例所指向的内存空间的值是不是相同。 但是一些特殊场景，我们需要对比俩个对象是否相等，例如：User user1 = new User();User user2 = new User(); user1 和 user2 对比。这是我们就需要重写 equals 方法。\",\"所以可以通过重写equals()方法来判断对象的值是否相等，但是有一个要求：equals()方法实现了等价关系，即：\",\"自反性：对于任何非空引用x，x.equals(x)应该返回true；\",\"对称性：对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true；\",\"传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true；\",\"一致性：如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果；\",\"非空性：对于任意非空引用x，x.equals(null)应该返回false；\",\"到这里也是一个很正常的操作，但是当我们要用到 HashSet 等集合时。存储的对象我们需要用 hashcode 判断对象是否存在，如果使用 Object 默认的hashcode方法，那我们同样属性的俩个用户一定是不相等的(例如下面user3、user4)，因为内存地址不同，这并不符合我们的业务，所以决定了重写 hashcode 的必要性。\",\"User user3 = new User(\\\"JavaPub\\\", \\\"man\\\", \\\"1996-08-28\\\") User user4 = new User(\\\"JavaPub\\\", \\\"man\\\", \\\"1996-08-28\\\")\"]},\"1289\":{\"h\":\"5. 谈谈NIO和BIO区别\",\"t\":[\"致力于大白话说清楚。NIO和BIO是一个相对有点抽象的概念，如果你对网络有点了解，理解起来可能会更顺畅。首先说一下基本\",\"BIO：同步阻塞IO，每一个客户端连接，服务端都会对应一个处理线程，对于没有分配到处理线程的连接就会被阻塞或者拒绝。相当于是一个连接一个线程。\",\"NIO：同步非阻塞IO，基于Reactor模型，客户端和channel进行通信，channel可以进行读写操作，通过多路复用器selector来轮询注册在其上的channel，而后再进行IO操作。这样的话，在进行IO操作的时候再用一个线程去处理就可以了，也就是一个请求一个线程。\",\"Reactor模型是什么?\",\"基于池化思想，避免为每个连接创建线程，连接完成后将业务处理交给线程池处理\",\"基于IO复用模型，多个连接共用同一个阻塞对象，不用等待所有的连接。遍历到有新数据可以处理时，操作系统会通知程序，线程跳出阻塞状态，进行业务逻辑处理 .\",\"简单来说：Reactor线程模型的思想就是基于IO复用和线程池的结合。\",\"AIO：（一般都会把AIO和NIO、BIO放一块比较，这里简单提一下。）异步非阻塞IO，相比NIO更进一步，完全由操作系统来完成请求的处理，然后通知服务端开启线程去进行处理，因此是一个有效请求一个线程。\",\"那么怎么理解同步和阻塞？\",\"首先，可以认为一个IO操作包含两个部分：\",\"发起IO请求\",\"实际的IO读写操作\",\"同步和异步在于第二个，实际的IO读写操作，如果操作系统帮你完成了再通知你，那就是异步，否则都叫做同步。\",\"阻塞和非阻塞在于第一个，发起IO请求，对于NIO来说通过channel发起IO操作请求后，其实就返回了，所以是非阻塞。\",\"NIO和BIO是非常重要的计算机知识，学习后会对整个计算机的理解更近一步，一次学会终身受益。JavaPub会单独写一篇深入图解NIO和BIO。\",\"网上看到一个例子（一定要看，会对你有所帮助）：\",\"一辆从 A 开往 B 的公共汽车上，路上有很多点可能会有人下车。司机不知道哪些点会有哪些人会下车，对于需要下车的人，如何处理更好？ 1. 司机过程中定时询问每个乘客是否到达目的地，若有人说到了，那么司机停车，乘客下车。 ( 类似阻塞式 ) 2. 每个人告诉售票员自己的目的地，然后睡觉，司机只和售票员交互，到了某个点由售票员通知乘客下车。 ( 类似非阻塞 ) 很显然，每个人要到达某个目的地可以认为是一个线程，司机可以认为是 CPU 。在阻塞式里面，每个线程需要不断的轮询，上下文切换，以达到找到目的地的结果。而在非阻塞方式里，每个乘客 ( 线程 ) 都在睡觉 ( 休眠 ) ，只在真正外部环境准备好了才唤醒，这样的唤醒肯定不会阻塞。\",\"建议阅读： https://www.cnblogs.com/aspirant/p/6877350.html https://www.cnblogs.com/shoshana-kong/p/11228555.html\"]},\"1290\":{\"h\":\"6. String、StringBuffer、StringBuilder 的区别是什么？\",\"t\":[\"String是Immutable类的典型实现，被声明为 final class，除了hash这个属性其它属性都声明为final。它的不可变性，所以例如拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。\",\"StringBuffer、StringBuilder就是解决String的这个性能问题。\",\"StringBuffer 是线程安全的，本质是一个线程安全的可修改的字符序列，把所有修改数据的方法都加上synchronized。\",\"StringBuffer 线程不安全，但是性能更好。\"]},\"1291\":{\"h\":\"7. 泛型是什么，有什么特点\",\"t\":[\"泛型在编码中有非常广泛的使用（jdk5引入），你一定经常能见到类似这种写法 <T> 。\",\"泛型提供了编译时类型安全检测机制，允许在编译时检测到非法的类型。本质是参数化类型。\",\"把类型当作是参数一样传递\",\"<数据类型>只能是引用类型\",\"泛型：就是一种不确定的数据类型。\",\"泛型的好处：\",\"省略了强转的代码。\",\"可以把运行时的问题提前到编译时期。\",\"引入泛型主要想实现一个通用的、可以处理不同类型的方法\",\"泛型擦除:\",\"泛型时提供给javac编译器使用的，用于限定集合的输入类型，让编译器在源代码级别上，避免向集合中插入非法数据。但编译器编译完带有泛型的java程序后，生成的class文件中不再带有泛型信息，以此使程序运行效率不受影响，这个过程称为擦除。\",\"JVM并不知道泛型的存在，因为泛型在编译阶段就已经被处理成普通的类和方法； 处理机制是通过类型擦除，擦除规则：\",\"若泛型类型没有指定具体类型，用Object作为原始类型；\",\"若有限定类型< T exnteds XClass >，使用XClass作为原始类型；\",\"若有多个限定< T exnteds XClass1 & XClass2 >，使用第一个边界类型XClass1作为原始类型；\"]},\"1292\":{\"h\":\"8. final 有哪些用法\",\"t\":[\"final关键字有四个常见用法。\",\"final修饰一个类\",\"当 final 关键字用来修饰一个类的时候，表明这个类不能有任何的子类，也就是说这个类不能被继承。\",\"final类中的所有成员方法都会被隐式地指定为final方法，也就是说一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写。\",\" public final class 类名称 { // ... }\",\"final修饰一个方法\",\"当 final 关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。\",\" 修饰符 final 返回值类型 方法名称(参数列表) { // 方法体 }\",\"注意：对于类、方法来说，abstract 关键字和 final 关键字不能同时使用，因为矛盾。\",\"final修饰一个局部变量\",\"一旦使用 final 用来修饰局部变量，那么这个变量就不能进行更改「一次赋值，终生不变」。\",\"对于基本类型来说，不可变说的是变量当中的数据不可改变；\",\"对于引用类型来说，不可变说的是变量当中的地址值不可改变。\",\"final修饰一个成员变量\",\"对于成员变量来说，如果使用 final 关键字修饰，那么这个变量也照样是不可变。\",\"由于成员变量具有默认值，所以用了 final 之后必须手动赋值，不会再给默认值了；\",\"对于 final 的成员变量，要么使用直接赋值，要么通过构造方法赋值，必须二者选其一；\",\"必须保证类当中所有重载的构造方法都最终会对 final 的成员变量进行赋值。\"]},\"1293\":{\"h\":\"9. 说一下Java注解\",\"t\":[\"在Java编程中，注解非常常见，注解的本质是什么？\",\"注解大致分为以下三种：\",\"Java原生注解 如@Override，@Deprecated 等。大多用于 [标记] 和 [检查] 。\",\"第三方注解，如 Spring、Mybatis等定义的注解（@Controller，@Data）。\",\"自定义注解。\",\"Java原生除了提供基本注解，还提供了 meta-annotation（元注解）。这些类型和它们所支持的类在java.lang.annotation包中可以找到。\",\"@Target\",\"@Retention\",\"@Documented\",\"@Inherited\",\"在这里插入图片描述\",\"一般比较常用的有 @Target，@Retention。@Target表示这个注解可以修饰那些地方（比如类、方法、成员变量），@Retention 主要是设置注解的生命周期。\",\"这是你一定会被问，\",\"有使用过注解吗？\",\"你是怎么使用的？\",\"注解有一个非常常见的使用场景，大家可以用这个来理解学习。\",\"场景一：自定义注解+拦截器 实现登录校验\",\"实现功能：\",\"接下来，我们使用springboot拦截器实现这样一个功能，如果方法上加了@LoginRequired，则提示用户该接口需要登录才能访问，否则不需要登录。\",\"首先定义一个LoginRequired注解\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface LoginRequired { }\",\"然后写两个简单的接口，访问sourceA，sourceB资源\",\"@RestController public class IndexController { @GetMapping(\\\"/sourceA\\\") public String sourceA(){ return \\\"你正在访问sourceA资源\\\"; } @GetMapping(\\\"/sourceB\\\") public String sourceB(){ return \\\"你正在访问sourceB资源\\\"; } }\",\"很简单的俩个接口，没添加拦截器之前成功访问\",\"在这里插入图片描述\",\"实现 spring 的 HandlerInterceptor 类先实现拦截器，但不拦截，只是简单打印日志，如下：\",\"public class SourceAccessInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"进入拦截器了\\\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } }\",\"实现spring类 WebMvcConfigurer，创建配置类把拦截器添加到拦截器链中\",\"@Configuration public class InterceptorTrainConfigurer implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new SourceAccessInterceptor()).addPathPatterns(\\\"/**\\\"); } }\",\"拦截成功如下\",\" 在 sourceB 方法上添加我们的登录注解 @LoginRequired\",\"@RestController public class IndexController { @GetMapping(\\\"/sourceA\\\") public String sourceA(){ return \\\"你正在访问sourceA资源\\\"; } @LoginRequired @GetMapping(\\\"/sourceB\\\") public String sourceB(){ return \\\"你正在访问sourceB资源\\\"; } }\",\"简单实现登录拦截逻辑\",\" @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"进入拦截器了\\\"); // 反射获取方法上的LoginRequred注解 HandlerMethod handlerMethod = (HandlerMethod)handler; LoginRequired loginRequired = handlerMethod.getMethod().getAnnotation(LoginRequired.class); if(loginRequired == null){ return true; } // 有LoginRequired注解说明需要登录，提示用户登录 response.setContentType(\\\"application/json; charset=utf-8\\\"); response.getWriter().print(\\\"你访问的资源需要登录\\\"); return false; }\",\"运行成功，访问sourceB时需要登录了，访问sourceA则不用登录。 \",\"场景二：自定义注解+AOP 实现日志打印\",\"先导入切面需要的依赖包\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-aop</artifactId> </dependency>\",\"定义一个注解@MyLog\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyLog { }\",\"定义一个切面类，见如下代码注释理解：\",\"@Aspect // 1.表明这是一个切面类 @Component public class MyLogAspect { // 2. PointCut表示这是一个切点，@annotation表示这个切点切到一个注解上，后面带该注解的全类名 // 切面最主要的就是切点，所有的故事都围绕切点发生 // logPointCut()代表切点名称 @Pointcut(\\\"@annotation(com.javapub.blog.MyLog)\\\") public void logPointCut(){}; // 3. 环绕通知 @Around(\\\"logPointCut()\\\") public void logAround(ProceedingJoinPoint joinPoint){ // 获取方法名称 String methodName = joinPoint.getSignature().getName(); // 获取入参 Object[] param = joinPoint.getArgs(); StringBuilder sb = new StringBuilder(); for(Object o : param){ sb.append(o + \\\"; \\\"); } System.out.println(\\\"进入[\\\" + methodName + \\\"]方法,参数为:\\\" + sb.toString()); // 继续执行方法 try { joinPoint.proceed(); } catch (Throwable throwable) { throwable.printStackTrace(); } System.out.println(methodName + \\\"方法执行结束\\\"); } }\",\"在步骤二中的IndexController写一个sourceC进行测试，加上我们的自定义注解：\",\" @MyLog @GetMapping(\\\"/sourceC/{source_name}\\\") public String sourceC(@PathVariable(\\\"source_name\\\") String sourceName){ return \\\"你正在访问sourceC资源\\\"; }\",\"启动springboot web项目，输入访问地址\",\"有些面试官喜欢问，注解三要素是哪些：\",\"注解声明、\",\"使用注解的元素、\",\"操作注解使其起作用(注解处理器)\"]},\"1294\":{\"h\":\"10. Java创建对象有几种方式\",\"t\":[\"Java中有5种创建对象的方式，下面给出它们的例子\",\"使用new关键字\",\"User user = new User();\",\"使用Class类的newInstance方法\",\"我们也可以使用Class类的newInstance方法创建对象。这个newInstance方法调用无参的构造函数创建对象。\",\"Employee emp = (Employee) Class.forName(\\\"org.javapub.blog.Employee\\\").newInstance(); 或者 Employee emp2 = Employee.class.newInstance();\",\"使用Constructor类的newInstance方法\",\"和Class类的newInstance方法很像， java.lang.reflect.Constructor类里也有一个newInstance方法可以创建对象。我们可以通过这个newInstance方法调用有参数的和私有的构造函数。\",\"Constructor<Employee> constructor = Employee.class.getConstructor(); Employee emp3 = constructor.newInstance();\",\"使用clone方法\",\"无论何时我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。\",\"要使用clone方法，我们需要先实现Cloneable接口并实现其定义的clone方法。\",\"Employee emp4 = (Employee) emp3.clone();\",\"使用反序列化\",\"当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数。\",\"为了反序列化一个对象，我们需要让我们的类实现Serializable接口\",\"ObjectInputStream in = new ObjectInputStream(new FileInputStream(\\\"data.obj\\\")); Employee emp5 = (Employee) in.readObject();\"]},\"1295\":{\"h\":\"Java并发\"},\"1296\":{\"h\":\"1. start()方法和run()方法的区别\",\"t\":[\"如果只是调用 run() 方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。\",\"只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。\",\"参考图：\",\"在这里插入图片描述\"]},\"1297\":{\"h\":\"2. volatile关键字的作用\",\"t\":[\"volatile 英 [ˈvɒlətaɪl] ，第一个想到的一定是保证内存可见性（Memory Visibility）。可见性是性对于线程而言。\",\" 上图是Java内存模型，所有线程的共享变量都放在主内存中，每一个线程都有一个独有的工作内存，每个线程不直接操作在主内存中的变量，而是将主内存上变量的副本放进自己的工作内存中，只操作工作内存中的数据。当修改完毕后，再把修改后的结果放回到主内存中。每个线程都只操作自己工作内存中的变量，无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。\",\"很明显，在并发环境下一定会发生脏数据问题。\",\"使用volatile变量能够保证:\",\"每次读取前必须先从主内存刷新最新的值。\",\"每次写入后必须立即同步回主内存当中。\",\"也就是说，volatile关键字修饰的变量看到的随时是自己的最新值。\",\"防止指令重排\",\"在基于偏序关系的Happens-Before内存模型中，指令重排技术大大提高了程序执行效率。但是也引入一个新问题：被部分初始化的对象\",\"例子：\",\"创建一个对象 instance = new Singleton();\",\"它并不是一个原子操作。事实上，它可以”抽象“为下面几条JVM指令：\",\"memory = allocate(); //1：分配对象的内存空间 initInstance(memory); //2：初始化对象 instance = memory; //3：设置instance指向刚分配的内存地址\",\"上面操作2依赖于操作1，但是操作3并不依赖于操作2，所以JVM可以以“优化”为目的对它们进行重排序，经过重排序后如下：\",\"memory = allocate(); //1：分配对象的内存空间 instance = memory; //3：设置instance指向刚分配的内存地址（此时对象还未初始化） initInstance(memory); //2：初始化对象\",\"可以看到指令重排之后，操作 3 排在了操作 2 之前，即引用instance指向内存memory时，这段崭新的内存还没有初始化。由于instance已经指向了一块内存空间，从而返回 instance!=null，用户得到了没有完成初始化的“半个”单例。\",\"但是有一点：volatile不保证原子性。\",\"这里有一篇生产环境使用volatile的例子：https://mp.weixin.qq.com/s/s1cwut9WvUSrMYw_6UK3sg\"]},\"1298\":{\"h\":\"3. sleep方法和wait方法有什么区别\",\"t\":[\"要了解sleep和wait，首先需要了解Java线程的6种状态。\",\"#下面是Java线程的6种状态 1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。 3. 阻塞(BLOCKED)：表示线程阻塞于锁。 4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 6. 终止(TERMINATED)：表示该线程已经执行完毕。\",\"sleep 休眠方法\",\"static void sleep(long ms)\",\"该方法会使当前线程进入阻塞状态指定毫秒，当阻塞指定毫秒后，当前线程会重新进入Runnable状态，等待划分时间片。\",\"sleep方法属于Thread类中方法，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可运行状态，不会马上进入运行状态，因为线程调度机制恢复线程的运行也需要时间，一个线程对象调用了sleep方法之后，并不会释放他所持有的所有对象锁，所以也就不会影响其他进程对象的运行。\",\"wait 方法一般是跟notify方法连用的\",\"多线程之间需要协调工作。如果条件不满足则等待。当条件满足时，等待该条件的线程将被唤醒。在Java中，这个机制实现依赖于wait/notify或wait/notifyAll。\",\"object.wait()让当前线程进入不可运行状态，如sleep()一样，但不同的是wait方法从一个对象调用，而不是从一个线程调用；我们称这个对象为“锁定对象（lockObj）”。在lockObj.wait()被调用之前，当前线程必须在lockObj上同步（synchronize）；然后调用wait()后释放这个锁，并将线程增加到与lockObj相关的“等待名单（wait list）”。然后，另一个在同一个lockObj锁定（synchronize）的方法可以调用lockObj.nofity()。这会唤醒原来等待的线程。基本上，wait() / notify()就像sleep() / interrupt()，只是活动线程不需要直接指向一个睡眠线程，他们只需要共享锁对象（lockObj）。\",\"到这里你是否明白这个问题，如果不明白来JavaPub，后续一篇代码分析，马上安排。\"]},\"1299\":{\"h\":\"4. 如何停止一个正在运行的线程？\",\"t\":[\"最直观的一定是 Thread.stop，但是它是不推荐的，并且已经废弃。看一下官方说明 https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html\",\"* This method is inherently unsafe. Stopping a thread with * Thread. stop causes it to unlock all of the monitors that it * has locked (as a natural consequence of the unchecked * <code>ThreadDeath</code> exception propagating up the stack). If * any of the objects previously protected by these monitors were in * an inconsistent state, the damaged objects become visible to * other threads, potentially resulting in arbitrary behavior. Many * uses of <code>stop</code> should be replaced by code that simply * modifies some variable to indicate that the target thread should * stop running. The target thread should check this variable * regularly, and return from its run method in an orderly fashion * if the variable indicates that it is to stop running. If the * target thread waits for long periods (on a condition variable, * for example), the <code>interrupt</code> method should be used to * interrupt the wait.\",\"小结： 简单来说，Thread.stop()不安全，已不再建议使用。\",\"方法一：\",\"使用 interrupt 方法中断线程。\",\"interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程。\",\"需要 this.isInterrupted(): 测试线程是否真的已经中断。\",\"方法二：\",\"最好的一种方法，使用标志位停止。\",\"run() 方法中做标识符，保证优雅的停止服务。\"]},\"1300\":{\"h\":\"5. java如何实现多线程之间的通讯和协作？(如何在两个线程间共享数据？)\",\"t\":[\"volatile关键字方式\",\"volatile有两大特性，一是可见性，二是有序性，禁止指令重排序，其中可见性就是可以让线程之间进行通信。\",\"等待/通知机制\",\"等待通知机制是基于wait和notify方法来实现的，在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被通知或者被唤醒。\",\"也就是通过等待/通知机制 让多个线程协作\",\"join方式\",\"join其实合理理解成是线程合并，当在一个线程调用另一个线程的join方法时，当前线程阻塞等待被调用join方法的线程执行完毕才能继续执行，所以join的好处能够保证线程的执行顺序，但是如果调用线程的join方法其实已经失去了并行的意义，虽然存在多个线程，但是本质上还是串行的，最后join的实现其实是基于等待通知机制的。\",\"threadLocal方式\",\"threadLocal方式的线程通信，不像以上三种方式是多个线程之间的通信，它更像是一个线程内部的通信，将当前线程和一个map绑定，在当前线程内可以任意存取数据，减省了方法调用间参数的传递。\"]},\"1301\":{\"h\":\"6. 什么是ThreadLocal?\",\"t\":[\"定义：线程局部变量是局限于线程内的变量，属于线程自身所有，不在多个线程间共享。java提供 ThreadLocal类 来支持线程局部变量，是一个实现线程安全的方式。\",\"作用：ThreadLocal 是一种以空间换时间的做法，在每一个 Thread 里面维护了一个 ThreadLocal.ThreadLocalMap 把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。\"]},\"1302\":{\"h\":\"7. Java 中 CountDownLatch 和 CyclicBarrier 有什么不同？\",\"t\":[\"概念：\",\"CountDownLatch 是一个同步的辅助类，允许一个或多个线程，等待其他一组线程完成操作，再继续执行。简单来说：CountDownLatch 是一个计数器，可以保证线程之间的顺序执行把线程从并发状态调整为串行状态保证了线程的执行顺序。(只可以使用一次)\",\"CyclicBarrier 是一个同步的辅助类，允许一组线程相互之间等待，达到一个共同点，再继续执行。典型场景：可以用于多线程计算数据，最后合并计算结果。（可以多次使用）\",\"分享一个直观的代码：\",\"package com.javapub.test; import java.util.concurrent.CountDownLatch; /** * @Author: JavaPub * @License: https://github.com/Rodert/ * @Contact: https://javapub.blog.csdn.net/ * @Date: 2022/1/1 16:50 * @Version: 1.0 * @Description: countDownLatch 可以保证线程之间的顺序执行把线程从并发状态调整为串行状态保证了线程的执行顺序。 * demo效果：当打印完B，再打印C。 */ class ThreadA extends Thread { private CountDownLatch down; public ThreadA(CountDownLatch down) { this.down = down; } @Override public void run() { System.out.println(\\\"A\\\"); try { down.await();//相当于wait(),调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"C\\\"); } } class ThreadB extends Thread { private CountDownLatch down; public ThreadB(CountDownLatch down) { this.down = down; } @Override public void run() { System.out.println(\\\"B\\\"); System.out.println(down.getCount()); down.countDown();//将count值减1 } } public class Test { public static void main(String[] args) { CountDownLatch down = new CountDownLatch(1);//创建1个计数器 new ThreadA(down).start(); new ThreadB(down).start(); } } /*输出 A B C */\",\"package com.roundyuan.fanggateway.test; import java.util.concurrent.CyclicBarrier; /** * @Author: JavaPub * @License: https://github.com/Rodert/ * @Contact: https://javapub.blog.csdn.net/ * @Date: 2022/1/2 13:42 * @Version: 1.0 * @Description: CyclicBarrier */ public class CyclicBarrierDemo { static class TaskThread extends Thread { CyclicBarrier barrier; public TaskThread(CyclicBarrier barrier) { this.barrier = barrier; } @Override public void run() { try { Thread.sleep(1000); System.out.println(getName() + \\\" 到达栅栏 A\\\"); barrier.await(); System.out.println(getName() + \\\" 冲破栅栏 A\\\"); Thread.sleep(2000); System.out.println(getName() + \\\" 到达栅栏 B\\\"); barrier.await(); System.out.println(getName() + \\\" 冲破栅栏 B\\\"); } catch (Exception e) { e.printStackTrace(); } } } public static void main(String[] args) { int threadNum = 5; CyclicBarrier barrier = new CyclicBarrier(threadNum, new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName() + \\\" 完成最后任务\\\"); } }); for (int i = 0; i < threadNum; i++) { new TaskThread(barrier).start(); } } } /* Thread-3 到达栅栏 A Thread-1 到达栅栏 A Thread-4 到达栅栏 A Thread-2 到达栅栏 A Thread-0 到达栅栏 A Thread-2 完成最后任务 Thread-2 冲破栅栏 A Thread-0 冲破栅栏 A Thread-4 冲破栅栏 A Thread-3 冲破栅栏 A Thread-1 冲破栅栏 A Thread-4 到达栅栏 B Thread-0 到达栅栏 B Thread-2 到达栅栏 B Thread-1 到达栅栏 B Thread-3 到达栅栏 B Thread-3 完成最后任务 Thread-3 冲破栅栏 B Thread-0 冲破栅栏 B Thread-4 冲破栅栏 B Thread-1 冲破栅栏 B Thread-2 冲破栅栏 B */\",\"网上看到一个比较形象一个例子：\",\"CountDownLatch： 宿管阿姨，晚上关宿舍大门睡觉，需要等到所有学生回寝，才能关门睡觉，学生之间不用相互等待，回寝就能睡觉。 （学生就是各个线程，宿管阿姨就是监听CountDownLatch为0后要执行的。） CyclicBarrier： 家庭聚餐，等待家庭成员到齐才能开饭，家庭成员之间需要相互等待，直到最后一个到达，才能同时开饭。\"]},\"1303\":{\"h\":\"8. 如何避免死锁？\",\"t\":[\" 从上图我们就可以看出，产生死锁就是俩个或多个线程在申请资源时，自己需要的资源别别人持有、并阻塞。所以导致死锁。\",\"如何解决：\",\"减小锁的范围，尽量保证之锁定自己需要的资源，减小交叉持有资源情况\",\"但是有些时候不得不持有多个资源，比如银行转账，我们必须同时获得两个账户上的锁，才能进行操作，两个锁的申请必须发生交叉。这时我们也可以打破死锁的那个闭环，在涉及到要同时申请两个锁的方法中，总是以相同的顺序来申请锁，比如总是先申请 id 大的账户上的锁 ，然后再申请 id 小的账户上的锁，这样就无法形成导致死锁的那个闭环。\",\"我们知道导致死锁有一个因素是阻塞，所以如果我们不使用默认阻塞的锁，也是可以避免死锁的。我们可以使用 ReentrantLock.tryLock() 方法，在一个循环中，如果 tryLock() 返回失败，那么就释放以及获得的锁，并睡眠一小段时间。这样就打破了死锁的闭环。\",\"package com.roundyuan.fanggateway.test; import java.util.Random; import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * @Author: JavaPub * @License: https://github.com/Rodert/ * @Contact: https://javapub.blog.csdn.net/ * @Date: 2022/1/2 14:38 * @Version: 1.0 * @Description: ReentrantLock */ public class DeadLock { private static Lock lock1 = new ReentrantLock(); private static Lock lock2 = new ReentrantLock(); public static void deathLock() { new Thread() { @Override public void run() { while (true) { if (lock1.tryLock()) { try { //如果获取成功则执行业务逻辑，如果获取失败，则释放lock1的锁，自旋重新尝试获得锁 if (lock2.tryLock()) { try { System.out.println(\\\"Thread1：已成功获取 lock1 and lock2 ...\\\"); break; } finally { lock2.unlock(); } } } finally { lock1.unlock(); } } System.out.println(\\\"Thread1：获取锁失败，重新获取---\\\"); try { //防止发生活锁 TimeUnit.NANOSECONDS.sleep(new Random().nextInt(100)); } catch (InterruptedException e) { e.printStackTrace(); } } } }.start(); new Thread() { @Override public void run() { while (true) { if (lock2.tryLock()) { try { //如果获取成功则执行业务逻辑，如果获取失败，则释放lock2的锁，自旋重新尝试获得锁 if (lock1.tryLock()) { try { System.out.println(\\\"Thread2：已成功获取 lock2 and lock1 ...\\\"); break; } finally { lock1.unlock(); } } } finally { lock2.unlock(); } } System.out.println(\\\"Thread2：获取锁失败，重新获取---\\\"); try { //防止发生活锁 TimeUnit.NANOSECONDS.sleep(new Random().nextInt(100)); } catch (InterruptedException e) { e.printStackTrace(); } } } }.start(); } public static void main(String[] args) throws InterruptedException { for (int i = 0; i < 5; i++) { deathLock(); } } }\",\"说起死锁，银行家算法非常有必要了解：\",\"银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。 1、操作系统按照银行家指定的规则为进程分配资源，当进程首次申请资源时，需要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请资源分配资源，否则就推迟分配； 2、当进程在执行中继续申请资源时，先测试该进程本次申请的资源数，是否超过了该资源剩余的总量，若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。\",\"参考阅读：\",\"如何快速排查死锁？如何避免死锁？ https://zhuanlan.zhihu.com/p/136294283\"]},\"1304\":{\"h\":\"9. Java 中 synchronized 和 ReentrantLock 有什么不同？\",\"t\":[\"等待可中断:\",\"使用synchronized，不能被中断。synchronized 也可以说是Java提供的原子性内置锁机制。内部锁扮演了互斥锁（mutual exclusion lock ，mutex）的角色，一个线程引用锁的时候，别的线程阻塞等待。\",\"使用ReentrantLock。等待了很长时间以后，可以中断等待，转而去做别的事情。\",\"公平锁:\",\"公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序来依次获得锁；而非公平锁则不能保证这一点。非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁。 synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁。\",\"还有大家已知的俩点：\",\"synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活。ReentrantLock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。\",\"synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。\"]},\"1305\":{\"h\":\"10. 有三个线程 T1，T2，T3，怎么确保它们按顺序执行？\",\"t\":[\"方法1：\",\"线程内部顺序调用，T1、T2、T3。这个可能不是要考察的点，但也是一个方案。\",\"方法2：\",\"join()方法用于将线程由 ”并行“变成”串行“，它用于等待其他线程的终止，在当前线程掉用了join()方法，那么当前线程将进入阻塞状态，等到另一个线程结束，当前线程再由阻塞状态转变成就绪状态，等待CPU的使用权。\",\"package com.javapub.test; /** * @Author: JavaPub * @License: https://github.com/Rodert/ * @Contact: https://javapub.blog.csdn.net/ * @Date: 2022/1/2 15:20 * @Version: 1.0 * @Description: */ public class Test1 { public static void main(String[] args) { ThreadA threadA = new ThreadA(); ThreadB threadB = new ThreadB(threadA); ThreadC threadC = new ThreadC(threadB); threadA.start(); threadB.start(); threadC.start(); } } class ThreadA extends Thread { @Override public void run() { System.out.println(\\\"线程A\\\"); } } class ThreadB extends Thread { Thread threadA; public ThreadB() { // dosomething Auto-generated constructor stub } public ThreadB(Thread threadA) { this.threadA = threadA; } @Override public void run() { try { threadA.join(); } catch (InterruptedException e) { // dosomething Auto-generated catch block e.printStackTrace(); } System.out.println(\\\"线程B\\\"); } } class ThreadC extends Thread { Thread threadB; public ThreadC(Thread threadB) { this.threadB = threadB; } @Override public void run() { try { threadB.join(); } catch (InterruptedException e) { // dosomething Auto-generated catch block e.printStackTrace(); } System.out.println(\\\"线程C\\\"); } }\",\"信号量方式 java.util.concurrent.Semaphore 英 [ˈseməfɔː(r)] 待研究\"]},\"1306\":{\"h\":\"Java 容器\"},\"1307\":{\"h\":\"1. 请说一下Java容器集合的分类，各自的继承结构\",\"t\":[\"Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：\",\"Collection包括：List、ArrayList、LinkedList、Vector、Stack、Set、HashSet、LinkedHashSet、TreeSet\",\"Map包括：HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap、Hashtable\"]},\"1308\":{\"h\":\"2. Collection 和 Collections 有什么区别？\",\"t\":[\"Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。\",\"Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法：Collections. sort(list)。\"]},\"1309\":{\"h\":\"3. List、Set、Map 之间的区别是什么？\",\"t\":[\"List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。\"]},\"1310\":{\"h\":\"4. HashMap 和 Hashtable 有什么区别？\",\"t\":[\"HashMap 是非线程安全的，HashTable 是线程安全的。\",\"HashMap 的键和值都允许有 null 值存在，而 HashTable 则不行。\",\"因为线程安全的问题，HashMap 效率比 HashTable 的要高。\",\"Hashtable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线程环境，而 Hashtable 适合于多线程环境。\",\"一般现在 **不建议用 HashTable **， \",\"一方面是因为 HashTable 是遗留类，内部实现很多没优化和冗余。\",\"另外，即使在 多线程 环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用 HashTable。\"]},\"1311\":{\"h\":\"5. 说一下 HashMap 的实现原理？\",\"t\":[\"HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。\",\"当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。\"]},\"1312\":{\"h\":\"6. 谈谈 ArrayList 和 LinkedList 的区别\",\"t\":[\"本质的区别来源于两者的底层实现：ArrayList的底层是数组，LinkedList的底层是双向链表。\",\"数组拥有O(1)的查询效率，可以通过下标直接定位元素；链表在查询元素的时候只能通过遍历的方式查询，效率比数组低。\",\"数组增删元素的效率比较低，通常要伴随拷贝数组的操作；链表增删元素的效率很高，只需要调整对应位置的指针即可。\",\"以上是数组和链表的通俗对比，在日常的使用中，两者都能很好地在自己的适用场景发挥作用。\",\"比如说我们常常用ArrayList代替数组，因为封装了许多易用的api，而且它内部实现了自动扩容机制，由于它内部维护了一个当前容量的指针size，直接往ArrayList中添加元素的时间复杂度是O(1)的，使用非常方便。\",\"而LinkedList常常被用作Queue队列的实现类，由于底层是双向链表，能够轻松地提供先入先出的操作。\",\"我觉得可以分两部分答，一个是数组与链表底层实现的不同，另一个是答ArrayList和LinkedList的实现细节。\"]},\"1313\":{\"h\":\"7. 谈谈ArrayList和Vector的区别\",\"t\":[\"两者的底层实现相似，关键的不同在于Vector的对外提供操作的方法都是用synchronized修饰的，也就是说Vector在并发环境下是线程安全的，而ArrayList在并发环境下可能会出现线程安全问题。\",\"由于Vector的方法都是同步方法，执行起来会在同步上消耗一定的性能，所以在单线程环境下，Vector的性能是不如ArrayList的\",\"除了线程安全这点本质区别外，还有一个实现上的小细节区别：ArrayList每次扩容的大小为原来的1.5倍；Vector可以指定扩容的大小，默认是原来大小的两倍。\",\"可以顺带谈谈多线程环境下ArrayList的替代品，比如CopyOnWriteArrayList，但是要谈谈优缺点。\"]},\"1314\":{\"h\":\"8. 请谈一谈 Java 集合中的 fail-fast 和 fail-safe 机制\",\"t\":[\"fail-fast 是一种错误检测机制，Java 在适合单线程使用的集合容器中很好地实现了 fail-fast 机制，举一个简单的例子：在多线程并发环境下，A线程在通过迭代器遍历一个 ArrayList 集合，B线程同时对该集合进行增删元素操作，这个时候线程A就会抛出并发修改异常，中断正常执行的逻辑。\",\"而fail-safe机制更像是一种对 fail-fast 机制的补充，它被广泛地实现在各种并发容器集合中。回头看上面的例子，如果线程A遍历的不是一个 ArrayList，而是一个 CopyOnWriteArrayList，则符合 fail-safe 机制，线程B可以同时对该集合的元素进行增删操作，线程A不会抛出任何异常。\",\"要理解这两种机制的表象，我们得了解这两种机制背后的实现原理：\",\"我们同样用 ArrayList 解释 fail-fast 背后的原理：首先 ArrayList 自身会维护一个 modCount 变量，每当进行增删元素等操作时，modCount 变量都会进行自增。当使用迭代器遍历 ArrayList 时，迭代器会新维护一个初始值等于 modCount 的 expectedModCount 变量，每次获取下一个元素的时候都会去检查 expectModCount 和 modCount 是否相等。在上面举的例子中，由于B线程增删元素会导致 modCount 自增，当A线程遍历元素时就会发现两个变量不等，从而抛出异常。\",\"CopyOnWriteArrayList 所实现的 fail-safe 在上述情况下没有抛出异常，它的原理是：当使用迭代器遍历集合时，会基于原数组拷贝出一个新的数组（ArrayList的底层是数组），后续的遍历行为在新数组上进行。所以线程B同时进行增删操作不会影响到线程A的遍历行为。\"]},\"1315\":{\"h\":\"9. HashMap是怎样确定key存放在数组的哪个位置的？JDK1.8\",\"t\":[\"首先计算key的hash值，计算过程是：先得到key的hashCode（int类型，4字节），然后把hashCode的高16位与低16位进行异或，得到key的hash值。\",\"接下来用key的hash值与数组长度减一的值进行按位与操作，得到key在数组中对应的下标。\"]},\"1316\":{\"h\":\"9.1. 追问：为什么计算key的hash时要把hashCode的高16位与低16位进行异或？（变式：为什么不直接用key的hashCode）?\",\"t\":[\"计算key在数组中的下标时，是通过hash值与数组长度减一的值进行按位与操作的。由于数组的长度通常不会超过2^16，所以hash值的高16位通常参与不了这个按位与操作。\",\"为了让hashCode的高16位能够参与到按位与操作中，所以把hashCode的高16位与低16位进行异或操作，使得高16位的影响能够均匀稀释到低16位中，使得计算key位置的操作能够充分散列均匀。\"]},\"1317\":{\"h\":\"10. 为什么要把链表转为红黑树，阈值为什么是8？\",\"t\":[\"在极端情况下，比如说key的hashCode()返回的值不合理，或者多个密钥共享一个hashCode，很有可能会在同一个数组位置产生严重的哈希冲突。\",\"这种情况下，如果我们仍然使用使用链表把多个冲突的元素串起来，这些元素的查询效率就会从O(1)下降为O(N)。为了能够在这种极端情况下仍保证较为高效的查询效率，HashMap选择把链表转换为红黑树，红黑树是一种常用的平衡二叉搜索树，添加，删除，查找元素等操作的时间复杂度均为O(logN)\",\"至于阈值为什么是8，这是HashMap的作者根据概率论的知识得到的。当key的哈希码分布均匀时，数组同一个位置上的元素数量是成泊松分布的，同一个位置上出现8个元素的概率已经接近千分之一了，这侧面说明如果链表的长度达到了8，key的hashCode()肯定是出了大问题，这个时候需要红黑树来保证性能，所以选择8作为阈值。\",\"追问：为什么红黑树转换回链表的阈值不是7而是6呢？\",\"如果是7的话，那么链表和红黑树之间的切换范围值就太小了。如果我的链表长度不停地在7和8之间切换，那岂不是得来回变换形态？所以选择6是一种折中的考虑。\"]},\"1318\":{\"h\":\"拓展题. 为什么 HashMap 数组的长度是2的幂次方？\",\"t\":[\"因为这样能够提高根据 key 计算数组位置的效率。\",\"HashMap 根据 key 计算数组位置的算法是：用 key 的 hash 值与数组长度减1的值进行按位与操作。\",\"在我们正常人的思维中，获取数组的某个位置最直接的方法是对数组的长度取余数。但是如果被除数是2的幂次方，那么这个对数组长度取余的方法就等价于对数组长度减一的值进行按位与操作。\",\"在计算机中，位运算的效率远高于取模运算，所以为了提高效率，把数组的长度设为2的幂次方。\",\"所以一定要看一遍源码，相比于框架的源码，集合的源码简直太友好了。在笔试的时候可能还会考一些集合的使用，比如遍历，排序，比较等等，这些算是Java基础，用得多也就熟了。\"]},\"1319\":{\"h\":\"JavaEE\"},\"1320\":{\"h\":\"1. JSP 有哪些内置对象？作用分别是什么？\",\"t\":[\"JSP有9个内置对象：\",\"request：封装客户端的请求，其中包含来自GET或POST请求的参数；\",\"response：封装服务器对客户端的响应；\",\"pageContext：通过该对象可以获取其他对象；\",\"session：封装用户会话的对象；\",\"application：封装服务器运行环境的对象；\",\"out：输出服务器响应的输出流对象；\",\"config：web应用的配置对象；\",\"page：jsp页面本身（相当于Java程序中的this）；\",\"exception：封装页面抛出异常的对象。\",\"JSP的9内置对象及其含义\"]},\"1321\":{\"h\":\"2. 介绍一下 Servlet 生命周期\",\"t\":[\"Servlet是运行在服务器端，以多线程的方式处理客户端请求的小程序。是sun公司提供的一套规范（规范的实现是接口）。\",\"servlet的生命周期就是从servlet出现到消亡(销毁)的全过程。主要分为以下几个阶段：\",\"加载类—>实例化(为对象分配空间)—>初始化(为对象的属性赋值)—>请求响应(服务阶段)—>销毁\",\"详细介绍：\",\"加载\",\"在下列时刻会加载Servlet（只执行一次）：\",\"如果已经配置自动加载选项，则在启动服务器时自动加载 web.xml 文件中设置的<load-on-start>；\",\"服务器启动之后，客户机首次向Servlet发出请求时会加载；\",\"重新加载Servlet时会进行一次加载；\",\"实例化\",\"加载Servlet后，服务器创建一个Servlet实例。（只执行一次）\",\"初始化\",\"调用 Servlet 的 init() 方法。在初始化阶段，Servlet 初始化参数被传递给 Servlet 配置对象 ServletConfig。（只执行一次）；\",\"请求处理\",\"对于到达服务器的客户机请求，服务器创建针对此次请求的一个\\\"请求对象\\\"和一个\\\"响应对象\\\"。\",\"服务器调用 Servlet 的 service() 方法，该方法用于传递\\\"请求\\\"和\\\"响应\\\"对象。\",\"service() 方法从\\\"请求\\\"对象获得请求信息、处理该请求并用\\\"响应\\\"对象的方法将响应回传给客户端。\",\"service() 方法可以调用其他方法来处理请求，例如 doGet()、doPost() 或其他方法。\",\"销毁\",\"当服务器不需要 Servlet，或重新装入 Servlet 的新实例时，服务器会调用 Servlet 的 destroy() 方法。（只执行一次）；\"]},\"1322\":{\"h\":\"3. Servlet和JSP的区别和联系\",\"t\":[\"区别：\",\"JSP是在HTML代码里面写Java代码；而Servlet是在Java代码中写HTML代码，Servlet本身是个Java类；\",\"JSP使人们将显示和逻辑分隔称为可能，这意味着两者的开发可以并行进行；而Servlet并没有将两者分开；\",\"Servlet独立地处理静态表示逻辑与动态业务逻辑，任何文件的变动都需要对此服务程序重新编译；JSP允许使用特殊标签直接嵌入到HTML页面，HTML内容与JAVA内容也可放在单独文件中，HTML内容的任何变动会自动编译装入到服务程序；\",\"Servlet需要在web.xml中配置；而JSP无需配置；\",\"目前JSP主要用在视图层，负责显示；而Servlet主要用在控制层，负责调度；\",\"联系：\",\"都是SUN公司推出的动态网页技术；\",\"先有Servlet，针对Servlet缺点推出JSP。JSP是Servlet的一种特殊形式，每个JSP页面就是一个Servlet实例，JSP页面由系统翻译成Servlet，Servlet再负责响应用户的请求。\"]},\"1323\":{\"h\":\"4. JSP的执行过程\",\"t\":[\"在JSP运行过程中，首先由客户端发出请求，Web服务器接收到请求之后，如果是第一次访问某个JSP页面，Web服务器对它进行一下三个操作：\",\"翻译\",\"由.jsp变为.java，由JSP引擎完成。\",\"编译\",\"由.java变为.class，由Java编译器实现。\",\"执行\",\"由.class变为.html，用Java虚拟机执行编译文件，然后将执行结果返回给Web服务器，并最终返回给客户端。\",\"如果不是第一次访问某个JSP页面，则只执行第三步，所以第一次访问JSP较慢。\"]},\"1324\":{\"h\":\"5. Session和Cookie的区别和联系；说明在自己项目中如何使用？\",\"t\":[\"Session 和 Cookie 都是会话(Seesion)跟踪技术。Cookie 通过在客户端记录信息确定用户身份，Session 通过在服务器端记录信息确定用户身份。但是 Session 的实现依赖于 Cookie，sessionId(session的唯一标识需要存放在客户端).\",\"cookie数据存放在客户的浏览器上，session数据放在服务器上。\",\"cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。\",\"session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。\",\"单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\",\"可以考虑将登录信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。\",\"在程序开发过程中，我们可以在客户端每次与服务器交互时检查SessionID（Session中属性值，非HttpServlet环境开发中也可以用其它的Key值代替），用于会话管理。\",\"将登陆信息等重要信息存放为SESSION\",\"其他信息如果需要保留，可以放在COOKIE中，比如购物车\",\"购物车最好使用cookie，但是cookie是可以在客户端禁用的，这时候我们要使用cookie+数据库的方式实现，当从cookie中不能取出数据时，就从数据库获取。\"]},\"1325\":{\"h\":\"6. 转发和重定向的联系和区别？\",\"t\":[\"转发：服务器端的跳转，路径不会发生改变（针对的是servlet），是服务器内部的处理，一次请求，请求对象不会变\",\"重定向：客户端的跳转，路径会发生改变，将要请求的路径和302重定向的状态码发给客户端浏览器，客户端浏览器将再次向服务器发出请求，不是同个请求，两次请求。\"]},\"1326\":{\"h\":\"7. 拦截器和过滤器的区别\",\"t\":[\"Spring 的拦截器与 Servlet 的 Filter 有相似之处，比如二者都是AOP编程思想的体现，都能实现权限检查、日志记录等。不同的是:\",\"使用范围不同: Filter 是 Servlet 规范规定的，只能用于Web程序中。而拦截器既可以用于Web程序，也可以用于 Application、Swing程序中。\",\"规范不同: Filter 是在 Servlet 规范中定义的，是 Servlet 容器支持的。而拦截器是在 Spring 容器内的，是 Spring 框架支持的。\",\"使用的资源不同:同其他的代码块一样，拦截器也是一个 Spring 的组件，归 Spring 管理，配置在 Spring 文件中，因此能使用 Spring 里的任何资源、对象，例如 Service 对象、数据源、事务管理等，通过 IoC 注入到拦截器即可;而Filter则不能。\",\"深度不同: Filter 在只在 Servlet 前后起作用。而拦截器能够深入到方法前后、异常抛出前后等，因此拦截器的使用具有更大的弹性。所以在 Spring 构架的程序中，要优先使用拦截器。\",\"一张经典的图\",\"过滤器&拦截器\"]},\"1327\":{\"h\":\"8. 三次握手和四次挥手\",\"t\":[\"这里是字面描述\",\"三次握手:\",\"客户端向服务器发出连接请求等待服务器确认\",\"服务器向客户端返回一个响应告诉客户端收到了请求\",\"客户端向服务器再次发出确认信息,此时连接建立\",\"四次挥手:\",\"客户端向服务器发出取消连接请求\",\"服务器向客户端返回一个响应,表示收到客户端取消请求\",\"服务器向客户端发出确认取消信息(向客户端表明可以取消连接了)\",\"客户端再次发送确认消息,此时连接取消\"]},\"1328\":{\"h\":\"9. TCP和UDP的区别\",\"t\":[\"TCP ：面向连接，UDP ：面向无连接\",\"TCP ：传输效率低，UDP ：传输效率高(有大小限制，一次限定在64kb之内)\",\"TCP：可靠，UDP ：不可靠\"]},\"1329\":{\"h\":\"10. 如何解决跨域问题？\",\"t\":[\"跨域指的是浏览器不能执行其它网站的脚本，它是由浏览器的同源策略造成的，是浏览器对 JavaScript 施加的安全限制。\",\"所谓同源指的是：协议、域名、端口号都相同，只要有一个不相同，那么都是非同源。\",\"解决方案：\",\"使用 ajax 的 jsonp。（这一点有些人是不知道的）\",\"nginx 转发：利用 nginx 反向代理，将请求分发到部署相应项目的 tomcat 服务器，当然也不存在跨域问题。\",\"使用 CORS：写一个配置类实现 WebMvcConfigurer 接口或者配置 FilterRegistrationBean。\",\"CORS（Cross-Origin Resource Sharing）是一个W3C标准，全称“跨域资源共享”\"]},\"1330\":{\"h\":\"11. 什么是 CSRF 攻击？如何防御CSRF 攻击\",\"t\":[\"CSRF（Cross-site request forgery） 跨站请求伪造。CSRF 攻击是在受害者毫不知情的情况下，以受害者名义伪造请求发送给受攻击站点，从而在受害者并未授权的情况下执行受害者权限下的各种操作。\",\"CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。\",\"目前防御 CSRF 攻击主要有三种策略：\",\"验证 HTTP Referer 字段\",\"在请求地址中添加 token 并验证\",\"在 HTTP 头中自定义属性并验证\"]},\"1331\":{\"h\":\"12. HTTP1.0和HTTP1.1和HTTP2.0的区别\",\"t\":[\"HTTP1.0 ：无状态，无连接。\",\"HTTP1.1 ：长连接，请求管道化，增加缓存处理，增加 Host 字段，支持断点传输。\",\"HTTP2.0 ：二进制分帧，多路复用(连接共享)，头部压缩，服务器推送。\"]},\"1332\":{\"h\":\"JVM\"},\"1333\":{\"h\":\"1. 说一说JVM的主要组成部分\",\"t\":[\"点击放大看，一图胜千文\",\"image\",\"方法区和堆是所有线程共享的内存区域；而虚拟机栈、本地方法栈和程序计数器的运行是线程私有的内存区域，运行时数据区域就是我们常说的JVM的内存。\",\"类加载子系统：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到运行时数据区中的方法区中。\",\"Java堆是Java虚拟机所管理的内存中最大的一块，也是垃圾回收的主要区域。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。\",\"方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\",\"程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器，用来指示执行引擎下一条执行指令的地址。\",\"Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、返回方法地址等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\",\"本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。\",\"执行引擎：根据程序计数器中存储的指令地址执行classes中的指令。\",\"本地接口：与本地方法库交互，是其它编程语言交互的接口。\"]},\"1334\":{\"h\":\"2. 说一下 JVM 的作用？\",\"t\":[\"首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。\"]},\"1335\":{\"h\":\"3. 说一下堆栈的区别？\",\"t\":[\"物理地址\",\"堆的物理地址分配对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）\",\"栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。\",\"内存分别\",\"堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。\",\"栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。\",\"存放的内容\",\"堆存放的是对象的实例和数组。因此该区更关注的是数据的存储\",\"栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。\",\"PS：\",\"静态变量放在方法区 静态的对象还是放在堆。 程序的可见度\",\"堆对于整个应用程序都是共享、可见的。\",\"栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。\"]},\"1336\":{\"h\":\"4. Java内存泄漏\",\"t\":[\"内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。\",\"严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。\",\"理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。\",\"但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。\"]},\"1337\":{\"h\":\"5. JVM 有哪些垃圾回收算法？\",\"t\":[\"标记-清除算法：标记有用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。\",\"复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半，消耗内存。\",\"标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。\",\"分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。\"]},\"1338\":{\"h\":\"6. 说一下 JVM 有哪些垃圾回收器？\",\"t\":[\"image\",\"image\"]},\"1339\":{\"h\":\"7. 说一下类加载的执行过程？\",\"t\":[\"加载：根据查找路径找到相应的 class 文件然后装载入内存中；\",\"image\",\"验证：检查加载的 class 文件的正确性；\",\"准备：给类中的静态变量分配内存空间；\",\"解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；\",\"初始化：对静态变量和静态代码块执行初始化工作。\"]},\"1340\":{\"h\":\"8. 什么是双亲委派模型？为什么要使用双亲委派模型？\",\"t\":[\"什么是双亲委派模型\",\"当需要加载一个类的时候，子类加载器并不会马上去加载，而是依次去请求父类加载器加载\",\"如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；\",\"如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。\",\"为什么要使用双亲委派模型\",\"可以防止内存中出现多份同样的字节码，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的Object类，那么类之间的比较结果及类的唯一性将无法保证，而且如果不使用这种双亲委派模型将会给虚拟机的安全带来隐患。所以，要让类对象进行比较有意义，前提是他们要被同一个类加载器加载。\"]},\"1341\":{\"h\":\"9. CMS垃圾清理的过程\",\"t\":[\"image\",\"CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记 stop-the-world)\",\"初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出 GC Roots 能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。\",\"并发标记（Concurrent-Mark）阶段：从 Gc Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。\",\"重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。\",\"并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的\"]},\"1342\":{\"h\":\"10. 常用的 JVM 调优的参数都有哪些？\",\"t\":[\"image\",\"-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；\",\"-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；\",\"–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；\",\"-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；\",\"-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；\",\"-XX:+PrintGC：开启打印 gc 信息；\",\"-XX:+PrintGCDetails：打印 gc 详细信息。\",\"image\"]},\"1343\":{\"h\":\"Kafka\",\"t\":[\"在面试kafka中，一定要了解为什么要用kafka、及kafka的架构等基本概念，才能对面试中的问题得心应手。\"]},\"1344\":{\"h\":\"术语0. Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么\",\"t\":[\"ISR:In-Sync Replicas 副本同步队列\",\"AR:Assigned Replicas 所有副本\",\"ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR=ISR+OSR。\"]},\"1345\":{\"h\":\"术语0. Kafka中的HW、LEO、LSO、LW等分别代表什么？\",\"t\":[\"HW:High Watermark 高水位，取一个partition对应的ISR中最小的LEO作为HW，consumer最多只能消费到HW所在的位置上一条信息。\",\"LEO:LogEndOffset 当前日志文件中下一条待写信息的offset HW/LEO这两个都是指最后一条的下一条的位置而不是指最后一条的位置。\",\"LSO:Last Stable Offset 对未完成的事务而言，LSO 的值等于事务中第一条消息的位置(firstUnstableOffset)，对已完成的事务而言，它的值同 HW 相同\",\"LW:Low Watermark 低水位, 代表 AR 集合中最小的 logStartOffset 值\"]},\"1346\":{\"h\":\"1. kafka 是什么？有什么作用？\",\"t\":[\"Kafka 是一个分布式的流式处理平台，它以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用\",\"主要功能体现于三点：\",\"消息系统：kafka与传统的消息中间件都具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。与此同时，kafka还提供了大多数消息系统难以实现的消息顺序性保障及回溯性消费的功能。\",\"存储系统：kafka把消息持久化到磁盘，相比于其他基于内存存储的系统而言，有效的降低了消息丢失的风险。这得益于其消息持久化和多副本机制。也可以将kafka作为长期的存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题日志压缩功能。\",\"流式处理平台：kafka为流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理框架，比如窗口、连接、变换和聚合等各类操作。\"]},\"1347\":{\"h\":\"2. kafka 的架构是怎么样的？\",\"t\":[\"这是一个基本概念的题目，一定要掌握。\",\"一个典型的 kafka 体系架构包括若干 Producer、若干 Consumer、以及一个 Zookeeper 集群（在2.8.0版本中移，除了 Zookeeper,通过 KRaft 进行自己的集群管理）\",\"Producer 将消息发送到 Broker，Broker 负责将受到的消息存储到磁盘中，而 Consumer 负责从 Broker 订阅并消费消息。\",\"Kafka 基本概念：\",\"Producer ：生产者，负责将消息发送到 Broker\",\"Consumer ：消费者，从 Broker 接收消息\",\"Consumer Group ：消费者组，由多个 Consumer 组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费，消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。\",\"Broker ：可以看做一个独立的 Kafka 服务节点或 Kafka 服务实例。如果一台服务器上只部署了一个 Kafka 实例，那么我们也可以将 Broker 看做一台 Kafka 服务器。\",\"Topic ：一个逻辑上的概念，包含很多 Partition，同一个 Topic 下的 Partiton 的消息内容是不相同的。\",\"Partition ：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker 上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。\",\"Replica ：副本，同一分区的不同副本保存的是相同的消息，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，- kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。\",\"Leader ：每个分区的多个副本中的\\\"主副本\\\"，生产者以及消费者只与 Leader 交互。\",\"Follower ：每个分区的多个副本中的\\\"从副本\\\"，负责实时从 Leader 中同步数据，保持和 Leader 数据的同步。Leader 发生故障时，从 Follower 副本中重新选举新的 Leader 副本对外提供服务。\"]},\"1348\":{\"h\":\"3. Kafka Replicas是怎么管理的？\",\"t\":[\"AR:分区中的所有 Replica 统称为 AR\",\"ISR:所有与 Leader 副本保持一定程度同步的Replica(包括 Leader 副本在内)组成 ISR\",\"OSR:与 Leader 副本同步滞后过多的 Replica 组成了 OSR\",\"Leader 负责维护和跟踪 ISR 集合中所有 Follower 副本的滞后状态，当 Follower 副本落后过多时，就会将其放入 OSR 集合，当 Follower 副本追上了 Leader 的进度时，就会将其放入 ISR 集合。\",\"默认情况下，只有 ISR 中的副本才有资格晋升为 Leader。\"]},\"1349\":{\"h\":\"4. 如何确定当前能读到哪一条消息？\",\"t\":[\"这个问题要先了解上一个问题的概念\",\"分区相当于一个日志文件，我们先简单介绍几个概念\",\"如上图是一个分区日志文件\",\"标识共有7条消息，offset (消息偏移量)分别是0~6\",\"0 代表这个日志文件的开始\",\"HW(High Watermark) 为4，0~3 代表这个日志文件可以消费的区间，消费者只能消费到这四条消息\",\"LEO 代表即将要写入消息的偏移量 offset\",\"分区 ISR 集合中的每个副本都会维护自己的 LEO，而 ISR 集合中最小的LEO 即为分区的 HW\",\"如上图: 三个分区副本都是 ISR集合当中的，最小的 LEO 为 3，就代表分区的 HW 为3，所以当前分区只能消费到 0~2 之间的三条数据，如下图\"]},\"1350\":{\"h\":\"5. 发送消息的分区策略有哪些？\",\"t\":[\"1.轮询：依次将消息发送该topic下的所有分区，如果在创建消息的时候 key 为 null，Kafka 默认采用这种策略。\",\"2.key 指定分区：在创建消息是 key 不为空，并且使用默认分区器，Kafka 会将 key 进行 hash，然后根据hash值映射到指定的分区上。这样的好处是 key 相同的消息会在一个分区下，Kafka 并不能保证全局有序，但是在每个分区下的消息是有序的，按照顺序存储，按照顺序消费。在保证同一个 key 的消息是有序的，这样基本能满足消息的顺序性的需求。但是如果 partation 数量发生变化，那就很难保证 key 与分区之间的映射关系了。\",\"3.自定义策略：实现 Partitioner 接口就能自定义分区策略。\",\"4.指定 Partiton 发送\"]},\"1351\":{\"h\":\"6. Kafka 的可靠性是怎么保证的？\",\"t\":[\"1.acks\",\"这个参数用来指定分区中有多少个副本收到这条消息，生产者才认为这条消息是写入成功的，这个参数有三个值：\",\"1.acks = 1，默认为1。生产者发送消息，只要 leader 副本成功写入消息，就代表成功。这种方案的问题在于，当返回成功后，如果 leader 副本和 follower 副本还没有来得及同步，leader 就崩溃了，那么在选举后新的 leader 就没有这条消息，也就丢失了。\",\"2.acks = 0。生产者发送消息后直接算写入成功，不需要等待响应。这个方案的问题很明显，只要服务端写消息时出现任何问题，都会导致消息丢失。\",\"3.acks = -1 或 acks = all。生产者发送消息后，需要等待 ISR 中的所有副本都成功写入消息后才能收到服务端的响应。毫无疑问这种方案的可靠性是最高的，但是如果 ISR 中只有leader 副本，那么就和 acks = 1 毫无差别了。\",\"2.消息发送的方式\",\"第6问中我们提到了生产者发送消息有三种方式，发完即忘，同步和异步。我们可以通过同步或者异步获取响应结果，失败做重试来保证消息的可靠性。\",\"3.手动提交位移\",\"默认情况下，当消费者消费到消息后，就会自动提交位移。但是如果消费者消费出错，没有进入真正的业务处理，那么就可能会导致这条消息消费失败，从而丢失。我们可以开启手动提交位移，等待业务正常处理完成后，再提交offset。\",\"4.通过副本 LEO 来确定分区 HW\",\"可参考第四问\"]},\"1352\":{\"h\":\"7. 分区再分配是做什么的？解决了什么问题？\",\"t\":[\"分区再分配主要是用来维护 kafka 集群的负载均衡\",\"既然是分区再分配，那么 kafka 分区有什么问题呢？\",\"问题1：当集群中的一个节点下线了\",\"如果该节点的分区是单副本的,那么分区将会变得不可用\",\"如果是多副本的，就会进行 leader 选举，在其他机器上选举出新的 leader\",\"kafka 并不会将这些失效的分区迁移到其他可用的 broker 上，这样就会影响集群的负载均衡，甚至也会影响服务的可靠性和可用性\",\"问题2：集群新增 broker 时，只有新的主题分区会分配在该 broker 上，而老的主题分区不会分配在该 broker 上，就造成了老节点和新节点之间的负载不均衡。\",\"为了解决该问题就出现了分区再分配，它可以在集群扩容，broker 失效的场景下进行分区迁移。\",\"分区再分配的原理就是通化控制器给分区新增新的副本，然后通过网络把旧的副本数据复制到新的副本上，在复制完成后，将旧副本清除。 当然，为了不影响集群正常的性能，在此复制期间还会有一系列保证性能的操作，比如复制限流。\"]},\"1353\":{\"h\":\"8. Kafka Partition 副本 leader 是怎么选举的？\",\"t\":[\"这个问题设计的点比较多，拓展的也更多一点，建议耐心阅读。\",\"常用选主机制的缺点：\",\"split-brain (脑裂): ​这是由ZooKeeper的特性引起的，虽然ZooKeeper能保证所有Watch按顺序触发，但是网络延迟，并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致，可能选出多个领导“大脑”，导致“脑裂”。 herd effect (羊群效应): ​如果宕机的那个Broker上的Partition比较多， 会造成多个Watch被触发，造成集群内大量的调整，导致大量网络阻塞。 ZooKeeper负载过重: ​每个Replica都要为此在ZooKeeper上注册一个Watch，当集群规模增加到几千个Partition时ZooKeeper负载会过重。\",\"优势：\",\"Kafka的Leader Election方案解决了上述问题，它在所有broker中选出一个controller，所有Partition的Leader选举都由controller决定。 controller会将Leader的改变直接通过RPC的方式(比ZooKeeper Queue的方式更高效)通知需为此作为响应的Broker。\",\"没有使用 zk，所以无 2.3 问题；也没有注册 watch无 2.2 问题 leader 失败了，就通过 controller 继续重新选举即可，所以克服所有问题。\",\"Kafka partition leader的选举：\",\"由 controller 执行：\",\"从Zookeeper中读取当前分区的所有ISR(in-sync replicas)集合\",\"调用配置的分区选择算法选择分区的leader\",\"分区选择算法\",\"上面五种分区算法都是选择PreferredReplica(优先副本选举)作为当前Partition的leader。区别仅仅是选择leader之后的操作有所不同。\"]},\"1354\":{\"h\":\"9. 分区数越多越好吗？吞吐量就会越高吗？\",\"t\":[\"般类似于这种问题的答案，都是持否定态度的。\",\"但是可以说，在一定条件下，分区数的数量是和吞吐量成正比的，分区数和性能也是成正比的。\",\"那么为什么说超过了一定限度，就会对性能造成影响呢？原因如下:\",\"1.客户端/服务器端需要使用的内存就越多\",\"服务端在很多组件中都维护了分区级别的缓存，分区数越大，缓存成本也就越大。 消费端的消费线程数是和分区数挂钩的，分区数越大消费线程数也就越多，线程的开销成本也就越大 生产者发送消息有缓存的概念，会为每个分区缓存消息，当积累到一定程度或者时间时会将消息发送到分区，分区越多，这部分的缓存也就越大\",\"2.文件句柄的开销\",\"每个 partition 都会对应磁盘文件系统的一个目录。在 Kafka 的数据日志文件目录中，每个日志数据段都会分配两个文件，一个索引文件和一个数据文件。每个 broker 会为每个日志段文件打开一个 index 文件句柄和一个数据文件句柄。因此，随着 partition 的增多，所需要保持打开状态的文件句柄数也就越多，最终可能超过底层操作系统配置的文件句柄数量限制。\",\"3.越多的分区可能增加端对端的延迟\",\"Kafka 会将分区 HW 之前的消息暴露给消费者。分区越多则副本之间的同步数量就越多，在默认情况下，每个 broker 从其他 broker 节点进行数据副本复制时，该 broker 节点只会为此工作分配一个线程，该线程需要完成该 broker 所有 partition 数据的复制。\",\"4.降低高可用性\",\"在第 7 问我们提到了分区再分配，会将数据复制到另一份副本当中，分区数量越多，那么恢复时间也就越长，而如果发生宕机的 broker 恰好是 controller 节点时：在这种情况下，新 leader 节点的选举过程在 controller 节点恢复到新的 broker 之前不会启动。controller 节点的错误恢复将会自动地进行，但是新的 controller 节点需要从 zookeeper 中读取每一个 partition 的元数据信息用于初始化数据。例如，假设一个Kafka 集群存在 10000个partition，从 zookeeper 中恢复元数据时每个 partition 大约花费 2 ms，则 controller 的恢复将会增加约 20 秒的不可用时间窗口。\"]},\"1355\":{\"h\":\"10. kafka 为什么这么快？\",\"t\":[\"1.顺序读写磁盘分为顺序读写与随机读写，基于磁盘的随机读写确实很慢，但磁盘的顺序读写性能却很高，kafka 这里采用的就是顺序读写。\",\"2.Page Cache为了优化读写性能，Kafka 利用了操作系统本身的 Page Cache，就是利用操作系统自身的内存而不是JVM空间内存。\",\"3.零拷贝Kafka使用了零拷贝技术，也就是直接将数据从内核空间的读缓冲区直接拷贝到内核空间的 socket 缓冲区，然后再写入到 NIC 缓冲区，避免了在内核空间和用户空间之间穿梭。\",\"4.分区分段+索引Kafka 的 message 是按 topic分 类存储的，topic 中的数据又是按照一个一个的 partition 即分区存储到不同 broker 节点。每个 partition 对应了操作系统上的一个文件夹，partition 实际上又是按照segment分段存储的。通过这种分区分段的设计，Kafka 的 message 消息实际上是分布式存储在一个一个小的 segment 中的，每次文件操作也是直接操作的 segment。为了进一步的查询优化，Kafka 又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。\",\"5.批量读写Kafka 数据读写也是批量的而不是单条的,这样可以避免在网络上频繁传输单个消息带来的延迟和带宽开销。假设网络带宽为10MB/S，一次性传输10MB的消息比传输1KB的消息10000万次显然要快得多。\",\"6.批量压缩Kafka 把所有的消息都变成一个批量的文件，并且进行合理的批量压缩，减少网络 IO 损耗，通过 mmap 提高 I/O 速度，写入数据的时候由于单个Partion是末尾添加所以速度最优；读取数据的时候配合 sendfile 进行直接读取。\",\"低谷蓄力\"]},\"1356\":{\"h\":\"MyBatis\"},\"1357\":{\"h\":\"1. 什么是MyBatis\",\"t\":[\"这个问题主要是对比JDBC来看\",\"MyBatis是一个ORM（对象关系映射）框架，它内部封装了JDBC,开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动，创建连接，创建statement等复杂的过程。开发人员不需要编写原生态sql，可以严格控制sql执行性能，灵活度高。\",\"MyBatis可以使用xml或者注解来配置映射原生信息，将POJO映射成数据库中的记录，避免了几乎所有的JDBC代码和手动设置的参数以及获取结果集。\"]},\"1358\":{\"h\":\"2. MyBatis的优点\",\"t\":[\"基于SQL语句编程，相对灵活（相对于hibernate），支持写动态sql语句并可重复使用。\",\"减少代码量，消除了冗余代码。（类似于JDBC的封装）\",\"与Spring完美集成。\",\"提供映射标签支持字段关系映射。\"]},\"1359\":{\"h\":\"3. #{}和${}的区别是什么？\",\"t\":[\"#{}预编译处理、是占位符，${}是字符串替换、是拼接符。\",\"使用#{}可以有效的防止sql注入，提高系统的安全性。\",\"Mybatis在处理 #{} 的时候会将sql中的 #{} 替换成？号，调用PreparedStatement来赋值\",\"/* SQL */ 如：select * from user where name = #{userName}；设userName=javapub 看日志我们可以看到解析时将#{userName}替换成了 ？ select * from user where name = ?; 然后再把 javapub 放进去，外面加上单引号\",\"Mybatis在处理 ${} 的时候就是把 ${} 替换成变量的值，调用Statement来赋值\",\"/* SQL */ 如：select * from user where name = #{userName}；设userName=javapub 看日志可以发现就是直接把值拼接上去了 select * from user where name = javapub; 这极有可能发生sql注入，下面举了一个简单的sql注入案例\"]},\"1360\":{\"h\":\"4. 一个 Xml 映射文件，都会写一个 Dao 接口与之对应，这个 Dao 接口的工作原理是什么?\",\"t\":[\"Dao 接口就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名就是映射文件中 MappedStatement 的 id 值，接口方法内的参数就是传递给 sql 的参数。\",\"接口里的方法是不能重载的，因为是全限名+方法名的保存和寻找策略。\",\"Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行接口方法所对应的MappedStatement所代表的sql，然后将sql执行结果返回。\",\"MappedStatement：MappedStatement维护了一条 <select|update|delete|insert>节点的封装,包括了传入参数映射配置、执行的SQL语句、结果映射配置等信息。\",\"<select id=\\\"selectAuthorLinkedHashMap\\\" resultType=\\\"java.util.LinkedHashMap\\\"> select id, username from author where id = #{value} </select>\"]},\"1361\":{\"h\":\"5. 如何获取自动生成的(主)键值?\",\"t\":[\"用法：\",\"在 <insert /> 标签中添加 useGeneratedKeys=\\\"true\\\" 等属性\",\"<insert id=\\\"insert\\\" useGeneratedKeys=\\\"true\\\" keyProperty=\\\"id\\\" keyColumn=\\\"id\\\" parameterType=\\\"person\\\" > INSERT INTO person(name, pswd) VALUE (#{name}, #{pswd}) </insert>\",\"当 Mybatis 解析 xml节点时，读到 insert 有配置时，会判断是否 有配置 useGeneratedKeys，如果有则会使用 Jdbc3KeyGenerator 作为sql回显，否则会以 NoKeyGenerator 作为主键回显。\",\"底层封装了JDBC获取自增主键，即当使用 prepareStatement 或者 Statement时候，可以通过 getGeneratedKeys 获取这条插入语句的自增而成的主键。例子\",\" Connection conn = DriverManager.getConnection(url, \\\"root\\\", \\\"123456\\\"); String[] columnNames = {\\\"id\\\", \\\"name\\\"}; PreparedStatement stmt = conn.prepareStatement(sql, columnNames); stmt.setString(1, \\\"jack wang\\\"); stmt.executeUpdate(); ResultSet rs = stmt.getGeneratedKeys(); int id = 0; if (rs.next()) { id = rs.getInt(1); System.out.println(\\\"----------\\\" + id); }\"]},\"1362\":{\"h\":\"6. Mybatis 动态 sql 有什么用？有哪些动态 sql？执行原理？\",\"t\":[\"Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。\",\"Mybatis 提供了9种动态sql标签： trim | where | set | foreach | if | choose | when | otherwise | bind。\",\"其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。\",\"是不是有点懵，继续阅读：\",\"科普：\",\"OGNL 是 Object-Graph Navigation Language 的缩写，对象图导航语言。例如 #{} 语法。\",\"OGNL 作用是在对象和视图之间做数据的交互，可以存取对象的属性和调用对象的方法，通过表达式可以迭代出整个对象的结构图。\",\"参考一个很形象的例子。\",\"有一个学生对象 student，属性分别有 id = 10，name = '小明' 和 课程对象 course，其中 course 对象中属性有：分数 score = 88，排名 rank = 5。\",\"对象关系图如下：\",\"student id：10 name：小明 course： score：88 rank：5\",\"当上下文（环境）中的对象为 student 的时候，也就是在 Mybatis 中查询时传入的参数对象为 student 的时候：\",\"通过 OGNL 表达式直接获取上下文中对象的属性值，比如：\",\"#{id} —> 10，相对于当前上下文对象.getId()，即 student.getId() 。\",\"#{name} —> 小明。\",\"#{course.score} —> 88，相当于 student.getCourse().getScore()。\",\"所以，通过 OGNL 表达式，可以迭代出整个对象的结构图。\",\"发布 《最少必要面试题》\"]},\"1363\":{\"h\":\"7. 什么是Mybatis的一级、二级缓存?\",\"t\":[\"一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。\",\"当Mybaits与Spring整合的时候，不带Spring事务的方法内，每次请求数据库，都会新建一个SqlSession，这时候是使用不到一级缓存的。除了事务问题，还有调用了Sqlsession的修改、添加、删除、commit()、close()等方法时，一级缓存也会被清空。\",\"二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)。即使开启了二级缓存，不同的sqlsession之间的缓存数据也不是想互访就能互访的，必须等到sqlsession关闭了以后，才会把其一级缓存中的数据写入二级缓存。默认不打开二级缓存。\",\"现在大多数应用都是支持分布式的，一般情况都是用中间件作为缓存层，比如redis。开启 MyBatis 的二级缓存也会多一步序列化和反序列化，影响服务性能。\"]},\"1364\":{\"h\":\"8. MyBatis的工作原理\",\"t\":[\"一图胜千文\",\"来源网络\",\"读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。\",\"加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。\",\"构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。\",\"创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。\",\"Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。\",\"MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。\",\"输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。\",\"输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。\"]},\"1365\":{\"h\":\"9. 什么是MyBatis的接口绑定？有哪些实现方式？\",\"t\":[\"接口绑定，就是在 MyBatis 中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来的SqlSession提供的方法我们可以有更加灵活的选择和设置。\",\"接口绑定有两种实现方式：\",\"通过注解绑定，就是在接口的方法上面加上 @Select、@Update 等注解，里面包含Sql语句来绑定；\",\"通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的 namespace 必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。\"]},\"1366\":{\"h\":\"10. Mybatis的分页原理\",\"t\":[\"Mybatis 使用 RowBounds 对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，所以一般不会使用。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。\",\"分页插件的原理就是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内，拦截待执行的SQL，然后根据设置的 dialect（方言），和设置的分页参数，重写SQL ，生成带有分页语句的SQL，执行重写后的SQL，从而实现分页。\",\"举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10。\"]},\"1367\":{\"h\":\"MySQL\",\"t\":[\"推荐一篇非常不错的文章，阅读后更有利于了解MySQL【B树和B+树的区别】： https://mp.weixin.qq.com/s/RWkc2lNarKnn8Dc0HrP58g\"]},\"1368\":{\"h\":\"1. mysql有哪几种log\",\"t\":[\"重做日志(redo log)、回滚日志(undo log)、二进制日志(binlog)、错误日志(errorlog)、慢查询日志(slow query log)、一般查询日志(general log)，中继日志(relay log)\",\"错误日志：记录出错信息，也记录一些警告信息或者正确的信息。\",\"查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。\",\"慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。\",\"二进制日志：记录对数据库执行更改的所有操作。\",\"中继日志：中继日志也是二进制日志，用来给slave 库恢复\",\"事务日志：重做日志redo和回滚日志undo\"]},\"1369\":{\"h\":\"2. MySQL的复制原理以及流程\",\"t\":[\"主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中。\",\"从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中。\",\"从：sql执行线程——执行relay log中的语句。\"]},\"1370\":{\"h\":\"3. 事物的4种隔离级别\",\"t\":[\"隔离强度逐渐增强，性能逐渐变差。\",\"读未提交(RU) READ UNCOMMITTED\",\"读已提交(RC) READ COMMITT\",\"可重复读(RR) REPEATABLE READ\",\"串行化 SERIALIZABLE\",\"事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）四个特性，简称 ACID，缺一不可。\"]},\"1371\":{\"h\":\"4. 相关概念\",\"t\":[\"脏读\",\"脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。\",\"可重复读\",\"可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据更新（UPDATE）操作。\",\"不可重复读\",\"对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。\",\"幻读\",\"幻读是针对数据插入（INSERT）操作来说的。假设事务 A 对某些行的内容作了更改，但是还未提交，此时事务 B 插入了与事务 A 更改前的记录相同的记录行，并且在事务 A 提交之前先提交了，而这时，在事务 A 中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务 B 刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。\"]},\"1372\":{\"h\":\"5. MySQL数据库几个基本的索引类型\",\"t\":[\"普通索引、唯一索引、主键索引、全文索引\"]},\"1373\":{\"h\":\"6. drop、delete与truncate的区\",\"t\":[\"SQL中的drop、delete、truncate都表示删除，但是三者有一些差别\",\"1、delete和truncate只删除表的数据不删除表的结构 2、速度,一般来说: drop> truncate >delete 3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效; 4、如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.\"]},\"1374\":{\"h\":\"7. 数据库的乐观锁和悲观锁是什么？\",\"t\":[\"悲观锁的特点是先获取锁，再进行业务操作，即 “悲观” 的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的 “一锁二查三更新” 即指的是使用悲观锁。\",\"通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的 select … for update 操作来实现悲观锁。 当数据库执行 select for update 时会获取被 select 中的数据行的行锁，因此其他并发执行的 select for update 如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update 获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。\",\"mysql 还有个问题是 select… for update 语句执行中，如果数据表没有添加索引或主键，所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在 mysql 中用悲观锁务必要确定走了索引，而不是全表扫描。\",\"乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。\",\"乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳。\",\"乐观锁的两种实现方式：\",\"使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 version 值进行比对，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。\",\"乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）,和上面的 version 类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则 OK，否则就是版本冲突。\"]},\"1375\":{\"h\":\"8. SQL优化方式\",\"t\":[\"对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。\",\"应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如果索引是整形，那么可以在索引上设置默认值 0，确保表中列没有 null 值。\",\"应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。\",\"应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。\",\"in 和 not in 也要慎用，否则会导致全表扫描。\",\"like ‘%abc%’ 也会导致全表扫描。\",\"应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。\",\"应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。\",\"在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。\",\"很多时候用 exists 代替 in 是一个好的选择。\"]},\"1376\":{\"h\":\"9. 从锁的类别上分MySQL都有哪些锁呢？\",\"t\":[\"从锁的类别上来讲，有共享锁和排他锁。\",\"共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。\",\"排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。\",\"参考：\",\"1. https://haicoder.net/note/mysql-interview/mysql-interview-optimistic-pessimism-lock.html\"]},\"1377\":{\"h\":\"Redis\"},\"1378\":{\"h\":\"1. Redis是什么？\",\"t\":[\"一般问这个问题你最少要答出以下几点\",\"Redis 是一个基于内存的 key-value 存储系统，数据结构包括字符串、list、set、zset（sorted set --有序集合）和hash，bitmap，GeoHash(坐标)，HyperLogLog，Streams（5.x版本以后）\"]},\"1379\":{\"h\":\"2. 你在哪些场景使用redis\",\"t\":[\"你有实战经验，那就直接表演。如果没有，选几个下面的经典场景\",\"作为队列使用，（因为是基于内存、一般不会作为消费队列、作为循环队列必要适用）；\",\"模拟类似于token这种需要设置过期时间的场景，登录失效；\",\"分布式缓存，避免大量请求底层关系型数据库，大大降低数据库压力；\",\"分布式锁；\",\"基于 bitmap 实现布隆过滤器；\",\"排行榜-基于zset（有序集合数据类型）；\",\"计数器-对于浏览量、播放量等并发较高，使用 redis incr 实现计数器功能；\",\"分布式会话；\",\"消息系统；\"]},\"1380\":{\"h\":\"3. 为什么Redis是单线程的?\",\"t\":[\"这个问题给一个官方答案\",\"因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。\"]},\"1381\":{\"h\":\"4. Redis持久化有几种方式？\",\"t\":[\"redis 提供了两种持久化的方式，分别是快照方式（RDB Redis DataBase）和文件追加（AOF Append Only File）。\",\"显而易见，快照方式重启恢复快、但是数据更容易丢失，文件追加数据更完整、重启恢复慢。\",\"混合持久化方式，Redis 4.0之后新增的方式，混合持久化是结合RDB和AOF的优点，在写入的时候先把当前的数据以RDB的形式写入到文件的开头，再将后续的操作以AOF的格式存入文件当中，这样既能保证重启时的速度，又能降低数据丢失的风险。\",\"在恢复时，先恢复快照方式保存的文件，然后再恢复追加文件中的增量数据。\"]},\"1382\":{\"h\":\"5. 什么是缓存穿透？怎么解决？\",\"t\":[\"缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍，然后返回空。\",\"如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至击垮数据库系统。\",\"这就叫做缓存穿透。\",\"怎么解决？\",\"对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert之后清理缓存。\",\"对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该Bitmap过滤。(也就是布隆过滤器的原理：大白话讲解布隆过滤器)\"]},\"1383\":{\"h\":\"6. 什么是缓存雪崩?\",\"t\":[\"缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，请求直接落到数据库上，引起数据库压力过大甚至宕机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。\",\"怎么解决？\",\"常用的解决方案有：\",\"均匀过期\",\"加互斥锁\",\"缓存永不过期\",\"双层缓存策略\",\"均匀过期：设置不同的过期时间，让缓存失效的时间点尽量均匀。通常可以为有效期增加随机值或者统一规划有效期。\",\"加互斥锁：跟缓存击穿解决思路一致，同一时间只让一个线程构建缓存，其他线程阻塞排队。\",\"缓存永不过期：跟缓存击穿解决思路一致，缓存在物理上永远不过期，用一个异步的线程更新缓存。\",\"双层缓存策略：使用主备两层缓存：\",\"主缓存：有效期按照经验值设置，设置为主读取的缓存，主缓存失效后从数据库加载最新值。\",\"备份缓存：有效期长，获取锁失败时读取的缓存，主缓存更新时需要同步更新备份缓存。\"]},\"1384\":{\"h\":\"7. Redis使用上如何做内存优化？\",\"t\":[\"缩短键值的长度\",\"缩短值的长度才是关键，如果值是一个大的业务对象，可以将对象序列化成二进制数组；\",\"首先应该在业务上进行精简，去掉不必要的属性，避免存储一些没用的数据；\",\"其次是序列化的工具选择上，应该选择更高效的序列化工具来降低字节数组大小；\",\"以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: protostuff，kryo等\",\"共享对象池\",\"对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。\",\"字符串优化\",\"因为redis的惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留。尽量做新增不做更新。\",\"编码优化\",\"所谓编码就是具体使用哪种底层数据结构来实现。编码不同将直接影响数据的内存占用和读写效率。\",\"这个需要掌握redis底层的数据结构。下图作为参考：\",\"image\",\"控制key的数量\"]},\"1385\":{\"h\":\"8. 你们redis使用哪种部署方式？\",\"t\":[\"redis部署分为单节点、主从部署（master-slave）、哨兵部署（Sentinel）、集群部署（cluster）。\",\"单节点：也就是单机部署；\",\"主从部署：分为一主一从或一主多从，主从之间同步分为全量或增量。量同步：master 节点通过 BGSAVE 生成对应的RDB文件，然后发送给slave节点，slave节点接收到写入命令后将master发送过来的文件加载并写入；增量同步：即在 master-slave 关系建立开始，master每执行一次数据变更的命令就会同步至slave节点。一般会将写请求转发到master，读请求转发到slave。提高了redis的性能。\",\"哨兵部署：分别有哨兵集群与Redis的主从集群，哨兵作为操作系统中的一个监控进程，对应监控每一个Redis实例，如果master服务异常（ping pong其中节点没有回复且超过了一定时间），就会多个哨兵之间进行确认，如果超过一半确认服务异常，则对master服务进行下线处理，并且选举出当前一个slave节点来转换成master节点；如果slave节点服务异常，也是经过多个哨兵确认后，进行下线处理。提高了redis集群高可用的特性，及横向扩展能力的增强。\",\"image\",\"集群部署：属于**“去中心化”**的一种方式，多个 master 节点保存整个集群中的全部数据，而数据根据 key 进行 crc-16 校验算法进行散列，将 key 散列成对应 16383 个 slot，而 Redis cluster 集群中每个 master 节点负责不同的slot范围。每个 master 节点下还可以配置多个 slave 节点，同时也可以在集群中再使用 sentinel 哨兵提升整个集群的高可用性。\",\"image\"]},\"1386\":{\"h\":\"9. redis实现分布式锁要注意什么？\",\"t\":[\"加锁过程要保证原子性；\",\"保证谁加的锁只能被谁解锁，即Redis加锁的value，解锁时需要传入相同的value才能成功，保证value唯一性；\",\"设置锁超时时间，防止加锁方异常无法释放锁时其他客户端无法获取锁，同时，超时时间要大于业务处理时间；\",\"使用Redis命令 SET lock_key unique_value NX EX seconds 进行加锁，单命令操作，Redis是串行执行命令，所以能保证只有一个能加锁成功。\"]},\"1387\":{\"h\":\"Spring\"},\"1388\":{\"h\":\"1. 什么是 Spring 框架？Spring 框架有哪些主要模块？\",\"t\":[\"Spring是针对bean的生命周期进行管理的轻量级容器，一个控制反转和面向切面的容器框架\",\"Spring有七大功能模块：\",\"1、Core\",\"Core模块是Spring的核心类库，Core实现了IOC功能。\",\"2、AOP\",\"Apring AOP模块是Spring的AOP库，提供了AOP（拦截器）机制，并提供常见的拦截器，供用户自定义和配置。\",\"3、orm\",\"提供对常用ORM框架的管理和支持，hibernate、mybatis等。\",\"4、Dao\",\"Spring提供对JDBC的支持，对JDBC进行封装。\",\"5、Web\",\"对Struts2的支持。\",\"6、Context\",\"Context模块提供框架式的Bean的访问方式，其它程序可以通过Context访问Spring的Bean资源，相当于资源注入。\",\"7、MVC\",\"MVC模块为spring提供了一套轻量级的MVC实现，即Spring MVC。\"]},\"1389\":{\"h\":\"2. Spring IOC、AOP举例说明\",\"t\":[\"这是一个基础问题，如果理解有难度、建议先读五遍。\",\"1、IOC理论的背景\",\"我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。\",\"图1：软件系统中耦合的对象\",\"如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒 针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项 任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。 齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着 工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临 更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。\",\"图2：对象之间复杂的依赖关系\",\"耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品Spring。\",\"2、什么是控制反转(IoC)\",\"IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。 1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以 后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依 赖关系的对象之间的解耦，如下图：\",\"图3：IOC解耦过程\",\"大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三 方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有 对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。 我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：\",\"图4：拿掉IoC容器后的系统\",\"我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样 的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言， 这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！ 我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下： 软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。 软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。 通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。\",\"参考资料：https://www.cnblogs.com/jianmang/articles/4947615.html\"]},\"1390\":{\"h\":\"3. 什么是控制反转(IOC)？什么是依赖注入（DI）？\",\"t\":[\"IoC(Inversion of Control) – 控制反转。它不是一种技术，而是一种思想。\",\"IOC：就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。BeanFactory接口是Spring Ioc容器的核心接口。\",\"DI：我们在使用Spring容器的时候，容器通过调用set方法或者是构造器来建立对象之间的依赖关系。 控制反转是目标，依赖注入是我们实现控制反转的一种手段。\"]},\"1391\":{\"h\":\"4. 描述一下 Spring Bean 的生命周期？\",\"t\":[\"这道题是spring一道标准题目\",\"按照阶段理解Spring中的bean的生命周期主要包含四个阶段：实例化Bean --＞ Bean属性填充 --＞ 初始化Bean --＞销毁Bean\",\"Spring Bean 的生命周期\",\"Spring中的bean的生命周期主要包含四个阶段：实例化Bean --＞ Bean属性填充 --＞ 初始化Bean --＞销毁Bean\",\"首先是实例化Bean，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚末初始化的依赖时，容器就会调用doCreateBean()方法进行实例化，实际上就是通过反射的方式创建出一个bean对象\",\"Bean实例创建出来后，接着就是给这个Bean对象进行属性填充，也就是注入这个Bean依赖的其它bean对象\",\"属性填充完成后，进行初始化Bean操作，初始化阶段又可以分为几个步骤：\",\"a. 执行Aware接口的方法\",\"Spring会检测该对象是否实现了xxxAware接口，通过Aware类型的接口，可以让我们拿到Spring容器的些资源。如实现BeanNameAware接口可以获取到BeanName，实现BeanFactoryAware接口可以获取到工厂对象BeanFactory等\",\"b. 执行BeanPostProcessor的前置处理方法postProcessBeforelnitialization()，对Bean进行一些自定义的前置处理\",\"c. 判断Bean是否实现了InitializingBean接口，如果实现了，将会执行lnitializingBean的afeterPropertiesSet()初始化方法；\",\"d. 执行用户自定义的初始化方法，如init-method等；\",\"e. 执行BeanPostProcessor的后置处理方法postProcessAfterinitialization()\",\"初始化完成后，Bean就成功创建了，之后就可以使用这个Bean， 当Bean不再需要时，会进行销毁操作，\",\"a. 首先判断Bean是否实现了DestructionAwareBeanPostProcessor接口，如果实现了，则会执行DestructionAwareBeanPostProcessor后置处理器的销毁回调方法 b. 其次会判断Bean是否实现了DisposableBean接口，如果实现了将会调用其实现的destroy()方法 c. 最后判断这个Bean是否配置了dlestroy-method等自定义的销毁方法，如果有的话，则会自动调用其配置的销毁方法；\"]},\"1392\":{\"h\":\"5. Spring Bean 的作用域之间有什么区别？\",\"t\":[\"Spring器中的bean可以分为5个范围：\",\"singleton：这种bean范围是默认的，这种范围确保不管接受多少请求，每个容器中只有一个bean的实例，单例模式；\",\"prototype：为每一个bean提供一个实例；\",\"request：在请求bean范围内为每一个来自客户端的网络请求创建一个实例，在请求完毕后，bean会失效并被垃圾回收器回收；\",\"session：为每个session创建一个实例，session过期后，bean会随之消失；\",\"global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet公用全局的存储变量的话，那么全局变量需要存储在global-session中。\"]},\"1393\":{\"h\":\"6. Spring中都应用了哪些设计模式\",\"t\":[\"1、简单工厂模式\",\"简单工厂模式的本质就是一个工厂类根据传入的参数，动态的决定实例化哪个类。\",\"Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象。\",\"2、工厂方法模式\",\"应用程序将对象的创建及初始化职责交给工厂对象，工厂Bean。\",\"定义工厂方法，然后通过config.xml配置文件，将其纳入Spring容器来管理，需要通过factory-method指定静态方法名称。\",\"3、单例模式\",\"Spring用的是双重判断加锁的单例模式，通过getSingleton方法从singletonObjects中获取bean。\",\" /** * Return the (raw) singleton object registered under the given name. * <p>Checks already instantiated singletons and also allows for an early * reference to a currently created singleton (resolving a circular reference). * @param beanName the name of the bean to look for * @param allowEarlyReference whether early references should be created or not * @return the registered singleton object, or {@code null} if none found */ protected Object getSingleton(String beanName, boolean allowEarlyReference) { Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) { synchronized (this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null && allowEarlyReference) { ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } return (singletonObject != NULL_OBJECT ? singletonObject : null); }\",\"4、代理模式\",\"Spring的AOP中，使用的Advice（通知）来增强被代理类的功能。Spring实现AOP功能的原理就是代理模式（① JDK动态代理，② CGLIB字节码生成技术代理。）对类进行方法级别的切面增强。\",\"5、装饰器模式\",\"装饰器模式：动态的给一个对象添加一些额外的功能。\",\"Spring的ApplicationContext中配置所有的DataSource。这些DataSource可能是不同的数据库，然后SessionFactory根据用户的每次请求，将DataSource设置成不同的数据源，以达到切换数据源的目的。\",\"在Spring中有两种表现：\",\"一种是类名中含有Wrapper，另一种是类名中含有Decorator。\",\"6、观察者模式\",\"定义对象间的一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。\",\"Spring中观察者模式一般用在listener的实现。\",\"7、策略模式\",\"策略模式是行为性模式，调用不同的方法，适应行为的变化 ，强调父类的调用子类的特性 。\",\"getHandler是HandlerMapping接口中的唯一方法，用于根据请求找到匹配的处理器。\",\"8、模板方法模式\",\"Spring JdbcTemplate的query方法总体结构是一个模板方法+回调函数，query方法中调用的execute()是一个模板方法，而预期的回调doInStatement(Statement state)方法也是一个模板方法。\"]},\"1394\":{\"h\":\"7. Spring AOP里面的几个名词的概念\",\"t\":[\"（1）连接点（Join point）：指程序运行过程中所执行的方法。在Spring AOP中，一个连接点总代表一个方法的执行。\",\"（2）切面（Aspect）：被抽取出来的公共模块，可以用来会横切多个对象。Aspect切面可以看成 Pointcut切点 和 Advice通知 的结合，一个切面可以由多个切点和通知组成。\",\"在Spring AOP中，切面可以在类上使用 @AspectJ 注解来实现。\",\"（3）切点（Pointcut）：切点用于定义 要对哪些Join point进行拦截。\",\"切点分为execution方式和annotation方式。execution方式可以用路径表达式指定对哪些方法拦截，比如指定拦截add*、search*。annotation方式可以指定被哪些注解修饰的代码进行拦截。\",\"（4）通知（Advice）：指要在连接点（Join Point）上执行的动作，即增强的逻辑，比如权限校验和、日志记录等。通知有各种类型，包括Around、Before、After、After returning、After throwing。\",\"（5）目标对象（Target）：包含连接点的对象，也称作被通知（Advice）的对象。 由于Spring AOP是通过动态代理实现的，所以这个对象永远是一个代理对象。\",\"（6）织入（Weaving）：通过动态代理，在目标对象（Target）的方法（即连接点Join point）中执行增强逻辑（Advice）的过程。\",\"（7）引入（Introduction）：添加额外的方法或者字段到被通知的类。Spring允许引入新的接口（以及对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。\",\"几个概念的关系图可以参考下图：\",\"网上有张非常形象的图，描述了各个概念所处的场景和作用，贴在这里供大家理解：\"]},\"1395\":{\"h\":\"8. BeanFactory和ApplicationContext有什么区别？\",\"t\":[\"BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。\",\"BeanFactory是Spring里面最底层的接口，是IoC的核心，定义了IoC的基本功能，包含了各种Bean的定义、加载、实例化，依赖注入和生命周期管理。ApplicationContext接口作为BeanFactory的子类，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：\",\"继承MessageSource，因此支持国际化。\",\"资源文件访问，如URL和文件（ResourceLoader）。\",\"载入多个（有继承关系）上下文（即同时加载多个配置文件） ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。\",\"提供在监听器中注册bean的事件。\",\"a. BeanFactroy采用的是延迟加载形式来注入Bean的，只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能提前发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。\",\"b. ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。\",\"c. ApplicationContext启动后预载入所有的单实例Bean，所以在运行的时候速度比较快，因为它们已经创建好了。相对于BeanFactory，ApplicationContext 唯一的不足是占用内存空间，当应用程序配置Bean较多时，程序启动较慢。\",\"BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。\",\"BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。\"]},\"1396\":{\"h\":\"9. Spring如何解决循环依赖问题：\",\"t\":[\"见：https://javapub.blog.csdn.net/\",\"循环依赖问题在Spring中主要有三种情况：\",\"（1）通过构造方法进行依赖注入时产生的循环依赖问题。\",\"（2）通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。\",\"（3）通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。\",\"在Spring中，只有第（3）种方式的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。这是因为：\",\"第一种构造方法注入的情况下，在new对象的时候就会堵塞住了，其实也就是”先有鸡还是先有蛋“的历史难题。\",\"第二种setter方法（多例）的情况下，每一次getBean()时，都会产生一个新的Bean，如此反复下去就会有无穷无尽的Bean产生了，最终就会导致OOM问题的出现。\",\"Spring在单例模式下的setter方法依赖注入引起的循环依赖问题，主要是通过二级缓存和三级缓存来解决的，其中三级缓存是主要功臣。解决的核心原理就是：在对象实例化之后，依赖注入之前，Spring提前暴露的Bean实例的引用在第三级缓存中进行存储。\",\"第一种构造方法注入的情况：\",\"例如：类A通过构造函数注入需要类B的实例，而类B通过构造函数注入需要类A的实例。如果将A类和B类的bean配置为相互注入，则Spring IoC容器会在运行时检测此循环引用，并抛出a BeanCurrentlyInCreationException。 一种可能的解决方案是编辑由setter而不是构造函数配置的某些类的源代码。或者，避免构造函数注入并仅使用setter注入。换句话说，尽管不推荐使用，但您可以使用setter注入配置循环依赖关系。 与典型情况（没有循环依赖）不同，bean A和bean B之间的循环依赖强制其中一个bean在完全初始化之前被注入另一个bean（经典的鸡与鸡蛋场景）。\",\" <bean id=\\\"person\\\" class=\\\"pojo.Person\\\"> <constructor-arg index=\\\"0\\\" value=\\\"小明\\\"/> <constructor-arg index=\\\"1\\\" value=\\\"12\\\"/> <constructor-arg index=\\\"2\\\" value=\\\"student\\\"/> </bean> <bean id=\\\"student\\\" class=\\\"pojo.Student\\\"> <constructor-arg index=\\\"0\\\" value=\\\"小王\\\"/> <constructor-arg index=\\\"1\\\" value=\\\"13\\\"/> <constructor-arg index=\\\"2\\\" value=\\\"person\\\"/> </bean>\"]},\"1397\":{\"h\":\"10. Spring事务的实现方式和实现原理：\",\"t\":[\"Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。Spring只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过 redo log 和 undo log实现的。Spring会在事务开始时，根据当前环境中设置的隔离级别，调整数据库隔离级别，由此保持一致。\",\"1. Spring事务的种类：\",\"spring支持编程式事务管理和声明式事务管理两种方式：\",\"a. 编程式事务管理使用 TransactionTemplate。\",\"b. 声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。\",\"声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。\",\"2. spring的事务传播机制：\",\"spring事务的传播机制说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。事务传播机制实际上是使用简单的ThreadLocal实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。\",\"① PROPAGATION_REQUIRED：（默认传播行为）如果当前没有事务，就创建一个新事务；如果当前存在事务，就加入该事务。\",\"② PROPAGATION_REQUIRES_NEW：无论当前存不存在事务，都创建新事务进行执行。\",\"③ PROPAGATION_SUPPORTS：如果当前存在事务，就加入该事务；如果当前不存在事务，就以非事务执行。‘\",\"④ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\",\"⑤ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则按REQUIRED属性执行。\",\"⑥ PROPAGATION_MANDATORY：如果当前存在事务，就加入该事务；如果当前不存在事务，就抛出异常。\",\"⑦ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\",\"事务不只限于脏读、幻读等名词。\",\"3. Spring中的隔离级别：\",\"① ISOLATION_DEFAULT：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。\",\"② ISOLATION_READ_UNCOMMITTED：读未提交，允许事务在执行过程中，读取其他事务未提交的数据。\",\"③ ISOLATION_READ_COMMITTED：读已提交，允许事务在执行过程中，读取其他事务已经提交的数据。\",\"④ ISOLATION_REPEATABLE_READ：可重复读，在同一个事务内，任意时刻的查询结果都是一致的。\",\"⑤ ISOLATION_SERIALIZABLE：所有事务逐个依次执行。\",\"低谷蓄力\"]},\"1398\":{\"h\":\"SpringBoot\"},\"1399\":{\"h\":\"1. 为什么要用 spring boot？\",\"t\":[\"通过自动配置方式简化 Spring 应用的开发，弱化配置，遵循 约定大于配置的原则 ，使开发者专注于业务开发而无需过多考虑配置相关操作，通过启动类的 main 方法一键启动应用。\"]},\"1400\":{\"h\":\"2. spring boot 有哪些优点？\",\"t\":[\"独立运行。 内嵌了 servlet，tomat 等，不需要打成 war 包部署到容器中，只需要将 SpringBoot 项目打成jar包就能独立运行。\",\"简化配置。 启动器自动依赖其他组件，简少了 maven 的配置。各种常用组件及配置已经默认配置完成，无需过多干预。\",\"避免大量的 Maven 导入和各种版本冲突。\",\"应用监控。 Spring Boot 提供一系列端点可以监控服务及应用。\"]},\"1401\":{\"h\":\"3. spring boot 核心配置文件是什么？\",\"t\":[\"springboot 核心的两个配置文件：\",\"bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的， 比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效，且 bootstrap 里面的属性不能被覆盖；一般来说我们在 SpringCloud Config 或者 Nacos 中会用到它。\",\"application (. yml 或者 . properties)：用于 springboot 项目的自动化配置\"]},\"1402\":{\"h\":\"4. spring boot的核心注解是什么？由那些注解组成？\",\"t\":[\"核心注解为：@SpringBootApplication\",\"该注解主要由三个注解组成：\",\"​ @SpringBootConfiguration():代表当前是一个配置类 ​ @EnableAutoConfiguration(): 启动自动配置 ​ @ComponentScan()：指定扫描哪些 Spring 注解\"]},\"1403\":{\"h\":\"5. 说一下springboot的自动装配原理\",\"t\":[\"SpringBoot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration。\",\"查看@EnableAutoConfiguration，其作用是利用AutoConfigurationImportSelector给容器中导入一些组件。\",\"查看AutoConfigurationImportSelector，其中public String[] selectImports(AnnotationMetadata annotationMetadata)方法内 最终调用getCandidateConfigurations()方法\",\"查看 getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes)，获取候选的配置，这个是扫描所有jar包类路径下\\\"META-INF/spring.factories\\\"\",\"然后把扫描到的这些文件包装成Properties对象。\",\"从properties中获取到EnableAutoConfiguration.class类名对应的值，然后把他们添加在容器中。\",\"简而言之，整个过程就是将类路径下 \\\"META-INF/spring.factories\\\" 里面配置的所有 EnableAutoConfiguration 的值加入到容器中。\"]},\"1404\":{\"h\":\"6. SpringBoot、Spring MVC和Spring有什么区别？\",\"t\":[\"Spring：主要用来创建IOC容器，依赖注入，实现程序间的松耦合\",\"SpringMVC: 主要是用来做WEB开发，通过各种组件的协调配合，简化Web应用的开发\",\"SpringBoot: SpringBoot更像是一个管家，当使用到对应功能时，只需要导入指定应用启动器，SpringBoot就能够在底层默认其配置，大大简化了开发所需的繁杂配置\"]},\"1405\":{\"h\":\"7. SpringBoot启动时都做了什么?\",\"t\":[\"Springboot 的启动，主要创建了配置环境 (environment)、事件监听 (listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的 Bean，至此，通过 SpringBoot 启动的程序已经构造完成。\"]},\"1406\":{\"h\":\"8. SpringBoot 中的监视器是什么？\",\"t\":[\"SpringBoot Actuator 是 SpringBoot 一项重要功能，其可以帮助我们查看应用的运行状态，对运行时指标进行检查和监控，监视器提供了一组可以直接作为 httpurl 访问的 rest 端点来访问查看指定功能状态。\"]},\"1407\":{\"h\":\"9. SpringBoot 中的starter到底是什么 ?\",\"t\":[\"首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。\",\"正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter\",\"拓展：如何自定义starter?\",\"创建项目，创建两个模块分别为 spring-boot-starter-*，spring-boot-starter-*-autoconfiguration\",\"spring-boot-starter-* pom 引入 spring-boot-starter-*-autoconfiguration\",\"spring-boot-starter-*-autoconfiguration 创建功能方法，创建 *properties类，创建一个配置类将功能方法类添加到 spring 容器，在 resouces 下创建 META-INF/spring.factories 配置 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration\",\"打包安装这两个模块到本地 maven 仓库，即可在其他项目引入 spring-boot-starter-* 注入功能类进行方法调用\"]},\"1408\":{\"h\":\"10. 微服务中如何实现 session 共享?\",\"t\":[\"在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。 这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。\"]},\"1409\":{\"h\":\"Zookeeper\"},\"1410\":{\"h\":\"1. 什么是 Zookeeper\",\"t\":[\"ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。\",\"Zookeeper 从设计模式角度来理解， 是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出反应。\",\"观察者模式是什么：设计模式\",\"可以这样理解：\",\"ZooKeeper=文件系统+通知机制\"]},\"1411\":{\"h\":\"2. ZK 的节点类型\",\"t\":[\"这道题相信大家都有所了解，zookeeper v3.6.2 版本后，支持7种节点类型。持久；持久顺序；临时；临时顺序；容器；持久 TTL；持久顺序 TTL。\",\"说出这几种类型当然已经回答了问题，但是细节的描述更能体现你的知识底蕴。\",\"持久 TTL、持久顺序 TTL\",\"关于持久和顺序这两个关键字，不用我再解释了，这两种类型的节点重点是后面的 TTL，TTL 是 time to live 的缩写，指带有存活时间，简单来说就是当该节点下面没有子节点的话，超过了 TTL 指定时间后就会被自动删除，但是 TTL 启用是需要额外的配置(这个之前也有提过)配置是 zookeeper.extendedTypesEnabled 需要配置成 true，否则的话创建 TTL 时会收到 Unimplemented 的报错。\"]},\"1412\":{\"h\":\"3. Zookeeper 下 Server 工作状态有哪些？\",\"t\":[\"服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。\",\"LOOKING：寻 找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入 Leader 选举状态。\",\"FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。\",\"LEADING：领导者状态。表明当前服务器角色是 Leader。\",\"OBSERVING：观察者状态。表明当前服务器角色是 Observer。（Observer角色除了不能投票(以及和投票相关的能力)和过半写成功策略外，其它和follower功能一样。observer角色减轻了投票的压力，在以前通过增、减follower的数量提高伸缩性。投票来说，follower是有状态的，都直接影响投票结果，特别是follower的数量越多，投票过程的性能就越差。）\"]},\"1413\":{\"h\":\"4. zookeeper是cp还是ap?\",\"t\":[\"zk遵循的是CP原则，即保证一致性和网络分区容错性，但不保证可用性。\",\"什么是cap?\",\"Consistency（一致性）：分布式系统中多个主机之间是否能够保持数据一致性的特性。即当系统数据发生更新操作之后，各个主机中的数据是否仍然处于一致的状态。\",\"Availability（可用性）：系统提供的服务必须一直处于可用的状态，即对于的每一个请求，系统总是可以在有限的时间内对用户做出响应。\",\"Partition tolerance（分区容错性）：分布式系统在遇到任何网络分区故障时候，仍然保证对外提供满足一致性和可用性的服务。\"]},\"1414\":{\"h\":\"5. 说几个 zookeeper 常用的命令。\",\"t\":[\"常用命令：ls get set create delete 等。\"]},\"1415\":{\"h\":\"6. 介绍一下ZAB协议？\",\"t\":[\"ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议。\",\"ZAB协议包括两种基本的模式：\",\"崩溃恢复\",\"消息广播\",\"当整个 zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。\"]},\"1416\":{\"h\":\"7. ZAB 和 Paxos 算法的联系与区别？\",\"t\":[\"相同点：\",\"两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行\",\"Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交\",\"ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 Leader 周期，Paxos 中名字为 Ballot\",\"不同点：\",\"ZAB(ZooKeeper Atomic Broadcast) 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建分布式一致性状态机系统。\",\"而 Paxos 算法与 ZAB 协议不同的是，Paxos 算法的发起者可以是一个或多个。当集群中的 Acceptor 服务器中的大多数可以执行会话请求后，提议者服务器只负责发送提交指令，事务的执行实际发生在 Acceptor 服务器。这与 ZooKeeper 服务器上事务的执行发生在 Leader 服务器上不同。Paxos 算法在数据同步阶段，是多台 Acceptor 服务器作为数据源同步给集群中的多台 Learner 服务器，而 ZooKeeper 则是单台 Leader 服务器作为数据源同步给集群中的其他角色服务器。\",\"注意：\",\"ZAB是在Paxos的基础上改进和演变过来的。\",\"提议者（Proposer）、决策者（Acceptor）、决策学习者（Learner）\"]},\"1417\":{\"h\":\"8. Zookeeper 的典型应用场景\",\"t\":[\"数据发布/订阅\",\"负载均衡\",\"命名服务\",\"分布式协调/通知\",\"集群管理\",\"Master 选举\",\"分布式锁\",\"分布式队列\",\"数据发布/订阅系统，即所谓的配置中心，目的：动态获取数据（配置信息），实现数据（配置信息）的集中式管理和数据的动态更新\",\"Zookeeper 分布式锁\",\"有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。\",\"对于第一类，我们将 zookeeper 上的一个 znode 看作是一把锁，通过 createznode的方式来实现。所有客户端都去创建 /task_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的 task_lock 节点就释放出锁。\",\"对于第二类， /task_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选 master 一样，编号最小的获得锁，用完删除，依次方便。\",\"Zookeeper 队列管理\",\"一般很少用到，可简单了解\",\"两种类型的队列：\",\"同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。\",\"队列按照 FIFO 方式进行入队和出队操作。\",\"第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。\",\"第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建 PERSISTENT_SEQUENTIAL 节点，创建成功时Watcher 通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper 的 znode 用于消息存储，znode 存储的数据就是消息队列中的消息内容，SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。\"]},\"1418\":{\"h\":\"9. Chroot特性\",\"t\":[\"zookeeper v3.2.0 版本后，添加了 Chroot 特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。\",\"通过设置 Chroot，能够将一个客户端应用于 Zookeeper 服务端的一颗子树相对应，在那些多个应用共用一个 Zookeeper 进群的场景下，对实现不同应用间的相互隔离非常有帮助。\"]},\"1419\":{\"h\":\"拓展\",\"t\":[\"ZooKeeper以Fast Paxos算法为基础，Paxos 算法存在活锁的问题，即当有多个 proposer 交错提交时有可能互相排斥导致没有一个proposer能提交成功，而Fast Paxos做了一些优化，通过选举产生一个领导者，只有leader才能提交proposer具体算法可见Fast Paxos。\",\"低谷蓄力\",\"点击在线阅读《最少必要面试题》\"]},\"1420\":{\"c\":[\"《最少必要面试题》\"]},\"1421\":{\"h\":\"面试专题\"},\"1422\":{\"h\":\"《新闻搜索ElasticSearch》项目组\",\"t\":[\"https://kazjsfecs3y.feishu.cn/wiki/FyuvwRd8Iixffikodcect8ipnof\"]},\"1423\":{\"c\":[\"项目实战\",\"《新闻搜索ElasticSearch》\"]},\"1424\":{\"c\":[\"项目实战\",\"新闻搜索\",\"ElasticSearch\"]},\"1425\":{\"h\":\"《新闻搜索ElasticSearch》介绍文档\"},\"1426\":{\"h\":\"《新闻搜索ElasticSearch》\",\"t\":[\"介绍文档\",\"手记微信阅读\"]},\"1427\":{\"c\":[\"项目实战\",\"《新闻搜索ElasticSearch》\"]},\"1428\":{\"c\":[\"项目实战\",\"新闻搜索\",\"ElasticSearch\"]},\"1429\":{\"h\":\"《用户中心》项目组\",\"t\":[\"这里是《用户中心》项目组，项目组文档自行取阅。\",\"从 0 到 1 开发用户中心，包括前后端完整项目。而且用户中心作为一个系统中必不可少的模块，通过对通用性的技术学习，也可以丰富我们的简历。 帮助初学者掌握项目的完整开发，从项目创建、设计、开发、到上线完整流程。\",\"这里的文章是整个项目中要用到的知识重点，如果有动手能力的朋友可以通过这些文章、关键源码和视频自学。\",\"需要全套源代码和手把手直播开发的朋友可阅读这里，直播视频和源码详细介绍，目前定价是一包华子的价格、平均每天 0.16¥，并且之后更新的所有视频和源码都可以获取观看。\"]},\"1430\":{\"h\":\"后端返回值结构体定义\",\"t\":[\"牛皮的程序猿后端返回值怎么定义\"]},\"1431\":{\"h\":\"《用户中心》\",\"t\":[\"介绍文档\",\"在后端接口封装中，我们一般都会对返回的数据做一个封装，以防止系统出现不可预期的数据结构和类型。比如这样：\",\"结构体 1\",\"{ \\\"success\\\": true, \\\"code\\\": 200, \\\"message\\\": \\\"成功\\\", \\\"data\\\": { \\\"items\\\": [ { \\\"id\\\": \\\"1\\\", \\\"name\\\": \\\"小王\\\", \\\"identified\\\": \\\"JavaPub博主\\\" } ] } }\",\"结构体 2\",\"{ \\\"ret\\\": 200, \\\"data\\\": { \\\"title\\\": \\\"Default Api\\\", \\\"content\\\": \\\"王哥 您好，欢迎使用 apifather!\\\", \\\"version\\\": \\\"1.1.0\\\", \\\"time\\\": 14231428021 }, \\\"msg\\\": \\\"\\\" }\",\"不论如何定义，多一个或少一个字段，我们都需要统一规范。接下来我们拆解一下，\",\"首先，通过观察，一定要有状态码，也就是案例中的 code 和 ret ，通过状态码可以知道当前程序哪里出了问题，比如 200 就是成功。有同学会问，为何不用 data 来判断，为空或者为 0 就是错误，当然不行。\",\"比如：下面这个结构，data 长度虽然等于 0，但是这属于确实没查到数据，而不是程序出错。\",\"{ \\\"ret\\\": 200, \\\"data\\\": [], \\\"msg\\\": \\\"\\\" }\",\"再看 data，这个毋庸置疑，它是接口的核心数据，也是接口对外提供的业务数据。\",\"再看 message 或者称为 msg，它是给状态做一个文字说明。比如，有个老六在定义了一个状态码（666），第一次调用这个接口的同学可能并不知道返回的状态码含义、也不想去查接口文档，我加个描述：（老六的接口不通啦），调用者就一目了然了。\",\"最后看 success 字段，这个字段是为了更规范而加的，方便前端直接将接口响应状态展示。比如：用户登录成功，可以展示一个 true，或者前端在判断时也可以写更简洁的代码 if result.success:。毕竟将（老六的接口不通啦）描述直接展示出来显得不太正式。\",\"基于以上几点，我们的返回结构这样定义：\",\"ApiResponse.class\",\"// 定义API响应结构体 public class ApiResponse<T> { private int status; // HTTP状态码 private String message; // 状态信息 private T data; // 返回的数据，泛型支持返回不同类型的数据 // 构造函数 public ApiResponse(ResponseStatus status) { this.status = status.getCode(); this.message = status.getMessage(); } // 带数据的构造函数 public ApiResponse(ResponseStatus status, T data) { this(status); this.data = data; } // Getter和Setter方法 // ... }\",\"定义完返回结构后，我们需要定义状态的枚举值。这是为了定一个统一的规范，方便开发时状态码搞混。\",\"// 定义状态码枚举 public enum ResponseStatus { SUCCESS(200, \\\"操作成功\\\"), ERROR(500, \\\"服务器内部错误\\\"), BAD_REQUEST(400, \\\"请求参数错误\\\"), NOT_FOUND(404, \\\"资源未找到\\\"), UNAUTHORIZED(401, \\\"未授权\\\"), FORBIDDEN(403, \\\"禁止访问\\\"); private final int code; private final String message; ResponseStatus(int code, String message) { this.code = code; this.message = message; } public int getCode() { return code; } public String getMessage() { return message; } }\",\"如何使用呢\",\"@GetMapping(\\\"/users/{id}\\\") public ResponseEntity<ApiResponse<User>> getUser(@PathVariable Long id) { try { User user = userService.getUserById(id); if (user != null) { return ResponseEntity.ok(new ApiResponse<>(ResponseStatus.SUCCESS, user)); } else { return ResponseEntity.status(HttpStatus.NOT_FOUND) .body(new ApiResponse<>(ResponseStatus.NOT_FOUND)); } } catch (Exception e) { // 这里可以根据异常类型返回不同的错误状态码和消息 return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(new ApiResponse<>(ResponseStatus.ERROR)); } }\",\"这里使用了 Spring 自带的返回结构体 ResponseEntity 进行封装。\",\"获取到的结果是这样的：\",\"{ \\\"code\\\": 200, \\\"message\\\": \\\"操作成功\\\", \\\"data\\\": { \\\"id\\\": \\\"1\\\", \\\"name\\\": \\\"javapub\\\", \\\"age\\\": 18 } }\",\"原文地址：\",\"https://javapub.net.cn/star/project/user-center/\"]},\"1432\":{\"c\":[\"项目实战\",\"《用户中心》\"]},\"1433\":{\"c\":[\"项目实战\",\"用户管理系统\"]},\"1434\":{\"h\":\"《用户中心》介绍文档\"},\"1435\":{\"h\":\"《用户中心》\",\"t\":[\"介绍文档\",\"手记微信阅读\"]},\"1436\":{\"c\":[\"项目实战\",\"《用户中心》\"]},\"1437\":{\"c\":[\"项目实战\",\"用户管理系统\"]},\"1438\":{\"h\":\"《用户中心》需求分析\",\"t\":[\"封面图\",\"程序员在企业中是如何做需求的 需求从哪里来，到哪里去\"]},\"1439\":{\"h\":\"《用户中心》\",\"t\":[\"介绍文档\",\"在企业中，一个需求从产生到完成生命周期是什么样的。\",\"它可以分为这样的步骤：\",\"需求分析 -> 设计（原型、功能、接口设计） -> 技术选型 -> 搭建项目框架 -> 编码（实现业务逻辑） -> 测试（自测+提测） -> 代码评审（code review） -> 部署上线\",\"需求是怎么产生的？\",\"一般来说需求都是由业务人员收集业务痛点，将这个痛点转换成需求；还有些需求是产品经理拍脑袋产生的... 这是一个很大的话题，同时也会诞生各种各样的奇葩需求，和大量的就业岗位。\",\"有个学妹自学了半年编程。今天找我说她打算找工作了，让我给讲讲公司里边做项目是什么流程、她好心里有个底。\",\"在实际工作中，项目的根据大小还有背景不同、整个生命周期也会有一些差别。大体分为：计划、设计、开发、测试、维护等步骤，我们就以一个需求的生命周期来分析。\",\"比如，有客户说，我们公司现在已经 3 个人了，需要一个用户管理系统来把这些人管理起来，你帮我安排一下。\",\"拿到需求后，是要做一个用户相关的系统，我给他起个名字就叫《用户中心》管理系统。\",\"需求\",\"首先是分析需求，这个系统作为用户管理，其中肯定要有用户的登录、用户添加、用户删除、用户查询等。\",\"设计\",\"原型设计\",\"功能设计 a.用户管理，用户登录、添加用户、用户删除、基于用户的名称的查询\",\"技术选型\",\"看需求有没有技术难点\",\"没有的话选择擅长和熟悉的技术栈\",\"搭建项目\",\"搭建项目的脚手架，也就是项目的公共模块 a. 比如对接口返回值的统一校验封装 b. 统一日志格式 c. 项目的代码模块目录 d. 还有一些常用的工具类等\",\"编码\",\"完成这一步就要开始编写代码。\",\"测试\",\"分为自测和提测，当然对于一些小公司划分的就没有这么细了，都是由于全干工程师一人搞定。\",\"代码评审\",\"也就是工友们一块审核代码规范，比如你的代码模块拆分，可以增强代码的可维护性。\",\"部署上线\",\"一般是项目开发中的最后一步，运维人员会将项目部署到用户可以访问的服务器，正式开始使用。\",\"视频：\",\"https://www.bilibili.com/video/BV17f421Q73r\",\"原文地址：\",\"https://javapub.net.cn/star/project/user-center/\"]},\"1440\":{\"c\":[\"项目实战\",\"《用户中心》\"]},\"1441\":{\"c\":[\"项目实战\",\"用户管理系统\"]},\"1442\":{\"h\":\"SpringBoot整合MyBatis-Plus\",\"t\":[\"SpringBoot如何整合MyBatis-plus MyBatis-plus这么好用，不允许还有人不会\"]},\"1443\":{\"h\":\"《用户中心》\",\"t\":[\"介绍文档\",\"你好呀，我是 javapub.\",\"做 Java 的同学都会用到的三件套，Spring、SpringMV、MyBatis。但是由于使用起来配置较多，依赖冲突频发。所有，各路大佬又在这上边做了包装，像我们常用的 SpringBoot、MyBatisPlus。\",\"基于当前要开发的是一个用户中心系统，查询逻辑比较简单，这里选用 MyBatis-Plus 就够用。但是很多同学还没用过这个工具，今天带你使用一下。省下时间来摸鱼啊。\"]},\"1444\":{\"h\":\"环境\",\"t\":[\"JDK17\",\"SpringBoot3.*\",\"初始化项目\",\"初始化一个 SpringBoot 项目，不需要添加 MyBatis 依赖。\",\"image-\",\"添加依赖\",\"在 mvnrepository 获取需要的 MyBatis-Plus 版本。这里以 MySQL 为例。\",\" <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus-spring-boot3-starter</artifactId> <version>3.5.7</version> </dependency>\",\"SpringBoot数据库信息配置\",\"application.yml\",\"# 应用服务 WEB 访问端口 server: port: 8080 # DataSource Config spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://rm-t4njraxo75r1e4jlevo.mysql.singapore.rds.aliyuncs.com:3306/javapub_test?characterEncoding=utf8&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true&useSSL=false username: javapub_admin password: JavaPub666 sql: init: schema-locations: mybatis-plus: mapper-locations: classpath:mapper/*.xml type-aliases-package: cn.net.javapub.entity configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 这个配置会将执行的sql打印出来\",\"如果你没有数据库，可以来 javapub，给你提供一个免费的实例。\",\"SQL语句\",\"提供一个 SQL，用来做测试。\",\"user.sql\",\"create table user ( id bigint not null comment '主键ID' primary key, name varchar(30) null comment '姓名', age int null comment '年龄', email varchar(50) null comment '邮箱' ); INSERT INTO javapub_test.user (id, name, age, email) VALUES (1, '张子涵', 18, 'test1@javapub.net.cn'); INSERT INTO javapub_test.user (id, name, age, email) VALUES (2, '张子恒', 20, 'test2@javapub.net.cn'); INSERT INTO javapub_test.user (id, name, age, email) VALUES (3, '李子璇', 28, 'test3@javapub.net.cn'); INSERT INTO javapub_test.user (id, name, age, email) VALUES (4, '王梓旭', 21, 'test4@javapub.net.cn'); INSERT INTO javapub_test.user (id, name, age, email) VALUES (5, '曹欣然', 24, 'test5@javapub.net.cn');\",\"代码逆向生成工具\",\"推荐一个 IDE 插件，免费、简洁、好用。MyBatis-X\",\"它可以帮我快速的生成 service、mapper、entity、xml 层，减少重复工作。\",\"image-\",\"演示\",\"至此，就可以使用 MyBatis-Plus 了。在 test 文件下执行测试案例。\",\"image-\",\"其他用例\",\"从这个方法点进来可以看到 MyBatis-plus 源码，它已经帮我们把大多数的常用工具都做好了，只需要实现这个 service 和 mapper 类即可。\",\"image-\",\"源码： https://github.com/Rodert/SpringBoot-javapub/\",\"原文地址：\",\"https://javapub.net.cn/star/project/user-center/\"]},\"1445\":{\"c\":[\"项目实战\",\"《用户中心》\"]},\"1446\":{\"c\":[\"项目实战\",\"用户管理系统\",\"springboot\",\"mybatis-plus\"]},\"1447\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"免费\",{\"1\":{\"1444\":1}}],[\"免费获取\",{\"1\":{\"643\":1}}],[\"曹欣然\",{\"1\":{\"1444\":1}}],[\"王梓旭\",{\"1\":{\"1444\":1}}],[\"王哥\",{\"1\":{\"182\":1,\"954\":2,\"994\":1,\"1431\":1}}],[\"李子璇\",{\"1\":{\"1444\":1}}],[\"张子恒\",{\"1\":{\"1444\":1}}],[\"张子涵\",{\"1\":{\"1444\":1}}],[\"省下时间来摸鱼啊\",{\"1\":{\"1443\":1}}],[\"省略了强转的代码\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"省略getter和setter方法\",{\"1\":{\"829\":1,\"830\":1}}],[\"省略构造方法\",{\"1\":{\"825\":2}}],[\"她好心里有个底\",{\"1\":{\"1439\":1}}],[\"牛皮的程序猿后端返回值怎么定义\",{\"1\":{\"1430\":1}}],[\"决策学习者\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"决策者\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"周期\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"退出恢复模式进入消息广播模式\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"退化成链表\",{\"1\":{\"503\":1}}],[\"崩溃恢复\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"仍然保证对外提供满足一致性和可用性的服务\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"仍然能够继续工作\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"投票过程的性能就越差\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"投票来说\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"观察者状态\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"观察者模式是什么\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"观察者模式\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"寻\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"独立运行\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"约定大于配置的原则\",{\"1\":{\"1224\":1,\"1399\":1}}],[\"弱化配置\",{\"1\":{\"1224\":1,\"1399\":1}}],[\"弱引用或虚引用变量引用\",{\"1\":{\"936\":1}}],[\"⑦\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"⑥\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"见\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"见如下代码注释理解\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"载入多个\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"载入当前数据库\",{\"1\":{\"962\":1}}],[\"贴在这里供大家理解\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"贴一下全部配置\",{\"1\":{\"406\":1}}],[\"织入\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"织入相关代码\",{\"1\":{\"689\":2}}],[\"装饰器模式\",{\"1\":{\"1216\":2,\"1393\":2}}],[\"＞销毁bean\",{\"1\":{\"1214\":2,\"1391\":2}}],[\"＞\",{\"1\":{\"1214\":4,\"1391\":4}}],[\"彼此毫无联系\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"粘合剂\",{\"1\":{\"1212\":3,\"1389\":3}}],[\"粘包\",{\"1\":{\"1032\":1}}],[\"粘包是怎么产生的\",{\"1\":{\"104\":1}}],[\"齿轮之间的传动全部依靠\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"齿轮组中齿轮之间的啮合关系\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"赖关系的对象之间的解耦\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"借助于\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"耦合关系不仅会出现在对象与对象之间\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"架构师和设计师对于系统的分析和设计\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"架构图\",{\"1\":{\"740\":1}}],[\"伴随着\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"针顺时针旋转\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"针对的是servlet\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"针对servlet缺点推出jsp\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"针对服务对象的不同\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"针对我使用的应用\",{\"1\":{\"942\":1}}],[\"针对上面问题\",{\"1\":{\"387\":1}}],[\"针对每一个投票\",{\"1\":{\"166\":1}}],[\"软件系统在引入ioc容器之后\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"软件系统在没有引入ioc容器之前\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"软件系统中耦合的对象\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"软件专家michael\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"软引用被清理等\",{\"1\":{\"936\":1}}],[\"校验算法进行散列\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"哨兵提升整个集群的高可用性\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"哨兵作为操作系统中的一个监控进程\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"哨兵部署\",{\"1\":{\"1205\":2,\"1385\":2}}],[\"哨兵和集群\",{\"1\":{\"960\":1}}],[\"缩短值的长度才是关键\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"缩短键值的长度\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"均匀过期\",{\"1\":{\"1203\":2,\"1383\":2}}],[\"均为0\",{\"1\":{\"166\":1}}],[\"混合持久化是结合rdb和aof的优点\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"混合持久化方式\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"播放量等并发较高\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"坐标\",{\"1\":{\"1198\":1,\"1378\":1}}],[\"乐观\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"乐观锁定的第二种实现方式和第一种差不多\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"乐观锁的两种实现方式\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"乐观锁的特点先进行业务操作\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"乐观锁在数据库上的实现完全是逻辑的\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"乐观锁则容忍并发冲突\",{\"1\":{\"1018\":1}}],[\"乐观锁和悲观锁是两种不同的锁机制\",{\"1\":{\"1018\":1}}],[\"乐观锁和悲观锁了解吗\",{\"1\":{\"1018\":1}}],[\"乐观锁和悲观锁有什么区别\",{\"0\":{\"568\":1}}],[\"乐观锁来实现\",{\"1\":{\"594\":1}}],[\"乐观锁通常不需要显式释放\",{\"1\":{\"579\":1}}],[\"乐观锁通常不使用数据库的锁定机制\",{\"1\":{\"569\":1}}],[\"乐观锁通常通过在表中添加一个版本号或时间戳字段来实现\",{\"1\":{\"579\":1}}],[\"乐观锁适用于写冲突较少的场景\",{\"1\":{\"573\":1}}],[\"乐观锁可以提供更好的性能\",{\"1\":{\"569\":1}}],[\"乐观锁基于这样的假设\",{\"1\":{\"569\":1}}],[\"乐观锁\",{\"0\":{\"569\":1},\"1\":{\"1018\":1}}],[\"悲观\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"悲观锁的特点是先获取锁\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"悲观锁和乐观锁也可以灵活结合\",{\"1\":{\"1018\":1}}],[\"悲观锁一般由同步机制实现\",{\"1\":{\"1018\":1}}],[\"悲观锁会导致性能下降\",{\"1\":{\"1018\":1}}],[\"悲观锁试图防止并发冲突\",{\"1\":{\"1018\":1}}],[\"悲观锁适用于写冲突较多的场景\",{\"1\":{\"573\":1}}],[\"悲观锁可能导致更多的等待和锁竞争\",{\"1\":{\"570\":1}}],[\"悲观锁通过数据库的锁定机制来确保数据一致性\",{\"1\":{\"570\":1}}],[\"悲观锁基于这样的假设\",{\"1\":{\"570\":1}}],[\"悲观锁\",{\"0\":{\"570\":1},\"1\":{\"1018\":1}}],[\"刚插入进来的\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"刚入职一个公司\",{\"1\":{\"934\":1}}],[\"缺一不可\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"缺点\",{\"1\":{\"768\":1,\"772\":1,\"1049\":1,\"1146\":2,\"1258\":1,\"1337\":2}}],[\"缺点是反射的性能比较低\",{\"1\":{\"1010\":1}}],[\"缺点是aof\",{\"1\":{\"962\":1}}],[\"缺点是数据有一定的丢失风险\",{\"1\":{\"962\":1}}],[\"缺点是实现相对复杂\",{\"1\":{\"932\":1}}],[\"缺点是只能使用一次\",{\"1\":{\"932\":1}}],[\"缺点是需要合理配置线程池的参数\",{\"1\":{\"926\":1}}],[\"缺点是字符串作为id占用空间大\",{\"1\":{\"382\":1}}],[\"缺点是有一定的误识别率和删除困难\",{\"1\":{\"332\":1}}],[\"课程对象\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"课程将在csdn学院上线\",{\"1\":{\"394\":1}}],[\"灵活度高\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"损耗\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"零拷贝kafka使用了零拷贝技术\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"越多的分区可能增加端对端的延迟\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"越早入手越划算\",{\"1\":{\"212\":1}}],[\"般类似于这种问题的答案\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"羊群效应\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"脑裂\",{\"1\":{\"1165\":2,\"1353\":2}}],[\"毫无差别了\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"毫无疑问这种方案的可靠性是最高的\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"毫秒内序列重置\",{\"1\":{\"388\":1}}],[\"毫秒内序列溢出\",{\"1\":{\"388\":1}}],[\"毫秒内序列\",{\"1\":{\"388\":1}}],[\"毫秒内的计数\",{\"1\":{\"388\":1}}],[\"毫秒级\",{\"1\":{\"388\":1}}],[\"毫秒\",{\"1\":{\"387\":2,\"388\":1,\"689\":2}}],[\"体系架构包括若干\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"体系中最为成熟的框架\",{\"1\":{\"950\":1}}],[\"冗余存储\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"术语0\",{\"0\":{\"1156\":1,\"1157\":1,\"1344\":1,\"1345\":1}}],[\"阶段\",{\"1\":{\"1150\":4,\"1341\":4}}],[\"倘若父类加载器无法完成此加载任务\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"物理地址分配是连续的\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"物理地址\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"物理存储维度\",{\"1\":{\"495\":1}}],[\"攻击主要有三种策略\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"攻击专门针对状态改变请求\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"攻击是在受害者毫不知情的情况下\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"攻击\",{\"0\":{\"1137\":2,\"1330\":2}}],[\"攻城狮很好的选择\",{\"1\":{\"397\":1}}],[\"施加的安全限制\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"购物车最好使用cookie\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"购物车早期\",{\"1\":{\"654\":1}}],[\"翻译\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"翻阅官方文档\",{\"1\":{\"526\":1}}],[\"规范中定义的\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"规范不同\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"规范规定的\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"规范的实现是接口\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"规则\",{\"1\":{\"747\":2}}],[\"阈值为什么是8\",{\"0\":{\"1122\":1,\"1317\":1}}],[\"追问\",{\"0\":{\"1121\":1,\"1316\":1},\"1\":{\"1122\":1,\"1317\":1}}],[\"ˈseməfɔː\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"ˈvɒlətaɪl\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"信号量方式\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"信息不安全\",{\"1\":{\"385\":1}}],[\"信息\",{\"1\":{\"183\":1,\"705\":1,\"1151\":1,\"1342\":1}}],[\"串行化\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"串行\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"易于操作\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"迪杰斯特拉在1965年为t\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"银行家算法\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"银行家算法非常有必要了解\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"家庭成员之间需要相互等待\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"家庭聚餐\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"晚上关宿舍大门睡觉\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"宿管阿姨就是监听countdownlatch为0后要执行的\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"宿管阿姨\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"冲破栅栏\",{\"1\":{\"1104\":12,\"1302\":12}}],[\"冲突的个数比较少时\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"冲突检测\",{\"1\":{\"569\":1}}],[\"冲突\",{\"1\":{\"564\":1,\"565\":1,\"566\":1,\"567\":1,\"1116\":1,\"1311\":1}}],[\"冲突和使用场景几个角度来区分\",{\"1\":{\"563\":1}}],[\"冲突较少\",{\"1\":{\"561\":1}}],[\"典型场景\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"典型的如cas算法采用乐观锁\",{\"1\":{\"1018\":1}}],[\"典型的生产者消费者模型\",{\"1\":{\"153\":1}}],[\"禁止访问\",{\"1\":{\"1431\":1}}],[\"禁止指令重排序\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"禁用批量terms\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"禁用wildcard\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"禁用刷新机制\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"禁用\",{\"2\":{\"22\":1}}],[\"禁用了如下功能\",{\"1\":{\"20\":1}}],[\"马上就停止循环\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"马上安排\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"马上获得我和\",{\"1\":{\"656\":1}}],[\"半个\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"拦截sql后重写为\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"拦截待执行的sql\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"拦截成功如下\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"拦截器也是一个\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"拦截器和过滤器的区别\",{\"0\":{\"1133\":1,\"1326\":1}}],[\"拦截器\",{\"0\":{\"770\":1},\"1\":{\"956\":1,\"1133\":1,\"1211\":1,\"1326\":1,\"1388\":1}}],[\"擦除规则\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"休眠方法\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"休眠\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"乘客下车\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"司机可以认为是\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"司机只和售票员交互\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"司机过程中定时询问每个乘客是否到达目的地\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"司机不知道哪些点会有哪些人会下车\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"谈谈arraylist和vector的区别\",{\"0\":{\"1118\":1,\"1313\":1}}],[\"谈谈\",{\"0\":{\"1117\":1,\"1312\":1}}],[\"谈谈nio和bio区别\",{\"0\":{\"1088\":1,\"1289\":1}}],[\"谈使用场景之前\",{\"1\":{\"112\":1}}],[\"←\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"→\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"刷刷面试\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"误差可以被设置辅助计算因子进行降低\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"误差率整体较低\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"误用\",{\"1\":{\"950\":1}}],[\"科普\",{\"1\":{\"1077\":1,\"1177\":1,\"1281\":1,\"1362\":1}}],[\"＝\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"度量\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"候选\",{\"1\":{\"1074\":1,\"1278\":1}}],[\"候选数量不小于\",{\"1\":{\"1074\":1,\"1278\":1}}],[\"候选人\",{\"1\":{\"970\":1,\"976\":1,\"978\":2,\"982\":1,\"984\":5,\"986\":10,\"990\":1,\"1002\":1,\"1008\":1}}],[\"深度不同\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"深分页\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"深翻页\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"深入学习\",{\"1\":{\"948\":1}}],[\"深入理解各种垃圾收集器的设计与实现原理\",{\"1\":{\"942\":1}}],[\"丰富结果文档\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"丰富\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"丰富的数据结构\",{\"1\":{\"615\":1}}],[\"丰富的数据类型\",{\"1\":{\"593\":1}}],[\"丰富的特性\",{\"1\":{\"593\":1}}],[\"段是不可变的\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"段本身是一个功能齐全的倒排索引\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"段的\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"延伸阅读\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"延迟加载\",{\"0\":{\"798\":1}}],[\"延迟\",{\"1\":{\"440\":1}}],[\"词频\",{\"1\":{\"1069\":1,\"1273\":1}}],[\"词条\",{\"1\":{\"436\":1}}],[\"充分利用倒排索引机制\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"充分发挥热门数据的操作效率\",{\"1\":{\"516\":1}}],[\"冷数据定期进行shrink操作\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"冷门字段分开放置在不同库中\",{\"1\":{\"516\":1}}],[\"滚动索引\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"守护进程\",{\"1\":{\"1061\":1,\"1267\":1}}],[\"虚拟机将常量池中的符号引用替换成直接引用的过程\",{\"1\":{\"1148\":1,\"1339\":1}}],[\"虚拟机里面还有额外的系统\",{\"1\":{\"1058\":1,\"1264\":1}}],[\"虚拟机栈描述的是java方法执行的内存模型\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"虚拟机栈\",{\"1\":{\"692\":1,\"936\":1}}],[\"逻辑相对比较复杂\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"逻辑维度\",{\"1\":{\"495\":1}}],[\"胖友先看看如下几篇文章\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"恰好是\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"恰好有一个请求\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"恰好在这个时间点对这个\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"穿透\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"雪崩\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"雪花算法\",{\"0\":{\"380\":1,\"386\":1},\"2\":{\"389\":1}}],[\"热数据存储到ssd\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"热门的或者推荐的商品\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"热点\",{\"1\":{\"1049\":2,\"1258\":2}}],[\"热加载组件\",{\"1\":{\"394\":1}}],[\"演练缓存宕掉后\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"演示了\",{\"1\":{\"924\":1}}],[\"演示环境在\",{\"1\":{\"108\":1}}],[\"演示\",{\"1\":{\"27\":1,\"683\":1,\"1444\":1}}],[\"论坛帖子的访问频率比较高\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"带数据的构造函数\",{\"1\":{\"1431\":1}}],[\"带来更好的性能\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"带有logo二维码\",{\"1\":{\"876\":1}}],[\"拿到需求后\",{\"1\":{\"1439\":1}}],[\"拿到心仪offer\",{\"1\":{\"920\":1}}],[\"拿掉ioc容器后的系统\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"拿最多的\",{\"1\":{\"1039\":1}}],[\"便可以将事务规则应用到业务逻辑中\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"便返回指向integercache\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"便诞生了handler组件\",{\"1\":{\"1034\":1}}],[\"便能得到一个有序序列了\",{\"1\":{\"364\":1}}],[\"市面上有很多消息推送系统都是基于\",{\"1\":{\"1033\":1}}],[\"凭借自己的了解\",{\"1\":{\"1033\":1}}],[\"拆包问题\",{\"1\":{\"1032\":1}}],[\"拆分到不同的模块中\",{\"1\":{\"954\":1}}],[\"拆分后\",{\"1\":{\"520\":1}}],[\"试试\",{\"1\":{\"1030\":1}}],[\"机制而出现短暂的暂停\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"机制的补充\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"机制的区别是什么\",{\"1\":{\"1027\":1}}],[\"机制\",{\"0\":{\"1119\":1,\"1314\":1},\"1\":{\"1119\":2,\"1211\":1,\"1314\":2,\"1388\":1}}],[\"机制和\",{\"1\":{\"1027\":1}}],[\"机器id向左移12位\",{\"1\":{\"388\":1}}],[\"机器id所占的位数\",{\"1\":{\"388\":1}}],[\"机器id\",{\"1\":{\"387\":1}}],[\"竞争次数偏移量\",{\"1\":{\"1023\":1}}],[\"竞争次数\",{\"1\":{\"1023\":1}}],[\"竞选的过程中\",{\"1\":{\"1008\":1}}],[\"竞选主节点\",{\"1\":{\"1008\":1}}],[\"责任线程指针偏移量\",{\"1\":{\"1023\":1}}],[\"责任线程指针\",{\"1\":{\"1023\":1}}],[\"责任人\",{\"1\":{\"182\":1}}],[\"偏向锁是一种针对单线程访问同步块的优化策略\",{\"1\":{\"1022\":1}}],[\"偏移量\",{\"1\":{\"658\":1,\"1069\":1,\"1273\":1}}],[\"今后在设计系统和使用锁机制时可以运用的更加娴熟和灵活\",{\"1\":{\"1018\":1}}],[\"今天带你使用一下\",{\"1\":{\"1443\":1}}],[\"今天找我说她打算找工作了\",{\"1\":{\"1439\":1}}],[\"今天就先到这吧\",{\"1\":{\"1018\":1}}],[\"今天就到这里吧\",{\"1\":{\"928\":1}}],[\"今天的面试到此结束\",{\"1\":{\"922\":1}}],[\"今天推荐这款工具\",{\"1\":{\"906\":1}}],[\"今天介绍三种快速创建\",{\"1\":{\"836\":1}}],[\"今天这篇文章就是给大家分享一下如何在我们实战生产中使用\",{\"1\":{\"652\":1}}],[\"今天我们来详细讨论一下elasticsearch选主的重要性和具体过程\",{\"1\":{\"1008\":1}}],[\"今天我们来聊聊elasticsearch的架构设计\",{\"1\":{\"1002\":1}}],[\"今天我们来聊聊kafka的使用场景\",{\"1\":{\"976\":1}}],[\"今天我们来聊聊日志打印的\",{\"1\":{\"190\":1}}],[\"今天我们将聊一聊elasticsearch集群架构\",{\"1\":{\"1004\":1}}],[\"今天我们将聊一下elasticsearch和lucene\",{\"1\":{\"1000\":1}}],[\"今天我们要聊聊kafka的性能\",{\"1\":{\"980\":1}}],[\"今天我们要聊一聊elasticsearch倒排索引\",{\"1\":{\"1006\":1}}],[\"今天我们要聊一聊elasticsearch基础知识\",{\"1\":{\"998\":1}}],[\"今天我们要聊一聊kafka基础\",{\"1\":{\"974\":1}}],[\"今天我们要聊一聊redis内存优化的话题\",{\"1\":{\"972\":1}}],[\"今天我们要聊一聊redis分片集群\",{\"1\":{\"968\":1}}],[\"今天我们一块来看看\",{\"1\":{\"482\":1}}],[\"屏蔽一切可能违反数据完整性的操作\",{\"1\":{\"1018\":1}}],[\"乃至设计并发系统会非常有帮助\",{\"1\":{\"1018\":1}}],[\"里\",{\"1\":{\"1049\":1,\"1116\":1,\"1258\":1,\"1311\":1}}],[\"里的任何资源\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"里的文档\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"里的\",{\"1\":{\"1018\":1}}],[\"里面配置的所有\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"里面的属性不能被覆盖\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"里面包含sql语句来绑定\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"里面维护了一个\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"里面\",{\"1\":{\"83\":1}}],[\"路上有很多点可能会有人下车\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"路由到目标分片\",{\"1\":{\"1012\":1}}],[\"路由到分片\",{\"1\":{\"1012\":1}}],[\"路由值可以是文档id的哈希值\",{\"1\":{\"1012\":1}}],[\"路径会发生改变\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"路径不会发生改变\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"路径\",{\"1\":{\"177\":1}}],[\"路径导航\",{\"1\":{\"20\":1,\"23\":1}}],[\"剩下的节点会重新竞选主节点\",{\"1\":{\"1008\":1}}],[\"喜欢吃苹果\",{\"1\":{\"1006\":2}}],[\"喜欢折腾\",{\"1\":{\"217\":1}}],[\"咱们先从搜索引擎说起吧\",{\"1\":{\"1006\":1}}],[\"咱们还需要在dto包里新建一个封装json返回结果的类result\",{\"1\":{\"830\":1}}],[\"副业\",{\"1\":{\"1026\":1,\"1030\":1,\"1056\":1,\"1126\":1,\"1141\":1,\"1155\":1,\"1171\":1,\"1210\":1,\"1223\":1,\"1236\":1}}],[\"副业赚钱\",{\"1\":{\"211\":1}}],[\"副本还没有来得及同步\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"副本和\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"副本成功写入消息\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"副本追上了\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"副本落后过多时\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"副本的滞后状态\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"副本的数量可以根据需求进行配置\",{\"1\":{\"1012\":1}}],[\"副本同步滞后过多的\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"副本同步队列\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"副本在内\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"副本保持一定程度同步的replica\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"副本对外提供服务\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"副本中重新选举新的\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"副本数\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"副本\",{\"0\":{\"1165\":1,\"1353\":1},\"1\":{\"1002\":1,\"1159\":1,\"1163\":1,\"1347\":1,\"1351\":1}}],[\"价格等\",{\"1\":{\"1000\":1}}],[\"幂等性写入\",{\"1\":{\"996\":1}}],[\"幂等性保证了消息的处理不会因为重复发送而产生副作用\",{\"1\":{\"996\":1}}],[\"幂等性其实就是指无论执行多少次相同的操作\",{\"1\":{\"996\":1}}],[\"别人可以分析存放在本地的cookie并进行cookie欺骗\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"别的线程阻塞等待\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"别担心\",{\"1\":{\"996\":1}}],[\"别名\",{\"0\":{\"768\":1},\"1\":{\"768\":1}}],[\"别名类型等\",{\"1\":{\"455\":1}}],[\"唤醒等待在此对象上的所有线程\",{\"1\":{\"988\":1}}],[\"唤醒等待在此对象上的一个线程\",{\"1\":{\"988\":1}}],[\"唤醒线程的操作是通过\",{\"1\":{\"932\":1}}],[\"告诉kafka这条消息已经被成功消费\",{\"1\":{\"984\":1}}],[\"告诉junit\",{\"1\":{\"828\":1}}],[\"哦\",{\"1\":{\"982\":1,\"990\":1,\"994\":2,\"996\":1,\"1006\":1}}],[\"吞吐量就会越高吗\",{\"0\":{\"1166\":1,\"1354\":1}}],[\"吞吐量有一些见解\",{\"1\":{\"982\":1}}],[\"吞吐量和延迟指标\",{\"1\":{\"950\":1}}],[\"祝你在未来的工作中取得更大的成功\",{\"1\":{\"980\":1}}],[\"祝面试官有一个美好的一天\",{\"1\":{\"966\":1}}],[\"嘿\",{\"1\":{\"978\":1}}],[\"管家的形象也很贴切\",{\"1\":{\"976\":1}}],[\"管理系统\",{\"1\":{\"1439\":1}}],[\"管理\",{\"1\":{\"950\":1,\"1057\":1,\"1133\":1,\"1263\":1,\"1326\":1}}],[\"管理项目\",{\"1\":{\"812\":1}}],[\"管理大量行锁的开销可能很大\",{\"1\":{\"574\":1}}],[\"管理什么的咱不说\",{\"1\":{\"153\":1}}],[\"备份缓存\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"备份咖啡师可以接手制作咖啡\",{\"1\":{\"974\":1}}],[\"备注\",{\"1\":{\"209\":1,\"212\":1}}],[\"制作咖啡并提供给顾客\",{\"1\":{\"974\":1}}],[\"低水位\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"低谷蓄力\",{\"1\":{\"1027\":1,\"1036\":1,\"1064\":1,\"1123\":1,\"1138\":1,\"1167\":1,\"1181\":1,\"1220\":1,\"1233\":1,\"1246\":1,\"1270\":1,\"1355\":1,\"1397\":1,\"1419\":1}}],[\"低延迟的分布式消息队列\",{\"1\":{\"980\":1}}],[\"低延迟的数据传输和处理\",{\"1\":{\"974\":1}}],[\"低停顿\",{\"1\":{\"938\":1}}],[\"尤其是redis作为分布式锁的选择\",{\"1\":{\"970\":1}}],[\"尤其是在一些对消息可靠性要求较高的场景下\",{\"1\":{\"994\":1}}],[\"尤其是在表中只有少数行会被访问时\",{\"1\":{\"564\":1}}],[\"尤其是在大型表上进行部分数据的读写操作\",{\"1\":{\"561\":1,\"566\":1}}],[\"尤其是在必须引用几个表才能获得所需的数据时\",{\"0\":{\"546\":1}}],[\"尤其是在数据插入\",{\"1\":{\"510\":1}}],[\"尤其是在高并发的写操作环境中\",{\"1\":{\"508\":1}}],[\"嗨\",{\"1\":{\"968\":2,\"970\":1,\"972\":1,\"974\":2,\"976\":1,\"980\":1,\"982\":2,\"984\":1,\"986\":1,\"990\":2,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":2,\"1004\":1,\"1006\":2,\"1008\":1,\"1012\":1}}],[\"边界有两种形式\",{\"1\":{\"966\":1}}],[\"边界是对类型参数指定的约束\",{\"1\":{\"966\":1}}],[\"坏处是导致些许运行期间的效率损失\",{\"1\":{\"966\":1}}],[\"哇\",{\"1\":{\"966\":1,\"982\":2,\"984\":1,\"986\":1,\"994\":1,\"996\":2,\"1006\":1}}],[\"泛型支持返回不同类型的数据\",{\"1\":{\"1431\":1}}],[\"泛型时提供给javac编译器使用的\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"泛型擦除\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"泛型\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"泛型提供了编译时类型安全检测机制\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"泛型在编码中有非常广泛的使用\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"泛型是什么\",{\"0\":{\"1090\":1,\"1291\":1}}],[\"泛型中通配符\",{\"1\":{\"966\":1}}],[\"泛型中的边界是干嘛的\",{\"1\":{\"966\":1}}],[\"泛型中<\",{\"1\":{\"966\":1}}],[\"泛型真的有些复杂\",{\"1\":{\"966\":1}}],[\"泛型的好处\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"泛型的上限是\",{\"1\":{\"966\":1}}],[\"泛型的上下限是什么\",{\"1\":{\"966\":1}}],[\"泛型的很多地方就不会再混淆了\",{\"1\":{\"966\":1}}],[\"泛型类\",{\"1\":{\"966\":1}}],[\"泛型类不能有静态方法的原因是因为静态方法在类加载的时候就被创建\",{\"1\":{\"966\":1}}],[\"泛型方法可以有\",{\"1\":{\"966\":1}}],[\"泛型方法更灵活\",{\"1\":{\"966\":1}}],[\"泛型方法\",{\"1\":{\"966\":1}}],[\"泛型方法是在普通类中定义带类型参数的方法\",{\"1\":{\"966\":1}}],[\"泛型方法和泛型类有什么区别\",{\"1\":{\"966\":1}}],[\"泛型来了之后\",{\"1\":{\"966\":1}}],[\"泛型要解决的最主要的问题就是类型不安全\",{\"1\":{\"966\":1}}],[\"泛型这个机制一开始我也是一头雾水\",{\"1\":{\"966\":1}}],[\"搞不太明白它到底要解决什么问题\",{\"1\":{\"966\":1}}],[\"搞java都能说出\",{\"1\":{\"698\":1}}],[\"断线重连\",{\"1\":{\"964\":1}}],[\"断开连接\",{\"1\":{\"286\":1}}],[\"期间\",{\"1\":{\"962\":1}}],[\"期待你加入我们团队\",{\"1\":{\"958\":1}}],[\"期待你的陪伴\",{\"1\":{\"1\":1}}],[\"触发的时机是定时触发\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"触发\",{\"1\":{\"962\":1}}],[\"触发事务\",{\"1\":{\"830\":1}}],[\"恭喜你进到面试的最后一个环节\",{\"1\":{\"958\":1}}],[\"轻量级锁是一种针对多线程访问同步块的优化策略\",{\"1\":{\"1022\":1}}],[\"轻量级锁和重量级锁等优化策略\",{\"1\":{\"1022\":1}}],[\"轻量级\",{\"1\":{\"956\":1}}],[\"早日通过面试\",{\"1\":{\"1016\":1}}],[\"早上好面试官\",{\"1\":{\"956\":1}}],[\"早上好\",{\"1\":{\"956\":1}}],[\"早期版本\",{\"1\":{\"429\":1}}],[\"破坏了\",{\"1\":{\"954\":1}}],[\"破坏\",{\"1\":{\"954\":1}}],[\"破坏安全性\",{\"1\":{\"934\":1}}],[\"探索\",{\"1\":{\"952\":1}}],[\"佩服佩服\",{\"1\":{\"952\":1}}],[\"棒\",{\"1\":{\"952\":1,\"998\":2}}],[\"种方式的循环依赖问题被解决了\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"种\",{\"1\":{\"952\":1}}],[\"种销毁方法\",{\"1\":{\"952\":1}}],[\"种初始化方法\",{\"1\":{\"952\":1}}],[\"种配置\",{\"1\":{\"433\":1}}],[\"熔断器\",{\"1\":{\"950\":1}}],[\"限流\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"限流与降级\",{\"1\":{\"950\":1}}],[\"限制视频的采集帧率\",{\"1\":{\"145\":1}}],[\"松耦合的服务\",{\"1\":{\"950\":1}}],[\"遵循\",{\"1\":{\"1224\":1,\"1399\":1}}],[\"遵循高内聚低耦合原则\",{\"1\":{\"950\":1}}],[\"遵循空字符结尾这一惯例的好处是\",{\"1\":{\"619\":1}}],[\"滥用\",{\"1\":{\"950\":1}}],[\"博客等\",{\"1\":{\"950\":1}}],[\"博主是个实战派\",{\"1\":{\"906\":1}}],[\"浏览器发送请求到\",{\"1\":{\"950\":1}}],[\"浏览属于你的网站\",{\"1\":{\"913\":1}}],[\"笑\",{\"1\":{\"950\":1}}],[\"旧版本的文档依然能匹配查询\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"旧版本的文档在\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"旧版javapub官网\",{\"1\":{\"219\":1}}],[\"旧的\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"旧的预期值\",{\"1\":{\"1018\":1}}],[\"旧键值对的重新映射策略与性能影响\",{\"1\":{\"948\":1}}],[\"何谓数据版本\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"何时应选择链表还是红黑树来解决哈希冲突\",{\"1\":{\"948\":1}}],[\"何时进行树化\",{\"1\":{\"948\":1}}],[\"何乐礼在打孔卡片制表机\",{\"1\":{\"374\":1}}],[\"碰撞处理等机制还需进一步理解\",{\"1\":{\"948\":1}}],[\"枚举的常量\",{\"1\":{\"944\":1}}],[\"枚举\",{\"1\":{\"944\":1}}],[\"枚举上\",{\"1\":{\"944\":1}}],[\"枚举例子\",{\"1\":{\"944\":1}}],[\"掌握elasticsearch的架构设计对于刚入行的技术人员来说是非常有价值的\",{\"1\":{\"1002\":1}}],[\"掌握各类jvm运行日志的生成与解析\",{\"1\":{\"942\":1}}],[\"掌握编程\",{\"1\":{\"210\":1}}],[\"研究jvm内存模型和对象创建过程\",{\"1\":{\"942\":1}}],[\"远未达到在行的程度\",{\"1\":{\"942\":1}}],[\"远程连接连接一个\",{\"1\":{\"1075\":1,\"1279\":1}}],[\"远程仓库\",{\"1\":{\"705\":1}}],[\"远程复制拷贝\",{\"1\":{\"94\":1}}],[\"堪称一代新高\",{\"1\":{\"940\":1}}],[\"思路简单\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"思想上做出重大改进\",{\"1\":{\"940\":1}}],[\"思考\",{\"1\":{\"761\":1}}],[\"思考上述crud中的问题\",{\"0\":{\"761\":1}}],[\"筛选待回收区域\",{\"1\":{\"940\":1}}],[\"筛选回收\",{\"1\":{\"936\":1,\"940\":1}}],[\"聪明\",{\"1\":{\"940\":1,\"952\":1}}],[\"铁子\",{\"1\":{\"940\":1}}],[\"极大的提高了工作效率\",{\"1\":{\"940\":1}}],[\"极大的简化了安装和配置的细节\",{\"1\":{\"245\":1}}],[\"增量同步\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"增量式并发回收\",{\"1\":{\"940\":1}}],[\"增量式地进行分代\",{\"1\":{\"940\":1}}],[\"增删快\",{\"1\":{\"946\":1}}],[\"增删慢但查找快\",{\"1\":{\"948\":1}}],[\"增删慢\",{\"1\":{\"946\":2}}],[\"增加\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"增加缓存处理\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"增加单节点性能以及避免单节点存储故障\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"增加分区数可以增加并行处理的能力\",{\"1\":{\"982\":1}}],[\"增加数据源\",{\"1\":{\"889\":1}}],[\"增加了它们的等待时间\",{\"1\":{\"574\":1}}],[\"增加了操作的复杂性\",{\"1\":{\"503\":1}}],[\"增加等待时间\",{\"1\":{\"574\":1}}],[\"增加开销\",{\"1\":{\"502\":1}}],[\"增加系统资源消耗占用\",{\"1\":{\"198\":1}}],[\"增加定位问题的难度\",{\"1\":{\"196\":1}}],[\"达到一个共同点\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"达到一种混合模型与新高度\",{\"1\":{\"940\":1}}],[\"达到高精度且高性能的铁子回收效果\",{\"1\":{\"940\":1}}],[\"达不到理想状态\",{\"1\":{\"938\":1}}],[\"脏读指的是读到了其他事务未提交的数据\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"脏读\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"脏\",{\"1\":{\"940\":3}}],[\"脏标记\",{\"1\":{\"938\":5}}],[\"卡片表\",{\"1\":{\"940\":1}}],[\"听起来有点高大上啊\",{\"1\":{\"1006\":1}}],[\"听说你小子很不错\",{\"1\":{\"1018\":1}}],[\"听说你对kafka的幂等性很感兴趣\",{\"1\":{\"996\":1}}],[\"听说你对kafka的ack机制很感兴趣\",{\"1\":{\"994\":1}}],[\"听说你对kafka的架构设计很感兴趣\",{\"1\":{\"986\":1}}],[\"听说你对kafka很感兴趣\",{\"1\":{\"984\":1}}],[\"听说你对redis分布式锁很感兴趣\",{\"1\":{\"970\":1}}],[\"听说你对\",{\"1\":{\"952\":1,\"954\":1,\"982\":1}}],[\"听说你对java集合中的map也很在行\",{\"1\":{\"948\":1}}],[\"听说你对java集合挺在行的\",{\"1\":{\"946\":1}}],[\"听说很牛逼的样子\",{\"1\":{\"940\":1}}],[\"听你一说\",{\"1\":{\"940\":1}}],[\"留下空隙\",{\"1\":{\"938\":1}}],[\"碎片化\",{\"1\":{\"938\":1}}],[\"浮动垃圾可能带来更长的gc停顿时间\",{\"1\":{\"938\":1}}],[\"啊\",{\"1\":{\"936\":1}}],[\"情景举例\",{\"1\":{\"936\":1}}],[\"情况就不一样了\",{\"1\":{\"966\":1}}],[\"情况就这么个情况\",{\"1\":{\"895\":1}}],[\"情况\",{\"1\":{\"831\":1}}],[\"情况下会有重复问题\",{\"1\":{\"385\":1}}],[\"情况三\",{\"1\":{\"141\":1}}],[\"情况二\",{\"1\":{\"141\":1,\"166\":1}}],[\"情况一\",{\"1\":{\"141\":1,\"166\":1}}],[\"帮我总结下\",{\"1\":{\"936\":1}}],[\"帮助初学者掌握项目的完整开发\",{\"1\":{\"1429\":1}}],[\"帮助我们更好地理解选主过程\",{\"1\":{\"1008\":1}}],[\"帮助我们快速整合第三方常用框架\",{\"1\":{\"836\":1}}],[\"帮助你更好地理解选主过程\",{\"1\":{\"1008\":1}}],[\"帮助你理解kafka的内部机制\",{\"1\":{\"974\":1}}],[\"帮助定位数据位置\",{\"1\":{\"494\":1}}],[\"帮助gc回收\",{\"1\":{\"286\":2}}],[\"帮助用户快速在本地搭建运行大模型\",{\"1\":{\"245\":1}}],[\"垃圾收集里最让我头疼的就是\",{\"1\":{\"940\":1}}],[\"垃圾收集器选择等\",{\"1\":{\"942\":1}}],[\"垃圾收集器跟我讲讲\",{\"1\":{\"938\":1}}],[\"垃圾收集器会根据这些内存区域中的对象进行回收\",{\"1\":{\"936\":1}}],[\"垃圾的回收\",{\"1\":{\"936\":1}}],[\"垃圾的判断\",{\"1\":{\"936\":1}}],[\"垃圾\",{\"1\":{\"936\":1}}],[\"垃圾就是那些不再被程序使用的对象\",{\"1\":{\"936\":1}}],[\"垃圾回收器组合\",{\"1\":{\"1151\":3,\"1342\":3}}],[\"垃圾回收的主要区域就是堆内存\",{\"1\":{\"936\":1}}],[\"垃圾回收的步骤\",{\"1\":{\"936\":1}}],[\"垃圾回收的时机\",{\"1\":{\"936\":1}}],[\"垃圾回收的机制\",{\"1\":{\"936\":1}}],[\"垃圾回收机制的主要内容\",{\"1\":{\"936\":1}}],[\"垃圾回收机制\",{\"0\":{\"936\":1},\"1\":{\"936\":1}}],[\"垃圾回收是jvm内存模型中非常重要的一部分\",{\"1\":{\"930\":1}}],[\"垃圾回收\",{\"1\":{\"930\":1}}],[\"垃圾回收整理一文中\",{\"1\":{\"692\":1}}],[\"综上\",{\"1\":{\"934\":1,\"952\":1}}],[\"综上所述\",{\"1\":{\"339\":1}}],[\"安全第一\",{\"1\":{\"934\":1}}],[\"安全性不错\",{\"1\":{\"1032\":1}}],[\"安全性\",{\"1\":{\"934\":1}}],[\"安装工具\",{\"0\":{\"909\":1}}],[\"安装docker稳定版\",{\"1\":{\"852\":1}}],[\"安装一些工具\",{\"1\":{\"852\":1}}],[\"安装教程\",{\"0\":{\"670\":1}}],[\"安装环境\",{\"1\":{\"669\":1}}],[\"安装和常用数据\",{\"1\":{\"613\":1}}],[\"安装和数据类型\",{\"1\":{\"587\":1}}],[\"安装目录截图\",{\"1\":{\"413\":1}}],[\"安装使用可视化工具插件head\",{\"0\":{\"408\":1},\"1\":{\"394\":1}}],[\"安装依赖\",{\"1\":{\"116\":1}}],[\"安装\",{\"0\":{\"123\":1,\"157\":1,\"595\":1,\"668\":1,\"672\":1,\"701\":1,\"895\":1},\"1\":{\"109\":2,\"114\":1,\"125\":1,\"408\":1,\"899\":1,\"909\":1}}],[\"幸好有jvm这个工具哥帮忙\",{\"1\":{\"934\":1}}],[\"难道要我一个个文件翻找吗\",{\"1\":{\"934\":1}}],[\"抱歉\",{\"1\":{\"932\":1}}],[\"永久\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"永久代的大小是固定的\",{\"1\":{\"930\":1}}],[\"永久代\",{\"1\":{\"930\":2}}],[\"永久代被移除\",{\"1\":{\"930\":2}}],[\"永远都是在学习和总结中不断超越自己\",{\"1\":{\"922\":1}}],[\"永远都会走在发展的最前沿\",{\"1\":{\"76\":1}}],[\"永远是\",{\"1\":{\"9\":1}}],[\"聊聊java的注解\",{\"1\":{\"944\":1}}],[\"聊聊\",{\"1\":{\"930\":1,\"960\":1}}],[\"聊聊我怎么用副业在赚钱\",{\"1\":{\"211\":1}}],[\"哈哈\",{\"1\":{\"926\":3,\"934\":2,\"974\":1,\"976\":2,\"986\":1,\"994\":1,\"996\":1,\"998\":1,\"1006\":1}}],[\"哈希槽听起来很有趣\",{\"1\":{\"968\":1}}],[\"哈希槽是一个固定数量的槽位\",{\"1\":{\"968\":1}}],[\"哈希槽\",{\"1\":{\"968\":1}}],[\"哈希函数\",{\"1\":{\"948\":1}}],[\"哈希函数的要求尽量满足平均分布\",{\"1\":{\"339\":1}}],[\"哈希的底层实现之一\",{\"1\":{\"633\":1}}],[\"哈希类型\",{\"1\":{\"589\":1}}],[\"哈希查询效率极高\",{\"1\":{\"499\":1}}],[\"哈希索引的效率较低\",{\"1\":{\"499\":1}}],[\"哈希索引\",{\"1\":{\"499\":1}}],[\"哈希索引就是采用哈希算法\",{\"1\":{\"495\":1}}],[\"哈希\",{\"0\":{\"336\":1,\"605\":1},\"1\":{\"636\":1}}],[\"哈希表使用链地址法来解决键冲突\",{\"1\":{\"626\":1}}],[\"哈希表在\",{\"1\":{\"625\":1}}],[\"哈希表保存的键值对会逐渐地增多或者减少\",{\"1\":{\"625\":1}}],[\"哈希表进行\",{\"1\":{\"624\":1}}],[\"哈希表只会在对\",{\"1\":{\"624\":1}}],[\"哈希表节点使用\",{\"1\":{\"624\":1}}],[\"哈希表节点\",{\"1\":{\"624\":1}}],[\"哈希表大小掩码\",{\"1\":{\"624\":1}}],[\"哈希表大小\",{\"1\":{\"624\":1}}],[\"哈希表数组\",{\"1\":{\"624\":1}}],[\"哈希表的实现\",{\"0\":{\"299\":1}}],[\"哈希表的构造\",{\"0\":{\"298\":1}}],[\"哈希表\",{\"0\":{\"297\":1,\"624\":1},\"1\":{\"613\":1,\"624\":3}}],[\"嗯\",{\"1\":{\"926\":2,\"932\":1,\"934\":2,\"936\":1,\"974\":1,\"976\":1,\"978\":3,\"984\":2,\"994\":2,\"1004\":2}}],[\"致力于大白话说清楚\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"致力于让每一位工程师拿到自己心仪的offer\",{\"1\":{\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1023\":1}}],[\"致力于最实用教程\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"648\":1,\"698\":1,\"732\":1}}],[\"讲解的真的很通俗易懂\",{\"1\":{\"966\":1}}],[\"讲解我们在面试中遇到的问题\",{\"1\":{\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1023\":1}}],[\"讲的很透彻\",{\"1\":{\"962\":1}}],[\"讲讲g1垃圾收集器的工作流程\",{\"1\":{\"936\":1}}],[\"讲遇到的问题和难点\",{\"1\":{\"394\":1}}],[\"系列面试题\",{\"1\":{\"1194\":1}}],[\"系列文章\",{\"0\":{\"1152\":1},\"1\":{\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1023\":1}}],[\"系统总是可以在有限的时间内对用户做出响应\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"系统提供的服务必须一直处于可用的状态\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"系统中将会出现多个不同的object类\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"系统缓冲区\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"系统立即就已经恢复\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"系统还没死透\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"系统异常\",{\"1\":{\"829\":1}}],[\"系统范围\",{\"1\":{\"706\":1}}],[\"系统可能会尝试将锁从更细的粒度升级到更粗的粒度\",{\"1\":{\"581\":1}}],[\"系统可能会选择一个或多个事务进行回滚\",{\"1\":{\"581\":1}}],[\"系统自动回滚事务\",{\"1\":{\"581\":1}}],[\"系统定期检查事务的执行状态\",{\"1\":{\"581\":1}}],[\"系统配置\",{\"1\":{\"574\":1}}],[\"系统前期开发阶段\",{\"1\":{\"525\":1}}],[\"系统会将数据逻辑地址传给磁盘\",{\"1\":{\"274\":1}}],[\"系统将要写入单元地址和数据分别放在地址总线和数据总线上\",{\"1\":{\"273\":1}}],[\"系统请求也将被阻塞\",{\"1\":{\"196\":1}}],[\"系统分页大小\",{\"1\":{\"106\":1}}],[\"系统操作\",{\"1\":{\"90\":1}}],[\"熟练运用设计模式\",{\"1\":{\"922\":1}}],[\"熟练使用redis\",{\"1\":{\"601\":1}}],[\"影响服务性能\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"影响性能\",{\"1\":{\"922\":1}}],[\"影响距离查询或近似查询\",{\"1\":{\"440\":1}}],[\"極端情况下\",{\"1\":{\"922\":1}}],[\"严格来说\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"严重影响查询性能\",{\"1\":{\"922\":1}}],[\"严苛\",{\"1\":{\"350\":1}}],[\"八股文种子选手\",{\"1\":{\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1022\":1}}],[\"八股文的朋友不要错过\",{\"1\":{\"920\":1}}],[\"收获颇丰\",{\"1\":{\"938\":1,\"966\":1}}],[\"收集器提出了并发收集和低停顿的理念\",{\"1\":{\"938\":1}}],[\"收集器虽然有缺陷\",{\"1\":{\"938\":1}}],[\"收集器的\",{\"1\":{\"938\":1}}],[\"收集器的主要优点是并发收集\",{\"1\":{\"938\":1}}],[\"收集器的优缺点分别是什么\",{\"1\":{\"938\":1}}],[\"收集器\",{\"1\":{\"936\":4}}],[\"收费吗\",{\"1\":{\"920\":1}}],[\"收录\",{\"1\":{\"4\":1}}],[\"涉及的列上建立索引\",{\"1\":{\"1192\":1,\"1375\":1}}],[\"涉及stw的阶段主要是\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"涉及到的源码我也在对话中做了标注\",{\"1\":{\"920\":1}}],[\"涉及一些基础命令和常见场景\",{\"1\":{\"587\":1}}],[\"考虑到减轻服务器性能方面\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"考虑到安全应当使用session\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"考虑列的访问模式和查询类型\",{\"1\":{\"510\":1}}],[\"考的没复习\",{\"1\":{\"920\":1}}],[\"干货满满\",{\"1\":{\"920\":1}}],[\"干了3年程序员\",{\"1\":{\"175\":1}}],[\"顺便说一下\",{\"1\":{\"918\":1}}],[\"顺序读写磁盘分为顺序读写与随机读写\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"顺序栈\",{\"0\":{\"291\":1}}],[\"顺序队列的实现可以使用数组来完成\",{\"1\":{\"288\":1}}],[\"顺序队列\",{\"0\":{\"288\":1},\"1\":{\"288\":1}}],[\"顺序存储实现\",{\"0\":{\"285\":1}}],[\"顺序存储结构是元素在存储器中的相对位置来表示数据元素之间的逻辑关系\",{\"1\":{\"284\":1}}],[\"顺序存储和链式存储\",{\"1\":{\"284\":1}}],[\"顺序向后读取一定长度的数据放入内存\",{\"1\":{\"274\":1}}],[\"效果不明显\",{\"1\":{\"922\":1}}],[\"效果是一样的\",{\"1\":{\"918\":1}}],[\"效率不高\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"效率比数组低\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"效率比\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"效率略低\",{\"1\":{\"948\":1}}],[\"效率low\",{\"1\":{\"936\":1}}],[\"效率较低\",{\"1\":{\"503\":1}}],[\"效率高且不产生碎片\",{\"1\":{\"936\":1}}],[\"效率高于serial\",{\"1\":{\"936\":1}}],[\"效率高\",{\"1\":{\"438\":1,\"936\":1}}],[\"效率会比自己写的循环高\",{\"1\":{\"285\":1}}],[\"撤销\",{\"1\":{\"918\":4}}],[\"意思是\",{\"1\":{\"918\":1}}],[\"意向排他锁\",{\"1\":{\"557\":1}}],[\"意向共识锁\",{\"1\":{\"557\":1}}],[\"意向锁是针对多粒度锁定协议的系统\",{\"1\":{\"557\":1}}],[\"意向锁\",{\"0\":{\"557\":1},\"1\":{\"575\":1}}],[\"几个概念的关系图可以参考下图\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"几个参数\",{\"1\":{\"918\":1}}],[\"几乎都可以不写xml配置了\",{\"1\":{\"944\":1}}],[\"几乎所有的对象实例都在这里分配内存\",{\"1\":{\"930\":1,\"1142\":1,\"1333\":1}}],[\"几乎是大白话式的对话\",{\"1\":{\"920\":1}}],[\"几乎是所有设计系统时都会遇到的\",{\"1\":{\"381\":1}}],[\"几乎覆盖我们生产\",{\"1\":{\"871\":1}}],[\"几乎每个写\",{\"1\":{\"844\":1}}],[\"几乎各一半\",{\"1\":{\"536\":1}}],[\"您说得对\",{\"1\":{\"946\":1}}],[\"您说的对\",{\"1\":{\"940\":1}}],[\"您好\",{\"1\":{\"928\":1,\"1431\":1}}],[\"您写的代码仍然保留\",{\"1\":{\"918\":1}}],[\"您必须声明一个索引列\",{\"1\":{\"526\":1}}],[\"举一个简单的例子\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"举个简单例子\",{\"1\":{\"958\":1}}],[\"举个自定义注解的例子\",{\"1\":{\"944\":1}}],[\"举个例子解释下\",{\"1\":{\"988\":1}}],[\"举个例子\",{\"1\":{\"420\":1,\"619\":1,\"635\":1,\"958\":2,\"966\":1,\"988\":2,\"1051\":1,\"1260\":1}}],[\"举例也很形象\",{\"1\":{\"934\":1}}],[\"举例\",{\"1\":{\"934\":1,\"1181\":1,\"1366\":1}}],[\"举例来说\",{\"1\":{\"917\":1}}],[\"挑拣\",{\"1\":{\"917\":1}}],[\"丢弃stash\",{\"1\":{\"916\":1}}],[\"起来\",{\"1\":{\"916\":1}}],[\"恢复时是将快照文件直接读入内存\",{\"1\":{\"962\":1}}],[\"恢复之前暂存的状态\",{\"1\":{\"916\":1}}],[\"恢复暂存时的状态有俩种命令\",{\"1\":{\"916\":1}}],[\"恢复到暂存时的状态\",{\"1\":{\"916\":1}}],[\"暂且认为它是\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"暂存起来\",{\"1\":{\"916\":1}}],[\"暂停容器\",{\"1\":{\"1063\":1,\"1269\":1}}],[\"暂停主线程2秒\",{\"1\":{\"692\":1}}],[\"暂停的时间\",{\"1\":{\"106\":1}}],[\"甲某\",{\"1\":{\"916\":1}}],[\"哼哧哼哧搞了起来\",{\"1\":{\"916\":1}}],[\"拉取新分支\",{\"1\":{\"915\":2,\"916\":1}}],[\"拉流保存\",{\"1\":{\"146\":1}}],[\"企业应用\",{\"1\":{\"950\":1}}],[\"企业生产环境中最常使用的git组合命令集\",{\"0\":{\"914\":1}}],[\"企业最终要的是可以创造价值\",{\"1\":{\"652\":1}}],[\"稍等几分钟\",{\"1\":{\"913\":1}}],[\"栏\",{\"1\":{\"913\":1}}],[\"绑定远端地址\",{\"1\":{\"913\":1}}],[\"阻止\",{\"1\":{\"911\":1}}],[\"阻塞\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"阻塞和非阻塞在于第一个\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"阻塞和非阻塞的\",{\"1\":{\"1032\":1}}],[\"阻塞等待事件发生\",{\"1\":{\"1020\":1}}],[\"阻塞到下一个毫秒\",{\"1\":{\"388\":2}}],[\"阻塞住查询请求\",{\"1\":{\"153\":1}}],[\"租云服务\",{\"1\":{\"906\":1}}],[\"终止\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"终生不变\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"终极办法02\",{\"0\":{\"898\":1}}],[\"终极办法01\",{\"0\":{\"897\":1}}],[\"终身学习我们一起行动\",{\"1\":{\"211\":1}}],[\"仔细阅读\",{\"1\":{\"895\":1}}],[\"密码\",{\"1\":{\"888\":1}}],[\"暴露路径\",{\"1\":{\"887\":1}}],[\"暴露端口\",{\"1\":{\"850\":1}}],[\"截图\",{\"0\":{\"867\":1}}],[\"截取前20位做唯一\",{\"1\":{\"385\":1}}],[\"驳回\",{\"1\":{\"865\":4}}],[\"镜像id``\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"镜像id\",{\"1\":{\"1062\":2,\"1268\":2}}],[\"镜像的所有命令\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"镜像的运行时实例\",{\"1\":{\"1057\":1,\"1263\":1}}],[\"镜像\",{\"1\":{\"854\":1,\"1061\":1,\"1267\":1}}],[\"忽略掉下划线开头的文件\",{\"1\":{\"911\":1}}],[\"忽略\",{\"1\":{\"852\":1}}],[\"拷贝\",{\"1\":{\"851\":1}}],[\"拷贝到项目的app\",{\"1\":{\"850\":1}}],[\"拷贝到\",{\"1\":{\"692\":1}}],[\"故名思思\",{\"1\":{\"844\":1}}],[\"利器\",{\"1\":{\"844\":1}}],[\"利用了操作系统本身的\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"利用\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"利用好多核\",{\"1\":{\"950\":1}}],[\"利用好硬件资源\",{\"1\":{\"950\":1}}],[\"利用好它提供的功能\",{\"1\":{\"922\":1}}],[\"利用数据库锁来控制资源的并发访问是不太理想的\",{\"1\":{\"594\":1}}],[\"利用数据库的自增id\",{\"1\":{\"383\":1}}],[\"利用缓存\",{\"1\":{\"525\":1}}],[\"利用映射函数将数据分配到各个桶中\",{\"1\":{\"352\":1}}],[\"利用它的反向代理功能提供负载均衡支持\",{\"1\":{\"106\":1}}],[\"填写项目名和相关配置\",{\"1\":{\"839\":1}}],[\"填写相关配置\",{\"1\":{\"838\":1}}],[\"填写必要信息\",{\"1\":{\"837\":1}}],[\"填写必要信息来生成\",{\"1\":{\"837\":1}}],[\"填充统计数组\",{\"1\":{\"360\":1}}],[\"细分\",{\"1\":{\"831\":1}}],[\"首次同步\",{\"1\":{\"964\":1}}],[\"首次执行是\",{\"1\":{\"830\":1}}],[\"首先选举产生新的\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"首先它提供了一个自动化配置类\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"首先判断bean是否实现了destructionawarebeanpostprocessor接口\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"首先判断该投票的有效性\",{\"1\":{\"166\":1}}],[\"首先提出了ioc\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"首先应该在业务上进行精简\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"首先应考虑在\",{\"1\":{\"1192\":1,\"1375\":1}}],[\"首先通过编译器把\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"首先通过对象的引用找到对应在堆内存的变量的值\",{\"1\":{\"692\":1}}],[\"首先由客户端发出请求\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"首先计算key的hash值\",{\"1\":{\"1120\":1,\"1315\":1}}],[\"首先需要了解java线程的6种状态\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"首先定义一个loginrequired注解\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"首先说一下基本\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"首先是分析需求\",{\"1\":{\"1439\":1}}],[\"首先是实例化bean\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"首先是位于一个类之中或者其子类中\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"首先是锁的超时时间\",{\"1\":{\"970\":1}}],[\"首先要了解什么是一致性\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"首先你一定要对\",{\"1\":{\"1041\":1}}],[\"首先简单说一下\",{\"1\":{\"954\":1}}],[\"首先大家要保证已经安装了\",{\"1\":{\"907\":1}}],[\"首先创建\",{\"1\":{\"692\":1}}],[\"首先考虑缓存\",{\"1\":{\"520\":1}}],[\"首先我们需要了解kafka的工作原理\",{\"1\":{\"984\":1}}],[\"首先我们需要简单的理解分布式和集群\",{\"1\":{\"165\":1}}],[\"首先我们创建个\",{\"1\":{\"844\":1}}],[\"首先我们就要去看是不是索引失效\",{\"1\":{\"501\":1}}],[\"首先\",{\"1\":{\"382\":1,\"509\":1,\"692\":1,\"966\":1,\"972\":1,\"976\":1,\"978\":2,\"980\":2,\"984\":2,\"992\":1,\"1012\":2,\"1088\":1,\"1119\":1,\"1232\":1,\"1289\":1,\"1314\":1,\"1407\":1,\"1431\":1}}],[\"首先根据个位数的数值\",{\"1\":{\"375\":1}}],[\"首先在根节点进行二分查找\",{\"1\":{\"267\":1}}],[\"首先分为\",{\"1\":{\"263\":1}}],[\"首先安装\",{\"1\":{\"250\":1}}],[\"首先会比较两者的zxid\",{\"1\":{\"166\":1}}],[\"首先就会去找这个leader\",{\"1\":{\"153\":1}}],[\"首先如果你是计算机的学生\",{\"1\":{\"98\":1}}],[\"抛出异常\",{\"1\":{\"830\":1}}],[\"角度设计接口\",{\"1\":{\"830\":1}}],[\"失效的场景下进行分区迁移\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"失效索引\",{\"1\":{\"501\":1}}],[\"失去了缓存的意义\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"失败了\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"失败做重试来保证消息的可靠性\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"失败\",{\"1\":{\"831\":1}}],[\"失败抛出异常\",{\"1\":{\"829\":1,\"830\":1}}],[\"封装页面抛出异常的对象\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"封装服务器运行环境的对象\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"封装服务器对客户端的响应\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"封装用户会话的对象\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"封装客户端的请求\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"封装请求信息\",{\"1\":{\"956\":1}}],[\"封装json对象\",{\"1\":{\"830\":1}}],[\"封装预约执行后结果\",{\"1\":{\"829\":1}}],[\"封面图\",{\"1\":{\"328\":1,\"380\":1,\"1438\":1}}],[\"识别不了\",{\"1\":{\"826\":1}}],[\"馆藏数量\",{\"1\":{\"824\":1,\"825\":1}}],[\"供用户自定义和配置\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"供全球用户浏览\",{\"1\":{\"913\":1}}],[\"供参考\",{\"1\":{\"824\":1}}],[\"供其它部件读取\",{\"1\":{\"273\":1}}],[\"给你提供一个免费的实例\",{\"1\":{\"1444\":1}}],[\"给类中的静态变量分配内存空间\",{\"1\":{\"1148\":1,\"1339\":1}}],[\"给类的静态变量赋予正确的初始值\",{\"1\":{\"934\":1}}],[\"给\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"给我普普通通地讲一讲泛型\",{\"1\":{\"966\":1}}],[\"给静态变量复杂的初始值\",{\"1\":{\"934\":1}}],[\"给出需要扫描dao接口包\",{\"1\":{\"815\":1}}],[\"给定一个非空的整数数组\",{\"1\":{\"353\":1}}],[\"端点来访问查看指定功能状态\",{\"1\":{\"1231\":1,\"1406\":1}}],[\"端浏览更佳\",{\"1\":{\"807\":1}}],[\"端口号都相同\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"端口号\",{\"1\":{\"648\":1}}],[\"端口是\",{\"1\":{\"177\":1}}],[\"手记微信阅读\",{\"1\":{\"1426\":1,\"1435\":1}}],[\"手到擒来\",{\"1\":{\"906\":1}}],[\"手把手\",{\"1\":{\"906\":1}}],[\"手把手springboot整合flowable\",{\"0\":{\"859\":1}}],[\"手把手整合\",{\"1\":{\"807\":1}}],[\"手把手整合ssm框架\",{\"0\":{\"807\":1}}],[\"手动提交位移\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"手动执行该脚本\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"手动\",{\"1\":{\"1049\":1,\"1052\":1,\"1258\":1,\"1261\":1}}],[\"手动过期\",{\"1\":{\"1048\":1,\"1049\":2,\"1257\":1,\"1258\":2}}],[\"手动控制目标方法调用时机\",{\"1\":{\"944\":1}}],[\"手动加了引号\",{\"1\":{\"780\":1}}],[\"手动加锁也就是显示的加表锁\",{\"1\":{\"572\":1}}],[\"手动给\",{\"0\":{\"572\":1}}],[\"案例5\",{\"0\":{\"919\":1}}],[\"案例4\",{\"0\":{\"918\":1}}],[\"案例3\",{\"0\":{\"917\":1}}],[\"案例2\",{\"0\":{\"916\":1},\"1\":{\"801\":1}}],[\"案例1\",{\"0\":{\"915\":1},\"1\":{\"801\":1}}],[\"案例\",{\"1\":{\"800\":1,\"844\":1}}],[\"案例源码仓库地址\",{\"1\":{\"112\":1}}],[\"冈本001\",{\"1\":{\"795\":1}}],[\"套子\",{\"1\":{\"795\":1}}],[\"香香的袜子\",{\"1\":{\"795\":1}}],[\"袜子\",{\"1\":{\"795\":1}}],[\"美女\",{\"1\":{\"789\":3,\"790\":2}}],[\"才对该bean进行加载实例化\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"才叫内存泄漏\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"才会将一个提案进行提交\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"才会把其一级缓存中的数据写入二级缓存\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"才会表现出多线程的特性\",{\"1\":{\"1098\":1,\"1296\":1}}],[\"才会清除掉\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"才会注入依赖对象\",{\"1\":{\"954\":1}}],[\"才会执行otherwise\",{\"1\":{\"785\":1}}],[\"才能对面试中的问题得心应手\",{\"1\":{\"1155\":1,\"1343\":1}}],[\"才能进行操作\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"才能同时开饭\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"才能关门睡觉\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"才能更好的理解docker\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"才能达到\",{\"1\":{\"958\":1}}],[\"才能准确地指出自己还需加深学习的知识点\",{\"1\":{\"948\":1}}],[\"才能删除表\",{\"1\":{\"864\":1}}],[\"才可以同时在一行记录加锁\",{\"1\":{\"555\":1}}],[\"鹏程\",{\"1\":{\"785\":3,\"786\":1,\"789\":5}}],[\"号\",{\"1\":{\"780\":1,\"1174\":1,\"1359\":1}}],[\"号打卡\",{\"1\":{\"658\":1}}],[\"改正\",{\"1\":{\"779\":1}}],[\"改变这个数组的类型\",{\"1\":{\"630\":1}}],[\"改变服务器的状态\",{\"1\":{\"166\":1}}],[\"改变服务器状态\",{\"1\":{\"166\":1}}],[\"报错\",{\"1\":{\"779\":1,\"827\":1}}],[\"报语法错误\",{\"1\":{\"779\":1}}],[\"报告\",{\"1\":{\"698\":1}}],[\"报告和文档的软件项目管理工具\",{\"1\":{\"698\":1}}],[\"书写查询sql语句\",{\"1\":{\"775\":1}}],[\"扫描web相关的bean\",{\"1\":{\"819\":1}}],[\"扫描web层\",{\"1\":{\"819\":1}}],[\"扫描service包下所有使用注解的类型\",{\"1\":{\"818\":1}}],[\"扫描sql配置文件\",{\"1\":{\"815\":1}}],[\"扫描\",{\"1\":{\"818\":1}}],[\"扫描entity包\",{\"1\":{\"815\":1}}],[\"扫描之后的别名就是类名\",{\"1\":{\"768\":1}}],[\"扫描指定包下的所有类\",{\"1\":{\"768\":1}}],[\"亦可通过\",{\"1\":{\"766\":1}}],[\"既保证了数据的持久性\",{\"1\":{\"962\":1}}],[\"既保证线程安全\",{\"1\":{\"922\":1}}],[\"既然单线程容易实现\",{\"1\":{\"1200\":1,\"1380\":1}}],[\"既然是分区再分配\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"既然你提到了\",{\"1\":{\"958\":1}}],[\"既然误算率一定存在\",{\"1\":{\"335\":1}}],[\"既可以支持快速查找\",{\"1\":{\"922\":1}}],[\"既可以保证查询效率\",{\"1\":{\"922\":1}}],[\"既可以在典型的\",{\"1\":{\"766\":1}}],[\"登录失效\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"登录\",{\"1\":{\"763\":1,\"779\":2}}],[\"登录后\",{\"1\":{\"109\":1}}],[\"硬编码到java代码中\",{\"1\":{\"761\":1}}],[\"硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块\",{\"1\":{\"274\":1}}],[\"外面加上单引号\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"外包装\",{\"1\":{\"988\":1}}],[\"外部的mapper\",{\"1\":{\"751\":1}}],[\"外键\",{\"1\":{\"560\":1}}],[\"外键锁这个术语并不是用来描述一种特定的锁类型\",{\"1\":{\"560\":1}}],[\"外键锁并不是一个标准的锁类型\",{\"1\":{\"560\":1}}],[\"外键锁顾名思义就是针对外键的\",{\"1\":{\"560\":1}}],[\"外键锁\",{\"0\":{\"560\":1}}],[\"外键引用\",{\"1\":{\"496\":1}}],[\"池类型的数据源\",{\"1\":{\"743\":2,\"745\":1}}],[\"池技术被广泛使用在系统开发中\",{\"1\":{\"645\":1}}],[\"唯一不足地方是\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"唯一的不足是占用内存空间\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"唯一\",{\"1\":{\"827\":1}}],[\"唯一标识符\",{\"1\":{\"838\":1,\"839\":1}}],[\"唯一标识\",{\"1\":{\"743\":1,\"744\":1,\"745\":1,\"755\":1,\"763\":4,\"776\":1,\"797\":1}}],[\"唯一索引有多个\",{\"1\":{\"496\":1}}],[\"唯一索引列的值必须唯一\",{\"1\":{\"495\":1}}],[\"唯一索引\",{\"1\":{\"495\":1,\"1189\":1,\"1372\":1}}],[\"静态的对象还是放在堆\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"静态代理只能代理一个类或接口\",{\"1\":{\"1016\":1}}],[\"静态代理需要手动编写代理类\",{\"1\":{\"1016\":1}}],[\"静态代理是在编译时就已经确定代理对象和被代理对象的关系\",{\"1\":{\"1016\":1}}],[\"静态代码块主要用于一次性地对类进行初始化设置\",{\"1\":{\"934\":1}}],[\"静态代码块执行\",{\"1\":{\"934\":2}}],[\"静态代码块是在类初始化阶段执行的\",{\"1\":{\"934\":1}}],[\"静态方法\",{\"1\":{\"934\":1}}],[\"静态常量\",{\"1\":{\"934\":1}}],[\"静态变量放在方法区\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"静态变量有内存了\",{\"1\":{\"934\":1}}],[\"静态变量等数据\",{\"1\":{\"930\":1}}],[\"静态变量\",{\"1\":{\"930\":1,\"934\":1,\"1142\":1,\"1333\":1}}],[\"静态资源默认servlet配置\",{\"1\":{\"819\":1}}],[\"静态工具类\",{\"1\":{\"388\":1}}],[\"静鹏\",{\"1\":{\"757\":1}}],[\"静静\",{\"1\":{\"736\":1,\"759\":1,\"763\":1,\"786\":1}}],[\"覆盖\",{\"1\":{\"724\":1}}],[\"覆盖索引是指一个查询可以完全通过索引来得到结果\",{\"1\":{\"504\":1}}],[\"覆盖索引\",{\"1\":{\"504\":1}}],[\"容错和自动恢复\",{\"1\":{\"950\":1}}],[\"容量加倍\",{\"1\":{\"948\":1}}],[\"容量capacity\",{\"1\":{\"948\":1}}],[\"容易被垃圾回收\",{\"1\":{\"922\":1}}],[\"容易造成阻塞\",{\"1\":{\"722\":1}}],[\"容器就会调用docreatebean\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"容器通过调用set方法或者是构造器来建立对象之间的依赖关系\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"容器内的\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"容器支持的\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"容器分为\",{\"1\":{\"1112\":1,\"1307\":1}}],[\"容器看起来就真的像是独立的操作系统了\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"容器经历以下阶段\",{\"1\":{\"1063\":1,\"1269\":1}}],[\"容器无法正常结束注入过程\",{\"1\":{\"954\":1}}],[\"容器中\",{\"1\":{\"954\":1}}],[\"容器中只有一个\",{\"1\":{\"952\":1}}],[\"容器启动时\",{\"1\":{\"952\":1}}],[\"容器启动时会调用\",{\"1\":{\"950\":1}}],[\"容器屏蔽了\",{\"1\":{\"950\":1}}],[\"容器实现的大致流程\",{\"1\":{\"950\":1}}],[\"容器会对\",{\"1\":{\"950\":1}}],[\"容器的生命周期\",{\"0\":{\"1063\":1,\"1269\":1}}],[\"容器的源码分析确实需要对它的原理有深入了解\",{\"1\":{\"950\":1}}],[\"容器的核心\",{\"1\":{\"950\":1}}],[\"容器的实现主要在\",{\"1\":{\"950\":1}}],[\"容器的实现你可以大致描述一下吗\",{\"1\":{\"950\":1}}],[\"容器管理对象依赖关系错乱\",{\"1\":{\"950\":1}}],[\"容器id\",{\"1\":{\"856\":2}}],[\"容器\",{\"0\":{\"1057\":1,\"1263\":1,\"1306\":1},\"1\":{\"524\":1,\"950\":1,\"1061\":1,\"1111\":1,\"1232\":1,\"1238\":1,\"1267\":1,\"1407\":1,\"1411\":1}}],[\"父类加载的类被所有的子类所信任\",{\"1\":{\"934\":1}}],[\"父项目的pom\",{\"1\":{\"715\":2}}],[\"父工程\",{\"1\":{\"715\":1}}],[\"父工程设置依赖\",{\"1\":{\"715\":1}}],[\"继承messagesource\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"继承vector\",{\"1\":{\"946\":1}}],[\"继承为了消除重复\",{\"1\":{\"715\":1}}],[\"继续阅读\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"继续重新选举即可\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"继续执行方法\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"继续执行其他任务\",{\"1\":{\"1020\":1}}],[\"继续往下执行\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"继续等待\",{\"1\":{\"1008\":1}}],[\"继续使用旧aof\",{\"1\":{\"962\":1}}],[\"继续保持\",{\"1\":{\"948\":1}}],[\"继续深入学习g1与其他垃圾收集器的设计与实现\",{\"1\":{\"940\":1}}],[\"继续努力深造\",{\"1\":{\"922\":1}}],[\"继续进行调整\",{\"1\":{\"364\":1}}],[\"继续调整\",{\"1\":{\"364\":1}}],[\"继续遍历数列并修改数组\",{\"1\":{\"359\":1}}],[\"继续\",{\"1\":{\"348\":1}}],[\"验证是否有正确的内部结构\",{\"1\":{\"934\":1}}],[\"验证通过了\",{\"1\":{\"934\":1}}],[\"验证\",{\"1\":{\"934\":2,\"1137\":1,\"1148\":1,\"1330\":1,\"1339\":1}}],[\"验证一下\",{\"1\":{\"898\":1}}],[\"验证包是否有效且达到质量标准\",{\"1\":{\"713\":1}}],[\"验证成功\",{\"1\":{\"702\":1}}],[\"绝对是有手就行\",{\"1\":{\"906\":1}}],[\"绝对不在集合中\",{\"1\":{\"342\":1}}],[\"绝大部分工作都发生在这个生命周期中\",{\"1\":{\"713\":1}}],[\"拥有了统一规范\",{\"1\":{\"705\":1}}],[\"许可等\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"许可证信息等\",{\"1\":{\"705\":1}}],[\"许多ffmpeg的开发人员都来自mplayer项目\",{\"1\":{\"122\":1}}],[\"私服\",{\"1\":{\"705\":2}}],[\"私有数据\",{\"1\":{\"624\":1}}],[\"仓库\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"仓库文件\",{\"1\":{\"913\":1}}],[\"仓库就是存放依赖和插件的地方\",{\"1\":{\"705\":1}}],[\"仓库地址\",{\"1\":{\"94\":1}}],[\"框架有哪些主要模块\",{\"0\":{\"1211\":1,\"1388\":1}}],[\"框架支持的\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"框架了\",{\"1\":{\"1033\":1}}],[\"框架的网络通信工具\",{\"1\":{\"1033\":1}}],[\"框架可以快速开发\",{\"1\":{\"950\":1}}],[\"框架使用\",{\"1\":{\"944\":1}}],[\"框架就已经搭建好了\",{\"1\":{\"824\":1}}],[\"框架\",{\"0\":{\"1211\":1,\"1388\":1},\"1\":{\"703\":1,\"704\":1,\"950\":1,\"956\":1,\"1172\":1,\"1357\":1}}],[\"输入参数类型可以是\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"输入参数映射过程类似于\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"输入参数映射\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"输入访问地址\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"输入\",{\"1\":{\"702\":1}}],[\"输出服务器响应的输出流对象\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"输出详细的gc日志\",{\"1\":{\"942\":1}}],[\"输出gc\",{\"1\":{\"942\":1}}],[\"输出的结果也是不同的\",{\"1\":{\"928\":1}}],[\"输出结果类型可以是\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"输出结果映射过程类似于\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"输出结果映射\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"输出结果表明i1和i2指向的是同一个对象\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"输出结果\",{\"1\":{\"360\":1}}],[\"输出数组元素的下标值\",{\"1\":{\"359\":1}}],[\"输出\",{\"1\":{\"143\":1,\"932\":1,\"1044\":1,\"1104\":1,\"1253\":1,\"1302\":1}}],[\"含有settings\",{\"1\":{\"701\":1}}],[\"含有maven运行时所需要的java类库\",{\"1\":{\"701\":1}}],[\"含有mvn运行的脚本\",{\"1\":{\"701\":1}}],[\"含有plexus\",{\"1\":{\"701\":1}}],[\"含义是5个primary\",{\"1\":{\"422\":1}}],[\"概念\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"概念来管理项目\",{\"1\":{\"698\":1}}],[\"概念关系\",{\"1\":{\"424\":1}}],[\"专注于面试\",{\"1\":{\"1026\":1,\"1030\":1,\"1056\":1,\"1126\":1,\"1141\":1,\"1155\":1,\"1171\":1,\"1210\":1,\"1223\":1,\"1236\":1}}],[\"专家\",{\"1\":{\"698\":1}}],[\"专门针对设计模式在生产环境怎么用\",{\"1\":{\"84\":1}}],[\"各路大佬又在这上边做了包装\",{\"1\":{\"1443\":1}}],[\"各自的\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"各自的继承结构\",{\"0\":{\"1112\":1,\"1307\":1}}],[\"各种常用组件及配置已经默认配置完成\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"各有其优缺点\",{\"1\":{\"1047\":1,\"1049\":1,\"1256\":1,\"1258\":1}}],[\"各有什么优缺点\",{\"1\":{\"936\":1}}],[\"各位看官\",{\"1\":{\"698\":1}}],[\"各个主机中的数据是否仍然处于一致的状态\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"各个服务独立部署在不同的服务器上\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"各个齿轮分别带动时针\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"各个namespace下的资源互不干扰\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"各个磁盘必须同步转动\",{\"1\":{\"274\":1}}],[\"各个自媒体更是跟风传着各种小道消息\",{\"1\":{\"76\":1}}],[\"强调父类的调用子类的特性\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"强烈建议大家实操\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"强转\",{\"1\":{\"966\":1}}],[\"强制线程每次读取该值的时候都去\",{\"1\":{\"692\":1}}],[\"强依赖机器时钟\",{\"1\":{\"387\":1}}],[\"秒的不可用时间窗口\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"秒\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"秒钟以后控制台打印\",{\"1\":{\"692\":1}}],[\"秒杀预约结果状态\",{\"1\":{\"829\":1}}],[\"秒杀抢购等等\",{\"1\":{\"664\":1}}],[\"秒杀等场景\",{\"1\":{\"594\":1}}],[\"似乎我的回答没有完全满足您的需求\",{\"1\":{\"932\":1}}],[\"似乎\",{\"1\":{\"692\":1}}],[\"描述直接展示出来显得不太正式\",{\"1\":{\"1431\":1}}],[\"描述一下\",{\"0\":{\"1071\":1,\"1214\":1,\"1275\":1,\"1391\":1}}],[\"描述\",{\"0\":{\"1063\":1,\"1269\":1},\"1\":{\"1000\":1}}],[\"描述这写交互\",{\"1\":{\"692\":1}}],[\"描述了各个概念所处的场景和作用\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"描述了\",{\"1\":{\"692\":1}}],[\"变换和聚合等各类操作\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"变式\",{\"0\":{\"1121\":1,\"1316\":1}}],[\"变成\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"变成o\",{\"1\":{\"922\":1}}],[\"变得太大\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"变量都会进行自增\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"变量名等\",{\"1\":{\"934\":1}}],[\"变量用于表示当前锁的状态\",{\"1\":{\"932\":1}}],[\"变量被声明为\",{\"1\":{\"924\":2}}],[\"变量没有被声明为\",{\"1\":{\"924\":2}}],[\"变量读写操作的实现\",{\"1\":{\"924\":1}}],[\"变量的修改\",{\"1\":{\"924\":2}}],[\"变量的值变为\",{\"1\":{\"924\":1}}],[\"变量的值时\",{\"1\":{\"924\":2}}],[\"变量的读操作和写操作合并为一个操作\",{\"1\":{\"924\":1}}],[\"变量的读写操作与其他指令重排序\",{\"1\":{\"924\":1}}],[\"变量的读写操作前后插入内存屏障\",{\"1\":{\"924\":1}}],[\"变量的具体值load到线程本地内存中\",{\"1\":{\"692\":1}}],[\"变量\",{\"1\":{\"692\":1,\"924\":4,\"932\":1,\"1119\":2,\"1314\":2}}],[\"变更内容\",{\"1\":{\"182\":1}}],[\"变更状态\",{\"1\":{\"166\":1}}],[\"块语句\",{\"1\":{\"692\":1}}],[\"谢谢您的夸奖\",{\"1\":{\"1010\":1,\"1016\":1}}],[\"谢谢您的提问\",{\"1\":{\"928\":1,\"930\":1,\"938\":1,\"940\":1}}],[\"谢谢邀请\",{\"1\":{\"968\":1}}],[\"谢谢你\",{\"1\":{\"988\":1}}],[\"谢谢你将这些泛型的概念讲解的如此清晰和深入\",{\"1\":{\"966\":1}}],[\"谢谢你的帮助\",{\"1\":{\"1008\":1}}],[\"谢谢你的解释\",{\"1\":{\"1006\":1}}],[\"谢谢你的解答\",{\"1\":{\"986\":1,\"994\":1,\"996\":1,\"1008\":1}}],[\"谢谢你的提问\",{\"1\":{\"974\":1}}],[\"谢谢你的分享\",{\"1\":{\"972\":1,\"982\":1,\"984\":1,\"1004\":1}}],[\"谢谢你的时间和分享\",{\"1\":{\"974\":1}}],[\"谢谢你的时间\",{\"1\":{\"970\":1,\"998\":1}}],[\"谢谢你的精彩讲解\",{\"1\":{\"966\":1}}],[\"谢谢你的回答\",{\"1\":{\"926\":1,\"990\":1,\"1010\":1}}],[\"谢谢面试官\",{\"1\":{\"958\":1}}],[\"谢谢面试官的肯定\",{\"1\":{\"1018\":1}}],[\"谢谢面试官的提问\",{\"1\":{\"1018\":1}}],[\"谢谢面试官的精彩问题\",{\"1\":{\"966\":1}}],[\"谢谢面试官的赞赏和提议\",{\"1\":{\"940\":1}}],[\"谢谢面试官的夸奖\",{\"1\":{\"922\":1,\"934\":1,\"966\":1}}],[\"谢谢夸奖\",{\"1\":{\"942\":1,\"946\":1,\"948\":1,\"976\":2}}],[\"谢谢详细的解释\",{\"1\":{\"938\":1}}],[\"谢谢\",{\"1\":{\"692\":1,\"922\":1,\"952\":1,\"954\":1,\"988\":1,\"1006\":1}}],[\"异步通信\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"异步非阻塞io\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"异步保存日志\",{\"1\":{\"689\":1}}],[\"异常抛出前后等\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"异常通知\",{\"1\":{\"944\":1}}],[\"异常\",{\"0\":{\"853\":1},\"1\":{\"524\":1,\"830\":1,\"926\":1,\"1023\":2,\"1034\":1}}],[\"环绕通知\",{\"1\":{\"944\":1,\"1092\":1,\"1293\":1}}],[\"环绕\",{\"1\":{\"689\":1}}],[\"环境下\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"环境安装\",{\"0\":{\"886\":1}}],[\"环境搭建\",{\"0\":{\"810\":1}}],[\"环境介绍\",{\"0\":{\"402\":1}}],[\"环境\",{\"0\":{\"771\":1,\"1444\":1},\"1\":{\"114\":1,\"743\":1,\"745\":1,\"1177\":1,\"1362\":1}}],[\"⑤\",{\"1\":{\"688\":1,\"1220\":2,\"1397\":2}}],[\"④\",{\"1\":{\"688\":1,\"1220\":2,\"1397\":2}}],[\"③\",{\"1\":{\"688\":1,\"1220\":2,\"1397\":2}}],[\"②排除依赖包中所包含的依赖关系\",{\"1\":{\"710\":1}}],[\"②\",{\"1\":{\"688\":1,\"1216\":1,\"1220\":2,\"1393\":1,\"1397\":2}}],[\"①所包含坐标\",{\"1\":{\"710\":1}}],[\"①\",{\"1\":{\"688\":1,\"1216\":1,\"1220\":2,\"1393\":1,\"1397\":2}}],[\"切点分为execution方式和annotation方式\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"切点用于定义\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"切点\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"切面可以在类上使用\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"切面\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"切面最主要的就是切点\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"切面注解权限\",{\"1\":{\"683\":1}}],[\"切面注解锁\",{\"1\":{\"683\":1}}],[\"切面注解日志\",{\"0\":{\"685\":1},\"1\":{\"683\":1}}],[\"切换分支\",{\"1\":{\"915\":1}}],[\"切换\",{\"1\":{\"897\":1}}],[\"切换图标\",{\"1\":{\"889\":1}}],[\"切换国内加速镜像\",{\"1\":{\"852\":1}}],[\"切换到\",{\"1\":{\"597\":2,\"917\":1}}],[\"切换basfe帐户\",{\"1\":{\"94\":1}}],[\"国内镜像\",{\"1\":{\"896\":1}}],[\"国内镜像地址\",{\"1\":{\"671\":1}}],[\"国内版本镜像页\",{\"1\":{\"405\":1}}],[\"详细信息\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"详细介绍\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"详细描述一下\",{\"0\":{\"1072\":1,\"1076\":1,\"1276\":1,\"1280\":1}}],[\"详细流程说明\",{\"1\":{\"956\":1}}],[\"详细参考文档及视频同步更新\",{\"1\":{\"668\":1}}],[\"详情\",{\"0\":{\"54\":1,\"60\":1}}],[\"造成数据库压力过大\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"造成集群内大量的调整\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"造成mybatis无法填充对应的字段信息\",{\"1\":{\"759\":1}}],[\"造成的后果是\",{\"1\":{\"664\":1}}],[\"造成现有客户端无法使用\",{\"1\":{\"181\":1}}],[\"抢占锁\",{\"1\":{\"664\":1}}],[\"抢到后再设置过期时间\",{\"1\":{\"664\":1}}],[\"众所周知\",{\"1\":{\"664\":1}}],[\"离线可以扫描二维码\",{\"1\":{\"877\":1}}],[\"离bug远一点\",{\"0\":{\"664\":1}}],[\"离左上角的坐标\",{\"1\":{\"140\":1}}],[\"占用存储无疑是很大的\",{\"1\":{\"659\":1}}],[\"占用存储空间越大\",{\"1\":{\"433\":1}}],[\"量同步\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"量级的基数统计\",{\"1\":{\"659\":1}}],[\"量就越大\",{\"1\":{\"270\":1}}],[\"呢\",{\"0\":{\"1032\":1},\"1\":{\"658\":1,\"988\":1}}],[\"耐心看完\",{\"1\":{\"657\":1}}],[\"抖音热搜\",{\"1\":{\"657\":1}}],[\"差集都可以这样操作\",{\"1\":{\"656\":1}}],[\"条件注解就是\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"条件\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"条件变量偏移量\",{\"1\":{\"1023\":1}}],[\"条件变量等待时间偏移量\",{\"1\":{\"1023\":1}}],[\"条件变量等待时间\",{\"1\":{\"1023\":1}}],[\"条件中包含\",{\"1\":{\"501\":1}}],[\"条的数据\",{\"1\":{\"655\":1}}],[\"粉丝列表等需要缓存的场景\",{\"1\":{\"655\":1}}],[\"订单编号的生成\",{\"1\":{\"653\":1}}],[\"订阅系统\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"订阅\",{\"1\":{\"1237\":1,\"1244\":1,\"1410\":1,\"1417\":1}}],[\"订阅并消费消息\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"订阅模式来传递消息\",{\"1\":{\"992\":1}}],[\"订阅模式\",{\"1\":{\"980\":1}}],[\"订阅及阻塞队列功能\",{\"1\":{\"594\":1}}],[\"订阅机制\",{\"1\":{\"589\":1}}],[\"⚠️注意\",{\"1\":{\"652\":1}}],[\"背后的原理\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"背最少的面试题\",{\"1\":{\"1039\":1}}],[\"背的很熟\",{\"1\":{\"932\":1}}],[\"背诵八股文已经不是找工作的绝对王牌\",{\"1\":{\"652\":1}}],[\"背景\",{\"1\":{\"386\":1}}],[\"怎么解决\",{\"0\":{\"1202\":1,\"1382\":1},\"1\":{\"1202\":1,\"1203\":1,\"1382\":1,\"1383\":1}}],[\"怎么解决http协议无状态协议\",{\"1\":{\"1027\":1}}],[\"怎么确保它们按顺序执行\",{\"0\":{\"1107\":1,\"1305\":1}}],[\"怎么回收\",{\"1\":{\"936\":1}}],[\"怎么办\",{\"0\":{\"1074\":1,\"1278\":1},\"1\":{\"918\":1}}],[\"怎么就找不到心意的工作\",{\"1\":{\"652\":1}}],[\"怎么这么难呢\",{\"1\":{\"90\":1}}],[\"归\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"归还连接到连接池\",{\"1\":{\"648\":1}}],[\"归并排序\",{\"1\":{\"357\":1,\"359\":1}}],[\"归并排序和快速排序\",{\"0\":{\"302\":1}}],[\"依此形成一个链条\",{\"1\":{\"934\":1}}],[\"依此类推\",{\"1\":{\"727\":1}}],[\"依赖注入\",{\"1\":{\"1229\":1,\"1404\":1}}],[\"依赖注入之前\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"依赖注入和生命周期管理\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"依赖注入是我们实现控制反转的一种手段\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"依赖管理和自动配置的能力\",{\"1\":{\"950\":1}}],[\"依赖管理和项目信息管理\",{\"1\":{\"699\":1}}],[\"依赖了slf4j1\",{\"1\":{\"709\":1}}],[\"依赖冲突频发\",{\"1\":{\"1443\":1}}],[\"依赖冲突是很常见的问题\",{\"1\":{\"709\":1}}],[\"依赖冲突\",{\"0\":{\"709\":1}}],[\"依赖于a\",{\"1\":{\"708\":1}}],[\"依赖的范围如下表\",{\"1\":{\"707\":1}}],[\"依赖范围scope\",{\"1\":{\"706\":1}}],[\"依赖范围\",{\"0\":{\"706\":1},\"1\":{\"706\":1}}],[\"依赖\",{\"1\":{\"648\":1,\"707\":2,\"715\":1,\"954\":3,\"1444\":1}}],[\"依次方便\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"依次将消息发送该topic下的所有分区\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"依次递归\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"依次进行一次排序\",{\"1\":{\"374\":1}}],[\"依次出队\",{\"1\":{\"289\":3}}],[\"依次插入1\",{\"1\":{\"289\":1}}],[\"动态获取数据\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"动态的给一个对象添加一些额外的功能\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"动态的决定实例化哪个类\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"动态地生成一个代理类的字节码\",{\"1\":{\"1016\":1}}],[\"动态地生成一个代理类\",{\"1\":{\"1016\":1}}],[\"动态地获取和设置泛型信息\",{\"1\":{\"1010\":1}}],[\"动态地获取和设置注解\",{\"1\":{\"1010\":1}}],[\"动态地获取和设置数组元素\",{\"1\":{\"1010\":1}}],[\"动态地获取和设置属性值\",{\"1\":{\"1010\":1}}],[\"动态地调用方法\",{\"1\":{\"1010\":1}}],[\"动态地创建对象\",{\"1\":{\"1010\":1}}],[\"动态选择部分内容\",{\"1\":{\"958\":1}}],[\"动态\",{\"0\":{\"1177\":1,\"1362\":1},\"1\":{\"958\":1,\"1177\":1,\"1362\":1}}],[\"动态预测并调整回收率与吞吐量\",{\"1\":{\"940\":1}}],[\"动态调整回收频率与时间\",{\"1\":{\"940\":1}}],[\"动态链接\",{\"1\":{\"930\":1,\"1142\":1,\"1333\":1}}],[\"动态扩容\",{\"1\":{\"922\":1}}],[\"动态实现dao接口\",{\"1\":{\"815\":1}}],[\"动态sql\",{\"0\":{\"783\":1}}],[\"动态代理会根据指定的接口或类\",{\"1\":{\"1016\":1}}],[\"动态代理只能代理接口\",{\"1\":{\"1016\":1}}],[\"动态代理还可以实现\",{\"1\":{\"1016\":1}}],[\"动态代理的实现原理是基于\",{\"1\":{\"1016\":1}}],[\"动态代理的实现依赖于反射机制\",{\"1\":{\"1016\":1}}],[\"动态代理的缺点是性能比较低\",{\"1\":{\"1016\":1}}],[\"动态代理的优点是可以在运行时动态地创建代理对象\",{\"1\":{\"1016\":1}}],[\"动态代理通常用于实现\",{\"1\":{\"1016\":1}}],[\"动态代理是一种基于反射的机制\",{\"1\":{\"1016\":1}}],[\"动态代理\",{\"0\":{\"1016\":1},\"1\":{\"920\":1}}],[\"动态代理实现\",{\"1\":{\"815\":1}}],[\"动态代理总结\",{\"0\":{\"764\":1}}],[\"动态代理mapper实现类\",{\"0\":{\"760\":1}}],[\"动态维护着\",{\"1\":{\"647\":1}}],[\"动态mapping\",{\"0\":{\"431\":1}}],[\"修饰符\",{\"1\":{\"966\":1,\"1091\":1,\"1292\":1}}],[\"修饰的变量\",{\"1\":{\"692\":1}}],[\"修饰的方法\",{\"1\":{\"692\":1}}],[\"修正并发标记期间的错误标记\",{\"1\":{\"940\":1}}],[\"修正并发标记期间并发修改导致的错误标记\",{\"1\":{\"936\":1}}],[\"修正在并发标记期间并发修改导致的错误标记\",{\"1\":{\"938\":1}}],[\"修炼之连接池篇\",{\"1\":{\"647\":1}}],[\"修改注释完毕后保存就好了\",{\"1\":{\"918\":1}}],[\"修改用户信息\",{\"1\":{\"786\":1}}],[\"修改测试用例的setup方法\",{\"1\":{\"762\":1}}],[\"修改方法\",{\"1\":{\"759\":1}}],[\"修改全局配置文件\",{\"0\":{\"745\":1}}],[\"修改如下\",{\"1\":{\"702\":1}}],[\"修改密码\",{\"1\":{\"673\":1}}],[\"修改redis\",{\"1\":{\"673\":1}}],[\"修改配置\",{\"0\":{\"673\":1,\"864\":1},\"1\":{\"887\":1}}],[\"修改和查询存在操作\",{\"1\":{\"603\":1}}],[\"修改后\",{\"1\":{\"438\":1}}],[\"修改\",{\"1\":{\"178\":1,\"406\":1,\"820\":1,\"1018\":1}}],[\"修改文件\",{\"1\":{\"125\":1}}],[\"受控的资源使用\",{\"1\":{\"645\":1}}],[\"白银一\",{\"0\":{\"639\":1,\"640\":1}}],[\"白嫖原创pdf\",{\"1\":{\"368\":1,\"732\":1}}],[\"五种类型的对象\",{\"1\":{\"636\":1}}],[\"五类数据结构\",{\"0\":{\"599\":1}}],[\"符号引用就理解为一个标示\",{\"1\":{\"1148\":1,\"1339\":1}}],[\"符号被过滤\",{\"1\":{\"411\":1}}],[\"符串\",{\"1\":{\"636\":1}}],[\"连一个搞中医的朋友都要要做一个自己的网站\",{\"1\":{\"906\":1}}],[\"连连接池是创建和管理一个连接的缓冲池的技术\",{\"1\":{\"645\":1}}],[\"连续的空间\",{\"1\":{\"632\":1}}],[\"连续的内存空间\",{\"1\":{\"632\":1}}],[\"连接点\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"连接\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"连接共享\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"连接完成后将业务处理交给线程池处理\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"连接zookeeper\",{\"1\":{\"1008\":1}}],[\"连接主机\",{\"1\":{\"964\":1}}],[\"连接一样操作\",{\"1\":{\"645\":1}}],[\"连接在系统初始化时就创建完成\",{\"1\":{\"645\":1}}],[\"连接池的静态块\",{\"1\":{\"648\":1}}],[\"连接池能够控制一个模块的资源占用率\",{\"1\":{\"645\":1}}],[\"连接池\",{\"0\":{\"644\":1,\"645\":1,\"646\":1,\"648\":1},\"1\":{\"645\":1,\"648\":3}}],[\"连接数\",{\"1\":{\"515\":1}}],[\"连接成功后\",{\"1\":{\"106\":2}}],[\"升级操作为整数集合带来了操作上的灵活性\",{\"1\":{\"630\":1}}],[\"升级为表锁可以简化锁管理\",{\"1\":{\"574\":1}}],[\"随时都可以问我\",{\"1\":{\"996\":1,\"1008\":1}}],[\"随时问我\",{\"1\":{\"986\":1}}],[\"随时问我哦\",{\"1\":{\"972\":1}}],[\"随时告诉我哦\",{\"1\":{\"1012\":1}}],[\"随时告诉我\",{\"1\":{\"974\":1,\"1002\":1}}],[\"随便写\",{\"1\":{\"744\":2,\"755\":2,\"763\":5,\"776\":1}}],[\"随机数\",{\"1\":{\"629\":1}}],[\"随着\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"随着字典操作的不断执行\",{\"1\":{\"625\":1}}],[\"随着操作的不断执行\",{\"1\":{\"625\":1}}],[\"随着公司业务快速发展\",{\"1\":{\"515\":1}}],[\"随着功能开发的日趋完善\",{\"1\":{\"181\":1}}],[\"速度\",{\"1\":{\"1167\":1,\"1190\":1,\"1355\":1,\"1373\":1}}],[\"速度快\",{\"1\":{\"936\":1,\"938\":1,\"960\":1}}],[\"速度就越快\",{\"1\":{\"628\":1}}],[\"速度相差了近\",{\"1\":{\"266\":1}}],[\"渐进式\",{\"1\":{\"625\":1}}],[\"维持在一个合理的范围之内\",{\"1\":{\"625\":1}}],[\"维护等步骤\",{\"1\":{\"1439\":1}}],[\"维护成本\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"维护\",{\"1\":{\"517\":1}}],[\"维护文档\",{\"1\":{\"182\":1}}],[\"维护接口文档版本更新\",{\"0\":{\"182\":1}}],[\"销毁\",{\"1\":{\"1128\":2,\"1321\":2}}],[\"销毁容器\",{\"1\":{\"1063\":1,\"1269\":1}}],[\"销毁前调用这个方法\",{\"1\":{\"952\":1}}],[\"销毁阶段\",{\"1\":{\"952\":1}}],[\"销毁值的函数\",{\"1\":{\"624\":1}}],[\"销毁键的函数\",{\"1\":{\"624\":1}}],[\"销毁代价比较大的数据库连接\",{\"1\":{\"77\":1}}],[\"键比较使用==而非equals\",{\"1\":{\"948\":1}}],[\"键有序\",{\"1\":{\"948\":1}}],[\"键是弱引用\",{\"1\":{\"922\":1}}],[\"键是枚举类型\",{\"1\":{\"922\":1}}],[\"键值\",{\"0\":{\"1176\":1,\"1361\":1}}],[\"键值读写依然是单线程\",{\"1\":{\"664\":1}}],[\"键值对已经过期\",{\"1\":{\"960\":1}}],[\"键值对\",{\"1\":{\"605\":1}}],[\"键对象\",{\"1\":{\"635\":1}}],[\"键\",{\"1\":{\"624\":1}}],[\"兼容部分\",{\"1\":{\"620\":1}}],[\"库恢复\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"库存不足异常\",{\"1\":{\"829\":1}}],[\"库存不足\",{\"1\":{\"829\":1,\"830\":1}}],[\"库中的函数\",{\"1\":{\"620\":1}}],[\"库内的水平分表\",{\"1\":{\"519\":1}}],[\"库内垂直分表只解决了单一表数据量过大的问题\",{\"1\":{\"517\":1}}],[\"杜绝缓冲区溢出\",{\"1\":{\"620\":1}}],[\"形成链表\",{\"1\":{\"624\":1}}],[\"形成了一个有序链表\",{\"1\":{\"503\":1}}],[\"形式\",{\"1\":{\"615\":1}}],[\"跳跃表中的节点按照分值大小进行排序\",{\"1\":{\"629\":1}}],[\"跳跃表信息\",{\"1\":{\"629\":1}}],[\"跳跃表是有序集合的底层实现之一\",{\"1\":{\"629\":1}}],[\"跳跃表节点的\",{\"1\":{\"628\":1}}],[\"跳跃表节点\",{\"1\":{\"628\":1}}],[\"跳跃表\",{\"0\":{\"627\":1,\"628\":1},\"1\":{\"613\":1}}],[\"跳转到指定行号\",{\"1\":{\"94\":1}}],[\"青铜\",{\"0\":{\"611\":1,\"612\":1},\"1\":{\"608\":1,\"641\":1,\"647\":1}}],[\"却可以重复\",{\"1\":{\"607\":1}}],[\"迭代器会新维护一个初始值等于\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"迭代顺序不定\",{\"1\":{\"922\":1}}],[\"迭代有序集合中的元素\",{\"1\":{\"607\":1}}],[\"迭代集合中的元素\",{\"1\":{\"606\":1}}],[\"迭代哈希表中的键值对\",{\"1\":{\"605\":1}}],[\"向客户端表明可以取消连接了\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"向有序集合添加一个或多个成员\",{\"1\":{\"607\":1}}],[\"向集合添加一个或多个成员\",{\"1\":{\"606\":1}}],[\"向下取整\",{\"1\":{\"352\":1}}],[\"尾部\",{\"1\":{\"604\":1}}],[\"尾指针\",{\"1\":{\"288\":1}}],[\"精度可以使用毫秒或秒\",{\"1\":{\"603\":1}}],[\"太好了\",{\"1\":{\"968\":1,\"976\":1,\"986\":1,\"992\":1,\"1000\":1}}],[\"太棒了\",{\"1\":{\"966\":1,\"968\":1,\"974\":2,\"978\":1,\"980\":1,\"982\":1,\"984\":2,\"986\":1,\"990\":1,\"992\":1,\"998\":3,\"1000\":1,\"1002\":1,\"1004\":1,\"1008\":1}}],[\"太难了\",{\"1\":{\"652\":1}}],[\"太短的键值通常也不是好主意\",{\"1\":{\"602\":1}}],[\"太长的键值不是个好主意\",{\"1\":{\"602\":1}}],[\"工厂bean\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"工厂方法模式\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"工业级应用的规模越来越庞大\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"工具\",{\"1\":{\"909\":1}}],[\"工具类\",{\"1\":{\"876\":1}}],[\"工具连接使用\",{\"1\":{\"601\":1}}],[\"工程\",{\"1\":{\"811\":1}}],[\"工作状态有哪些\",{\"0\":{\"1239\":1,\"1412\":1}}],[\"工作内存中\",{\"1\":{\"692\":1}}],[\"工作完成之后\",{\"1\":{\"625\":1}}],[\"工作正式开始\",{\"1\":{\"625\":1}}],[\"工作原理\",{\"1\":{\"499\":2}}],[\"工作id\",{\"1\":{\"388\":1}}],[\"工作机器id\",{\"1\":{\"388\":1}}],[\"工作的原理是将数组分到有限数量的桶子里\",{\"1\":{\"348\":1}}],[\"工作一年起码顶俩年\",{\"1\":{\"225\":1}}],[\"工作总结\",{\"0\":{\"189\":1},\"1\":{\"189\":1}}],[\"工作模式与连接数上限\",{\"1\":{\"106\":1}}],[\"工作中最常用shell指令\",{\"1\":{\"94\":1}}],[\"散列成对应\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"散列\",{\"1\":{\"601\":1,\"619\":1}}],[\"窗口\",{\"1\":{\"597\":3}}],[\"盘\",{\"1\":{\"597\":1}}],[\"盘片被划分成一系列同心环\",{\"1\":{\"274\":1}}],[\"流式处理平台\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"流式回复\",{\"1\":{\"251\":1}}],[\"流量削峰\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"流量削峰及异步处理实时性低的业务\",{\"1\":{\"594\":1}}],[\"流程如下\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"流程id为\",{\"1\":{\"866\":1}}],[\"踩\",{\"1\":{\"594\":1}}],[\"社区活跃\",{\"1\":{\"1032\":1}}],[\"社区建设\",{\"1\":{\"483\":1}}],[\"社交网站的访问量通常来说比较大\",{\"1\":{\"594\":1}}],[\"社交网络\",{\"1\":{\"594\":1}}],[\"缓冲\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"缓冲区用于存储数据\",{\"1\":{\"1020\":1}}],[\"缓冲区\",{\"1\":{\"1020\":1,\"1167\":2,\"1355\":2}}],[\"缓冲区代理缓冲用户端请求的最大字节数\",{\"1\":{\"106\":1}}],[\"缓存在物理上永远不过期\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"缓存永不过期\",{\"1\":{\"1203\":2,\"1383\":2}}],[\"缓存时间设置短一点\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"缓存成本也就越大\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"缓存淘汰\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"缓存数据的淘汰策略有哪些\",{\"0\":{\"1052\":1,\"1261\":1}}],[\"缓存数据库查询结果\",{\"1\":{\"950\":1}}],[\"缓存预热\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"缓存上从不设置过期时间\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"缓存高可用\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"缓存挂掉了\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"缓存空间占用小\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"缓存空对象\",{\"1\":{\"1047\":2,\"1256\":2}}],[\"缓存穿透是指用户请求的数据在缓存中不存在即没有命中\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"缓存穿透\",{\"1\":{\"1047\":2,\"1256\":2}}],[\"缓存和\",{\"0\":{\"1050\":1,\"1259\":1},\"1\":{\"1046\":1,\"1050\":2,\"1255\":1,\"1259\":2}}],[\"缓存和消息中间件\",{\"1\":{\"601\":1,\"614\":1}}],[\"缓存如何失效\",{\"1\":{\"1046\":1,\"1255\":1}}],[\"缓存何时写入\",{\"1\":{\"1046\":1,\"1255\":1}}],[\"缓存算法\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"缓存到\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"缓存是\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"缓存与异步\",{\"1\":{\"950\":1}}],[\"缓存刷新时才写入\",{\"1\":{\"924\":1}}],[\"缓存中的旧值\",{\"1\":{\"924\":1}}],[\"缓存机制等实用功能\",{\"1\":{\"615\":1}}],[\"缓存不具有一致性\",{\"1\":{\"615\":1}}],[\"缓存雪崩是不同数据都过期了\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"缓存雪崩是指缓存中数据大批量到过期时间\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"缓存雪崩\",{\"1\":{\"608\":1,\"1048\":1,\"1257\":1}}],[\"缓存击穿指并发查同一条数据\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"缓存击穿\",{\"1\":{\"608\":1,\"1049\":1,\"1258\":1}}],[\"缓存现在几乎是所有中大型网站都在用的必杀技\",{\"1\":{\"594\":1}}],[\"缓存\",{\"0\":{\"788\":1,\"1250\":1},\"1\":{\"594\":1,\"1041\":3,\"1042\":1,\"1049\":1,\"1251\":1,\"1258\":1},\"2\":{\"1055\":1}}],[\"缓存产品有以下三个特点\",{\"1\":{\"592\":1}}],[\"集中定义依赖版本号\",{\"1\":{\"715\":1}}],[\"集合的源码简直太友好了\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"集合的类型\",{\"1\":{\"797\":1}}],[\"集合包含的元素数量\",{\"1\":{\"630\":1}}],[\"集合键\",{\"1\":{\"630\":1}}],[\"集合是通过哈希表实现的\",{\"1\":{\"607\":1}}],[\"集合中所有\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"集合中最小的leo\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"集合中最小的\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"集合中最大的成员数为\",{\"1\":{\"607\":1}}],[\"集合中的每个副本都会维护自己的\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"集合中的\",{\"0\":{\"1119\":1,\"1314\":1}}],[\"集合中\",{\"1\":{\"606\":1}}],[\"集合移动到\",{\"1\":{\"606\":1}}],[\"集合成员是唯一的\",{\"1\":{\"606\":1}}],[\"集合等数据结构能很方便的的实现这些功能\",{\"1\":{\"594\":1}}],[\"集合\",{\"0\":{\"606\":1},\"1\":{\"589\":1,\"601\":1,\"606\":2,\"619\":1,\"636\":1,\"1119\":1,\"1160\":2,\"1165\":1,\"1314\":1,\"1348\":2,\"1353\":1}}],[\"集群刚刚启动或者leader服务器宕机\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"集群管理\",{\"1\":{\"1237\":1,\"1244\":1,\"1410\":1,\"1417\":1}}],[\"集群中每个\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"集群部署\",{\"1\":{\"1205\":2,\"1385\":2}}],[\"集群存在\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"集群新增\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"集群的负载均衡\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"集群的每个服务器收到投票后\",{\"1\":{\"166\":1}}],[\"集群会自动选举一个从节点作为新的主节点\",{\"1\":{\"968\":1}}],[\"集群会根据命令的键值对选择正确的分片\",{\"1\":{\"968\":1}}],[\"集群模式下\",{\"1\":{\"594\":1}}],[\"集群发现\",{\"1\":{\"406\":1}}],[\"集群就是将单个独立的应用复制多分放在不同的主机上来减轻服务器的压力\",{\"1\":{\"165\":1}}],[\"集群内节点状态的快速感知\",{\"1\":{\"153\":1}}],[\"集群\",{\"0\":{\"116\":1,\"461\":1},\"1\":{\"416\":1,\"1075\":1,\"1159\":1,\"1279\":1,\"1347\":1}}],[\"黑铁\",{\"0\":{\"585\":1,\"586\":1},\"1\":{\"613\":1,\"641\":1,\"647\":1}}],[\"杀死容器\",{\"1\":{\"1063\":1,\"1269\":1}}],[\"杀死该进程\",{\"1\":{\"581\":1}}],[\"杀死引起死锁的进程\",{\"1\":{\"581\":1}}],[\"释放内存空间\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"释放资源\",{\"1\":{\"737\":1}}],[\"释放它们持有的资源\",{\"1\":{\"581\":1}}],[\"释放锁失败\",{\"1\":{\"1023\":1}}],[\"释放锁成功\",{\"1\":{\"1023\":1}}],[\"释放锁和判断锁是否被当前线程占用的操作\",{\"1\":{\"932\":1}}],[\"释放锁\",{\"1\":{\"577\":1,\"578\":1,\"579\":1}}],[\"`docker\",{\"1\":{\"1062\":4,\"1268\":4}}],[\"`max\",{\"1\":{\"982\":2}}],[\"`fetch\",{\"1\":{\"982\":2}}],[\"`job=<job\",{\"1\":{\"887\":1}}],[\"`jedis\",{\"1\":{\"648\":1}}],[\"`number`\",{\"1\":{\"824\":1}}],[\"`name`\",{\"1\":{\"726\":1,\"824\":1,\"827\":1}}],[\"`idx\",{\"1\":{\"824\":1}}],[\"`id`\",{\"1\":{\"726\":2}}],[\"`appoint\",{\"1\":{\"824\":2}}],[\"`appointment`\",{\"1\":{\"824\":2}}],[\"`student\",{\"1\":{\"824\":2}}],[\"`status`\",{\"1\":{\"726\":1}}],[\"`book`\",{\"1\":{\"824\":6}}],[\"`book\",{\"1\":{\"824\":4}}],[\"`bitcount`\",{\"1\":{\"658\":1}}],[\"``元素内容必须由格式正确的字符数据或标记组成\",{\"1\":{\"800\":1}}],[\"```error\",{\"1\":{\"800\":1}}],[\"`user\",{\"1\":{\"726\":2}}],[\"`\",{\"1\":{\"648\":1}}],[\"`直接调用\",{\"1\":{\"648\":1}}],[\"`returnresource\",{\"1\":{\"648\":1}}],[\"`lock\",{\"1\":{\"577\":2}}],[\"`test\",{\"1\":{\"726\":1}}],[\"`table\",{\"1\":{\"725\":1,\"726\":2}}],[\"`t\",{\"1\":{\"577\":1}}],[\"幻读等名词\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"幻读是针对数据插入\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"幻读\",{\"1\":{\"575\":1,\"1188\":1,\"1371\":1}}],[\"隔离性\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"隔离性和持久性\",{\"1\":{\"553\":1}}],[\"隔离强度逐渐增强\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"隔离\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"隔离级别下\",{\"1\":{\"575\":1}}],[\"隐式锁定\",{\"1\":{\"570\":1}}],[\"显而易见\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"显式指定参数的名字\",{\"1\":{\"779\":1}}],[\"显式锁定\",{\"1\":{\"570\":1}}],[\"显然表名多了引号\",{\"1\":{\"779\":1}}],[\"显示第一个存储的改动\",{\"1\":{\"916\":1}}],[\"显示做了哪些改动\",{\"1\":{\"916\":1}}],[\"显示viewresolver\",{\"1\":{\"819\":2}}],[\"显示识别的颜色名称\",{\"1\":{\"144\":1}}],[\"显示channel名称\",{\"1\":{\"144\":1}}],[\"显示比特流filter\",{\"1\":{\"144\":1}}],[\"显示所有编码器\",{\"1\":{\"144\":1}}],[\"显示所有编解码器\",{\"1\":{\"144\":1}}],[\"显示可用编解码器\",{\"1\":{\"144\":1}}],[\"显示可用的采样格式\",{\"1\":{\"144\":1}}],[\"显示可用的像素格式\",{\"1\":{\"144\":1}}],[\"显示可用的过滤器\",{\"1\":{\"144\":1}}],[\"显示可用的协议\",{\"1\":{\"144\":1}}],[\"显示可用的格式\",{\"1\":{\"144\":1}}],[\"显示可用的设备\",{\"1\":{\"144\":1}}],[\"显示可用的muxers\",{\"1\":{\"144\":1}}],[\"显示可用的demuxers\",{\"1\":{\"144\":1}}],[\"显示版本\",{\"1\":{\"144\":1}}],[\"显示后20行数据\",{\"1\":{\"94\":1}}],[\"显示行号\",{\"1\":{\"94\":1}}],[\"事物的4种隔离级别\",{\"0\":{\"1187\":1,\"1370\":1}}],[\"事件监听\",{\"1\":{\"1230\":1,\"1405\":1}}],[\"事件\",{\"1\":{\"1020\":1}}],[\"事件调度线程\",{\"1\":{\"1018\":1}}],[\"事件驱动架构等\",{\"1\":{\"974\":1}}],[\"事件发布者等机制的实现\",{\"1\":{\"952\":1}}],[\"事情变得如此简单\",{\"1\":{\"659\":1}}],[\"事半功倍\",{\"1\":{\"643\":1}}],[\"事务的执行实际发生在\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"事务不只限于脏读\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"事务传播实际上是会失效的\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"事务传播机制实际上是使用简单的threadlocal实现的\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"事务提交之后才生效\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"事务具有原子性\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"事务日志\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"事务管理等\",{\"1\":{\"1016\":2,\"1133\":1,\"1326\":1}}],[\"事务管理错误\",{\"1\":{\"950\":1}}],[\"事务管理\",{\"1\":{\"950\":1}}],[\"事务管理器\",{\"1\":{\"743\":2,\"745\":1}}],[\"事务\",{\"1\":{\"601\":1,\"958\":1}}],[\"事务在等待资源超过一定时间后超时\",{\"1\":{\"581\":1}}],[\"事务可以看到一致的快照数据\",{\"1\":{\"575\":1}}],[\"事务开始时记录版本号\",{\"1\":{\"569\":1}}],[\"事务将被回滚\",{\"1\":{\"569\":1}}],[\"事实上\",{\"1\":{\"425\":1,\"940\":1,\"1099\":1,\"1297\":1}}],[\"互斥条件\",{\"1\":{\"562\":1}}],[\"互不放手\",{\"1\":{\"562\":1}}],[\"死锁检测\",{\"1\":{\"581\":1}}],[\"死锁通常由以下四种情况同时出现时引起\",{\"1\":{\"562\":1}}],[\"死锁是在事务数据库中会发生的一种特殊现象\",{\"1\":{\"562\":1}}],[\"粒度\",{\"1\":{\"561\":1,\"567\":1}}],[\"粒度较小\",{\"1\":{\"561\":1}}],[\"粒度较大\",{\"1\":{\"561\":1}}],[\"虽然zookeeper能保证所有watch按顺序触发\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"虽然存在多个线程\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"虽然有了namespace技术可以实现资源隔离\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"虽然损失了一定的时效性\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"虽然它的部署和配置可能有些复杂\",{\"1\":{\"978\":1}}],[\"虽然redis分片集群可以提高性能和可扩展性\",{\"1\":{\"968\":1}}],[\"虽然\",{\"1\":{\"771\":1,\"1049\":1,\"1258\":1}}],[\"虽然页锁不是用户可以直接控制的锁类型\",{\"1\":{\"561\":1}}],[\"虽然不能保证全局唯一\",{\"1\":{\"383\":1}}],[\"持久顺序\",{\"1\":{\"1238\":3,\"1411\":3}}],[\"持久\",{\"1\":{\"1238\":3,\"1411\":3}}],[\"持久性\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"持久化的工作并不实时\",{\"1\":{\"962\":1}}],[\"持久化\",{\"1\":{\"960\":1}}],[\"持续更新git命令集\",{\"1\":{\"914\":1}}],[\"持续轮训表里有没有需要发送验证码的邮箱地址\",{\"1\":{\"664\":1}}],[\"持续3\",{\"1\":{\"329\":1}}],[\"持有者指针偏移量\",{\"1\":{\"1023\":1}}],[\"持有者指针\",{\"1\":{\"1023\":1}}],[\"持有和等待条件\",{\"1\":{\"562\":1}}],[\"持有插入意向锁的事务可以继续执行插入操作\",{\"1\":{\"558\":1}}],[\"间隙锁通常在执行范围查询并加上共享或排他锁时自动应用\",{\"1\":{\"558\":1}}],[\"间隙锁主要用于防止其他事务在这个间隙中插入新的行\",{\"1\":{\"558\":1}}],[\"间隙锁是一种行锁\",{\"1\":{\"558\":1}}],[\"间隙锁和插入意向锁针对实现了多版本并发控制\",{\"1\":{\"558\":1}}],[\"间隙锁\",{\"0\":{\"558\":1},\"1\":{\"558\":1,\"575\":1}}],[\"临时顺序\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"临时\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"临时表并不是不可使用\",{\"1\":{\"541\":1}}],[\"临键锁结合了记录锁和间隙锁\",{\"1\":{\"556\":1}}],[\"临键锁\",{\"0\":{\"556\":1},\"1\":{\"556\":1}}],[\"行锁的粒度更小\",{\"1\":{\"571\":1}}],[\"行锁适用于高并发读写\",{\"1\":{\"567\":1}}],[\"行锁可能导致最多的锁冲突\",{\"1\":{\"567\":1}}],[\"行锁可能导致更多的锁冲突\",{\"1\":{\"564\":1}}],[\"行锁提供最高的并发性\",{\"1\":{\"567\":1}}],[\"行锁允许多个事务同时访问表中的不同行\",{\"1\":{\"564\":1}}],[\"行锁是锁定表中的单行或多行\",{\"1\":{\"564\":1}}],[\"行锁通常在执行涉及单个行的操作时自动应用\",{\"1\":{\"556\":1}}],[\"行锁\",{\"0\":{\"556\":1,\"563\":1,\"564\":1},\"1\":{\"556\":1,\"561\":1,\"567\":1,\"571\":1,\"575\":1}}],[\"行业内有句话\",{\"1\":{\"481\":1}}],[\"什么情况下需要自定义这些方法\",{\"1\":{\"952\":1}}],[\"什么情况下可以获得\",{\"1\":{\"555\":1}}],[\"什么类负责\",{\"1\":{\"934\":1}}],[\"什么时候使用该注解\",{\"1\":{\"688\":2}}],[\"什么是cap\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"什么是控制反转\",{\"0\":{\"1213\":1,\"1390\":1},\"1\":{\"1212\":1,\"1389\":1}}],[\"什么是双亲委派模型\",{\"0\":{\"1149\":1,\"1340\":1},\"1\":{\"1149\":1,\"1340\":1}}],[\"什么是threadlocal\",{\"0\":{\"1103\":1,\"1301\":1}}],[\"什么是装箱拆箱\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"什么是缓存雪崩\",{\"0\":{\"1203\":1,\"1383\":1}}],[\"什么是缓存穿透\",{\"0\":{\"1202\":1,\"1382\":1}}],[\"什么是缓存预热\",{\"0\":{\"1051\":1,\"1260\":1}}],[\"什么是缓存\",{\"0\":{\"1042\":1,\"1251\":1}}],[\"什么是netty\",{\"0\":{\"1031\":1}}],[\"什么是http协议无状态协议\",{\"1\":{\"1027\":1}}],[\"什么是垃圾\",{\"1\":{\"936\":1}}],[\"什么是类的生命周期\",{\"1\":{\"934\":1}}],[\"什么是mybatis的接口绑定\",{\"0\":{\"1180\":1,\"1365\":1}}],[\"什么是mybatis的一级\",{\"0\":{\"1178\":1,\"1363\":1}}],[\"什么是mybatis\",{\"0\":{\"1172\":1,\"1357\":1}}],[\"什么是mybatis之jdbc攻城狮\",{\"0\":{\"733\":1}}],[\"什么是maven项目规约\",{\"1\":{\"702\":1}}],[\"什么是依赖注入\",{\"0\":{\"1213\":1,\"1390\":1}}],[\"什么是依赖\",{\"1\":{\"699\":1}}],[\"什么是理想的项目构建\",{\"1\":{\"699\":1}}],[\"什么是项目构建\",{\"1\":{\"699\":1}}],[\"什么是计数器\",{\"1\":{\"594\":1}}],[\"什么是死锁\",{\"0\":{\"562\":1}}],[\"什么是回表\",{\"0\":{\"504\":1}}],[\"什么是聚簇索引和非聚簇索引\",{\"0\":{\"497\":1}}],[\"什么是\",{\"0\":{\"429\":1,\"1027\":1,\"1057\":1,\"1059\":1,\"1137\":1,\"1211\":1,\"1237\":1,\"1263\":1,\"1265\":1,\"1330\":1,\"1388\":1,\"1410\":1},\"1\":{\"658\":1,\"920\":1,\"954\":1,\"958\":1}}],[\"什么是完全二叉树\",{\"1\":{\"364\":1}}],[\"什么是zookeeper\",{\"0\":{\"151\":1}}],[\"排名\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"排在了操作\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"排除spring\",{\"1\":{\"710\":1}}],[\"排除依赖\",{\"0\":{\"710\":1}}],[\"排行榜\",{\"1\":{\"594\":1,\"657\":1,\"1199\":1,\"1379\":1}}],[\"排他锁只可以加一个\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"排他锁会在事务结束时释放\",{\"1\":{\"578\":1}}],[\"排他锁\",{\"1\":{\"572\":1,\"1193\":1,\"1376\":1}}],[\"排它锁\",{\"0\":{\"555\":1}}],[\"排序过程可能会变得非常沉重\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"排序文档\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"排序的\",{\"1\":{\"657\":1}}],[\"排序的概念和分类\",{\"0\":{\"295\":1}}],[\"排序和分组操作的列\",{\"1\":{\"502\":1}}],[\"排序操作或模糊查询\",{\"1\":{\"499\":1}}],[\"排序就很简单了\",{\"1\":{\"359\":1}}],[\"排序\",{\"1\":{\"443\":1,\"607\":1,\"1070\":1,\"1123\":1,\"1274\":1,\"1318\":1},\"2\":{\"354\":1,\"355\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"378\":1,\"379\":1}}],[\"排序算法的选择\",{\"1\":{\"350\":1}}],[\"共享对象池\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"共享\",{\"0\":{\"1233\":1,\"1408\":1},\"1\":{\"664\":1,\"1233\":2,\"1408\":2}}],[\"共享锁都相斥\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"共享锁可以同时加上多个\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"共享锁|排他锁\",{\"1\":{\"557\":1}}],[\"共享锁允许其他事务读取这些行\",{\"1\":{\"555\":1}}],[\"共享锁\",{\"0\":{\"555\":1},\"1\":{\"555\":1,\"572\":1,\"575\":1,\"1193\":1,\"1376\":1}}],[\"共同完成某项\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"共同关注的人\",{\"1\":{\"656\":2}}],[\"共同好友等是社交网站的基本功能\",{\"1\":{\"594\":1}}],[\"共有字\",{\"1\":{\"636\":1}}],[\"共10个\",{\"1\":{\"422\":1}}],[\"汇总xmind\",{\"1\":{\"552\":1}}],[\"锁服务可以分为两类\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"锁机制作为并发编程的基础\",{\"1\":{\"1018\":1}}],[\"锁的问题变得容易\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"锁的问题归更到底就是资源竞争导致的\",{\"1\":{\"552\":1}}],[\"锁的粒度\",{\"1\":{\"1018\":1}}],[\"锁的标识\",{\"1\":{\"577\":1}}],[\"锁的兼容性\",{\"1\":{\"575\":1}}],[\"锁竞争\",{\"1\":{\"574\":1}}],[\"锁升级\",{\"1\":{\"575\":1,\"581\":1}}],[\"锁升级是数据库系统自动进行的\",{\"1\":{\"574\":1}}],[\"锁升级的缺点包括\",{\"1\":{\"574\":1}}],[\"锁升级的优点包括\",{\"1\":{\"574\":1}}],[\"锁升级可以减少死锁的可能性\",{\"1\":{\"574\":1}}],[\"锁升级通常发生在一下情况\",{\"1\":{\"574\":1}}],[\"锁升级指细粒度锁升级为粗粒度锁\",{\"1\":{\"574\":1}}],[\"锁定对象\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"锁定的页数\",{\"1\":{\"574\":1}}],[\"锁定的行数\",{\"1\":{\"574\":1}}],[\"锁定多个表的示例\",{\"1\":{\"572\":1}}],[\"锁定\",{\"1\":{\"570\":1}}],[\"锁定减少\",{\"1\":{\"518\":1}}],[\"锁粒度\",{\"1\":{\"564\":1,\"565\":1,\"566\":1}}],[\"锁\",{\"1\":{\"555\":1},\"2\":{\"665\":1,\"666\":1}}],[\"锁和\",{\"1\":{\"555\":1}}],[\"锁是保证数据库事务四个特性\",{\"1\":{\"553\":1}}],[\"游标通常要优于其他逐行处理方法\",{\"0\":{\"546\":1}}],[\"游标并不是不可使用\",{\"0\":{\"546\":1}}],[\"替代\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"替代方法\",{\"1\":{\"542\":1}}],[\"替换成变量的值\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"替换成了\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"替换成\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"替换旧aof\",{\"1\":{\"962\":1}}],[\"替换等\",{\"1\":{\"944\":1}}],[\"替换的元素个数\",{\"1\":{\"284\":1}}],[\"替换元素\",{\"1\":{\"284\":2}}],[\"替换文件制定字符\",{\"1\":{\"94\":1}}],[\"视线\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"视图\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"视具体情况而定\",{\"1\":{\"537\":1}}],[\"视频地址\",{\"1\":{\"889\":1}}],[\"视频网站视频的播放数等\",{\"1\":{\"594\":1}}],[\"视频参考\",{\"1\":{\"251\":1}}],[\"视频参数\",{\"1\":{\"127\":1}}],[\"视频抽取一些帧作为图片时很常用的操作\",{\"1\":{\"141\":1}}],[\"视频添加logo\",{\"0\":{\"139\":1}}],[\"视频编码格式转换\",{\"0\":{\"135\":1}}],[\"视频编解码库libavcodec\",{\"1\":{\"122\":1}}],[\"视频格式转换\",{\"0\":{\"131\":1}}],[\"视频剪切\",{\"0\":{\"128\":1}}],[\"视频\",{\"0\":{\"218\":1,\"859\":1},\"1\":{\"122\":1,\"244\":1,\"871\":1,\"878\":1,\"881\":1,\"1439\":1}}],[\"视频教程\",{\"0\":{\"860\":1},\"1\":{\"112\":1}}],[\"及横向扩展能力的增强\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"及kafka的架构等基本概念\",{\"1\":{\"1155\":1,\"1343\":1}}],[\"及之后的版本中引入了偏向锁\",{\"1\":{\"1022\":1}}],[\"及之后的版本中\",{\"1\":{\"1022\":1}}],[\"及之前的版本中\",{\"1\":{\"1022\":1}}],[\"及其子类\",{\"1\":{\"950\":1}}],[\"及早解决潜在问题\",{\"1\":{\"942\":1}}],[\"及时回收资源等方式优化\",{\"1\":{\"936\":1}}],[\"及演示源代码\",{\"1\":{\"906\":1}}],[\"及定义一个返回标准方便前端解析\",{\"1\":{\"829\":1}}],[\"及数据库接口操作都没有问题\",{\"1\":{\"829\":1}}],[\"及渲染后的\",{\"1\":{\"819\":1}}],[\"及\",{\"0\":{\"537\":1},\"1\":{\"593\":1,\"1192\":1,\"1375\":1}}],[\"及以上版本\",{\"1\":{\"488\":1}}],[\"及以上\",{\"1\":{\"402\":1}}],[\"型字段上使用索引会不会用到的问题\",{\"1\":{\"536\":1}}],[\"算是入门水平吧\",{\"1\":{\"942\":1}}],[\"算术运算或其他表达式运算\",{\"0\":{\"533\":1}}],[\"算法存在活锁的问题\",{\"1\":{\"1246\":1,\"1419\":1}}],[\"算法存储空间的需求等\",{\"0\":{\"280\":1}}],[\"算法在数据同步阶段\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"算法实现的\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"算法实现可一个\",{\"1\":{\"659\":1}}],[\"算法接近\",{\"1\":{\"940\":1}}],[\"算法已忽略其最关键的优点\",{\"1\":{\"940\":1}}],[\"算法的发起者可以是一个或多个\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"算法的联系与区别\",{\"0\":{\"1243\":1,\"1416\":1}}],[\"算法的升级版\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"算法的思想\",{\"1\":{\"940\":1}}],[\"算法的步骤如下\",{\"1\":{\"358\":1}}],[\"算法与\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"算法与设计模式等基础内容的运用\",{\"1\":{\"922\":1}}],[\"算法与数据结构\",{\"0\":{\"65\":1}}],[\"算法来计算键的哈希值\",{\"1\":{\"626\":1}}],[\"算法生成的\",{\"1\":{\"387\":1}}],[\"算法介绍\",{\"0\":{\"387\":1}}],[\"算法过程\",{\"0\":{\"351\":1}}],[\"算法效率的度量\",{\"0\":{\"280\":1}}],[\"算法设计的要求\",{\"0\":{\"280\":1}}],[\"算法\",{\"0\":{\"255\":1,\"280\":1},\"1\":{\"100\":1,\"940\":1},\"2\":{\"256\":1,\"257\":1}}],[\"已有功能来实现的\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"已成功获取\",{\"1\":{\"1105\":2,\"1303\":2}}],[\"已不再建议使用\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"已解决\",{\"0\":{\"895\":1}}],[\"已提供依赖范围\",{\"1\":{\"706\":1}}],[\"已经预先存在\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"已经过期\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"已经存在\",{\"1\":{\"960\":1}}],[\"已经正常退出了\",{\"1\":{\"692\":1}}],[\"已经有了一定了解\",{\"1\":{\"608\":1}}],[\"已经没人\",{\"1\":{\"153\":1}}],[\"已知该人没有电话\",{\"1\":{\"526\":1}}],[\"未授权\",{\"1\":{\"1431\":1}}],[\"未提交意味着这些数据可能会回滚\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"未来缓存服务恢复后\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"未来会对并发编程有很大帮助\",{\"1\":{\"1018\":1}}],[\"未知类型\",{\"1\":{\"966\":1}}],[\"未知电话号码\",{\"1\":{\"526\":1}}],[\"未考虑扩展性\",{\"1\":{\"950\":1}}],[\"未正确配置事务属性\",{\"1\":{\"950\":1}}],[\"未正确配置\",{\"1\":{\"950\":1}}],[\"未设定时则使用与输入流相同的编解码器\",{\"1\":{\"127\":2}}],[\"敏捷版本迭代\",{\"1\":{\"525\":1}}],[\"阅读后更有利于了解mysql\",{\"1\":{\"1184\":1,\"1367\":1}}],[\"阅读全套系列面试题教程\",{\"1\":{\"524\":1}}],[\"阅读建议\",{\"0\":{\"524\":1}}],[\"阅读大约6分钟\",{\"1\":{\"525\":1}}],[\"阅读大约3分钟\",{\"1\":{\"515\":1}}],[\"阅读大概需要3分钟\",{\"1\":{\"380\":1}}],[\"阅读大概需要4\",{\"1\":{\"328\":1}}],[\"阅读大概需要10分钟\",{\"1\":{\"277\":1}}],[\"叄月\",{\"1\":{\"521\":1}}],[\"辛丑年\",{\"1\":{\"521\":1}}],[\"且\",{\"1\":{\"1159\":1,\"1226\":1,\"1347\":1,\"1401\":1}}],[\"且次数需一样\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"且要实时更新阅读量\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"且更新不需要很强一致性的用乐观锁\",{\"1\":{\"1018\":1}}],[\"且知道解决方法\",{\"1\":{\"1018\":1}}],[\"且简单的解决方案\",{\"1\":{\"664\":1}}],[\"且不允许重复的成员\",{\"1\":{\"607\":1}}],[\"且持续增长\",{\"1\":{\"520\":1}}],[\"且对性能要求较高\",{\"1\":{\"499\":1}}],[\"且对每个桶的排序方式也是快排\",{\"1\":{\"348\":1}}],[\"争抢并减少锁表的几率\",{\"1\":{\"519\":1}}],[\"往后查找空位置\",{\"1\":{\"928\":1}}],[\"往往能解决单库存储量及性能瓶颈\",{\"1\":{\"518\":1}}],[\"往下10s\",{\"1\":{\"141\":1}}],[\"稳定性和灵活性的方法\",{\"1\":{\"1031\":1}}],[\"稳定性体现在io冲突减少\",{\"1\":{\"518\":1}}],[\"稳定的布隆过滤器\",{\"1\":{\"343\":1}}],[\"监听节点数目是否是我们要求的数目\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"监听就会自动触发返回结果\",{\"1\":{\"1034\":1}}],[\"监听器等\",{\"1\":{\"820\":1}}],[\"监听端口\",{\"1\":{\"106\":1}}],[\"监视器提供了一组可以直接作为\",{\"1\":{\"1231\":1,\"1406\":1}}],[\"监视器\",{\"1\":{\"622\":1}}],[\"监控和优化查询性能\",{\"1\":{\"1002\":1}}],[\"监控日志\",{\"1\":{\"958\":1}}],[\"监控系统的负载\",{\"1\":{\"950\":1}}],[\"监控死锁\",{\"1\":{\"581\":1}}],[\"监控\",{\"1\":{\"517\":1,\"958\":1}}],[\"某些指定的内容​​\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"某些字段不希望被搜索到\",{\"1\":{\"432\":1}}],[\"某业务实体中的各个数据项的访问频次是不一样的\",{\"1\":{\"516\":1}}],[\"命名服务\",{\"1\":{\"1237\":1,\"1244\":1,\"1410\":1,\"1417\":1}}],[\"命名空间+\",{\"1\":{\"747\":2}}],[\"命名空间\",{\"1\":{\"744\":1,\"755\":1,\"763\":1}}],[\"命中率更高\",{\"1\":{\"516\":1}}],[\"命令建议在本地安装做一个实操\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"命令将按照我们指定的依赖顺序启动和运行服务\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"命令将字符串解析成整型\",{\"1\":{\"603\":1}}],[\"命令传播\",{\"1\":{\"964\":1}}],[\"命令后\",{\"1\":{\"916\":1,\"962\":2}}],[\"命令进行恢复\",{\"1\":{\"916\":1}}],[\"命令恢复之前缓存的工作目录\",{\"1\":{\"916\":1}}],[\"命令恢复\",{\"1\":{\"916\":1}}],[\"命令之后会在stash列表中生成一个对应的信息\",{\"1\":{\"916\":1}}],[\"命令行构建java项目\",{\"0\":{\"703\":1}}],[\"命令行操使用\",{\"0\":{\"126\":1}}],[\"命令可以指定元素获取区间\",{\"1\":{\"655\":1}}],[\"命令可以帮助维持索引的健康状况\",{\"1\":{\"511\":1}}],[\"命令不区分大小写\",{\"1\":{\"652\":1}}],[\"命令又懒得安装\",{\"1\":{\"614\":1}}],[\"命令及描述\",{\"1\":{\"605\":1,\"606\":1,\"607\":1}}],[\"命令用来查看key对应的值剩余存活时间\",{\"1\":{\"603\":1}}],[\"命令用于在列表的元素前或者后插入元素\",{\"1\":{\"604\":1}}],[\"命令用于删除文件或目录\",{\"1\":{\"91\":1}}],[\"命令用于移动文件或目录\",{\"1\":{\"91\":1}}],[\"命令用于复制文件或目录\",{\"1\":{\"91\":1}}],[\"命令用于创建目录\",{\"1\":{\"91\":1}}],[\"命令用于显示工作目录\",{\"1\":{\"91\":1}}],[\"命令用于显示指定工作目录下之内容\",{\"1\":{\"91\":1}}],[\"命令去除超时时间\",{\"1\":{\"603\":1}}],[\"命令返回key对应的存储类型\",{\"1\":{\"603\":1}}],[\"命令返回由值组成的数组\",{\"1\":{\"603\":1}}],[\"命令来实现计数器功能\",{\"1\":{\"594\":1}}],[\"命令来重建表的索引\",{\"1\":{\"511\":1}}],[\"命令来重新组织表的数据\",{\"1\":{\"511\":1}}],[\"命令\",{\"1\":{\"90\":2,\"603\":1,\"658\":1,\"664\":1,\"916\":3,\"964\":3}}],[\"命令的问题\",{\"1\":{\"90\":1}}],[\"水平分表是在同一个数据库内\",{\"1\":{\"519\":1}}],[\"水平分表\",{\"0\":{\"519\":1},\"1\":{\"520\":1}}],[\"水平分表四种方式\",{\"1\":{\"515\":1}}],[\"水平分库带来的提升是\",{\"1\":{\"518\":1}}],[\"水平分库是对数据行的拆分\",{\"1\":{\"518\":1}}],[\"水平分库是把同一个表的数据按一定规则拆到不同的数据库中\",{\"1\":{\"518\":1}}],[\"水平分库\",{\"0\":{\"518\":1},\"1\":{\"515\":1,\"520\":1}}],[\"水平拆分\",{\"1\":{\"509\":1}}],[\"垂直切分带来的性能提升主要集中在热门数据的操作效率上\",{\"1\":{\"516\":1}}],[\"垂直分表方案\",{\"1\":{\"520\":1}}],[\"垂直分表定义\",{\"1\":{\"516\":1}}],[\"垂直分表\",{\"0\":{\"516\":1},\"1\":{\"515\":1,\"520\":1}}],[\"垂直分库是把不同表拆到不同数据库中\",{\"1\":{\"518\":1}}],[\"垂直分库是指按照业务将表进行分类\",{\"1\":{\"517\":1}}],[\"垂直分库通过将表按业务分类\",{\"1\":{\"517\":1}}],[\"垂直分库一定程度的提升io\",{\"1\":{\"517\":1}}],[\"垂直分库\",{\"0\":{\"517\":1},\"1\":{\"515\":1,\"520\":1}}],[\"垂直拆分\",{\"1\":{\"509\":1}}],[\"把上图中间的ioc容器拿掉\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"把系统中的所有\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"把所有的消息都变成一个批量的文件\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"把所有修改数据的方法都加上synchronized\",{\"1\":{\"1089\":1,\"1290\":1}}],[\"把数组的长度设为2的幂次方\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"把数据进行隔离\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"把数据送到各个需要的地方\",{\"1\":{\"976\":1}}],[\"把数据流传输给各个处理节点\",{\"1\":{\"976\":1}}],[\"把数据分散在不同的数据库中\",{\"1\":{\"515\":1}}],[\"把类型当作是参数一样传递\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"把类标记为spring的组件\",{\"1\":{\"944\":1}}],[\"把读写速度\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"把事件通知给各个关心的人\",{\"1\":{\"976\":1}}],[\"把事件发送给各个订阅者\",{\"1\":{\"976\":1}}],[\"把事务管理交由\",{\"1\":{\"818\":1}}],[\"把日志从各个系统搬运到我们的数据湖中\",{\"1\":{\"976\":1}}],[\"把订单放在柜台上\",{\"1\":{\"974\":1}}],[\"把结果映射为\",{\"1\":{\"958\":1}}],[\"把要调用的映射语句的参数传入并解析出\",{\"1\":{\"958\":1}}],[\"把请求转发到各个组件\",{\"1\":{\"956\":1}}],[\"把相关的符号引用转换为直接引用\",{\"1\":{\"934\":1}}],[\"把这些符号转成直接引用\",{\"1\":{\"934\":1}}],[\"把卸载命令全部重新执行一遍\",{\"1\":{\"853\":1}}],[\"把\",{\"1\":{\"800\":1}}],[\"把每个字节数组的\",{\"1\":{\"658\":1}}],[\"把同一个表的数据按一定规则拆到多个表中\",{\"1\":{\"519\":1}}],[\"把text\",{\"1\":{\"516\":1}}],[\"把不常用的字段单独放在一张表\",{\"1\":{\"516\":1}}],[\"把小耀也分配给小西\",{\"1\":{\"153\":1}}],[\"访问端口\",{\"1\":{\"1444\":1}}],[\"访问的\",{\"1\":{\"1231\":1,\"1406\":1}}],[\"访问sourceb时需要登录了\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"访问sourcea则不用登录\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"访问sourcea\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"访问权限不能比父类中被重写的方法的访问权限更低\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"访问修饰符和返回值类型可以相同也可以不同\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"访问静态常量\",{\"1\":{\"934\":1}}],[\"访问静态变量\",{\"1\":{\"934\":1}}],[\"访问某个类的静态常量\",{\"1\":{\"934\":1}}],[\"访问该类的静态变量\",{\"1\":{\"934\":1}}],[\"访问类的静态变量和方法等\",{\"1\":{\"934\":1}}],[\"访问测试\",{\"0\":{\"675\":1}}],[\"访问其他节点的\",{\"1\":{\"628\":1}}],[\"访问性能也变慢了\",{\"1\":{\"515\":1}}],[\"访问下面地址\",{\"1\":{\"407\":1}}],[\"明白了\",{\"1\":{\"996\":1,\"1008\":1}}],[\"明显\",{\"1\":{\"511\":1}}],[\"明确标注事务方法的编程风格\",{\"1\":{\"830\":1}}],[\"明确责任归属\",{\"1\":{\"190\":1}}],[\"明确请求头有哪些\",{\"0\":{\"183\":1}}],[\"明确\",{\"0\":{\"176\":1}}],[\"评分\",{\"1\":{\"1002\":1}}],[\"评估索引的必要性\",{\"1\":{\"510\":1}}],[\"评论区见\",{\"1\":{\"1026\":1,\"1030\":1,\"1041\":1,\"1056\":1,\"1067\":1,\"1083\":1,\"1097\":1,\"1111\":1,\"1126\":1,\"1141\":1,\"1155\":1,\"1171\":1,\"1184\":1,\"1197\":1,\"1210\":1,\"1223\":1,\"1236\":1}}],[\"评论区补充\",{\"1\":{\"525\":1}}],[\"评论\",{\"1\":{\"20\":1,\"23\":1}}],[\"频繁攻击我们的应用\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"频繁的更新操作可能导致索引的页变得碎片化\",{\"1\":{\"508\":1}}],[\"频繁更新的列可能不适合建立索引\",{\"1\":{\"502\":1}}],[\"回头看上面的例子\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"回寝就能睡觉\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"回答不上来也没关系\",{\"1\":{\"1022\":1}}],[\"回收率与吞吐量预测\",{\"1\":{\"940\":1}}],[\"回收垃圾\",{\"1\":{\"940\":1}}],[\"回收垃圾对象\",{\"1\":{\"936\":1}}],[\"回收部分垃圾对象\",{\"1\":{\"936\":1}}],[\"回收\",{\"1\":{\"648\":1}}],[\"回滚日志\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"回滚事务\",{\"1\":{\"581\":1}}],[\"回滚\",{\"1\":{\"581\":1}}],[\"回表定义\",{\"1\":{\"504\":1}}],[\"回忆完以上\",{\"1\":{\"329\":1}}],[\"降低高可用性\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"降低程序的可读性和维护性\",{\"1\":{\"954\":1}}],[\"降低数据库压力\",{\"1\":{\"950\":1}}],[\"降低并发性\",{\"1\":{\"574\":1}}],[\"降低单机硬件资源的瓶颈\",{\"1\":{\"517\":1}}],[\"降低了维护开销\",{\"1\":{\"503\":1}}],[\"降低系统uptime\",{\"1\":{\"106\":1}}],[\"降低系统的负载\",{\"1\":{\"106\":1}}],[\"化器可能认为全表扫描比使用索引更快\",{\"1\":{\"501\":1}}],[\"走了索引也需要全表扫描\",{\"1\":{\"501\":1}}],[\"走进作者\",{\"0\":{\"213\":1}}],[\"慢查询日志\",{\"1\":{\"1185\":2,\"1368\":2}}],[\"慢查询\",{\"1\":{\"622\":1}}],[\"慢查询优化方案\",{\"0\":{\"525\":1},\"1\":{\"528\":1}}],[\"慢sql\",{\"2\":{\"550\":1}}],[\"慢sql优化23式\",{\"1\":{\"525\":1}}],[\"慢\",{\"1\":{\"501\":1,\"1042\":1,\"1251\":1}}],[\"性价最佳\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"性能逐渐变差\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"性能就越低\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"性能得以提高\",{\"1\":{\"1018\":1}}],[\"性能统计\",{\"1\":{\"1016\":2}}],[\"性能超高\",{\"1\":{\"960\":1}}],[\"性能差一些\",{\"1\":{\"922\":1}}],[\"性能高效\",{\"1\":{\"922\":1}}],[\"性能也更佳\",{\"1\":{\"922\":1}}],[\"性能比较差\",{\"1\":{\"722\":1}}],[\"性能问题\",{\"1\":{\"616\":1}}],[\"性能非常好\",{\"1\":{\"594\":1}}],[\"性能极高\",{\"1\":{\"593\":1}}],[\"性能\",{\"0\":{\"591\":1},\"1\":{\"569\":1,\"570\":1,\"1031\":1}}],[\"性能上可能没怎么在意\",{\"1\":{\"525\":1}}],[\"性能开销\",{\"1\":{\"508\":1}}],[\"性能逼近二分查找\",{\"1\":{\"265\":1}}],[\"性别\",{\"1\":{\"500\":1}}],[\"列表中的信息是会继续保留的\",{\"1\":{\"916\":1}}],[\"列表的最大长度是\",{\"1\":{\"655\":1}}],[\"列表和\",{\"1\":{\"633\":1}}],[\"列表\",{\"0\":{\"604\":1},\"1\":{\"601\":1,\"604\":1,\"619\":1,\"636\":1,\"956\":1,\"1156\":1,\"1344\":1}}],[\"列没有\",{\"1\":{\"526\":1}}],[\"列分别创建了位图索引\",{\"1\":{\"505\":1}}],[\"列的顺序非常重要\",{\"1\":{\"498\":1}}],[\"列出当前目录下的文件和目录\",{\"1\":{\"91\":1}}],[\"联系\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"联系javapub\",{\"1\":{\"1093\":1,\"1107\":1}}],[\"联系站长\",{\"0\":{\"214\":1},\"1\":{\"2\":1,\"217\":1},\"2\":{\"216\":1}}],[\"联合索引指多个字段上创建的索引\",{\"1\":{\"495\":1}}],[\"联合索引\",{\"1\":{\"495\":1}}],[\"普通二维码\",{\"1\":{\"876\":1}}],[\"普通的statement\",{\"1\":{\"763\":1}}],[\"普通的select语句是快照读\",{\"1\":{\"575\":1}}],[\"普通索引是\",{\"1\":{\"495\":1}}],[\"普通索引\",{\"1\":{\"495\":1,\"1189\":1,\"1372\":1}}],[\"普通人如何快速搭建本地大语言模型\",{\"1\":{\"244\":1}}],[\"引起数据库压力过大甚至宕机\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"引言\",{\"1\":{\"692\":1}}],[\"引用计数\",{\"1\":{\"635\":2}}],[\"引擎对查询的优化\",{\"1\":{\"528\":1}}],[\"引擎\",{\"1\":{\"495\":2}}],[\"引入泛型主要想实现一个通用的\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"引入分布式锁\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"引入本地缓存也会有相应的问题\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"引入二维码依赖\",{\"1\":{\"874\":1}}],[\"引入mapper\",{\"1\":{\"772\":1}}],[\"引入mysql依赖包\",{\"0\":{\"735\":1}}],[\"引入依赖\",{\"0\":{\"687\":1,\"742\":1,\"874\":1}}],[\"引入\",{\"1\":{\"648\":1,\"1217\":1,\"1232\":1,\"1394\":1,\"1407\":1}}],[\"引入的类型\",{\"1\":{\"457\":1}}],[\"引入接口版本管理\",{\"0\":{\"181\":1}}],[\"聚合\",{\"0\":{\"716\":1}}],[\"聚合检索\",{\"1\":{\"443\":1}}],[\"聚簇索引的叶子节点直接存储了实际的数据行\",{\"1\":{\"497\":1}}],[\"聚簇索引是将表的数据按照索引顺序存储在磁盘上\",{\"1\":{\"497\":1}}],[\"聚簇索引\",{\"1\":{\"495\":1}}],[\"簇\",{\"1\":{\"495\":1}}],[\"擅长做对等比较\",{\"1\":{\"495\":1}}],[\"擅长范围查询\",{\"1\":{\"495\":1}}],[\"道数据库锁面试题\",{\"1\":{\"552\":1}}],[\"道\",{\"1\":{\"493\":1}}],[\"否则一直等待所有成员到达\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"否则一直占用资源\",{\"1\":{\"648\":1}}],[\"否则的话创建\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"否则就是版本冲突\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"否则就推迟分配\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"否则认为是过期数据\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"否则其他线程无法获得锁\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"否则也要推迟分配\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"否则不需要登录\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"否则都叫做同步\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"否则创建一个新的integer对象\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"否则会以\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"否则会出现脑裂问题\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"否则会导致全表扫描\",{\"0\":{\"529\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"否则重新选举\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"否则返回false\",{\"1\":{\"970\":1,\"1084\":1,\"1285\":1}}],[\"否则子类才会负责加载\",{\"1\":{\"934\":1}}],[\"否则可能会导致线程池过大或过小\",{\"1\":{\"926\":1}}],[\"否则命令将失败\",{\"1\":{\"917\":1}}],[\"否则查找姓名为\",{\"1\":{\"785\":2}}],[\"否则如果输入了年龄则按照年龄查找\",{\"1\":{\"785\":2}}],[\"否则反之\",{\"1\":{\"708\":1}}],[\"否则获取锁失败\",{\"1\":{\"594\":1}}],[\"否则放弃更新\",{\"1\":{\"579\":1}}],[\"否则该索引将不会被使用\",{\"0\":{\"534\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"否则系统将可能无法正确使用索引\",{\"0\":{\"533\":1}}],[\"否则将引擎放弃使用索引而进行全表扫描\",{\"0\":{\"527\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"否则将导致引擎放弃使用索引而进行全表扫描\",{\"0\":{\"526\":1,\"528\":1},\"1\":{\"1192\":2,\"1375\":2}}],[\"否则\",{\"1\":{\"526\":1}}],[\"否则性能方面将得不偿失\",{\"1\":{\"520\":1}}],[\"否则存入过多数据可能会出现加不成功的现象\",{\"1\":{\"509\":1}}],[\"否则中断并打印后面的说明\",{\"1\":{\"488\":1}}],[\"否则谁也不知道谁对谁错\",{\"1\":{\"77\":1}}],[\"累加被领取的代币总和\",{\"1\":{\"488\":1}}],[\"领导者状态\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"领取\",{\"1\":{\"886\":1}}],[\"领取代币的函数\",{\"1\":{\"488\":1}}],[\"领域的绝对霸主\",{\"1\":{\"836\":1}}],[\"领域\",{\"1\":{\"211\":1}}],[\"满足条件\",{\"1\":{\"486\":1}}],[\"部署上线\",{\"1\":{\"1439\":2}}],[\"部署在不同服务器上\",{\"1\":{\"950\":1}}],[\"部署\",{\"0\":{\"913\":1},\"1\":{\"702\":1}}],[\"部署等等\",{\"1\":{\"711\":1}}],[\"部署等几乎所有构建步骤\",{\"1\":{\"711\":1}}],[\"部署等\",{\"1\":{\"698\":1}}],[\"部署合约\",{\"1\":{\"486\":1}}],[\"部分是比较考验工程师基本功的\",{\"1\":{\"924\":1}}],[\"部分由\",{\"1\":{\"801\":1}}],[\"部分中的所有内容都会被解析器忽略\",{\"1\":{\"801\":1}}],[\"部分可用`\",{\"1\":{\"518\":1}}],[\"部分数据项可能是占用存储空间比较大的blob或是text\",{\"1\":{\"516\":1}}],[\"部分资源在百度网盘\",{\"1\":{\"209\":1}}],[\"居多\",{\"1\":{\"484\":1}}],[\"奖励机制\",{\"1\":{\"483\":1}}],[\"签到\",{\"1\":{\"483\":1}}],[\"智能合约\",{\"1\":{\"481\":1},\"2\":{\"479\":1,\"480\":1,\"489\":1,\"490\":1}}],[\"智能聊天\",{\"1\":{\"64\":1}}],[\"四个特性\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"四个属性之外\",{\"1\":{\"635\":1}}],[\"四次挥手\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"四\",{\"0\":{\"460\":1}}],[\"面向无连接\",{\"1\":{\"1135\":1,\"1328\":1}}],[\"面向连接\",{\"1\":{\"1135\":1,\"1328\":1}}],[\"面向切面编程\",{\"1\":{\"950\":1,\"1016\":2}}],[\"面向对象的思想\",{\"1\":{\"793\":1}}],[\"面\",{\"1\":{\"454\":1}}],[\"面试过后导致自己自信心受挫\",{\"1\":{\"920\":1}}],[\"面试1v1\",{\"0\":{\"1025\":1},\"1\":{\"920\":17,\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1023\":1},\"2\":{\"921\":1,\"923\":1,\"925\":1,\"927\":1,\"929\":1,\"931\":1,\"933\":1,\"935\":1,\"937\":1,\"939\":1,\"941\":1,\"943\":1,\"945\":1,\"947\":1,\"949\":1,\"951\":1,\"953\":1,\"955\":1,\"957\":1,\"959\":1,\"961\":1,\"963\":1,\"965\":1,\"967\":1,\"969\":1,\"971\":1,\"973\":1,\"975\":1,\"977\":1,\"979\":1,\"981\":1,\"983\":1,\"985\":1,\"987\":1,\"989\":1,\"991\":1,\"993\":1,\"995\":1,\"997\":1,\"999\":1,\"1001\":1,\"1003\":1,\"1005\":1,\"1007\":1,\"1009\":1,\"1011\":1,\"1013\":1,\"1015\":1,\"1017\":1,\"1019\":1,\"1021\":1,\"1024\":1}}],[\"面试必读专题\",{\"1\":{\"204\":1}}],[\"面试题\",{\"0\":{\"780\":1,\"1026\":1,\"1030\":1,\"1056\":1,\"1126\":1,\"1155\":1,\"1171\":1,\"1223\":1,\"1236\":1},\"1\":{\"101\":1,\"1026\":2,\"1030\":2,\"1041\":2,\"1056\":2,\"1067\":1,\"1126\":2,\"1141\":1,\"1155\":2,\"1171\":2,\"1197\":2,\"1210\":1,\"1223\":2,\"1236\":2},\"2\":{\"1029\":1,\"1038\":1,\"1055\":1,\"1066\":1,\"1082\":1,\"1096\":1,\"1110\":1,\"1125\":1,\"1140\":1,\"1154\":1,\"1170\":1,\"1183\":1,\"1196\":1,\"1209\":1,\"1222\":1,\"1235\":1,\"1248\":1}}],[\"面试总是会遇到被问\",{\"1\":{\"90\":1}}],[\"面试官\",{\"0\":{\"90\":1},\"1\":{\"950\":1,\"970\":2,\"972\":1,\"982\":1,\"984\":5,\"986\":11,\"990\":1,\"996\":1,\"1002\":1}}],[\"面试专题合集\",{\"0\":{\"204\":1}}],[\"面试专题\",{\"0\":{\"1421\":1},\"1\":{\"49\":1}}],[\"嵌套类型将数组中的每个\",{\"1\":{\"451\":1}}],[\"嵌套类型就是为了解决这种问题的\",{\"1\":{\"451\":1}}],[\"嵌套类型可以看成是一个特殊的对象类型\",{\"1\":{\"451\":1}}],[\"嵌套类型\",{\"0\":{\"451\":1}}],[\"属性填充完成后\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"属性分别有\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"属性配置\",{\"1\":{\"952\":1}}],[\"属性设置\",{\"1\":{\"952\":1}}],[\"属性控制\",{\"1\":{\"952\":1}}],[\"属性赋值\",{\"1\":{\"952\":1}}],[\"属性的类型\",{\"1\":{\"797\":1}}],[\"属性的值设为\",{\"1\":{\"625\":1}}],[\"属性的值增一\",{\"1\":{\"625\":1}}],[\"属性中指定的属性\",{\"1\":{\"766\":1}}],[\"属性中指定的配置文件次之\",{\"1\":{\"766\":1}}],[\"属性指定的路径读取属性文件\",{\"1\":{\"766\":1}}],[\"属性读取类路径下属性文件或根据\",{\"1\":{\"766\":1}}],[\"属性也可以被传递到\",{\"1\":{\"766\":1}}],[\"属性将会由\",{\"1\":{\"766\":1}}],[\"属性文件中配置\",{\"1\":{\"766\":1}}],[\"属性说明\",{\"1\":{\"724\":1}}],[\"属性记录\",{\"1\":{\"635\":1}}],[\"属性是一个包含两个项的数组\",{\"1\":{\"624\":1}}],[\"属性\",{\"1\":{\"620\":1,\"635\":1,\"648\":1,\"952\":2}}],[\"属性为\",{\"1\":{\"447\":1}}],[\"属于线程自身所有\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"属于两种特定统计情况\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"属于地理空间数据类型查询\",{\"1\":{\"495\":1}}],[\"属于\",{\"1\":{\"371\":1,\"1205\":1,\"1385\":1}}],[\"属于原地排序方式\",{\"1\":{\"348\":1}}],[\"底层定义了一个\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"底层封装了jdbc获取自增主键\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"底层数据结构\",{\"1\":{\"946\":1}}],[\"底层依然采用的是时间戳的形式存储\",{\"1\":{\"445\":1}}],[\"底数大小与节点的子节点数目有关\",{\"1\":{\"266\":1}}],[\"底数为2\",{\"1\":{\"266\":1}}],[\"格式化的日期字符串\",{\"1\":{\"445\":1}}],[\"格式的示例\",{\"1\":{\"180\":1}}],[\"商品信息\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"商品信息的操作的高效率不会被商品描述的低效率所拖累\",{\"1\":{\"516\":1}}],[\"商品编号生成\",{\"1\":{\"653\":1}}],[\"商品按时间的上新排行榜等\",{\"1\":{\"594\":1}}],[\"商品名称等\",{\"1\":{\"443\":1}}],[\"商务合作\",{\"1\":{\"217\":1}}],[\"姓名\",{\"1\":{\"443\":1,\"1444\":1}}],[\"姓氏\",{\"1\":{\"436\":3}}],[\"邮箱\",{\"1\":{\"1444\":1}}],[\"邮箱中的垃圾邮件过滤等\",{\"1\":{\"330\":1}}],[\"邮件内容等比较长的文字\",{\"1\":{\"443\":1}}],[\"核心注解为\",{\"1\":{\"1227\":1,\"1402\":1}}],[\"核心的两个配置文件\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"核心配置文件是什么\",{\"0\":{\"1226\":1,\"1401\":1}}],[\"核心组件有哪些\",{\"0\":{\"1034\":1}}],[\"核心\",{\"1\":{\"1032\":1}}],[\"核心思路是copy\",{\"1\":{\"962\":1}}],[\"核心思想扩展order对象\",{\"1\":{\"793\":1}}],[\"核心线程数是线程池中最少的线程数\",{\"1\":{\"926\":1}}],[\"核心文件\",{\"1\":{\"817\":1}}],[\"核心命令\",{\"1\":{\"703\":1,\"704\":1}}],[\"核心类型\",{\"0\":{\"442\":1},\"1\":{\"441\":1}}],[\"核心业务逻辑\",{\"0\":{\"200\":1}}],[\"除此之外\",{\"1\":{\"934\":1,\"966\":1}}],[\"除此之外它在\",{\"1\":{\"629\":1}}],[\"除非index设置成no选项\",{\"1\":{\"440\":1}}],[\"除了提供beanfactory所具有的功能外\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"除了整数值对象\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"除了事务问题\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"除了\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"除了线程安全这点本质区别外\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"除了hash这个属性其它属性都声明为final\",{\"1\":{\"1089\":1,\"1290\":1}}],[\"除了hashmap\",{\"1\":{\"922\":1}}],[\"除了这俩点\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"除了声明为private和final的方法\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"除了缓存服务器自带的缓存自动失效策略之外\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"除了基本的搜索功能\",{\"1\":{\"998\":1}}],[\"除了上述的措施外\",{\"1\":{\"984\":1}}],[\"除了上述方法\",{\"1\":{\"982\":1}}],[\"除了上面几种应用外\",{\"1\":{\"165\":1}}],[\"除了知道每个阶段的调用外\",{\"1\":{\"952\":1}}],[\"除了查找效率高于linkedhashmap外\",{\"1\":{\"948\":1}}],[\"除了我们讨论过的remembered\",{\"1\":{\"940\":1}}],[\"除了前面介绍过的\",{\"1\":{\"635\":1}}],[\"除了分配修改时所必要的空间\",{\"1\":{\"620\":1}}],[\"除了接口路径\",{\"1\":{\"177\":1}}],[\"纯手写\",{\"1\":{\"438\":1}}],[\"纯视频\",{\"1\":{\"133\":1}}],[\"俩种都可以\",{\"1\":{\"916\":1}}],[\"俩种方法\",{\"1\":{\"438\":1}}],[\"俩个键在同一个节点\",{\"1\":{\"624\":1}}],[\"俩个人同时买一个商品\",{\"1\":{\"553\":1}}],[\"俩万通用后台管理系统\",{\"1\":{\"219\":1}}],[\"名字就叫\",{\"1\":{\"913\":1}}],[\"名字\",{\"1\":{\"436\":3,\"723\":1}}],[\"名称无所谓\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"名称\",{\"1\":{\"186\":1,\"956\":1}}],[\"另外一个线程才可以执行其run\",{\"1\":{\"1098\":1,\"1296\":1}}],[\"另外对于写操作\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"另外只有\",{\"1\":{\"434\":1}}],[\"另外\",{\"0\":{\"1074\":1,\"1278\":1},\"1\":{\"433\":1,\"594\":1,\"928\":2,\"980\":1,\"984\":2,\"1047\":1,\"1115\":1,\"1256\":1,\"1310\":1}}],[\"另外还有\",{\"1\":{\"432\":1}}],[\"另一种是类名中含有decorator\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"另一种方法是使用\",{\"1\":{\"1022\":1}}],[\"另一种情况\",{\"1\":{\"917\":1}}],[\"另一端做pop操作\",{\"1\":{\"288\":1}}],[\"另一个是控制时序\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"另一个是答arraylist和linkedlist的实现细节\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"另一个是删除操作\",{\"1\":{\"282\":1}}],[\"另一个在同一个lockobj锁定\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"另一个方法是使用批量发送消息的方式来提高吞吐量\",{\"1\":{\"982\":1}}],[\"另一个缺点是kafka对磁盘的使用比较高\",{\"1\":{\"978\":1}}],[\"另一个常见的使用场景是实时数据流处理\",{\"1\":{\"976\":1}}],[\"另一个优化策略是使用redlock算法来增加锁的可靠性\",{\"1\":{\"970\":1}}],[\"另一个类型参数\",{\"1\":{\"966\":1}}],[\"另一个仅在进行\",{\"1\":{\"626\":1}}],[\"另一个产品小西也过来要人\",{\"1\":{\"153\":1}}],[\"字典被广泛用于实现\",{\"1\":{\"626\":1}}],[\"字典只使用\",{\"1\":{\"624\":1}}],[\"字典所使用的哈希表由\",{\"1\":{\"624\":1}}],[\"字典是\",{\"1\":{\"624\":1}}],[\"字典\",{\"0\":{\"623\":1},\"1\":{\"624\":1}}],[\"字节编解码器用于将字节流转换为字符流\",{\"1\":{\"1020\":1}}],[\"字节数组\",{\"1\":{\"619\":1}}],[\"字节字符串\",{\"1\":{\"591\":1}}],[\"字段来实现\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"字段做路由分发被转发到对应的shard上\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"字段包括\",{\"1\":{\"948\":1}}],[\"字段是一个\",{\"1\":{\"451\":1}}],[\"字段是否可以被索引\",{\"1\":{\"432\":1}}],[\"字段长度越短\",{\"1\":{\"444\":1}}],[\"字段不能被用于排序\",{\"1\":{\"443\":1}}],[\"字段不会被修改来显示复制的值\",{\"1\":{\"436\":1}}],[\"字段类型使用时间戳\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"字段类型主要有\",{\"1\":{\"441\":1}}],[\"字段类型类似于\",{\"1\":{\"441\":1}}],[\"字段数据类型\",{\"0\":{\"441\":1}}],[\"字段级别的分数加权\",{\"1\":{\"440\":1}}],[\"字段将不会被索引\",{\"1\":{\"440\":1}}],[\"字段的值一同读出\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"字段的时候\",{\"1\":{\"439\":1}}],[\"字段的附加属性不满足我们的需求\",{\"1\":{\"438\":1}}],[\"字段仍然可以分别查询\",{\"1\":{\"436\":1}}],[\"字段复制到full\",{\"1\":{\"436\":1}}],[\"字段\",{\"1\":{\"429\":1,\"436\":1,\"511\":1,\"944\":2,\"1072\":1,\"1137\":1,\"1138\":1,\"1276\":1,\"1330\":1,\"1331\":1,\"1431\":1}}],[\"字符串缩减后的空间不释放\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"字符串优化\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"字符串直接拼接\",{\"1\":{\"763\":1}}],[\"字符串函数\",{\"1\":{\"620\":1}}],[\"字符串函数库里面的函数\",{\"1\":{\"619\":1}}],[\"字符串方式是redis最简单的数据类型\",{\"1\":{\"603\":1}}],[\"字符串\",{\"0\":{\"603\":1},\"1\":{\"589\":1,\"601\":1,\"619\":1}}],[\"字符串允许嵌套对象\",{\"1\":{\"450\":1}}],[\"字符串类型也可以被\",{\"1\":{\"446\":1}}],[\"字符串类型\",{\"0\":{\"443\":1}}],[\"字符串常量池所在的内存块没有空间了\",{\"1\":{\"196\":1}}],[\"字符串切割\",{\"1\":{\"94\":1}}],[\"学生就是各个线程\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"学生之间不用相互等待\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"学生和学习者可以公众号后台回复\",{\"1\":{\"643\":1}}],[\"学号不能为空\",{\"1\":{\"831\":1}}],[\"学号\",{\"1\":{\"824\":1,\"825\":1}}],[\"学会构建一个好的索引\",{\"1\":{\"428\":1}}],[\"学习后会对整个计算机的理解更近一步\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"学习和掌握kafka将是一个很好的选择\",{\"1\":{\"978\":1}}],[\"学习java\",{\"1\":{\"942\":1}}],[\"学习各项运行指标的测量与对调优的意义\",{\"1\":{\"942\":1}}],[\"学习者对链表应该都很熟悉\",{\"1\":{\"621\":1}}],[\"学习者和爱好者\",{\"1\":{\"523\":1}}],[\"学习阶段初学者\",{\"1\":{\"406\":1}}],[\"学习\",{\"1\":{\"397\":1,\"652\":1}}],[\"学习一个新技术\",{\"1\":{\"397\":1}}],[\"学习一个东西\",{\"1\":{\"153\":1}}],[\"学习目标\",{\"1\":{\"394\":1}}],[\"学习基础数据结构\",{\"0\":{\"277\":1}}],[\"短语查询\",{\"1\":{\"425\":1}}],[\"额外记载了两类信息\",{\"1\":{\"425\":1}}],[\"之前不会启动\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"之前的消息暴露给消费者\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"之前\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"之前整理过一些\",{\"1\":{\"844\":1}}],[\"之前你是基于\",{\"1\":{\"656\":1}}],[\"之后就可以使用这个bean\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"之后必须手动赋值\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"之后我们可以直接调用\",{\"1\":{\"958\":1}}],[\"之后使用cas保证并发度高的操作\",{\"1\":{\"922\":1}}],[\"之后会出第二季吗\",{\"1\":{\"920\":1}}],[\"之后的教程讲述和spring整合之后解决\",{\"1\":{\"772\":1}}],[\"之后复制对应的坐标到pom\",{\"1\":{\"705\":1}}],[\"之后线程就不再和对象在堆内存变量值有任何关系\",{\"1\":{\"692\":1}}],[\"之后\",{\"1\":{\"443\":1,\"1178\":1,\"1186\":1,\"1363\":1,\"1369\":1}}],[\"之所以如此\",{\"1\":{\"425\":1}}],[\"之所以要记录这个信息\",{\"1\":{\"425\":2}}],[\"之间\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"之间是兼容的\",{\"1\":{\"575\":1}}],[\"之间的三条数据\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"之间的区别是什么\",{\"0\":{\"1114\":1,\"1309\":1}}],[\"之间的依赖关系对生命周期的影响\",{\"1\":{\"952\":1}}],[\"之间的依赖关系\",{\"1\":{\"950\":1}}],[\"之间的距离\",{\"1\":{\"660\":1}}],[\"之间的\",{\"1\":{\"629\":1}}],[\"之间的间隙上设置间隙锁\",{\"1\":{\"558\":1}}],[\"之间的节点\",{\"1\":{\"270\":1}}],[\"之间进行循环\",{\"1\":{\"288\":1}}],[\"倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息\",{\"1\":{\"424\":1}}],[\"倒排列表\",{\"1\":{\"424\":2}}],[\"倒排文件是存储倒排索引的物理文件\",{\"1\":{\"424\":1}}],[\"倒排文件\",{\"1\":{\"424\":2}}],[\"倒排索引也就是单词到文档的映射\",{\"1\":{\"1069\":1,\"1273\":1}}],[\"倒排索引可以帮助用户快速找到想要的商品\",{\"1\":{\"1006\":1}}],[\"倒排索引在搜索引擎\",{\"1\":{\"1006\":1}}],[\"倒排索引会记录下这个关键词在文档1中出现过\",{\"1\":{\"1006\":1}}],[\"倒排索引存储\",{\"1\":{\"443\":1}}],[\"倒排索引的相关配置\",{\"1\":{\"429\":1}}],[\"倒排索引从逻辑结构和基本思路上来讲非常简单\",{\"1\":{\"425\":1}}],[\"倒排索引主要由两个部分组成\",{\"1\":{\"424\":1}}],[\"倒排索引是实现\",{\"1\":{\"424\":1}}],[\"倒排索引\",{\"1\":{\"424\":1,\"1002\":1}}],[\"倒排索引相关术语\",{\"0\":{\"424\":1}}],[\"倒序遍历数组获取出现顺序从大到小的排列\",{\"1\":{\"353\":1}}],[\"废弃问题\",{\"1\":{\"419\":1}}],[\"类即可\",{\"1\":{\"1444\":1}}],[\"类a通过构造函数注入需要类b的实例\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"类存储的\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"类先实现拦截器\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"类是\",{\"1\":{\"1023\":1}}],[\"类来实现可重入锁\",{\"1\":{\"1022\":1}}],[\"类来自定义线程池\",{\"1\":{\"926\":1}}],[\"类中使用\",{\"1\":{\"1016\":1}}],[\"类中名为\",{\"1\":{\"1010\":2}}],[\"类等\",{\"1\":{\"944\":1}}],[\"类的实现\",{\"1\":{\"1023\":1}}],[\"类的实例\",{\"1\":{\"1010\":2}}],[\"类的泛型参数\",{\"1\":{\"1010\":1}}],[\"类的\",{\"1\":{\"1010\":4}}],[\"类的私有成员上\",{\"1\":{\"944\":1}}],[\"类的生命周期中\",{\"1\":{\"934\":1}}],[\"类的生命周期描述了一个类从被加载到被卸载的整个过程\",{\"1\":{\"934\":1}}],[\"类的生命周期\",{\"1\":{\"934\":1}}],[\"类的内部类\",{\"1\":{\"932\":1}}],[\"类加载器\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"类加载子系统\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"类加载等情况\",{\"1\":{\"942\":1}}],[\"类加载双亲委派模型带来的好处主要有两点\",{\"1\":{\"934\":1}}],[\"类加载的顺序为\",{\"1\":{\"934\":1}}],[\"类加载过程\",{\"0\":{\"934\":1}}],[\"类及其子类负责finding和loading操作\",{\"1\":{\"934\":1}}],[\"类则是\",{\"1\":{\"932\":1}}],[\"类\",{\"1\":{\"924\":1,\"932\":1,\"944\":2,\"1016\":2}}],[\"类名或者接口名\",{\"1\":{\"966\":1}}],[\"类名\",{\"1\":{\"772\":1,\"934\":1}}],[\"类名称\",{\"1\":{\"689\":1,\"1091\":1,\"1292\":1}}],[\"类处理器\",{\"0\":{\"769\":1}}],[\"类似非阻塞\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"类似阻塞式\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"类似这样\",{\"1\":{\"913\":1}}],[\"类似的命令还有\",{\"1\":{\"603\":1}}],[\"类似\",{\"1\":{\"589\":1,\"1191\":1,\"1374\":1}}],[\"类似地\",{\"1\":{\"574\":1}}],[\"类似于jdbc的封装\",{\"1\":{\"1173\":1,\"1358\":1}}],[\"类似于数据库中的记录\",{\"1\":{\"1002\":1}}],[\"类似于数据库中的表的类型\",{\"1\":{\"1002\":1}}],[\"类似于数据库中的表\",{\"1\":{\"1002\":1}}],[\"类似于数据库中的表结构定义\",{\"1\":{\"429\":1}}],[\"类似于\",{\"1\":{\"654\":1,\"1068\":1,\"1272\":1}}],[\"类似于关系型数据库的数据库实例\",{\"1\":{\"418\":1}}],[\"类型就像是表中的记录类型\",{\"1\":{\"998\":1}}],[\"类型或其子类\",{\"1\":{\"966\":1}}],[\"类型擦除有利有弊\",{\"1\":{\"966\":1}}],[\"类型擦除就是编译器删除所有与类型参数相关的信息\",{\"1\":{\"966\":1}}],[\"类型擦除是干嘛的\",{\"1\":{\"966\":1}}],[\"类型参数t是在定义泛型类box时使用的\",{\"1\":{\"966\":1}}],[\"类型安全\",{\"1\":{\"966\":1}}],[\"类型内建了许多相应的类型别名\",{\"1\":{\"768\":1}}],[\"类型命名的一个短的名字\",{\"1\":{\"768\":1}}],[\"类型别名是为\",{\"1\":{\"768\":1}}],[\"类型特定函数\",{\"1\":{\"624\":1}}],[\"类型元素的集合\",{\"1\":{\"607\":1}}],[\"类型中会涉及到很多的\",{\"1\":{\"600\":1}}],[\"类型相对更多\",{\"1\":{\"589\":1}}],[\"类型去查询\",{\"1\":{\"501\":1}}],[\"类型不匹配导致隐式转换\",{\"1\":{\"501\":1}}],[\"类型字段的名称\",{\"1\":{\"457\":1}}],[\"类型是\",{\"1\":{\"457\":1}}],[\"类型的参数\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"类型的分数\",{\"1\":{\"607\":1}}],[\"类型的无序集合\",{\"1\":{\"606\":1}}],[\"类型的数据\",{\"1\":{\"592\":1}}],[\"类型的\",{\"1\":{\"457\":1,\"605\":1,\"658\":1}}],[\"类型的字段时\",{\"1\":{\"501\":1}}],[\"类型的字段\",{\"1\":{\"456\":1}}],[\"类型的字段可以用来存储\",{\"1\":{\"456\":1}}],[\"类型的自动识别是基于\",{\"1\":{\"439\":1}}],[\"类型和\",{\"1\":{\"455\":1}}],[\"类型可以表达一块地理区域\",{\"1\":{\"454\":1}}],[\"类型会被\",{\"1\":{\"443\":1}}],[\"类型适用于需要被全文检索的字段\",{\"1\":{\"443\":1}}],[\"类型已经不再支持了\",{\"1\":{\"443\":1}}],[\"类型自动识别字段对应表\",{\"1\":{\"439\":1}}],[\"类型自动识别\",{\"0\":{\"439\":1}}],[\"类型支持设定\",{\"1\":{\"434\":1}}],[\"类型默认配置为\",{\"1\":{\"433\":1}}],[\"类型\",{\"0\":{\"456\":1},\"1\":{\"387\":1,\"419\":1,\"439\":1,\"444\":1,\"450\":1,\"455\":3,\"501\":1,\"635\":1,\"769\":1,\"830\":1,\"966\":1,\"998\":1,\"1002\":1,\"1179\":2,\"1364\":2}}],[\"具有相同的方法名\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"具有相同结构的文档的集合\",{\"1\":{\"418\":1}}],[\"具有下面这些优点\",{\"1\":{\"1032\":1}}],[\"具有更高的性能和更好的扩展性\",{\"1\":{\"1020\":1}}],[\"具有灵活的消息传递模型和持久性存储的能力\",{\"1\":{\"978\":1}}],[\"具有上界的语义\",{\"1\":{\"966\":1}}],[\"具有高选择性的列\",{\"1\":{\"502\":2}}],[\"具有唯一性约束的列\",{\"1\":{\"502\":1}}],[\"具体实现都是由各数据库自己实现\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"具体看运行时定\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"具体用哪种方案\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"具体可参考\",{\"1\":{\"832\":1}}],[\"具体顺序遵循文档的顺序\",{\"1\":{\"765\":1}}],[\"具体的值需要使用特殊的标识\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"具体的sql\",{\"1\":{\"827\":1}}],[\"具体的sql语句\",{\"1\":{\"776\":1,\"777\":1,\"778\":1}}],[\"具体的依赖范围有如下6种\",{\"1\":{\"706\":1}}],[\"具体的数据类型如下图所示\",{\"1\":{\"441\":1}}],[\"具体和操作系统有关\",{\"1\":{\"270\":1}}],[\"具体大小和操作系统有关\",{\"1\":{\"266\":1}}],[\"具体数量依赖外部存储器的特性\",{\"1\":{\"266\":1}}],[\"教程使用的是\",{\"1\":{\"412\":1,\"413\":1}}],[\"少创建临时对象等\",{\"1\":{\"942\":1}}],[\"少不了使用分词器\",{\"1\":{\"411\":1}}],[\"少年应有鸿鹄志\",{\"1\":{\"223\":1}}],[\"财经相关\",{\"1\":{\"408\":1}}],[\"哥\",{\"1\":{\"408\":1,\"425\":1}}],[\"示例\",{\"1\":{\"434\":1,\"558\":2,\"559\":1,\"561\":1,\"564\":1,\"565\":1,\"566\":1,\"571\":1,\"572\":2,\"619\":1,\"708\":1}}],[\"示例如下\",{\"1\":{\"406\":1}}],[\"示意图\",{\"1\":{\"351\":1}}],[\"仅针对需要分词的字段\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"仅记录数据库里面和快照不同的键\",{\"1\":{\"962\":1}}],[\"仅在事务提交时检查是否有其他事务对数据进行了修改\",{\"1\":{\"569\":1}}],[\"仅仅是撤回\",{\"1\":{\"918\":1}}],[\"仅仅调用site来生成站点\",{\"1\":{\"711\":1}}],[\"仅仅对字符串型和分词类型有效\",{\"1\":{\"440\":1}}],[\"仅仅添加一个配置就可以\",{\"1\":{\"401\":1}}],[\"仅选择视频流\",{\"1\":{\"143\":1}}],[\"适应行为的变化\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"适配器\",{\"1\":{\"956\":1}}],[\"适配\",{\"1\":{\"956\":1}}],[\"适用场景\",{\"1\":{\"569\":1,\"570\":1,\"1047\":1,\"1256\":1}}],[\"适用于大内存服务器\",{\"1\":{\"936\":1}}],[\"适用于大内存的机器\",{\"1\":{\"936\":1}}],[\"适用于对响应时间有要求的场景\",{\"1\":{\"936\":1,\"938\":1}}],[\"适用于微服务等\",{\"1\":{\"936\":1}}],[\"适用于服务请求量\",{\"1\":{\"883\":1}}],[\"适用于写操作多于读操作的环境\",{\"1\":{\"570\":1}}],[\"适用于写操作频繁或者写冲突可能性较高的场景\",{\"1\":{\"570\":1}}],[\"适用于写操作不频繁或者写冲突可能性较低的场景\",{\"1\":{\"569\":1}}],[\"适用于读操作远多于写操作的环境\",{\"1\":{\"569\":1}}],[\"适用于需要对整个表执行批量操作的场景\",{\"1\":{\"565\":1}}],[\"适用于需要高并发读写操作的场景\",{\"1\":{\"564\":1}}],[\"适用于需要较高并发性能的场景\",{\"1\":{\"561\":1,\"566\":1}}],[\"适用于全表操作\",{\"1\":{\"561\":1}}],[\"适用版本等各种问题\",{\"1\":{\"401\":1}}],[\"适当地使用它们可以使某些例程更有效\",{\"1\":{\"541\":1}}],[\"适当的回表是必要的\",{\"1\":{\"504\":1}}],[\"适合于多线程环境\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"适合大规模的数据恢复\",{\"1\":{\"962\":1}}],[\"适合阅读人群\",{\"0\":{\"523\":1}}],[\"适合建立索引\",{\"1\":{\"502\":1}}],[\"适合简短\",{\"1\":{\"443\":1}}],[\"适合初学\",{\"1\":{\"397\":1,\"411\":1,\"428\":1,\"460\":1}}],[\"团队提供的全新框架\",{\"1\":{\"401\":1}}],[\"然而\",{\"1\":{\"400\":1,\"499\":1,\"507\":1}}],[\"然后集群中\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"然后接受观察者的注册\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"然后接收者从中间件中接收消息\",{\"1\":{\"992\":1}}],[\"然后它还会提供一系列的默认配置\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"然后sessionfactory根据用户的每次请求\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"然后发送给slave节点\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"然后返回空\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"然后返回相关的结果\",{\"1\":{\"1006\":1}}],[\"然后直接清除掉端边界以外的内存\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"然后把他们添加在容器中\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"然后把扫描到的这些文件包装成properties对象\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"然后把接口里面的方法和sql语句绑定\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"然后把hashcode的高16位与低16位进行异或\",{\"1\":{\"1120\":1,\"1315\":1}}],[\"然后把堆内存\",{\"1\":{\"692\":1}}],[\"然后调用wait\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"然后调用它的\",{\"1\":{\"928\":1}}],[\"然后写两个简单的接口\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"然后睡觉\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"然后通知服务端开启线程去进行处理\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"然后通过类型安全的属性注入将这些配置属性注入进来\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"然后通过config\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"然后通过网络把旧的副本数据复制到新的副本上\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"然后通过反射调用\",{\"1\":{\"944\":1}}],[\"然后通过可视化的dashboard\",{\"1\":{\"883\":1}}],[\"然后通过$\",{\"1\":{\"779\":1}}],[\"然后定时\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"然后选出第一个\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"然后又变回x的时候\",{\"1\":{\"1018\":1}}],[\"然后又变回a\",{\"1\":{\"1018\":1}}],[\"然后一次性发送给\",{\"1\":{\"982\":1}}],[\"然后多个消费者可以并行地从这个主题中读取数据进行处理\",{\"1\":{\"980\":1}}],[\"然后你用它装了一个苹果\",{\"1\":{\"966\":1}}],[\"然后会调用\",{\"1\":{\"950\":1}}],[\"然后使用\",{\"1\":{\"944\":1}}],[\"然后进行清除回收\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"然后进行处理\",{\"1\":{\"990\":1}}],[\"然后进入阻塞状态\",{\"1\":{\"932\":1}}],[\"然后进一步处理高16位和低16位产生最终的hash值\",{\"1\":{\"922\":1}}],[\"然后输出\",{\"1\":{\"932\":1}}],[\"然后启动了\",{\"1\":{\"932\":2}}],[\"然后启动线程\",{\"1\":{\"692\":1}}],[\"然后就可以执行下一步操作了\",{\"1\":{\"932\":1}}],[\"然后就没有问题了\",{\"1\":{\"800\":1}}],[\"然后在用的时候\",{\"1\":{\"966\":1}}],[\"然后在配置文件中进行配置\",{\"1\":{\"958\":1}}],[\"然后在映射文件中\",{\"1\":{\"958\":1}}],[\"然后在注入依赖时\",{\"1\":{\"954\":1}}],[\"然后在另一个线程中读取它的值\",{\"1\":{\"924\":1}}],[\"然后在创建新表\",{\"1\":{\"864\":1}}],[\"然后重新计算hash值\",{\"1\":{\"922\":1}}],[\"然后重新投票\",{\"1\":{\"166\":1}}],[\"然后鼠标一直向下滚动\",{\"1\":{\"913\":1}}],[\"然后prometheus应用从此接口定时拉取数据\",{\"1\":{\"883\":1}}],[\"然后新建一个类\",{\"1\":{\"839\":1}}],[\"然后点击生成或\",{\"1\":{\"837\":1}}],[\"然后根据设置的\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"然后根据hash值映射到指定的分区上\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"然后根据哈希运算的结果中的\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"然后根据\",{\"1\":{\"766\":1}}],[\"然后其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值\",{\"1\":{\"766\":1}}],[\"然后从本地仓库\",{\"1\":{\"715\":1}}],[\"然后b项目依赖于a项目\",{\"1\":{\"708\":1}}],[\"然后修改\",{\"1\":{\"692\":1}}],[\"然后对表中的特定行加排他锁\",{\"1\":{\"557\":1}}],[\"然后insert\",{\"0\":{\"542\":1}}],[\"然后这样查询\",{\"1\":{\"526\":1}}],[\"然后分布在不同数据库\",{\"1\":{\"517\":1}}],[\"然后分布式部署到不同容器\",{\"1\":{\"387\":1}}],[\"然后存储到哈希表中\",{\"1\":{\"495\":1}}],[\"然后将sql执行结果返回\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"然后将执行结果返回给web服务器\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"然后将哈希值映射到对应的哈希槽上\",{\"1\":{\"968\":1}}],[\"然后将新键值对添加到该位置或链表中\",{\"1\":{\"948\":1}}],[\"然后将计数器的值设置为线程的数量\",{\"1\":{\"932\":1}}],[\"然后将计数器的值设置为子任务的数量\",{\"1\":{\"932\":1}}],[\"然后将剩余n\",{\"1\":{\"364\":1}}],[\"然后将此存储单元数据放到数据总线上\",{\"1\":{\"273\":1}}],[\"然后\",{\"0\":{\"543\":1},\"1\":{\"351\":1,\"374\":1,\"692\":1,\"1000\":1,\"1004\":1,\"1010\":2,\"1016\":1,\"1100\":1,\"1298\":1}}],[\"然后异常返回\",{\"1\":{\"274\":1}}],[\"然后磁盘旋转将目标扇区旋转到磁头下\",{\"1\":{\"274\":1}}],[\"然后说明自己的情况\",{\"1\":{\"212\":1}}],[\"然后各自将投票发送给集群中所有机器\",{\"1\":{\"166\":1}}],[\"然后各自将这个投票发给集群中其他机器\",{\"1\":{\"166\":1}}],[\"然后开始进入leader选举过程\",{\"1\":{\"166\":1}}],[\"然后再来看看这套系统\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"然后再恢复追加文件中的增量数据\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"然后再把\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"然后再把已使用的内存空间一次清理掉\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"然后再写入到\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"然后再申请\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"然后再创建代理对象\",{\"1\":{\"954\":1}}],[\"然后再添加\",{\"1\":{\"710\":1}}],[\"然后再将新值回到主内存\",{\"1\":{\"692\":1}}],[\"然后再说说主线程的执行过程\",{\"1\":{\"692\":1}}],[\"然后再进行一次磁盘i\",{\"1\":{\"497\":1}}],[\"然后再结合这些原理分析b\",{\"1\":{\"271\":1}}],[\"然后再开始针对性学习\",{\"1\":{\"98\":1}}],[\"然后再试着做一个项目\",{\"1\":{\"98\":1}}],[\"建立一个变量副本\",{\"1\":{\"692\":1}}],[\"建立索引可能没有太大必要\",{\"1\":{\"502\":1}}],[\"建立索引可以加快查询速度\",{\"1\":{\"502\":1}}],[\"建立索引是必要的\",{\"1\":{\"502\":1}}],[\"建立索引反而会增加额外开销\",{\"1\":{\"500\":1}}],[\"建立的特殊索引\",{\"1\":{\"495\":1}}],[\"建立在一个全文搜索引擎库\",{\"1\":{\"400\":1}}],[\"建议耐心阅读\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"建议使用名词用官方语言描述会更准确\",{\"1\":{\"1067\":1}}],[\"建议使用的时候和类名一致\",{\"1\":{\"768\":1}}],[\"建议阅读\",{\"1\":{\"1041\":1,\"1088\":1,\"1289\":1}}],[\"建议先读五遍\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"建议先读一下系列攻略目录\",{\"1\":{\"411\":1,\"428\":1,\"460\":1}}],[\"建议先用文末的代码demo练下手\",{\"1\":{\"1033\":1}}],[\"建议完全模仿\",{\"1\":{\"910\":1}}],[\"建议收藏\",{\"1\":{\"881\":1,\"895\":1,\"1026\":1,\"1030\":1,\"1041\":1,\"1056\":1,\"1067\":1,\"1083\":1,\"1097\":1,\"1111\":1,\"1126\":1,\"1141\":1,\"1155\":1,\"1171\":1,\"1184\":1,\"1197\":1,\"1210\":1,\"1223\":1,\"1236\":1,\"1249\":1}}],[\"建议收藏阅读\",{\"1\":{\"277\":1,\"515\":1}}],[\"建议对需要参与评分字段使用\",{\"1\":{\"440\":1}}],[\"建议环境\",{\"1\":{\"244\":1}}],[\"建议\",{\"1\":{\"199\":1}}],[\"建议开启\",{\"1\":{\"106\":1}}],[\"建议和打开文件数一致\",{\"1\":{\"106\":1}}],[\"好用\",{\"1\":{\"1444\":1}}],[\"好像明白了\",{\"1\":{\"1006\":1}}],[\"好像寒冬马上要侵蚀整个it行业\",{\"1\":{\"76\":1}}],[\"好问题\",{\"1\":{\"980\":1,\"994\":1,\"996\":1,\"1004\":1,\"1008\":1}}],[\"好主意\",{\"1\":{\"972\":1}}],[\"好处是可以在1\",{\"1\":{\"966\":1}}],[\"好嘞\",{\"1\":{\"966\":1}}],[\"好\",{\"1\":{\"934\":1,\"1045\":1,\"1254\":1}}],[\"好的面试官\",{\"1\":{\"936\":1}}],[\"好的\",{\"1\":{\"926\":1,\"932\":2,\"934\":1,\"950\":1,\"956\":1,\"966\":1,\"968\":1,\"972\":1,\"978\":1,\"986\":1,\"1008\":1,\"1022\":1}}],[\"好的办法就是一次批量一部分\",{\"1\":{\"728\":1}}],[\"好事成双\",{\"1\":{\"394\":1}}],[\"批量压缩kafka\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"批量读写kafka\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"批量发送消息\",{\"1\":{\"982\":1}}],[\"批量更新\",{\"1\":{\"722\":1}}],[\"批量插入\",{\"0\":{\"472\":1}}],[\"批量删除元素\",{\"1\":{\"284\":1}}],[\"批处理\",{\"1\":{\"394\":1}}],[\"理解起来可能会更顺畅\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"理解性阅读\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"理解透彻cas和aba问题\",{\"1\":{\"1018\":1}}],[\"理解了这两个概念的区别\",{\"1\":{\"966\":1}}],[\"理解\",{\"1\":{\"952\":1}}],[\"理解数组\",{\"1\":{\"946\":1}}],[\"理解jit\",{\"1\":{\"942\":1}}],[\"理解好锁的原理\",{\"1\":{\"552\":1}}],[\"理解倒排索引\",{\"0\":{\"423\":1},\"1\":{\"394\":1}}],[\"理论上来说\",{\"1\":{\"1033\":1,\"1145\":1,\"1336\":1}}],[\"理论上每台nginx服务器的最大连接数为\",{\"1\":{\"106\":1}}],[\"理论值应该是最多打开文件数\",{\"1\":{\"106\":1}}],[\"拼音分词器插件安装\",{\"0\":{\"413\":1},\"1\":{\"394\":1}}],[\"初始\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"初始标记代码示例\",{\"1\":{\"938\":1}}],[\"初始标记\",{\"1\":{\"936\":1,\"938\":1,\"940\":1,\"1150\":2,\"1341\":2}}],[\"初始容量为\",{\"1\":{\"928\":1}}],[\"初始状态index\",{\"1\":{\"916\":1}}],[\"初始化一个\",{\"1\":{\"1444\":1}}],[\"初始化项目\",{\"1\":{\"1444\":1}}],[\"初始化完成后\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"初始化完毕后\",{\"1\":{\"952\":1}}],[\"初始化方法\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"初始化方法有哪些\",{\"1\":{\"952\":1}}],[\"初始化bean\",{\"1\":{\"1214\":2,\"1391\":2}}],[\"初始化参数被传递给\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"初始化前后进行一些处理\",{\"1\":{\"952\":1}}],[\"初始化前阶段\",{\"1\":{\"952\":1}}],[\"初始化后调用这个方法\",{\"1\":{\"952\":1}}],[\"初始化后调用该方法\",{\"1\":{\"952\":1}}],[\"初始化后自动调用被此注解标注的方法\",{\"1\":{\"952\":1}}],[\"初始化阶段又可以分为几个步骤\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"初始化阶段\",{\"1\":{\"952\":1}}],[\"初始化以及其他aware接口回调\",{\"1\":{\"950\":1}}],[\"初始化仓库\",{\"1\":{\"913\":1}}],[\"初始化本地代码\",{\"1\":{\"913\":1}}],[\"初始化成功后\",{\"1\":{\"911\":1}}],[\"初始化2\",{\"1\":{\"289\":1}}],[\"初始化1\",{\"1\":{\"289\":1}}],[\"初始化\",{\"0\":{\"873\":1,\"910\":1},\"1\":{\"289\":1,\"648\":1,\"711\":1,\"934\":1,\"950\":1,\"1128\":1,\"1148\":1,\"1321\":1,\"1339\":1}}],[\"初始化队列\",{\"1\":{\"288\":2,\"289\":1}}],[\"初始化存储容器并且添加元素\",{\"1\":{\"285\":1}}],[\"初始化存储容器\",{\"1\":{\"285\":2}}],[\"初始化连接时最长能忍受多少个心跳时间间隔数\",{\"1\":{\"157\":1}}],[\"初始化对象\",{\"1\":{\"80\":1,\"1099\":2,\"1297\":2}}],[\"初始化内存空间\",{\"1\":{\"80\":1}}],[\"初步配置和使用\",{\"0\":{\"406\":1},\"1\":{\"394\":1}}],[\"敬请期待\",{\"1\":{\"394\":1}}],[\"移除所有上一次构建生成的文件\",{\"1\":{\"712\":1}}],[\"移除有序集合中给定的分数区间的所有成员\",{\"1\":{\"607\":1}}],[\"移除有序集合中给定的排名区间的所有成员\",{\"1\":{\"607\":1}}],[\"移除有序集合中给定的字典区间的所有成员\",{\"1\":{\"607\":1}}],[\"移除有序集合中的一个或多个成员\",{\"1\":{\"607\":1}}],[\"移除集合中一个或多个成员\",{\"1\":{\"606\":1}}],[\"移除并返回集合中的一个随机元素\",{\"1\":{\"606\":1}}],[\"移除列表的最后一个元素\",{\"1\":{\"604\":2}}],[\"移除列表元素\",{\"1\":{\"604\":1}}],[\"移除表中所有与\",{\"1\":{\"604\":1}}],[\"移除与\",{\"1\":{\"604\":2}}],[\"移出并获取列表的最后一个元素\",{\"1\":{\"604\":1}}],[\"移出并获取列表的第一个元素\",{\"1\":{\"604\":2}}],[\"移位并通过或运算拼到一起组成64位的id\",{\"1\":{\"388\":1}}],[\"移动元素过程中不再依赖原始集合\",{\"1\":{\"351\":1}}],[\"获得新的时间戳\",{\"1\":{\"388\":1}}],[\"获得下一个id\",{\"1\":{\"388\":1}}],[\"获取需要的\",{\"1\":{\"1444\":1}}],[\"获取到的结果是这样的\",{\"1\":{\"1431\":1}}],[\"获取候选的配置\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"获取的行锁会在当前事务结束时自动释放\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"获取的id虽然是唯一的\",{\"1\":{\"383\":1}}],[\"获取这条插入语句的自增而成的主键\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"获取数组的某个位置最直接的方法是对数组的长度取余数\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"获取cpu的使用权\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"获取入参\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"获取方法名称\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"获取缓存\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"获取对象的锁\",{\"1\":{\"1023\":2}}],[\"获取栈顶元素\",{\"1\":{\"1023\":2}}],[\"获取键值对的值\",{\"1\":{\"928\":1}}],[\"获取sqlsession\",{\"1\":{\"747\":2,\"757\":1,\"763\":1}}],[\"获取statement\",{\"1\":{\"737\":1}}],[\"获取连接超时时间\",{\"1\":{\"815\":1}}],[\"获取连接\",{\"1\":{\"737\":1}}],[\"获取地理位置的坐标\",{\"1\":{\"660\":1}}],[\"获取有序集合的成员数\",{\"1\":{\"607\":1}}],[\"获取集合的成员数\",{\"1\":{\"606\":1}}],[\"获取哈希表中所有值\",{\"1\":{\"605\":1}}],[\"获取哈希表中字段的数量\",{\"1\":{\"605\":1}}],[\"获取所有已经就绪的事件\",{\"1\":{\"1020\":1}}],[\"获取所有给定字段的值\",{\"1\":{\"605\":1}}],[\"获取所有哈希表中的字段\",{\"1\":{\"605\":1}}],[\"获取在哈希表中指定\",{\"1\":{\"605\":1}}],[\"获取存储在哈希表中指定字段的值\",{\"1\":{\"605\":1}}],[\"获取列表指定范围内的元素\",{\"1\":{\"604\":1}}],[\"获取列表长度\",{\"1\":{\"604\":1}}],[\"获取锁失败时读取的缓存\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"获取锁失败\",{\"1\":{\"1023\":1,\"1105\":2,\"1303\":2}}],[\"获取锁成功\",{\"1\":{\"1023\":1}}],[\"获取锁\",{\"1\":{\"577\":1,\"578\":1,\"579\":1}}],[\"获取出现的次数作为下标\",{\"1\":{\"353\":1}}],[\"获取指定节点的node\",{\"1\":{\"286\":1}}],[\"获取指定元素的所有位置\",{\"1\":{\"284\":1}}],[\"获取指定位置的元素\",{\"1\":{\"284\":1}}],[\"获取线性表的元素个数\",{\"1\":{\"284\":1}}],[\"获取视频课程点击\",{\"1\":{\"205\":1}}],[\"获取\",{\"1\":{\"115\":1,\"648\":2,\"952\":1,\"956\":1}}],[\"构架的程序中\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"构成循环\",{\"1\":{\"936\":1}}],[\"构造会话工厂\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"构造器注入避免\",{\"1\":{\"954\":1}}],[\"构造器循环依赖\",{\"1\":{\"954\":1}}],[\"构造器\",{\"1\":{\"944\":1}}],[\"构造器上\",{\"1\":{\"944\":1}}],[\"构造方法不能被重写\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"构造方法和方法参数\",{\"1\":{\"944\":1}}],[\"构造方法在每次创建实例时都会执行\",{\"1\":{\"934\":1}}],[\"构造方法执行\",{\"1\":{\"934\":3}}],[\"构造函数等\",{\"1\":{\"1010\":1}}],[\"构造函数\",{\"1\":{\"388\":1,\"488\":1,\"1431\":1}}],[\"构建自定义镜像\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"构建\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"构建倒排索引其实也很简单\",{\"1\":{\"1006\":1}}],[\"构建新aof\",{\"1\":{\"962\":1}}],[\"构建sqlsessionfactory\",{\"0\":{\"746\":1},\"1\":{\"746\":1,\"747\":1,\"757\":1,\"763\":1}}],[\"构建的核心部分\",{\"1\":{\"711\":1}}],[\"构建maven项目命令的使用\",{\"0\":{\"705\":1}}],[\"构建mapping方式\",{\"0\":{\"438\":1}}],[\"构建临时索引\",{\"1\":{\"438\":1}}],[\"构建大顶堆\",{\"1\":{\"364\":1}}],[\"结合hashmap提供按插入顺序或访问顺序遍历map中的条目\",{\"1\":{\"922\":1}}],[\"结束\",{\"1\":{\"801\":1,\"865\":1}}],[\"结束循环\",{\"1\":{\"692\":1}}],[\"结构体\",{\"1\":{\"1431\":2}}],[\"结构包含的最后一个属性为\",{\"1\":{\"635\":1}}],[\"结构的\",{\"1\":{\"635\":1}}],[\"结构则用于保存跳跃表节点的相关信息\",{\"1\":{\"628\":1}}],[\"结构用于表示跳跃表节点\",{\"1\":{\"628\":1}}],[\"结构都保存着一个键值对\",{\"1\":{\"624\":1}}],[\"结构表示\",{\"1\":{\"624\":2}}],[\"结构表示一个\",{\"1\":{\"619\":1}}],[\"结构定义\",{\"1\":{\"624\":1}}],[\"结构组成的链表\",{\"1\":{\"621\":1}}],[\"结构和三个\",{\"1\":{\"621\":1}}],[\"结构来表示\",{\"1\":{\"621\":1,\"622\":2}}],[\"结构做了梳理\",{\"1\":{\"613\":1}}],[\"结构化字符串\",{\"1\":{\"443\":1}}],[\"结构混乱\",{\"1\":{\"364\":1}}],[\"结果映射配置等信息\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"结果result\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"结果中被过滤掉\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"结果都是一样的\",{\"1\":{\"996\":1}}],[\"结果集封装\",{\"0\":{\"829\":1}}],[\"结果集对应的数据类型\",{\"1\":{\"797\":1}}],[\"结果集分装\",{\"1\":{\"394\":1}}],[\"结果\",{\"1\":{\"591\":1}}],[\"结果是31\",{\"1\":{\"388\":2}}],[\"产生死锁就是俩个或多个线程在申请资源时\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"产生原因\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"产生过aba问题\",{\"1\":{\"1018\":1}}],[\"产生碎片\",{\"1\":{\"938\":1}}],[\"产生4096个id序号<br>\",{\"1\":{\"388\":1}}],[\"产生投票\",{\"1\":{\"166\":1}}],[\"负荷大增\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"负责维护和跟踪\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"负责实时从\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"负责从master上拉取\",{\"1\":{\"1186\":1,\"1369\":1}}],[\"负责从\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"负责调度\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"负责显示\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"负责协调整个集群的操作\",{\"1\":{\"1008\":1}}],[\"负责将消息发送到\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"负责将消息推送\",{\"1\":{\"990\":1}}],[\"负责将受到的消息存储到磁盘中\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"负责将请求映射到对应的处理器\",{\"1\":{\"956\":1}}],[\"负责重写工作\",{\"1\":{\"962\":1}}],[\"负责数据填充和呈现结果\",{\"1\":{\"956\":1}}],[\"负责具体\",{\"1\":{\"956\":1}}],[\"负责转发请求到各个组件\",{\"1\":{\"956\":1}}],[\"负责加载用户自定义的类\",{\"1\":{\"934\":1}}],[\"负责加载jdk扩展目录中的jar包\",{\"1\":{\"934\":1}}],[\"负责加载jdk内置的类\",{\"1\":{\"934\":1}}],[\"负数是1\",{\"1\":{\"388\":1}}],[\"负载因子\",{\"1\":{\"625\":1}}],[\"负载均衡\",{\"0\":{\"165\":1},\"1\":{\"106\":1,\"964\":1,\"1237\":1,\"1244\":1,\"1410\":1,\"1417\":1}}],[\"负载均衡配置\",{\"1\":{\"106\":1}}],[\"负载的权重就越大\",{\"1\":{\"106\":1}}],[\"源码解读在javapub公众号发出\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"源码参考\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"源码分析将首发在\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"源码分析等\",{\"1\":{\"608\":1}}],[\"源码实现吗\",{\"1\":{\"1022\":1}}],[\"源码都背下来了\",{\"1\":{\"1022\":1,\"1023\":1}}],[\"源码阶段\",{\"1\":{\"944\":1}}],[\"源码地址\",{\"1\":{\"889\":1}}],[\"源码下载\",{\"1\":{\"867\":1}}],[\"源码在文末\",{\"1\":{\"807\":1}}],[\"源码案例下载\",{\"1\":{\"728\":1}}],[\"源码仓库\",{\"1\":{\"690\":1}}],[\"源码全部都在gitee免费提供\",{\"1\":{\"683\":1}}],[\"源码\",{\"0\":{\"388\":1,\"681\":1},\"1\":{\"812\":2,\"856\":1,\"878\":1,\"885\":1,\"944\":1,\"1444\":2}}],[\"台容器\",{\"1\":{\"387\":1}}],[\"况且\",{\"1\":{\"387\":1}}],[\"序言\",{\"0\":{\"522\":1}}],[\"序列化与反序列化\",{\"1\":{\"946\":1}}],[\"序列在id中占的位数\",{\"1\":{\"388\":1}}],[\"序列号就是消息的编号\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"序列号\",{\"1\":{\"387\":1}}],[\"序号\",{\"1\":{\"387\":1,\"605\":1,\"606\":1,\"607\":1}}],[\"云云就不介绍了\",{\"1\":{\"386\":1}}],[\"附加\",{\"0\":{\"899\":1}}],[\"附带功能化\",{\"1\":{\"877\":1}}],[\"附视频\",{\"0\":{\"870\":1,\"871\":1}}],[\"附源码\",{\"0\":{\"847\":1,\"859\":1,\"870\":1,\"871\":1,\"881\":1},\"1\":{\"380\":1,\"881\":1}}],[\"附录\",{\"0\":{\"252\":1}}],[\"版本后\",{\"1\":{\"1238\":1,\"1245\":1,\"1411\":1,\"1418\":1}}],[\"版本为1\",{\"1\":{\"854\":1}}],[\"版本锁定\",{\"1\":{\"715\":1}}],[\"版本也是网络并发\",{\"1\":{\"664\":1}}],[\"版本号时\",{\"1\":{\"1018\":1}}],[\"版本号作为乐观锁\",{\"1\":{\"1018\":1}}],[\"版本号由父工程里面统一指定不再需要特别指定\",{\"1\":{\"715\":1}}],[\"版本号\",{\"1\":{\"569\":2}}],[\"版本\",{\"1\":{\"412\":1,\"413\":1,\"488\":1,\"897\":1,\"1444\":1}}],[\"版本是\",{\"1\":{\"404\":1}}],[\"版本信息等\",{\"1\":{\"143\":1}}],[\"版雪花id生成算法\",{\"1\":{\"388\":1}}],[\"版\",{\"0\":{\"377\":1}}],[\"子加载器才会尝试自己去加载\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"子加载器才会尝试自己去加载这个类\",{\"1\":{\"934\":1}}],[\"子进程退出\",{\"1\":{\"962\":1}}],[\"子进程完成后\",{\"1\":{\"962\":1}}],[\"子进程构建新的aof\",{\"1\":{\"962\":1}}],[\"子进程载入当前数据库快照\",{\"1\":{\"962\":1}}],[\"子进程创建\",{\"1\":{\"962\":1}}],[\"子类加载器并不会马上去加载\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"子类和父类在同一个包中\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"子类或者实现类无法继承父类或者接口的注解\",{\"1\":{\"944\":1}}],[\"子类不会再重复加载该类\",{\"1\":{\"934\":1}}],[\"子对象的java类型\",{\"1\":{\"793\":1,\"794\":1}}],[\"子对象在父对象中的属性名\",{\"1\":{\"793\":1,\"794\":1}}],[\"子项目名称3<\",{\"1\":{\"716\":1}}],[\"子项目名称2<\",{\"1\":{\"716\":1}}],[\"子项目名称1<\",{\"1\":{\"716\":1}}],[\"子工程设置依赖\",{\"1\":{\"715\":1}}],[\"子工程中不再需要指定具体版本号\",{\"1\":{\"715\":1}}],[\"子句\",{\"1\":{\"556\":1}}],[\"子句中的\",{\"0\":{\"533\":1}}],[\"子句中使用\",{\"0\":{\"527\":1,\"528\":1},\"1\":{\"1192\":2,\"1375\":2}}],[\"子句中对字段进行函数操作\",{\"1\":{\"1192\":1,\"1375\":1}}],[\"子句中对字段进行表达式操作\",{\"0\":{\"531\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"子句中对字段进行\",{\"0\":{\"526\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"子句引用了符合索引的所有列或者前导列时\",{\"1\":{\"498\":1}}],[\"子字段\",{\"1\":{\"439\":1}}],[\"子桶\",{\"1\":{\"375\":2}}],[\"子节点数量一般在上千\",{\"1\":{\"266\":1}}],[\"由其负责协调多个\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"由那些注解组成\",{\"0\":{\"1227\":1,\"1402\":1}}],[\"由父\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"由此保持一致\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"由主动行为变为了被动行为\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"由会话工厂创建\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"由多个\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"由多个节点组成\",{\"1\":{\"1004\":1}}],[\"由java编译器实现\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"由jsp引擎完成\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"由应用层来处理具体的冲突\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"由它调用其它组件处理用户的请求\",{\"1\":{\"956\":1}}],[\"由remembered\",{\"1\":{\"940\":1}}],[\"由一个\",{\"1\":{\"621\":1}}],[\"由一台或多台的elasticsearch\",{\"1\":{\"416\":1}}],[\"由存储引擎在执行查询时自动管理决定的\",{\"1\":{\"556\":1}}],[\"由\",{\"1\":{\"488\":1,\"801\":1,\"832\":1,\"920\":1,\"1130\":3,\"1165\":1,\"1323\":3,\"1353\":1}}],[\"由分析过程产生\",{\"1\":{\"436\":1}}],[\"由数据中心id和机器id作区分\",{\"1\":{\"388\":1}}],[\"由我们程序来指定的\",{\"1\":{\"388\":1}}],[\"由键值的最左边开始\",{\"1\":{\"374\":1}}],[\"由于创建的节点是持久化的\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"由于spring\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"由于ioc容器的加入\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"由于instance已经指向了一块内存空间\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"由于引进了中间位置的\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"由于不需要移动存活对象\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"由于直接关联对象比较小\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"由于数组的长度通常不会超过2^16\",{\"1\":{\"1121\":1,\"1316\":1}}],[\"由于数据量本身就少\",{\"1\":{\"502\":1}}],[\"由于vector的方法都是同步方法\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"由于底层是双向链表\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"由于它内部维护了一个当前容量的指针size\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"由于它的持久性存储和消息回溯的特性\",{\"1\":{\"978\":1}}],[\"由于成员变量具有默认值\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"由于缓存是不命中时被动写\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"由于业务的复杂性\",{\"1\":{\"1018\":1}}],[\"由于锁定粒度太大\",{\"1\":{\"1018\":1}}],[\"由于锁定了整个表\",{\"1\":{\"561\":1,\"565\":1}}],[\"由于其查询效率高且适用于大容量场景\",{\"1\":{\"948\":1}}],[\"由于g1采用分代和分片回收\",{\"1\":{\"940\":1}}],[\"由于每个线程都有自己的变量副本\",{\"1\":{\"928\":2}}],[\"由于最近在项目当中用到了关于并发方面的技术\",{\"1\":{\"692\":1}}],[\"由于完全实现了发布\",{\"1\":{\"589\":1}}],[\"由于唯一键冲突\",{\"1\":{\"577\":1}}],[\"由于前期的快速开发\",{\"1\":{\"525\":1}}],[\"由于查询维度较多\",{\"1\":{\"515\":1}}],[\"由于使用了位图索引\",{\"1\":{\"505\":1}}],[\"由于long基本类型在java中是带符号的\",{\"1\":{\"388\":1}}],[\"由于在并发标记阶段中\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"由于在\",{\"1\":{\"387\":1}}],[\"由于\",{\"1\":{\"364\":1,\"499\":1,\"924\":1}}],[\"由于篇幅过长\",{\"1\":{\"343\":1}}],[\"由于磁盘顺序读取的效率很高\",{\"1\":{\"274\":1}}],[\"由于存储介质的特性\",{\"1\":{\"274\":1}}],[\"由于b线程增删元素会导致\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"由于b树的节点都存了key和data\",{\"1\":{\"270\":1}}],[\"由于b\",{\"1\":{\"270\":1}}],[\"由于b+树的高度通常较低\",{\"1\":{\"503\":1}}],[\"由于b+树的非叶子节点不存储实际数据\",{\"1\":{\"503\":1}}],[\"由于b+树的叶子节点的数据都是使用链表连接起来的\",{\"1\":{\"270\":1}}],[\"由于b+树所有的\",{\"1\":{\"270\":1}}],[\"由于内节点无\",{\"1\":{\"270\":1}}],[\"由于是初始情况\",{\"1\":{\"166\":1}}],[\"统称为\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"统一日志格式\",{\"1\":{\"1439\":1}}],[\"统一保存在\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"统一的\",{\"1\":{\"1032\":1}}],[\"统一一体化了其他框架和技术\",{\"1\":{\"950\":1}}],[\"统一依赖管理\",{\"1\":{\"699\":1}}],[\"统一为同样的数位长度\",{\"1\":{\"374\":1}}],[\"统计\",{\"1\":{\"658\":1,\"659\":1}}],[\"统计数组中每个值为i的元素出现的次数\",{\"1\":{\"358\":1}}],[\"统计每个元素出现的次数\",{\"1\":{\"353\":1}}],[\"统计投票\",{\"1\":{\"166\":2}}],[\"特此记录\",{\"1\":{\"722\":1}}],[\"特别适合排序需求\",{\"1\":{\"948\":1}}],[\"特别适合用于存储对象\",{\"1\":{\"605\":1}}],[\"特别是follower的数量越多\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"特别是热门商品\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"特别是list这个接口\",{\"1\":{\"946\":1}}],[\"特别是gc日志\",{\"1\":{\"942\":1}}],[\"特别是g1\",{\"1\":{\"942\":1}}],[\"特别是对于新手来说\",{\"1\":{\"978\":1}}],[\"特别是对于大型表\",{\"1\":{\"511\":1}}],[\"特别是对数据结构\",{\"1\":{\"922\":1}}],[\"特别是像生产者消费者模式中\",{\"1\":{\"164\":1}}],[\"特性实现的\",{\"1\":{\"1008\":1}}],[\"特性和分布式场景来分析会遇到哪些关键点\",{\"1\":{\"664\":1}}],[\"特性\",{\"0\":{\"592\":1},\"1\":{\"587\":1,\"1245\":1,\"1418\":1}}],[\"特殊类型包括\",{\"1\":{\"455\":1}}],[\"特殊类型\",{\"0\":{\"455\":1}}],[\"特点\",{\"0\":{\"372\":1},\"1\":{\"561\":2,\"569\":1,\"570\":1}}],[\"藉以达到排序的作用\",{\"1\":{\"371\":1}}],[\"桶子\",{\"1\":{\"375\":1}}],[\"桶子法\",{\"1\":{\"371\":1}}],[\"桶\",{\"1\":{\"371\":1}}],[\"桶排序的步骤\",{\"1\":{\"351\":1}}],[\"桶排序算法的复杂度和稳定性\",{\"1\":{\"350\":1}}],[\"桶排序则是提供了额外的操作空间\",{\"1\":{\"348\":1}}],[\"桶排序则是将集合拆分为多个桶\",{\"1\":{\"348\":1}}],[\"桶排序使用线性时间\",{\"1\":{\"348\":1}}],[\"桶排序是将待排序集合中处于同一个值域的元素存入同一个桶中\",{\"1\":{\"348\":1}}],[\"桶排序是\",{\"1\":{\"348\":2}}],[\"桶排序\",{\"0\":{\"348\":1},\"1\":{\"348\":1,\"353\":1,\"370\":3}}],[\"桶排序就是对计数排序\",{\"1\":{\"347\":1}}],[\"桶排序就是这么容易\",{\"0\":{\"346\":1},\"1\":{\"353\":1}}],[\"又能降低数据丢失的风险\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"又叫做写锁\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"又叫做读锁\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"又默认为分段后的数据文件建立了索引文件\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"又会将老的数据写入到\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"又分为两种\",{\"1\":{\"962\":1}}],[\"又是什么\",{\"1\":{\"958\":1}}],[\"又来挑战你了\",{\"1\":{\"948\":1}}],[\"又不想把没开发完的代码提交远程仓库\",{\"1\":{\"916\":1}}],[\"又想节省存储空间我们可以对数组进行压缩\",{\"1\":{\"632\":1}}],[\"又称\",{\"1\":{\"371\":1}}],[\"又可以充分利用bit数组的空间\",{\"1\":{\"339\":1}}],[\"级别的缓存\",{\"1\":{\"958\":2}}],[\"级别的缓\",{\"1\":{\"958\":1}}],[\"级别的结构化或者非结构化数据\",{\"1\":{\"400\":1}}],[\"级别越高压缩率越大\",{\"1\":{\"106\":1}}],[\"级\",{\"1\":{\"364\":1}}],[\"近似为nlogn\",{\"1\":{\"364\":1}}],[\"逐步递减\",{\"1\":{\"364\":1}}],[\"需谨慎使用非线程安全的类\",{\"1\":{\"988\":1}}],[\"需与用户程序同时运行\",{\"1\":{\"938\":1}}],[\"需求是怎么产生的\",{\"1\":{\"1439\":1}}],[\"需求从哪里来\",{\"1\":{\"1438\":1}}],[\"需求分析\",{\"0\":{\"1438\":1},\"1\":{\"1439\":1}}],[\"需求说明\",{\"1\":{\"792\":1}}],[\"需求\",{\"1\":{\"485\":1,\"1439\":1}}],[\"需交换n\",{\"1\":{\"364\":1}}],[\"需要全套源代码和手把手直播开发的朋友可阅读这里\",{\"1\":{\"1429\":1}}],[\"需要配置成\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"需要通过factory\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"需要在\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"需要在mybatis中\",{\"1\":{\"800\":1}}],[\"需要等待行锁被释放\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"需要等待\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"需要等到所有学生回寝\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"需要测试该进程对资源的最大需求量\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"需要\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"需要从你的集群取回大量的文档\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"需要被取回\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"需要提前预热到缓存中\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"需要过多的缓存空间\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"需要设置较短的过期时间\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"需要设置成server模式\",{\"1\":{\"692\":1}}],[\"需要考虑这个问题\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"需要考虑\",{\"1\":{\"1018\":1}}],[\"需要强一致性的用悲观锁\",{\"1\":{\"1018\":1}}],[\"需要强转类型\",{\"1\":{\"966\":1}}],[\"需要实现商品搜索功能\",{\"1\":{\"1000\":1}}],[\"需要权衡内存和cpu的使用情况\",{\"1\":{\"972\":1}}],[\"需要深入学习与理解\",{\"1\":{\"948\":1}}],[\"需要深入研读源码和官方文档方能全面理解\",{\"1\":{\"940\":1}}],[\"需要你继续努力\",{\"1\":{\"946\":1}}],[\"需要耐心学习与长期实践\",{\"1\":{\"942\":1}}],[\"需要部分stw\",{\"1\":{\"940\":1}}],[\"需要部分stw阶段\",{\"1\":{\"938\":1}}],[\"需要stop\",{\"1\":{\"940\":1}}],[\"需要stw\",{\"1\":{\"936\":2,\"938\":1,\"940\":2}}],[\"需要记录新生代和老年代以及各个region之间的引用链\",{\"1\":{\"940\":1}}],[\"需要更频繁的major\",{\"1\":{\"938\":1}}],[\"需要更长的读取时间\",{\"1\":{\"516\":1}}],[\"需要处理一致性问题\",{\"1\":{\"938\":1}}],[\"需要最终标记修正\",{\"1\":{\"938\":1}}],[\"需要重写hashcode\",{\"1\":{\"922\":1}}],[\"需要对其进行额外的同步措施\",{\"1\":{\"988\":1}}],[\"需要对hashmap进行同步处理\",{\"1\":{\"922\":1}}],[\"需要对每个不同的单词赋予唯一的单词编号\",{\"1\":{\"425\":1}}],[\"需要修改servlet版本为3\",{\"1\":{\"820\":1}}],[\"需要手动完成结果集映射resultmap\",{\"1\":{\"793\":1}}],[\"需要手动定义映射\",{\"1\":{\"456\":1}}],[\"需要使用$\",{\"1\":{\"779\":1}}],[\"需要使用多个hash函数\",{\"1\":{\"333\":1}}],[\"需要一个用户管理系统来把这些人管理起来\",{\"1\":{\"1439\":1}}],[\"需要一个一个的去加载mapper\",{\"1\":{\"772\":1}}],[\"需要一个leader\",{\"1\":{\"153\":1}}],[\"需要告诉\",{\"1\":{\"772\":1}}],[\"需要找一个用来唯一标识一个构建的统一规范\",{\"1\":{\"705\":1}}],[\"需要拿到这个锁来获取执行任务权限的应用都停止了\",{\"1\":{\"664\":1}}],[\"需要涉及到地图的业务才会使用\",{\"1\":{\"660\":1}}],[\"需要将两个账号粉丝进行去重统计\",{\"1\":{\"656\":1}}],[\"需要将磁头放到这个扇区上方\",{\"1\":{\"274\":1}}],[\"需要时直接从池中取用\",{\"1\":{\"645\":1}}],[\"需要自己手动来写\",{\"1\":{\"615\":1}}],[\"需要严格保证数据一致性的场合\",{\"1\":{\"570\":1}}],[\"需要支持高并发访问的系统\",{\"1\":{\"569\":1}}],[\"需要额外进行数据操作的路由工作\",{\"1\":{\"518\":1}}],[\"需要分析查询类型\",{\"1\":{\"502\":1}}],[\"需要维护树的平衡\",{\"1\":{\"499\":1}}],[\"需要确定全局唯一id是整型还是字符串\",{\"1\":{\"382\":1}}],[\"需要传入两个参数\",{\"1\":{\"339\":1}}],[\"需要注意的是counter只能增不能减\",{\"1\":{\"883\":1}}],[\"需要注意的是上图中的自定义路径必须存在\",{\"1\":{\"702\":1}}],[\"需要注意的是\",{\"1\":{\"288\":1,\"511\":1}}],[\"需要参数加密做好脱敏处理和说明\",{\"1\":{\"184\":1}}],[\"需要和外部公司对接\",{\"1\":{\"175\":1}}],[\"需要进入leader选举\",{\"1\":{\"166\":1}}],[\"调优\",{\"1\":{\"1151\":1}}],[\"调优的参数都有哪些\",{\"0\":{\"1151\":1,\"1342\":1}}],[\"调优手段是现在很常见的面试题\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"调度员\",{\"1\":{\"976\":1}}],[\"调整数据库隔离级别\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"调整线程池和队列大小\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"调整大顶堆\",{\"1\":{\"364\":1}}],[\"调整堆结构+交换堆顶元素与末尾元素\",{\"1\":{\"364\":1}}],[\"调用者就一目了然了\",{\"1\":{\"1431\":1}}],[\"调用getbean\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"调用不同的方法\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"调用statement来赋值\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"调用session\",{\"1\":{\"751\":2}}],[\"调用preparedstatement来赋值\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"调用配置的分区选择算法选择分区的leader\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"调用await\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"调用addelem添加的时间复杂度为o\",{\"1\":{\"286\":1}}],[\"调用interrupt方法是在当前线程中打了一个停止标志\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"调用了该对象的start\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"调用handler\",{\"1\":{\"956\":1}}],[\"调用方法之后\",{\"1\":{\"958\":1}}],[\"调用方法之前\",{\"1\":{\"958\":1}}],[\"调用方法\",{\"1\":{\"952\":1}}],[\"调用自定义的\",{\"1\":{\"952\":2}}],[\"调用相应的处理逻辑\",{\"1\":{\"944\":1}}],[\"调用静态方法\",{\"1\":{\"934\":1}}],[\"调用该类的静态方法\",{\"1\":{\"934\":1}}],[\"调用\",{\"1\":{\"251\":1,\"928\":1,\"950\":1,\"956\":3,\"1023\":2,\"1128\":1,\"1321\":1}}],[\"调用llama3试用\",{\"0\":{\"249\":1}}],[\"得到key在数组中对应的下标\",{\"1\":{\"1120\":1,\"1315\":1}}],[\"得到key的hash值\",{\"1\":{\"1120\":1,\"1315\":1}}],[\"得到主服务器最新的数据\",{\"1\":{\"964\":1}}],[\"得到请求对应的\",{\"1\":{\"950\":1}}],[\"得到的值\",{\"1\":{\"388\":1}}],[\"得到第二大元素8\",{\"1\":{\"364\":1}}],[\"得到数列的最大值\",{\"1\":{\"360\":1}}],[\"重做日志redo和回滚日志undo\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"重做日志\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"重定向\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"重写sql\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"重写\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"重载就是对于不同的情况写不同的方法\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"重载\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"重载和重写是一个特别好理解的概念\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"重载和重写区别\",{\"0\":{\"1086\":1,\"1287\":1}}],[\"重建缓存数据\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"重建索引\",{\"1\":{\"511\":1}}],[\"重量级锁是一种针对多线程访问同步块的默认策略\",{\"1\":{\"1022\":1}}],[\"重连后再次执行同步操作\",{\"1\":{\"964\":1}}],[\"重要的是候选人的心态和潜力\",{\"1\":{\"922\":1}}],[\"重构\",{\"1\":{\"922\":1}}],[\"重复预约异常\",{\"1\":{\"829\":2}}],[\"重复预约\",{\"1\":{\"829\":1,\"830\":2}}],[\"重复元素\",{\"1\":{\"630\":1}}],[\"重启或者网络故障导致不存在过半的服务器与\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"重启恢复慢\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"重启恢复数据\",{\"1\":{\"615\":1}}],[\"重启容器\",{\"1\":{\"1063\":1,\"1269\":1}}],[\"重启的时候可以再次加载进行使用\",{\"1\":{\"592\":1}}],[\"重启es\",{\"1\":{\"412\":1,\"413\":1}}],[\"重点\",{\"0\":{\"626\":1,\"629\":1,\"636\":1,\"728\":1},\"1\":{\"575\":1}}],[\"重点关注\",{\"1\":{\"101\":1}}],[\"重新标记\",{\"1\":{\"1150\":2,\"1341\":2}}],[\"重新标记阶段和并发清除阶段\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"重新加载servlet时会进行一次加载\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"重新获取\",{\"1\":{\"1105\":2,\"1303\":2}}],[\"重新拉取\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"重新计算后的索引位置有很大概率仍然会发生冲突\",{\"1\":{\"922\":1}}],[\"重新散列该位置之后的键值对\",{\"1\":{\"928\":1}}],[\"重新散列\",{\"0\":{\"625\":1}}],[\"重新对堆进行调整\",{\"1\":{\"364\":1}}],[\"重新调整结构\",{\"1\":{\"364\":1}}],[\"交错提交时有可能互相排斥导致没有一个proposer能提交成功\",{\"1\":{\"1246\":1,\"1419\":1}}],[\"交换会导致性能问题\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"交换元素\",{\"1\":{\"364\":1}}],[\"交换\",{\"1\":{\"364\":1}}],[\"交换4和6\",{\"1\":{\"364\":1}}],[\"交换导致了子根\",{\"1\":{\"364\":1}}],[\"交互\",{\"0\":{\"115\":1},\"1\":{\"1159\":1,\"1347\":1}}],[\"叶结点自然不用调整\",{\"1\":{\"364\":1}}],[\"叶子节点类似于一个单链表\",{\"1\":{\"264\":1}}],[\"叶子节点中有指向下一个叶子节点的指针\",{\"1\":{\"264\":1}}],[\"叶子节点保存了完整的索引和数据\",{\"1\":{\"264\":1}}],[\"整理算法\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"整理了一些读者的问题\",{\"1\":{\"920\":1}}],[\"整数集合的底层实现为\",{\"1\":{\"630\":1}}],[\"整数集合是\",{\"1\":{\"630\":1}}],[\"整数集合\",{\"0\":{\"630\":1},\"1\":{\"613\":1,\"630\":2}}],[\"整体上按照时间自增排序\",{\"1\":{\"388\":1}}],[\"整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成\",{\"1\":{\"364\":1}}],[\"整个生命周期也会有一些差别\",{\"1\":{\"1439\":1}}],[\"整个过程就是将类路径下\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"整个过程分为4个主要阶段\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"整个过程中\",{\"1\":{\"962\":1}}],[\"整个过程中最关键的部份是映射文件及映射过程\",{\"1\":{\"958\":1}}],[\"整个流程控制的中心\",{\"1\":{\"956\":1}}],[\"整个\",{\"1\":{\"952\":1}}],[\"整个分布式系统内不会产生重复id\",{\"1\":{\"387\":1}}],[\"整个序列的最大值就是堆顶的根节点\",{\"1\":{\"364\":1}}],[\"整合的时候解决\",{\"1\":{\"772\":1}}],[\"整合了所有的框架\",{\"1\":{\"401\":1}}],[\"整合了所有的\",{\"1\":{\"401\":1}}],[\"整合\",{\"0\":{\"889\":1},\"1\":{\"251\":1}}],[\"称为\",{\"1\":{\"400\":1}}],[\"称为小顶堆\",{\"1\":{\"364\":1}}],[\"称为大顶堆\",{\"1\":{\"364\":1}}],[\"弄清楚\",{\"1\":{\"364\":1}}],[\"范围类型可以用来表达一个数据的区间\",{\"1\":{\"448\":1}}],[\"范围类型\",{\"0\":{\"448\":1},\"1\":{\"442\":1}}],[\"范围在0到1亿之间\",{\"1\":{\"361\":1}}],[\"范围缩小的速度越快\",{\"1\":{\"266\":1}}],[\"局部变量\",{\"1\":{\"944\":1,\"1144\":1,\"1335\":1}}],[\"局部变量上\",{\"1\":{\"944\":1}}],[\"局部变量表等信息也会被销毁\",{\"1\":{\"930\":1}}],[\"局部性原理与磁盘预读\",{\"1\":{\"274\":1}}],[\"局部性原理\",{\"1\":{\"266\":1}}],[\"局限性\",{\"0\":{\"361\":1}}],[\"遍历到有新数据可以处理时\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"遍历慢\",{\"1\":{\"922\":1}}],[\"遍历会很慢\",{\"1\":{\"922\":1}}],[\"遍历oldtable的每个桶\",{\"1\":{\"922\":1}}],[\"遍历统计数组\",{\"1\":{\"360\":1}}],[\"遍历数列\",{\"1\":{\"360\":1}}],[\"遍历待排序集合\",{\"1\":{\"351\":1}}],[\"操作符\",{\"1\":{\"1192\":1,\"1375\":1}}],[\"操作不触发trigger\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"操作立即生效\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"操作来实现悲观锁\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"操作来说的\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"操作来保证并发度高的操作\",{\"1\":{\"922\":1}}],[\"操作系统按照银行家指定的规则为进程分配资源\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"操作系统会通知程序\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"操作注解使其起作用\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"操作失败\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"操作成功\",{\"1\":{\"1050\":1,\"1259\":1,\"1431\":2}}],[\"操作都为异步的\",{\"1\":{\"1034\":1}}],[\"操作完成的同时\",{\"1\":{\"1020\":1}}],[\"操作方式\",{\"1\":{\"1020\":1}}],[\"操作进行检查时就可以发现版本号不同\",{\"1\":{\"1018\":1}}],[\"操作只会在预期值a和当前值相同时更改为新值b\",{\"1\":{\"1018\":1}}],[\"操作开始时\",{\"1\":{\"1018\":1}}],[\"操作包含三个操作数\",{\"1\":{\"1018\":1}}],[\"操作数栈\",{\"1\":{\"930\":1,\"1142\":1,\"1144\":1,\"1333\":1,\"1335\":1}}],[\"操作过程\",{\"1\":{\"922\":1}}],[\"操作crud\",{\"1\":{\"747\":2}}],[\"操作已完成\",{\"1\":{\"625\":1}}],[\"操作命令\",{\"1\":{\"600\":1}}],[\"操作\",{\"1\":{\"359\":1,\"460\":1,\"630\":1,\"648\":1,\"917\":1,\"918\":2,\"934\":1,\"1020\":2,\"1099\":1,\"1188\":2,\"1297\":1,\"1371\":2}}],[\"冒泡排序还是快速排序等等\",{\"1\":{\"359\":1}}],[\"冒号后面的\",{\"1\":{\"145\":1}}],[\"冒号前面的\",{\"1\":{\"145\":1}}],[\"题目\",{\"1\":{\"359\":1}}],[\"题解\",{\"1\":{\"353\":1}}],[\"减follower的数量提高伸缩性\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"减小交叉持有资源情况\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"减小锁的范围\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"减省了方法调用间参数的传递\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"减库存\",{\"1\":{\"594\":1,\"830\":1}}],[\"减1是因为可表示的数值范围是从0开始算的\",{\"1\":{\"387\":1}}],[\"减去1\",{\"1\":{\"358\":1}}],[\"减少重复工作\",{\"1\":{\"1444\":1}}],[\"减少业务代码的污染\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"减少代码量\",{\"1\":{\"1173\":1,\"1358\":1}}],[\"减少网络\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"减少网络传输的开销\",{\"1\":{\"982\":1}}],[\"减少时间消耗\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"减少停顿\",{\"1\":{\"938\":1}}],[\"减少垃圾收集时程序暂停的时间\",{\"1\":{\"938\":1}}],[\"减少馆藏数量\",{\"1\":{\"826\":1}}],[\"减少连接创建时间\",{\"1\":{\"645\":1}}],[\"减少修改字符串长度时所需的内存重分配次数\",{\"1\":{\"620\":1}}],[\"减少内存分配的次数\",{\"1\":{\"620\":1}}],[\"减少系统开销\",{\"1\":{\"574\":1}}],[\"减少碎片化\",{\"1\":{\"511\":2}}],[\"减少回表\",{\"1\":{\"504\":1}}],[\"减少了时间开销\",{\"1\":{\"645\":1}}],[\"减少了锁冲突的可能性\",{\"1\":{\"561\":1,\"565\":1}}],[\"减少了i\",{\"1\":{\"503\":1}}],[\"减少了磁盘io\",{\"1\":{\"516\":1}}],[\"减少了磁盘\",{\"1\":{\"270\":1}}],[\"减少磁盘\",{\"1\":{\"266\":1}}],[\"减少波动\",{\"1\":{\"134\":1}}],[\"项\",{\"1\":{\"358\":1}}],[\"项目组文档自行取阅\",{\"1\":{\"1429\":1}}],[\"项目组\",{\"0\":{\"1422\":1,\"1429\":1},\"1\":{\"1429\":1}}],[\"项目打成jar包就能独立运行\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"项目练手\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"项目启动时\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"项目所属的实际项目组\",{\"1\":{\"844\":1}}],[\"项目目录结构参考\",{\"1\":{\"840\":1}}],[\"项目基本属性\",{\"1\":{\"837\":1}}],[\"项目元数据\",{\"1\":{\"837\":1}}],[\"项目\",{\"0\":{\"850\":1,\"873\":1},\"1\":{\"811\":1,\"837\":1,\"839\":1,\"844\":1,\"1444\":1}}],[\"项目a中\",{\"1\":{\"709\":1}}],[\"项目a配置slf4j的依赖并设置optional为true\",{\"1\":{\"708\":1}}],[\"项目版本号\",{\"1\":{\"703\":1,\"704\":1}}],[\"项目名称\",{\"1\":{\"703\":1,\"704\":1}}],[\"项目名称描述\",{\"1\":{\"699\":1}}],[\"项目部署等\",{\"1\":{\"698\":1}}],[\"项目的代码模块目录\",{\"1\":{\"1439\":1}}],[\"项目的根据大小还有背景不同\",{\"1\":{\"1439\":1}}],[\"项目的自动化配置\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"项目的名称和描述\",{\"1\":{\"844\":1}}],[\"项目的名称来自mpeg视频编码标准\",{\"1\":{\"122\":1}}],[\"项目的方式\",{\"1\":{\"836\":1}}],[\"项目的开发和维护\",{\"1\":{\"589\":1}}],[\"项目方部署空投合约\",{\"1\":{\"486\":1}}],[\"项目总结\",{\"1\":{\"394\":1}}],[\"项目中用到的技术点和手记都免费公开\",{\"1\":{\"205\":1}}],[\"项目实战\",{\"0\":{\"205\":1},\"2\":{\"206\":1,\"207\":1,\"1423\":1,\"1424\":1,\"1427\":1,\"1428\":1,\"1432\":1,\"1433\":1,\"1436\":1,\"1437\":1,\"1440\":1,\"1441\":1,\"1445\":1,\"1446\":1}}],[\"项目主页\",{\"0\":{\"0\":1}}],[\"找\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"找出正确的\",{\"1\":{\"956\":1}}],[\"找出应用相关的bean\",{\"1\":{\"944\":1}}],[\"找出性能瓶颈\",{\"1\":{\"942\":1}}],[\"找出待排序的数组中最大和最小的元素\",{\"1\":{\"358\":1}}],[\"找寻并加载类的二进制数据\",{\"1\":{\"934\":1}}],[\"找到最小的节点\",{\"1\":{\"1008\":1}}],[\"找到匹配的结果并返回\",{\"1\":{\"1004\":1}}],[\"找到正确的\",{\"1\":{\"950\":1}}],[\"找到类文件了\",{\"1\":{\"934\":1}}],[\"找到$\",{\"1\":{\"702\":1}}],[\"找到引起死锁的进程\",{\"1\":{\"581\":1}}],[\"找到第二个非叶节点4\",{\"1\":{\"364\":1}}],[\"找到比其小的数\",{\"1\":{\"352\":1}}],[\"找到待插入位置的前一个节点prev\",{\"1\":{\"286\":1}}],[\"找到待删除节点delete的前一个节点prev\",{\"1\":{\"286\":1}}],[\"堆对于整个应用程序都是共享\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"堆存放的是对象的实例和数组\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"堆因为是不连续的\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"堆的物理地址分配对象是不连续的\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"堆初始值\",{\"1\":{\"942\":1}}],[\"堆最大值\",{\"1\":{\"942\":1}}],[\"堆内存设置为\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"堆内存中又分为几个区域\",{\"1\":{\"936\":1}}],[\"堆内存存储对象实例\",{\"1\":{\"936\":1}}],[\"堆内存\",{\"1\":{\"936\":3}}],[\"堆是一个近似完全二叉树的结构\",{\"1\":{\"364\":1}}],[\"堆是具有以下性质的完全二叉树\",{\"1\":{\"364\":1}}],[\"堆排序的基本思想是\",{\"1\":{\"364\":1}}],[\"堆排序是一种选择排序\",{\"1\":{\"364\":1}}],[\"堆排序是一种\",{\"1\":{\"364\":1}}],[\"堆排序是利用这种数据结构而设计的一种排序算法\",{\"1\":{\"364\":1}}],[\"堆排序在常用排序算法中属于比较难理解的\",{\"1\":{\"364\":1}}],[\"堆排序就是这么容易\",{\"0\":{\"364\":1}}],[\"堆排序\",{\"1\":{\"357\":1,\"364\":1}}],[\"堆和堆排序\",{\"0\":{\"308\":1}}],[\"ο\",{\"1\":{\"357\":1}}],[\"真是一个非常愉快的交流过程\",{\"1\":{\"966\":1}}],[\"真是一个很细致的区分\",{\"1\":{\"966\":1}}],[\"真正在写操作的业务逻辑\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"真正的无连接数据包套接字支持\",{\"1\":{\"1032\":1}}],[\"真正干活的其实是\",{\"1\":{\"956\":1}}],[\"真正做到面向切面编程\",{\"1\":{\"944\":1}}],[\"真的吗\",{\"1\":{\"982\":1}}],[\"真的学到很多\",{\"1\":{\"966\":1}}],[\"真的很常用\",{\"1\":{\"944\":1}}],[\"真的非常方便\",{\"1\":{\"906\":1}}],[\"真诚地希望这些知识能在你的工作中派上用场\",{\"1\":{\"934\":1}}],[\"真不容易\",{\"1\":{\"934\":1}}],[\"真题\",{\"1\":{\"353\":1}}],[\"真实的\",{\"1\":{\"270\":1}}],[\"该特性允许每个客户端为自己设置一个命名空间\",{\"1\":{\"1245\":1,\"1418\":1}}],[\"该注解主要由三个注解组成\",{\"1\":{\"1227\":1,\"1402\":1}}],[\"该参数是对映射信息的封装\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"该文件中配置了操作数据库的\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"该文档依然能匹配查询\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"该文档指定了父文档\",{\"1\":{\"457\":1}}],[\"该线程需要完成该\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"该\",{\"1\":{\"1166\":1,\"1178\":1,\"1354\":1,\"1363\":1}}],[\"该节点上的\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"该区更关注的是程序方法的执行\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"该状态不同于waiting\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"该状态的线程位于可运行线程池中\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"该代码块使用\",{\"1\":{\"1022\":1}}],[\"该机制可以保证主进程始终可用\",{\"1\":{\"962\":1}}],[\"该对象中包含了执行\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"该对象为垃圾\",{\"1\":{\"936\":1}}],[\"该对象所占用的内存就会被自动释放\",{\"1\":{\"636\":1}}],[\"该接口公开了度量的列表和当前的值\",{\"1\":{\"883\":1}}],[\"该指令用于统计给定的\",{\"1\":{\"658\":1}}],[\"该学的都学了\",{\"1\":{\"652\":1}}],[\"该属性记录了对象最后一次被命令程序访问的时间\",{\"1\":{\"635\":1}}],[\"该哈希表已有节点的数量\",{\"1\":{\"624\":1}}],[\"该类型可以通过缩放因子来精确浮点数\",{\"1\":{\"444\":1}}],[\"该数据可以被索引\",{\"1\":{\"431\":1}}],[\"该框架使用了特定的方式来进行配置\",{\"1\":{\"401\":1}}],[\"该方法用于传递\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"该方法会使当前线程进入阻塞状态指定毫秒\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"该方法是线程安全的\",{\"1\":{\"388\":1}}],[\"该方法对不同的基本数据类型都有对应的重载方法\",{\"1\":{\"352\":1}}],[\"该算法于1954年由\",{\"1\":{\"357\":1}}],[\"该用户是非会员\",{\"1\":{\"200\":1}}],[\"该用户是\",{\"1\":{\"200\":1}}],[\"自测+提测\",{\"1\":{\"1439\":1}}],[\"自身会维护一个\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"自然就没有线程安全方面的问题了\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"自然不错\",{\"1\":{\"643\":1}}],[\"自反性\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"自带各种协议栈\",{\"1\":{\"1032\":1}}],[\"自带编解码器解决\",{\"1\":{\"1032\":1}}],[\"自带的返回结构体\",{\"1\":{\"1431\":1}}],[\"自带的\",{\"1\":{\"1032\":1}}],[\"自带了一些简单分词器\",{\"1\":{\"411\":1}}],[\"自旋重新尝试获得锁\",{\"1\":{\"1105\":2,\"1303\":2}}],[\"自旋提前量偏移量\",{\"1\":{\"1023\":1}}],[\"自旋提前量\",{\"1\":{\"1023\":1}}],[\"自旋持续时间偏移量\",{\"1\":{\"1023\":1}}],[\"自旋持续时间\",{\"1\":{\"1023\":1}}],[\"自旋时钟偏移量\",{\"1\":{\"1023\":1}}],[\"自旋时钟\",{\"1\":{\"1023\":1}}],[\"自旋频率偏移量\",{\"1\":{\"1023\":1}}],[\"自旋频率\",{\"1\":{\"1023\":1}}],[\"自建服务器\",{\"1\":{\"906\":1}}],[\"自己必须主动去创建对象b或者使用已经创建的对象b\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"自己的relay\",{\"1\":{\"1186\":1,\"1369\":1}}],[\"自己需要的资源别别人持有\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"自己安装\",{\"1\":{\"898\":1}}],[\"自己设计的一种数据存储结构\",{\"1\":{\"632\":1}}],[\"自己就面试个后端开发岗位\",{\"1\":{\"90\":1}}],[\"自增\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"自增字段生成的值是唯一的\",{\"1\":{\"559\":1}}],[\"自增来生成唯一序列\",{\"1\":{\"559\":1}}],[\"自增锁在事务提交时释放\",{\"1\":{\"559\":1}}],[\"自增锁\",{\"0\":{\"559\":1},\"1\":{\"559\":1,\"575\":1}}],[\"自动从内存中清除\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"自动醒来进入到可运行状态\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"自动拆箱\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"自动装箱\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"自动装配bean\",{\"1\":{\"944\":1}}],[\"自动装配成员变量\",{\"1\":{\"944\":1}}],[\"自动进行初始化\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"自动添加get\",{\"1\":{\"825\":2}}],[\"自动注册defaultanootationhandlermapping\",{\"1\":{\"819\":1}}],[\"自动下载\",{\"1\":{\"699\":1}}],[\"自动把线程变量副本的值回写到对象在堆中变量\",{\"1\":{\"692\":1}}],[\"自动根据分数排序\",{\"1\":{\"657\":1}}],[\"自动去重\",{\"1\":{\"656\":1}}],[\"自动发送代币到用户地址\",{\"1\":{\"486\":1}}],[\"自动分发\",{\"1\":{\"486\":1}}],[\"自动扩容\",{\"1\":{\"352\":1}}],[\"自定义策略\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"自定义\",{\"1\":{\"952\":2}}],[\"自定义注解+aop\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"自定义注解+拦截器\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"自定义注解需要两个注解\",{\"1\":{\"944\":1}}],[\"自定义注解需要什么\",{\"1\":{\"944\":1}}],[\"自定义注解\",{\"1\":{\"944\":2,\"1092\":1,\"1293\":1}}],[\"自定义注解实现aop切面日志\",{\"0\":{\"681\":1}}],[\"自定义键的hashcode\",{\"1\":{\"922\":1}}],[\"自定义构件\",{\"1\":{\"706\":1}}],[\"自定义仓库路径\",{\"1\":{\"702\":1}}],[\"自定义日志注解\",{\"1\":{\"688\":1}}],[\"自定义分词器\",{\"1\":{\"411\":1}}],[\"自定义扩展词库\",{\"1\":{\"394\":1}}],[\"自我介绍\",{\"0\":{\"398\":1},\"1\":{\"394\":1}}],[\"步骤\",{\"0\":{\"358\":1,\"375\":1},\"1\":{\"351\":1}}],[\"确定文档属于分片\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"确定申请的桶个数\",{\"1\":{\"351\":1}}],[\"确认后再发送下一条消息\",{\"1\":{\"994\":1}}],[\"确实\",{\"1\":{\"978\":1,\"1072\":2,\"1276\":2}}],[\"确实是这样\",{\"1\":{\"954\":1}}],[\"确保文档是最新版本\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"确保消息的可靠性和容错性\",{\"1\":{\"992\":1}}],[\"确保系统的稳定性和可靠性\",{\"1\":{\"984\":1}}],[\"确保订单不会丢失\",{\"1\":{\"974\":1}}],[\"确保集群的正常运行\",{\"1\":{\"968\":1,\"1008\":1}}],[\"确保在方法中可以正常使用某些操作\",{\"1\":{\"966\":1}}],[\"确保在执行优化操作之前备份数据\",{\"1\":{\"511\":1}}],[\"确保数据的持久性\",{\"1\":{\"960\":1}}],[\"确保数据一致性至关重要\",{\"1\":{\"567\":1}}],[\"确保正确的标记对象\",{\"1\":{\"938\":1}}],[\"确保我的java程序没有安全隐患\",{\"1\":{\"934\":1}}],[\"确保某条记录在事务中被锁定\",{\"1\":{\"578\":1}}],[\"确保表中列没有\",{\"1\":{\"1192\":1,\"1375\":1}}],[\"确保表中\",{\"1\":{\"526\":1}}],[\"确保每个索引都有其明确的用途\",{\"1\":{\"510\":1}}],[\"确保查询中涉及的列都被包含在索引中\",{\"1\":{\"504\":1}}],[\"确保索引能够被有效利用\",{\"1\":{\"502\":1}}],[\"确保你的服务器安装了\",{\"1\":{\"403\":1}}],[\"确保容量够用\",{\"1\":{\"285\":1}}],[\"确保电脑安装了\",{\"1\":{\"109\":1}}],[\"确保一个类只有一个实例\",{\"1\":{\"78\":1}}],[\"宽泛\",{\"1\":{\"350\":1}}],[\"映射文件即\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"映射文件内\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"映射文件中直接插入一些逻辑\",{\"1\":{\"958\":1}}],[\"映射文件\",{\"0\":{\"1175\":1,\"1360\":1},\"1\":{\"958\":1,\"1179\":1,\"1364\":1}}],[\"映射文件的statement的id必须和mapper接口的方法名保持一致\",{\"1\":{\"763\":1}}],[\"映射文件的命名空间\",{\"1\":{\"763\":1}}],[\"映射到\",{\"1\":{\"950\":1}}],[\"映射到对应槽位\",{\"1\":{\"495\":1}}],[\"映射请求url\",{\"1\":{\"944\":1}}],[\"映射请求url到控制器处理方法\",{\"1\":{\"944\":1}}],[\"映射\",{\"1\":{\"922\":1,\"1002\":1}}],[\"映射地址\",{\"1\":{\"850\":1}}],[\"映射语句\",{\"1\":{\"772\":1}}],[\"映射为一个唯一\",{\"1\":{\"658\":1}}],[\"映射参数解析\",{\"1\":{\"440\":1}}],[\"映射参数\",{\"0\":{\"440\":1}}],[\"映射规则需要根据待排序集合的元素分布特性进行选择\",{\"1\":{\"350\":1}}],[\"映射对应的值到\",{\"1\":{\"333\":1,\"339\":1}}],[\"避免大量的\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"避免大量请求底层关系型数据库\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"避免构造函数注入并仅使用setter注入\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"避免存储一些没用的数据\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"避免向集合中插入非法数据\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"避免为每个连接创建线程\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"避免脑裂问题\",{\"1\":{\"1074\":1,\"1278\":1}}],[\"避免把\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"避免后续请求全部到达\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"避免缓存挂掉导致无法提供服务的情况\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"避免aba问题\",{\"1\":{\"1018\":1}}],[\"避免破坏程序的安全性\",{\"1\":{\"1010\":1}}],[\"避免不必要的字段和复杂的数据结构\",{\"1\":{\"1002\":1}}],[\"避免误释放\",{\"1\":{\"970\":1}}],[\"避免因为替换错误类型导致的运行错误\",{\"1\":{\"966\":1}}],[\"避免classcastexception异常\",{\"1\":{\"966\":1}}],[\"避免循环依赖\",{\"1\":{\"954\":1}}],[\"避免过于提前暴露\",{\"1\":{\"954\":1}}],[\"避免过度索引\",{\"1\":{\"510\":1}}],[\"避免线程阻塞\",{\"1\":{\"950\":1}}],[\"避免线程之间的竞争\",{\"1\":{\"930\":1}}],[\"避免被高流量打垮\",{\"1\":{\"950\":1}}],[\"避免高复杂度算法\",{\"1\":{\"942\":1}}],[\"避免重复消费\",{\"1\":{\"984\":1}}],[\"避免重复标记对象\",{\"1\":{\"940\":1}}],[\"避免重复加载\",{\"1\":{\"934\":1}}],[\"避免频繁地创建和销毁对象\",{\"1\":{\"930\":1}}],[\"避免频繁创建和删除临时表\",{\"0\":{\"541\":1}}],[\"避免了几乎所有的jdbc代码和手动设置的参数以及获取结果集\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"避免了在内核空间和用户空间之间穿梭\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"避免了循环依赖\",{\"1\":{\"954\":1}}],[\"避免了频繁创建和销毁线程的开销\",{\"1\":{\"926\":1}}],[\"避免了构成桶过程的元素比较和交换操作\",{\"1\":{\"348\":1}}],[\"避免背课文式的对话\",{\"1\":{\"920\":1}}],[\"避免造成大量\",{\"0\":{\"542\":1}}],[\"避免使用不代表一定不使用\",{\"1\":{\"528\":1}}],[\"避免\",{\"1\":{\"519\":1}}],[\"避免io争抢\",{\"1\":{\"516\":1}}],[\"避免在高度重复的列上创建索引\",{\"1\":{\"510\":1}}],[\"避免select\",{\"1\":{\"504\":1}}],[\"避免阻断流程\",{\"0\":{\"193\":1}}],[\"快照方式重启恢复快\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"快照读与当前读\",{\"1\":{\"575\":1}}],[\"快\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"快递小哥\",{\"1\":{\"976\":1}}],[\"快于任何比较排序算法\",{\"1\":{\"357\":1}}],[\"快排是在集合本身上进行排序\",{\"1\":{\"348\":1}}],[\"快速构建一个java项目结构\",{\"1\":{\"703\":1}}],[\"快速排序是将集合拆分为两个值域\",{\"1\":{\"348\":1}}],[\"快速索引需要有效的减少磁盘\",{\"1\":{\"266\":1}}],[\"快速处理\",{\"1\":{\"209\":1}}],[\"快速定位存储了数据的叶子节点\",{\"1\":{\"499\":1}}],[\"快速定位到数据\",{\"1\":{\"499\":1}}],[\"快速定位\",{\"1\":{\"191\":1}}],[\"快速开始调试程序\",{\"1\":{\"180\":1}}],[\"快速入门\",{\"0\":{\"156\":1,\"741\":1}}],[\"快速搭建项目\",{\"1\":{\"401\":1}}],[\"快速搭建\",{\"0\":{\"108\":1,\"908\":1}}],[\"快速搭建prometheus+grafana保姆级教程\",{\"0\":{\"107\":1}}],[\"快速掌握生产环境中实战要点\",{\"1\":{\"78\":1}}],[\"高水位\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"高速缓存的读写速度远高于内存\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"高速缓存\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"高可用\",{\"1\":{\"960\":1,\"964\":1}}],[\"高可用这是现在互联网经常提到的一个词\",{\"1\":{\"616\":1}}],[\"高级查询的整理\",{\"0\":{\"797\":1}}],[\"高级查询\",{\"0\":{\"791\":1}}],[\"高度自动化\",{\"1\":{\"699\":1}}],[\"高版本\",{\"1\":{\"648\":1}}],[\"高频面试问题更是基础中的高频实战要点\",{\"1\":{\"522\":1}}],[\"高频查询列\",{\"1\":{\"502\":1}}],[\"高并发的系统\",{\"1\":{\"950\":1}}],[\"高并发的性能瓶颈\",{\"1\":{\"518\":1}}],[\"高并发\",{\"1\":{\"569\":1,\"616\":1}}],[\"高并发场景下\",{\"0\":{\"573\":1},\"1\":{\"517\":1}}],[\"高效率的收集器\",{\"1\":{\"940\":1}}],[\"高效的gc算法提供了参考\",{\"1\":{\"938\":1}}],[\"高效的范围查询和排序\",{\"1\":{\"503\":2}}],[\"高效与否的关键就在于这个映射函数的确定\",{\"1\":{\"348\":1}}],[\"高性能的网络服务器和客户端\",{\"1\":{\"1031\":1}}],[\"高性能\",{\"1\":{\"400\":1}}],[\"高亮\",{\"1\":{\"394\":1}}],[\"高的元素\",{\"1\":{\"353\":1}}],[\"高负荷下缓冲大小\",{\"1\":{\"106\":1}}],[\"θ\",{\"1\":{\"348\":1}}],[\"鸽巢排序\",{\"1\":{\"348\":1}}],[\"衰减的布隆过滤器等\",{\"1\":{\"343\":1}}],[\"至此\",{\"1\":{\"795\":1,\"830\":1,\"1230\":1,\"1405\":1,\"1444\":1}}],[\"至目标测试目录\",{\"1\":{\"713\":1}}],[\"至目标目录\",{\"1\":{\"713\":1}}],[\"至于阈值为什么是8\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"至于安装方式是\",{\"1\":{\"643\":1}}],[\"至于参数估计的方法\",{\"1\":{\"339\":1}}],[\"至\",{\"1\":{\"387\":1,\"625\":1,\"629\":1}}],[\"至少需要的大小\",{\"1\":{\"285\":1}}],[\"尽管不推荐使用\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"尽管短生命周期对象已经不再需要\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"尽管它有缺陷\",{\"1\":{\"938\":1}}],[\"尽管可以配置多个环境\",{\"1\":{\"771\":1}}],[\"尽管这种行为在默认配置下不常见\",{\"1\":{\"575\":1}}],[\"尽可能的使用\",{\"0\":{\"539\":1}}],[\"尽可能让它平均分布到每一位\",{\"1\":{\"336\":1}}],[\"尽量做新增不做更新\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"尽量保证之锁定自己需要的资源\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"尽量使用整数对象以节省内存\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"尽量使用自动生成的id\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"尽量使用数字型字段\",{\"0\":{\"538\":1}}],[\"尽量根据自己公司使用情况回答\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"尽量说自己了解的\",{\"1\":{\"1027\":1}}],[\"尽量加在必要的范围内\",{\"1\":{\"1018\":1}}],[\"尽量选择java提供的线程安全类\",{\"1\":{\"988\":1}}],[\"尽量减小扩容带来的性能消耗\",{\"1\":{\"946\":1}}],[\"尽量减少垃圾产生\",{\"1\":{\"936\":1}}],[\"尽量减少不必要的回表操作\",{\"1\":{\"504\":1}}],[\"尽量编码路径中不要包含中文\",{\"1\":{\"701\":1}}],[\"尽量避免向客户端返回大数据量\",{\"0\":{\"548\":1}}],[\"尽量避免大事务操作\",{\"0\":{\"547\":1}}],[\"尽量避免使用游标\",{\"0\":{\"544\":1}}],[\"尽量从业务角度避免联查\",{\"1\":{\"520\":1}}],[\"尽量指定需要的列\",{\"1\":{\"504\":1}}],[\"尽量增大桶的数量\",{\"1\":{\"348\":1}}],[\"尽量在打印时日志时输出英文\",{\"1\":{\"199\":1}}],[\"尽量不影响分辨率\",{\"1\":{\"134\":1}}],[\"尽量大\",{\"1\":{\"106\":1}}],[\"目标对象\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"目标就是设计一种尽可能少碰撞的hash算法\",{\"1\":{\"336\":1}}],[\"目的是\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"目的是限制类型参数能被替换的实际类型\",{\"1\":{\"966\":1}}],[\"目的是简化\",{\"1\":{\"950\":1}}],[\"目的\",{\"1\":{\"827\":1,\"1244\":1,\"1417\":1}}],[\"目录下包含以下几个文件\",{\"1\":{\"911\":1}}],[\"目录下创建一个包\",{\"1\":{\"839\":1}}],[\"目录里新建两个文件\",{\"1\":{\"827\":1}}],[\"目录包括\",{\"1\":{\"809\":1}}],[\"目录结构如图所示\",{\"1\":{\"822\":1}}],[\"目录结构如下\",{\"1\":{\"795\":1}}],[\"目录结构\",{\"0\":{\"748\":1,\"758\":1},\"1\":{\"763\":1}}],[\"目录\",{\"0\":{\"394\":1,\"809\":1},\"1\":{\"412\":1,\"413\":1,\"525\":1}}],[\"目前定价是一包华子的价格\",{\"1\":{\"1429\":1}}],[\"目前这个理论已经被成功地应用到实践当中\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"目前防御\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"目前jsp主要用在视图层\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"目前很多新项目很少会用到javaee的技术栈\",{\"1\":{\"1126\":1}}],[\"目前大多项目都是前后端分离\",{\"1\":{\"831\":1}}],[\"目前apache下绝大多数项目都已经采用maven进行管理\",{\"1\":{\"698\":1}}],[\"目前来说\",{\"1\":{\"635\":1}}],[\"目前在互联网公司\",{\"1\":{\"594\":1}}],[\"目前计算机使用的主存基本都是随机读写存储器\",{\"1\":{\"273\":1}}],[\"目前所有内容都由站长个人维护\",{\"1\":{\"1\":1}}],[\"位运算的效率远高于取模运算\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"位用于存储是否是偏向锁\",{\"1\":{\"1022\":1}}],[\"位用于存储锁标志位\",{\"1\":{\"1022\":1}}],[\"位用于存储对象的分代年龄\",{\"1\":{\"1022\":1}}],[\"位用于存储对象的哈希码和分代年龄\",{\"1\":{\"1022\":1}}],[\"位用于存储对象的哈希码\",{\"1\":{\"1022\":1}}],[\"位的\",{\"1\":{\"1022\":1}}],[\"位的数量\",{\"1\":{\"658\":1}}],[\"位于\",{\"1\":{\"934\":1}}],[\"位即可\",{\"1\":{\"658\":1}}],[\"位表示\",{\"1\":{\"658\":1}}],[\"位映射为\",{\"1\":{\"658\":1}}],[\"位利用起来\",{\"1\":{\"658\":1}}],[\"位和\",{\"1\":{\"597\":1}}],[\"位图索引通常在低基数列\",{\"1\":{\"505\":1}}],[\"位图索引是一种将数据列的所有可能值映射到二进制位上的索引\",{\"1\":{\"505\":1}}],[\"位\",{\"1\":{\"387\":1,\"597\":1,\"658\":2}}],[\"位机器码重复\",{\"1\":{\"387\":1}}],[\"位数组总长度\",{\"1\":{\"342\":1}}],[\"位数组长度\",{\"1\":{\"340\":1}}],[\"位数组长度和误差率都是拍脑袋定的\",{\"1\":{\"339\":1}}],[\"位数组\",{\"1\":{\"333\":2,\"339\":2,\"342\":1}}],[\"位置\",{\"1\":{\"429\":1,\"1069\":1,\"1273\":1}}],[\"位置信息只有在支持\",{\"1\":{\"425\":1}}],[\"位置都为1\",{\"1\":{\"333\":1,\"339\":1}}],[\"位置不合法\",{\"1\":{\"286\":1}}],[\"位置不合法异常\",{\"1\":{\"285\":1,\"286\":1}}],[\"位置对应的元素\",{\"1\":{\"284\":1}}],[\"置位1\",{\"1\":{\"333\":1,\"339\":1}}],[\"到哪里去\",{\"1\":{\"1438\":1}}],[\"到哪里去找映射文件\",{\"1\":{\"772\":1}}],[\"到哪里去找到\",{\"1\":{\"772\":1}}],[\"到上线完整流程\",{\"1\":{\"1429\":1}}],[\"到任何被代理的对象\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"到底为什么要起这么个名字\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"到的状态是一样的\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"到达栅栏\",{\"1\":{\"1104\":12,\"1302\":12}}],[\"到了某个点由售票员通知乘客下车\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"到kafka的broker节点\",{\"1\":{\"990\":1}}],[\"到子类型的范围内的某种类型\",{\"1\":{\"966\":1}}],[\"到这一步\",{\"1\":{\"912\":1}}],[\"到这里你是否明白这个问题\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"到这里也是一个很正常的操作\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"到这里我们的网站目录就搭建成功了\",{\"1\":{\"910\":1}}],[\"到这里\",{\"1\":{\"829\":1}}],[\"到这里为止\",{\"1\":{\"702\":1}}],[\"到linux服务器文件夹下\",{\"1\":{\"851\":1}}],[\"到一个路径\",{\"1\":{\"701\":1}}],[\"到新哈希表里面\",{\"1\":{\"626\":1}}],[\"到此为止\",{\"1\":{\"407\":1}}],[\"到此为止相信你已经对b树和b+树有一定认识\",{\"1\":{\"264\":1}}],[\"到\",{\"1\":{\"375\":1,\"625\":1,\"635\":1,\"636\":1,\"807\":1,\"917\":1,\"1071\":1,\"1072\":2,\"1275\":1,\"1276\":2,\"1429\":1}}],[\"到目前我使用比较多的是在数据采集中\",{\"1\":{\"330\":1}}],[\"长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"长连接\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"长度虽然等于\",{\"1\":{\"1431\":1}}],[\"长度的队列\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"长度\",{\"1\":{\"629\":1}}],[\"长度后\",{\"1\":{\"157\":1}}],[\"长城防火墙有100亿个需要屏蔽的网站\",{\"1\":{\"330\":1}}],[\"宁错杀三千\",{\"1\":{\"330\":1}}],[\"英\",{\"1\":{\"1099\":1,\"1107\":1,\"1297\":1,\"1305\":1}}],[\"英文基础知识\",{\"1\":{\"904\":1}}],[\"英文记做\",{\"1\":{\"282\":1}}],[\"英语\",{\"1\":{\"364\":1}}],[\"英雄联盟布隆\",{\"1\":{\"329\":1}}],[\"坚不可摧\",{\"1\":{\"329\":2}}],[\"布尔类型常用于检索中的过滤条件\",{\"1\":{\"446\":1}}],[\"布尔类型\",{\"0\":{\"446\":1},\"1\":{\"442\":1}}],[\"布尔\",{\"1\":{\"429\":1}}],[\"布隆过滤原理图\",{\"1\":{\"333\":1,\"339\":1}}],[\"布隆过滤器底层选用的数据结构就是\",{\"1\":{\"658\":1}}],[\"布隆过滤器换包含\",{\"1\":{\"343\":1}}],[\"布隆过滤器自提出以后\",{\"1\":{\"342\":1}}],[\"布隆过滤器参数计算公式\",{\"1\":{\"339\":1}}],[\"布隆过滤器只能插入数据\",{\"1\":{\"334\":1}}],[\"布隆过滤器的核心思想\",{\"1\":{\"342\":1}}],[\"布隆过滤器的核心是\",{\"1\":{\"330\":1}}],[\"布隆过滤器的属性\",{\"0\":{\"334\":1}}],[\"布隆过滤器的原理还是比较简单的\",{\"1\":{\"333\":1}}],[\"布隆过滤器的原理和哈希表的原理有点类似\",{\"1\":{\"333\":1}}],[\"布隆过滤器可以用于检索一个元素是否在一个集合中\",{\"1\":{\"332\":1}}],[\"布隆过滤器\",{\"1\":{\"332\":1,\"336\":1,\"1047\":2,\"1256\":2},\"2\":{\"345\":1}}],[\"布隆过滤器主要用来做去重操作\",{\"1\":{\"330\":1}}],[\"布隆朝一个方向举起盾牌\",{\"1\":{\"329\":1}}],[\"布隆大家都知道吧\",{\"1\":{\"329\":1}}],[\"布局包括\",{\"1\":{\"23\":1}}],[\"布局\",{\"0\":{\"23\":1},\"2\":{\"25\":1}}],[\"布局与功能禁用\",{\"0\":{\"20\":1}}],[\"拓扑排序\",{\"0\":{\"324\":1}}],[\"拓展的也更多一点\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"拓展题\",{\"0\":{\"1123\":1,\"1318\":1}}],[\"拓展阅读\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"拓展\",{\"0\":{\"271\":1,\"1052\":1,\"1246\":1,\"1261\":1,\"1419\":1},\"1\":{\"1077\":1,\"1232\":1,\"1281\":1,\"1407\":1}}],[\"邻接矩阵\",{\"0\":{\"319\":1}}],[\"广义表的定义\",{\"0\":{\"303\":1}}],[\"折半查找\",{\"0\":{\"302\":1}}],[\"递归深度等\",{\"1\":{\"1023\":1}}],[\"递归深度偏移量\",{\"1\":{\"1023\":1}}],[\"递归深度\",{\"1\":{\"1023\":1}}],[\"递归函数的执行过程\",{\"0\":{\"301\":1}}],[\"递归\",{\"0\":{\"300\":1}}],[\"递归授权所有文件\",{\"1\":{\"94\":1}}],[\"希尔排序和基数排序\",{\"0\":{\"296\":1}}],[\"希望下次还能见到你\",{\"1\":{\"1016\":1}}],[\"希望这个对话能帮助到你\",{\"1\":{\"1012\":1}}],[\"希望这些技巧能帮助你提高\",{\"1\":{\"982\":1}}],[\"希望我能帮到你\",{\"1\":{\"1008\":1}}],[\"希望你在日后继续深入学习其他垃圾收集算法\",{\"1\":{\"938\":1}}],[\"希望你能保护好自己\",{\"1\":{\"640\":1}}],[\"希望能有机会为您的团队贡献我的技术能力\",{\"1\":{\"1000\":1}}],[\"希望能有机会为您的团队贡献我的技术和经验\",{\"1\":{\"998\":1}}],[\"希望能对你有所帮助\",{\"1\":{\"936\":1}}],[\"希望能够帮助您更好地理解\",{\"1\":{\"928\":1}}],[\"希望使用1个方法来完成操作\",{\"1\":{\"779\":1}}],[\"希望将大家留在这个玩法中\",{\"1\":{\"483\":1}}],[\"希望可以结识你\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"648\":1,\"698\":1}}],[\"希望码率波动\",{\"1\":{\"134\":1}}],[\"准面试官等\",{\"1\":{\"523\":1}}],[\"准备分配内存并设置初始值\",{\"1\":{\"934\":1}}],[\"准备和解析\",{\"1\":{\"934\":1}}],[\"准备数据\",{\"0\":{\"736\":1}}],[\"准备打包\",{\"1\":{\"713\":1}}],[\"准备了\",{\"1\":{\"493\":1,\"552\":1}}],[\"准备\",{\"1\":{\"412\":1,\"413\":1,\"934\":1,\"1148\":1,\"1339\":1}}],[\"准备工作\",{\"1\":{\"289\":1}}],[\"准确来说\",{\"1\":{\"131\":1}}],[\"运用得更加娴熟高效\",{\"1\":{\"942\":1}}],[\"运行成功\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"运行容器\",{\"1\":{\"1063\":1,\"1269\":1}}],[\"运行和分发应用程序的过程\",{\"1\":{\"1057\":1,\"1263\":1}}],[\"运行阶段\",{\"1\":{\"944\":1}}],[\"运行期\",{\"1\":{\"944\":1}}],[\"运行期使用\",{\"1\":{\"944\":1}}],[\"运行本地服务器\",{\"1\":{\"912\":1}}],[\"运行上一步中的\",{\"1\":{\"839\":1}}],[\"运行项目\",{\"0\":{\"832\":1}}],[\"运行任何一个阶段的时候\",{\"1\":{\"713\":1}}],[\"运行任何检查\",{\"1\":{\"713\":1}}],[\"运行某个阶段的时候\",{\"1\":{\"712\":1}}],[\"运行mvn\",{\"1\":{\"712\":1}}],[\"运行所有这三套生命周期\",{\"1\":{\"711\":1}}],[\"运行时数据区域就是我们常说的jvm的内存\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"运行时注解主要有两大使用场景\",{\"1\":{\"944\":1}}],[\"运行时注解的使用场景\",{\"1\":{\"944\":1}}],[\"运行时可以通过反射获取\",{\"1\":{\"944\":1}}],[\"运行时无法获得\",{\"1\":{\"944\":1}}],[\"运行时异常类\",{\"1\":{\"829\":1}}],[\"运行时提供\",{\"1\":{\"706\":1}}],[\"运行时刻内存的分配\",{\"1\":{\"692\":1}}],[\"运行三种classpath都有效\",{\"1\":{\"706\":1}}],[\"运行的classpath的关系\",{\"1\":{\"706\":1}}],[\"运行测试代码\",{\"1\":{\"705\":1}}],[\"运行\",{\"0\":{\"855\":1},\"1\":{\"597\":1,\"944\":1,\"1100\":2,\"1298\":2}}],[\"运行结果\",{\"1\":{\"288\":1,\"289\":1}}],[\"运维人员会将项目部署到用户可以访问的服务器\",{\"1\":{\"1439\":1}}],[\"运维监控重点关注\",{\"1\":{\"191\":1}}],[\"运维operations\",{\"0\":{\"105\":1}}],[\"入列有编号\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"入口文件\",{\"1\":{\"911\":1}}],[\"入口路径\",{\"1\":{\"844\":1}}],[\"入门教程\",{\"1\":{\"652\":1}}],[\"入门就先简单学到这里\",{\"1\":{\"608\":1}}],[\"入门\",{\"1\":{\"604\":1}}],[\"入门知识\",{\"1\":{\"587\":1}}],[\"入门到实战\",{\"1\":{\"587\":1}}],[\"入队a\",{\"1\":{\"288\":1}}],[\"入栈\",{\"1\":{\"282\":1}}],[\"头中自定义属性并验证\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"头部压缩\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"头部\",{\"1\":{\"604\":1}}],[\"头指针\",{\"1\":{\"288\":1}}],[\"头结点\",{\"1\":{\"286\":1}}],[\"队只有一个元素时直接初始化即可\",{\"1\":{\"289\":1}}],[\"队为空时\",{\"1\":{\"289\":1}}],[\"队尾指针\",{\"1\":{\"289\":1}}],[\"队尾指针+1\",{\"1\":{\"288\":1}}],[\"队头指针\",{\"1\":{\"289\":1}}],[\"队头指针+1\",{\"1\":{\"288\":1}}],[\"队满则无法进队\",{\"1\":{\"288\":1}}],[\"队满\",{\"1\":{\"288\":1}}],[\"队满的条件也是\",{\"1\":{\"288\":1}}],[\"队空判断\",{\"1\":{\"289\":1}}],[\"队空\",{\"1\":{\"288\":1}}],[\"队空状态的条件为\",{\"1\":{\"288\":1}}],[\"队列删除序列号最小的节点用以消费\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"队列按照\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"队列管理\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"队列是否为满\",{\"1\":{\"288\":2}}],[\"队列是否为空\",{\"1\":{\"288\":2,\"289\":2}}],[\"队列是一种特殊的线性表\",{\"1\":{\"282\":1}}],[\"队列抽象数据类型\",{\"1\":{\"287\":1}}],[\"队列的容量\",{\"1\":{\"288\":1}}],[\"队列的特点就是先进先出\",{\"1\":{\"287\":1}}],[\"队列的接口\",{\"1\":{\"154\":1}}],[\"队列同样是一种特殊的线性表\",{\"1\":{\"287\":1}}],[\"队列和线性表的应用\",{\"0\":{\"293\":1}}],[\"队列和线性表的实现\",{\"0\":{\"283\":1}}],[\"队列和线性表的定义和基本概念\",{\"0\":{\"282\":1}}],[\"队列\",{\"0\":{\"287\":1},\"1\":{\"282\":1}}],[\"公平锁是指多个线程在等待同一个锁时\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"公平锁\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"公司名称\",{\"1\":{\"838\":1,\"839\":1}}],[\"公司域名倒写\",{\"1\":{\"703\":1,\"704\":1}}],[\"公式进行指针计算\",{\"1\":{\"288\":1}}],[\"公众号二维码\",{\"1\":{\"150\":1}}],[\"公众号\",{\"0\":{\"3\":1},\"1\":{\"212\":1,\"808\":1,\"1068\":1,\"1272\":1}}],[\"循环依赖问题在spring中主要有三种情况\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"循环依赖有了更深入的认识\",{\"1\":{\"954\":1}}],[\"循环依赖还是比较清晰的\",{\"1\":{\"954\":1}}],[\"循环依赖呢\",{\"1\":{\"954\":1}}],[\"循环依赖关系使得程序难以理解\",{\"1\":{\"954\":1}}],[\"循环依赖会导致\",{\"1\":{\"954\":1}}],[\"循环依赖会带来什么问题\",{\"1\":{\"954\":1}}],[\"循环依赖主要会带来以下问题\",{\"1\":{\"954\":1}}],[\"循环依赖指的是\",{\"1\":{\"954\":1}}],[\"循环依赖\",{\"1\":{\"954\":4}}],[\"循环依赖比较熟悉\",{\"1\":{\"954\":1}}],[\"循环来等待\",{\"1\":{\"924\":1}}],[\"循环\",{\"1\":{\"692\":1}}],[\"循环退出的例子\",{\"1\":{\"692\":1}}],[\"循环抓取新闻的主站点列表\",{\"1\":{\"655\":1}}],[\"循环等待条件\",{\"1\":{\"562\":1}}],[\"循环顺序队列\",{\"1\":{\"288\":1}}],[\"循环队列是改进版的顺序队列\",{\"1\":{\"288\":1}}],[\"循环队列\",{\"1\":{\"288\":1}}],[\"假定一个元素用16位比特\",{\"1\":{\"339\":1}}],[\"假溢出\",{\"1\":{\"288\":1}}],[\"假设事务\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"假设网络带宽为10mb\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"假设一个kafka\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"假设一行数据的大小是1k\",{\"1\":{\"272\":1}}],[\"假设我们使用\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"假设我们有三个文档\",{\"1\":{\"1006\":1}}],[\"假设我们有一个电商网站\",{\"1\":{\"1000\":1}}],[\"假设我们有一个简单的消息队列\",{\"1\":{\"992\":1}}],[\"假设不会发生并发冲突\",{\"1\":{\"1018\":1}}],[\"假设\",{\"1\":{\"707\":1}}],[\"假设键\",{\"1\":{\"635\":1}}],[\"假设另一个事务已经在id为10到20的范围内设置了间隙锁\",{\"1\":{\"558\":1}}],[\"假设你有一个包含大量数据的表\",{\"0\":{\"509\":1}}],[\"假设代币是以太币\",{\"1\":{\"487\":1,\"488\":1}}],[\"假设有五个文档\",{\"1\":{\"425\":1}}],[\"假设原来有一串数值如下所示\",{\"1\":{\"375\":1}}],[\"假设给定无序序列结构如下\",{\"1\":{\"364\":1}}],[\"假设长度为m\",{\"1\":{\"333\":1,\"339\":1}}],[\"假设每个节点有\",{\"1\":{\"267\":1}}],[\"假设正在运行的有server1\",{\"1\":{\"166\":1}}],[\"假设60s\",{\"1\":{\"141\":1}}],[\"肯定是出了大问题\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"肯定含有此位置\",{\"1\":{\"286\":1}}],[\"肯定都会被问到mysql的知识\",{\"1\":{\"262\":1}}],[\"双层缓存策略\",{\"1\":{\"1203\":2,\"1383\":2}}],[\"双亲委派模型体现了\",{\"1\":{\"934\":1}}],[\"双亲孩子和孩子兄弟表示法\",{\"0\":{\"312\":1}}],[\"双向链表\",{\"0\":{\"286\":1}}],[\"双非本科\",{\"1\":{\"223\":1}}],[\"扩容时\",{\"1\":{\"948\":1}}],[\"扩容的全过程\",{\"1\":{\"948\":1}}],[\"扩容的核心就是在每次插入前判断当前\",{\"1\":{\"342\":1}}],[\"扩容机制\",{\"1\":{\"946\":1}}],[\"扩容\",{\"1\":{\"928\":2,\"948\":1}}],[\"扩容因子为\",{\"1\":{\"928\":1}}],[\"扩容失败\",{\"1\":{\"285\":1}}],[\"扩展性\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"扩展类加载器\",{\"1\":{\"934\":1}}],[\"扩展等\",{\"1\":{\"517\":1}}],[\"扩展阅读\",{\"0\":{\"353\":1}}],[\"扩展\",{\"0\":{\"29\":1,\"30\":1},\"1\":{\"30\":1}}],[\"超越了传统标记\",{\"1\":{\"940\":1}}],[\"超出作用域\",{\"1\":{\"936\":1}}],[\"超出线性表范围\",{\"1\":{\"285\":2,\"286\":1}}],[\"超时时间要大于业务处理时间\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"超时等待\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"超时\",{\"1\":{\"581\":1,\"603\":1,\"648\":1}}],[\"超过了\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"超过所有候选节点一半以上来解决脑裂问题\",{\"1\":{\"1074\":1,\"1278\":1}}],[\"超过100个字符的文本\",{\"1\":{\"440\":1}}],[\"超过50\",{\"1\":{\"342\":1}}],[\"超过半数的投票\",{\"1\":{\"166\":1}}],[\"待研究\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"待持久化过程都结束了\",{\"1\":{\"962\":1}}],[\"待确定\",{\"1\":{\"916\":1}}],[\"待办列表查询\",{\"1\":{\"866\":1}}],[\"待续\",{\"1\":{\"525\":1}}],[\"待检查位置\",{\"1\":{\"285\":1,\"286\":1}}],[\"待删除的元素\",{\"1\":{\"284\":1}}],[\"待查找元素\",{\"1\":{\"284\":2}}],[\"待添加的线性表\",{\"1\":{\"284\":1,\"285\":1,\"286\":1}}],[\"被从物理空间上隔离开了\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"被抽取出来的公共模块\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"被调用之前\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"被部分初始化的对象\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"被声明为\",{\"1\":{\"1089\":1,\"1290\":1}}],[\"被操作系统做了限制\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"被广泛应用于大规模数据处理和实时流处理场景\",{\"1\":{\"980\":1}}],[\"被广泛应用于大数据处理和实时数据流处理\",{\"1\":{\"976\":1}}],[\"被实例化多次\",{\"1\":{\"954\":1}}],[\"被引用的时候\",{\"1\":{\"797\":1}}],[\"被成功回收\",{\"1\":{\"648\":1}}],[\"被分配一个任务需要执行一个java类\",{\"1\":{\"934\":1}}],[\"被分配到同一个索引上的多个键值对会连接成一个单向链表\",{\"1\":{\"626\":1}}],[\"被分配到同一个索引上的多个节点可以用这个单向链表连接起来\",{\"1\":{\"624\":1}}],[\"被分割为\",{\"1\":{\"267\":1}}],[\"被视为空列表\",{\"1\":{\"604\":1}}],[\"被关注\",{\"1\":{\"594\":1}}],[\"被唯一索引约束的健可以为空\",{\"1\":{\"496\":1}}],[\"被设置为\",{\"1\":{\"431\":1,\"692\":1}}],[\"被替换元素\",{\"1\":{\"284\":1}}],[\"插件安装\",{\"0\":{\"861\":1}}],[\"插件配置等\",{\"1\":{\"844\":1}}],[\"插件比如pagehelper都是基于这个原理\",{\"1\":{\"770\":1}}],[\"插件\",{\"0\":{\"770\":1},\"1\":{\"703\":1,\"844\":1,\"1444\":1}}],[\"插件来实现\",{\"1\":{\"29\":1}}],[\"插入了与事务\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"插入和删除\",{\"1\":{\"948\":1}}],[\"插入和删除操作可能导致频繁的节点分裂和合并\",{\"1\":{\"503\":1}}],[\"插入和删除操作\",{\"1\":{\"499\":2}}],[\"插入键值对\",{\"1\":{\"928\":1}}],[\"插入的行数\",{\"1\":{\"826\":1}}],[\"插入预约图书记录\",{\"1\":{\"826\":1}}],[\"插入一个元素\",{\"1\":{\"604\":1}}],[\"插入一个空字符串\",{\"1\":{\"526\":1}}],[\"插入俩个元素\",{\"1\":{\"604\":1}}],[\"插入意向锁允许多个事务保留在特定间隙中插入新行的意图\",{\"1\":{\"558\":1}}],[\"插入意向锁是一种特殊的间隙锁\",{\"1\":{\"558\":1}}],[\"插入意向锁\",{\"0\":{\"558\":1},\"1\":{\"558\":1}}],[\"插入数据\",{\"0\":{\"470\":1},\"1\":{\"736\":1,\"755\":1}}],[\"插入\",{\"1\":{\"352\":1,\"503\":1}}],[\"插入排序\",{\"1\":{\"352\":1}}],[\"插入操作\",{\"1\":{\"286\":1}}],[\"插入元素\",{\"1\":{\"284\":1}}],[\"插入位置\",{\"1\":{\"284\":1}}],[\"添加用户\",{\"1\":{\"1439\":1}}],[\"添加了\",{\"1\":{\"1245\":1,\"1418\":1}}],[\"添加了外部的x265或者x264\",{\"1\":{\"135\":1}}],[\"添加额外的方法或者字段到被通知的类\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"添加\",{\"1\":{\"1122\":1,\"1178\":1,\"1317\":1,\"1363\":1}}],[\"添加缓存等优化\",{\"1\":{\"950\":1}}],[\"添加所有文件\",{\"1\":{\"918\":1}}],[\"添加备注\",{\"1\":{\"916\":1}}],[\"添加图表\",{\"1\":{\"889\":1}}],[\"添加依赖\",{\"1\":{\"839\":1,\"885\":1,\"1444\":1}}],[\"添加相关依赖\",{\"1\":{\"838\":1}}],[\"添加userdao测试用例\",{\"0\":{\"756\":1}}],[\"添加配置\",{\"1\":{\"755\":1}}],[\"添加环境变量maven\",{\"1\":{\"702\":1}}],[\"添加地理位置的坐标\",{\"1\":{\"660\":1}}],[\"添加新节点到压缩列表\",{\"1\":{\"633\":1}}],[\"添加后的容量\",{\"1\":{\"285\":1}}],[\"添加线性表\",{\"1\":{\"284\":1}}],[\"添加元素到\",{\"1\":{\"659\":1}}],[\"添加元素\",{\"1\":{\"284\":2,\"946\":1}}],[\"清除模型\",{\"1\":{\"940\":1}}],[\"清除算法\",{\"1\":{\"938\":1,\"940\":1,\"1146\":1,\"1337\":1}}],[\"清除被标记的对象\",{\"1\":{\"938\":1}}],[\"清除\",{\"1\":{\"936\":1,\"940\":6}}],[\"清除原来的编译结果\",{\"1\":{\"705\":1}}],[\"清理指定位置的键值对\",{\"1\":{\"928\":2}}],[\"清理过期的键值对\",{\"1\":{\"928\":2}}],[\"清理键值对\",{\"1\":{\"928\":1}}],[\"清理键值对的阈值\",{\"1\":{\"928\":1}}],[\"清空线性表\",{\"1\":{\"284\":1}}],[\"清晰\",{\"1\":{\"176\":1}}],[\"策略模式是行为性模式\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"策略模式\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"策略英文记为\",{\"1\":{\"282\":1}}],[\"策略的数据结构类型\",{\"1\":{\"282\":1}}],[\"弹栈\",{\"1\":{\"282\":2}}],[\"出列按编号\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"出版日期等\",{\"1\":{\"1004\":1}}],[\"出差报销\",{\"1\":{\"865\":1}}],[\"出了这几种情况还有一些导致索引失效\",{\"1\":{\"501\":1}}],[\"出队\",{\"1\":{\"287\":1,\"288\":5,\"289\":1}}],[\"出栈\",{\"1\":{\"282\":1}}],[\"出参\",{\"0\":{\"192\":1},\"1\":{\"191\":1}}],[\"压垮\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"压栈\",{\"1\":{\"282\":2}}],[\"压缩算法会增加cpu的使用量\",{\"1\":{\"972\":1}}],[\"压缩算法会对性能有什么影响吗\",{\"1\":{\"972\":1}}],[\"压缩列表可以包含多个节点\",{\"1\":{\"633\":1}}],[\"压缩列表\",{\"0\":{\"631\":1,\"633\":1},\"1\":{\"613\":1,\"633\":1}}],[\"压缩数据\",{\"1\":{\"145\":1}}],[\"压缩级别\",{\"1\":{\"106\":2}}],[\"压缩解压\",{\"1\":{\"94\":1}}],[\"压缩方式\",{\"1\":{\"94\":1}}],[\"压缩\",{\"1\":{\"94\":1,\"1144\":2,\"1335\":2}}],[\"栈只对于线程是可见的\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"栈存放\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"栈是连续的\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"栈是一种采用\",{\"1\":{\"282\":1}}],[\"栈使用的是数据结构中的栈\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"栈的实现\",{\"0\":{\"290\":1}}],[\"栈的删除操作也称为\",{\"1\":{\"282\":1}}],[\"栈的插入操作也称为\",{\"1\":{\"282\":1}}],[\"栈基本上只有两种操作\",{\"1\":{\"282\":1}}],[\"栈有一个非常非常重要的一个特点\",{\"1\":{\"282\":1}}],[\"栈底记做\",{\"1\":{\"282\":1}}],[\"栈顶记做\",{\"1\":{\"282\":1}}],[\"栈\",{\"0\":{\"282\":1,\"283\":1,\"293\":1},\"1\":{\"282\":1}}],[\"线上环境不建议使用\",{\"1\":{\"962\":1}}],[\"线程的开销成本也就越大\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"线程c\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"线程b可以同时对该集合的元素进行增删操作\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"线程b\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"线程a不会抛出任何异常\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"线程a\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"线程内部顺序调用\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"线程局部变量是局限于线程内的变量\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"线程将进入等待队列进行等待直到被通知或者被唤醒\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"线程对象创建后\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"线程间变量值的传递需要通过主内存来完成\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"线程不安全\",{\"1\":{\"1089\":1,\"1290\":1}}],[\"线程跳出阻塞状态\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"线程模型等\",{\"1\":{\"950\":1}}],[\"线程模型优化\",{\"1\":{\"950\":1}}],[\"线程等在内存中的存储方式和访问方式\",{\"1\":{\"930\":1}}],[\"线程会返回线程池\",{\"1\":{\"926\":1}}],[\"线程池还可能会导致任务执行的顺序发生变化\",{\"1\":{\"926\":1}}],[\"线程池的优点是可以提高系统的性能和资源利用率\",{\"1\":{\"926\":1}}],[\"线程池的拒绝策略有四种\",{\"1\":{\"926\":1}}],[\"线程池的参数包括核心线程数\",{\"1\":{\"926\":1}}],[\"线程池拒绝策略用于处理任务队列已满时的情况\",{\"1\":{\"926\":1}}],[\"线程池拒绝策略等\",{\"1\":{\"926\":1}}],[\"线程池会首先检查是否有空闲线程可用\",{\"1\":{\"926\":1}}],[\"线程池是一种管理线程的机制\",{\"1\":{\"926\":1}}],[\"线程池\",{\"0\":{\"926\":1},\"1\":{\"920\":1}}],[\"线程池等\",{\"1\":{\"645\":1}}],[\"线程每次判断\",{\"1\":{\"692\":1}}],[\"线程开始执行\",{\"1\":{\"692\":1}}],[\"线程栈内存\",{\"1\":{\"692\":1}}],[\"线程栈保存了线程运行时候变量值信息\",{\"1\":{\"692\":1}}],[\"线程仍然在运行\",{\"1\":{\"692\":1}}],[\"线程方法结束退出\",{\"1\":{\"692\":1}}],[\"线程在进行判断\",{\"1\":{\"692\":1}}],[\"线程在进行下一次\",{\"1\":{\"692\":1}}],[\"线程在每次使用变量的时候\",{\"1\":{\"692\":1}}],[\"线程已经开始执行\",{\"1\":{\"692\":1}}],[\"线程\",{\"1\":{\"692\":1,\"942\":1,\"1088\":1,\"1289\":1}}],[\"线程退出之前\",{\"1\":{\"692\":1}}],[\"线程安全对我们来说很重要\",{\"1\":{\"988\":1}}],[\"线程安全吗\",{\"1\":{\"988\":1}}],[\"线程安全就是多个线程访问同一个对象或调用同一方法时\",{\"1\":{\"988\":1}}],[\"线程安全\",{\"1\":{\"83\":1,\"84\":1,\"922\":1,\"988\":1}}],[\"线程安全+懒加载\",{\"1\":{\"78\":1}}],[\"线\",{\"1\":{\"454\":1,\"495\":1}}],[\"线性表的元素个数\",{\"1\":{\"284\":1}}],[\"线性表有两种实现方式\",{\"1\":{\"284\":1}}],[\"线性表分为两大类\",{\"1\":{\"282\":1}}],[\"线性表里的元素是按线性排列的\",{\"1\":{\"282\":1}}],[\"线性表\",{\"0\":{\"284\":1},\"1\":{\"282\":2}}],[\"线性数据结构\",{\"0\":{\"281\":1}}],[\"抽象\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"抽象数据类型等\",{\"0\":{\"279\":1}}],[\"抽象出一个十分简单的存取模型来说明ram的工作原理\",{\"1\":{\"273\":1}}],[\"哪位要是有好的资料麻烦共享一份给我\",{\"1\":{\"692\":1}}],[\"哪些情况下适合建立索引\",{\"0\":{\"502\":1}}],[\"哪些算是有效日志\",{\"1\":{\"192\":1}}],[\"哪个扇区\",{\"1\":{\"274\":1}}],[\"圆心是盘片中心\",{\"1\":{\"274\":1}}],[\"磁道被沿半径线划分成一个个小的段\",{\"1\":{\"274\":1}}],[\"磁头需要移动对准相应磁道\",{\"1\":{\"274\":1}}],[\"磁头不能转动\",{\"1\":{\"274\":1}}],[\"磁头支架固定了一组磁头\",{\"1\":{\"274\":1}}],[\"磁盘上的每个段都有一个相应的\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"磁盘缓存其实就把常用的磁盘数据保存在内存中\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"磁盘缓存\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"磁盘使用是一个需要考虑的因素\",{\"1\":{\"978\":1}}],[\"磁盘持久化\",{\"1\":{\"601\":1}}],[\"磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中\",{\"1\":{\"274\":1}}],[\"磁盘也会从这个位置开始\",{\"1\":{\"274\":1}}],[\"磁盘往往不是严格按需读取\",{\"1\":{\"274\":1}}],[\"磁盘本身存取就比主存慢很多\",{\"1\":{\"274\":1}}],[\"磁盘的存取速度往往是主存的几百分分之一\",{\"1\":{\"274\":1}}],[\"磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址\",{\"1\":{\"274\":1}}],[\"磁盘的角度来看看b\",{\"1\":{\"266\":1}}],[\"磁盘可以转动\",{\"1\":{\"274\":1}}],[\"磁盘i\",{\"1\":{\"274\":1,\"503\":1}}],[\"磁盘存储和i\",{\"1\":{\"499\":1}}],[\"磁盘存储\",{\"1\":{\"499\":2,\"1073\":1,\"1277\":1}}],[\"磁盘存储单位是按\",{\"1\":{\"266\":1}}],[\"磁盘存取原理\",{\"0\":{\"274\":1}}],[\"磁盘扇区\",{\"1\":{\"272\":1}}],[\"磁盘预读原理就会提前把这些数据都读进内存\",{\"1\":{\"270\":1}}],[\"磁盘\",{\"1\":{\"266\":2,\"517\":1,\"1064\":1,\"1270\":1}}],[\"磁盘读取时间远远超过了数据在内存中比较的时间\",{\"1\":{\"266\":1}}],[\"距离\",{\"1\":{\"273\":1}}],[\"做\",{\"1\":{\"1443\":1}}],[\"做出正确的反馈后\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"做一些练习\",{\"1\":{\"1079\":1,\"1283\":1}}],[\"做一些简单操作了\",{\"1\":{\"702\":1}}],[\"做一些简单了解即可\",{\"1\":{\"589\":1}}],[\"做概率估算从而得到基数\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"做空间整合\",{\"1\":{\"938\":1}}],[\"做法\",{\"1\":{\"916\":1}}],[\"做整体映射\",{\"1\":{\"819\":1}}],[\"做容错\",{\"1\":{\"689\":1}}],[\"做简单的\",{\"1\":{\"653\":1}}],[\"做起事来\",{\"1\":{\"643\":1}}],[\"做很多操作时性能仍下降严重\",{\"1\":{\"515\":1}}],[\"做索引与搜索\",{\"1\":{\"400\":1}}],[\"做相应的写操作\",{\"1\":{\"273\":1}}],[\"做了什么动作\",{\"1\":{\"179\":1}}],[\"解耦\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"解锁时需要传入相同的value才能成功\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"解释\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"解释一下它的实现原理吗\",{\"1\":{\"1022\":1}}],[\"解释一下\",{\"1\":{\"940\":1}}],[\"解答java自动装箱和拆箱\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"解答\",{\"1\":{\"1026\":1,\"1030\":1,\"1249\":1}}],[\"解析为view\",{\"1\":{\"956\":1}}],[\"解析器\",{\"1\":{\"956\":1}}],[\"解析请求对应的\",{\"1\":{\"956\":1}}],[\"解析\",{\"1\":{\"950\":2,\"956\":3,\"1148\":1,\"1176\":1,\"1339\":1,\"1361\":1}}],[\"解析和初始化5个阶段组成\",{\"1\":{\"934\":1}}],[\"解析信号并定位到指定存储单元\",{\"1\":{\"273\":1}}],[\"解决的核心原理就是\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"解决空间碎片问题\",{\"1\":{\"940\":1}}],[\"解决碎片问题\",{\"1\":{\"940\":1}}],[\"解决方案二\",{\"1\":{\"779\":1}}],[\"解决方案一\",{\"1\":{\"779\":1}}],[\"解决方案\",{\"1\":{\"768\":1,\"1050\":1,\"1136\":1,\"1259\":1,\"1329\":1}}],[\"解决方案3\",{\"1\":{\"759\":1}}],[\"解决方案2\",{\"1\":{\"759\":1}}],[\"解决方案1\",{\"1\":{\"759\":1}}],[\"解决数据库字段名和实体类属性名不一致的问题\",{\"0\":{\"759\":1}}],[\"解决jar依赖问题\",{\"1\":{\"700\":1}}],[\"解决jar冲突\",{\"1\":{\"700\":1}}],[\"解决键冲突\",{\"1\":{\"624\":1}}],[\"解决死锁\",{\"1\":{\"581\":2}}],[\"解决慢查询\",{\"1\":{\"525\":1}}],[\"解决了什么问题\",{\"0\":{\"1164\":1,\"1352\":1}}],[\"解决了单一表数据量过大的问题\",{\"1\":{\"519\":1}}],[\"解决了单库大数据\",{\"1\":{\"518\":1}}],[\"解决了这些问题我们就可以很轻松地实现循环队列了\",{\"1\":{\"288\":1}}],[\"解决业务层面的耦合\",{\"1\":{\"517\":1}}],[\"解压缩后用自己喜欢的\",{\"1\":{\"837\":1}}],[\"解压缩方式\",{\"1\":{\"94\":1}}],[\"解压maven压缩包\",{\"1\":{\"701\":1}}],[\"解压文件\",{\"1\":{\"701\":1}}],[\"解压文件到目录\",{\"1\":{\"412\":1,\"413\":1}}],[\"解压后\",{\"1\":{\"597\":2}}],[\"解压到对应pinyin目录\",{\"1\":{\"413\":1}}],[\"解压到对应ik目录\",{\"1\":{\"412\":1}}],[\"解压就可以启动使用\",{\"1\":{\"157\":1}}],[\"解压\",{\"1\":{\"125\":1,\"405\":1,\"408\":1,\"597\":1,\"672\":1}}],[\"现场有个紧急需求\",{\"1\":{\"916\":1}}],[\"现象\",{\"1\":{\"288\":1}}],[\"现代主存的编址规则比较复杂\",{\"1\":{\"273\":1}}],[\"现代ram的结构和存取原理比较复杂\",{\"1\":{\"273\":1}}],[\"现在大多数应用都是支持分布式的\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"现在也有同步的\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"现在不太建议使用\",{\"1\":{\"922\":1}}],[\"现在不建议使用\",{\"1\":{\"922\":1}}],[\"现在有什么其他的map实现可以选择\",{\"1\":{\"922\":1}}],[\"现在将提交f应用到master分支\",{\"1\":{\"917\":1}}],[\"现在整个项目全部完成\",{\"1\":{\"832\":1}}],[\"现在测试一下\",{\"1\":{\"828\":1}}],[\"现在的写法是从数据库层向前\",{\"1\":{\"828\":1}}],[\"现在需要编写相应的\",{\"1\":{\"827\":1}}],[\"现在一些mybatis\",{\"1\":{\"770\":1}}],[\"现在为止应该没有使用jdk1\",{\"1\":{\"701\":1}}],[\"现在多机器部署的程序可以基于\",{\"1\":{\"656\":1}}],[\"现在多数使用\",{\"1\":{\"507\":1}}],[\"现在\",{\"1\":{\"594\":1,\"986\":1,\"1212\":1,\"1389\":1}}],[\"现在是\",{\"1\":{\"521\":1,\"836\":1}}],[\"现在只需要安装\",{\"1\":{\"251\":1}}],[\"现在这个直播使用很广泛的时代\",{\"1\":{\"134\":1}}],[\"现在很多市场上的剪辑软件都是基于它做的\",{\"1\":{\"121\":1}}],[\"现在在linux\",{\"1\":{\"106\":1}}],[\"现在市面上机构也很多\",{\"1\":{\"98\":1}}],[\"他和其他的排他锁\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"他们只需要共享锁对象\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"他们经常认为这\",{\"1\":{\"526\":1}}],[\"他是这样做的\",{\"1\":{\"916\":1}}],[\"他是一个普普通通的男生\",{\"1\":{\"217\":1}}],[\"他都能回答出maven是一个项目管理工具\",{\"1\":{\"698\":1}}],[\"他的生命周期和线程相同\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"他的粉丝一共有多少\",{\"1\":{\"656\":1}}],[\"他的最小单元是块\",{\"1\":{\"272\":1}}],[\"他不受到\",{\"1\":{\"348\":1}}],[\"换句话说\",{\"1\":{\"271\":1,\"1219\":1,\"1396\":1}}],[\"则是单台\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"则是一个屏障\",{\"1\":{\"932\":1}}],[\"则spring\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"则对master服务进行下线处理\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"则予以更新\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"则进一步向上委托\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"则进行更新并增加版本号或更新时间戳\",{\"1\":{\"573\":1}}],[\"则进行毫秒内序列\",{\"1\":{\"388\":1}}],[\"则只执行第三步\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"则在嵌套事务内执行\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"则在启动服务器时自动加载\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"则在垃圾回收时这些变量会被清除\",{\"1\":{\"936\":1}}],[\"则符合\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"则释放lock2的锁\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"则释放lock1的锁\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"则提示用户该接口需要登录才能访问\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"则通过编译\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"则直接返回\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"则直接释放锁\",{\"1\":{\"1023\":1}}],[\"则直接替换值\",{\"1\":{\"928\":1}}],[\"则尝试获取锁\",{\"1\":{\"1023\":1}}],[\"则抛出异常\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"则抛出\",{\"1\":{\"1023\":2}}],[\"则从broker节点拉取\",{\"1\":{\"990\":1}}],[\"则唤醒优先级最高的线程\",{\"1\":{\"988\":1}}],[\"则会自动调用其配置的销毁方法\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"则会执行destructionawarebeanpostprocessor后置处理器的销毁回调方法\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"则会编译错误\",{\"1\":{\"966\":1}}],[\"则会根据线程池的配置信息创建新的线程来执行任务\",{\"1\":{\"926\":1}}],[\"则覆盖原来的值\",{\"1\":{\"960\":1}}],[\"则发生哈希碰撞\",{\"1\":{\"948\":1}}],[\"则触发rehash\",{\"1\":{\"948\":1}}],[\"则标记整个分段为\",{\"1\":{\"940\":1}}],[\"则判断为垃圾\",{\"1\":{\"936\":1}}],[\"则这两个对象之间形成的循环引用链为垃圾\",{\"1\":{\"936\":1}}],[\"则这棵二叉树称为完全二叉树\",{\"1\":{\"364\":1}}],[\"则该线程可以直接释放该锁\",{\"1\":{\"1023\":1}}],[\"则该线程可以直接获取该锁\",{\"1\":{\"1022\":3,\"1023\":1}}],[\"则该线程会被阻塞\",{\"1\":{\"1022\":1,\"1023\":1}}],[\"则该线程会尝试自旋等待该锁的释放\",{\"1\":{\"1022\":1}}],[\"则该线程会尝试升级为轻量级锁或重量级锁\",{\"1\":{\"1022\":1,\"1023\":1}}],[\"则该线程将被阻塞\",{\"1\":{\"1022\":2}}],[\"则该对象可被回收\",{\"1\":{\"936\":1}}],[\"则该对象为垃圾\",{\"1\":{\"936\":3}}],[\"则该字段不可被搜索\",{\"1\":{\"432\":1}}],[\"则插入新的键值对\",{\"1\":{\"928\":2}}],[\"则往后查找空位置\",{\"1\":{\"928\":1}}],[\"则将任务分配给其中一个空闲线程执行\",{\"1\":{\"926\":1}}],[\"则将地址信号放到地址总线上传给主存\",{\"1\":{\"273\":1}}],[\"则自动创建\",{\"1\":{\"864\":1}}],[\"则按required属性执行\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"则按驼峰匹配\",{\"1\":{\"793\":1,\"794\":1}}],[\"则按姓名查询\",{\"1\":{\"784\":2}}],[\"则不行\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"则不做任何操作\",{\"1\":{\"960\":1}}],[\"则不再扩容\",{\"1\":{\"928\":1}}],[\"则不修改\",{\"1\":{\"786\":1}}],[\"则不会使用索引\",{\"1\":{\"501\":1}}],[\"则namespace必须为dao接口的全路径\",{\"1\":{\"762\":1}}],[\"则name的值为name1\",{\"1\":{\"727\":1}}],[\"则jvm会进行优化\",{\"1\":{\"692\":1}}],[\"则用于表示跳跃表节点\",{\"1\":{\"629\":1}}],[\"则认为成功获取了锁\",{\"1\":{\"577\":1}}],[\"则认为获取锁失败\",{\"1\":{\"577\":1}}],[\"则认为获取了锁\",{\"1\":{\"577\":1}}],[\"则放弃更新\",{\"1\":{\"573\":1}}],[\"则回滚事务\",{\"1\":{\"569\":1}}],[\"则表示有冲突\",{\"1\":{\"569\":1}}],[\"则可以使用\",{\"1\":{\"1048\":3,\"1257\":3}}],[\"则可以在usermapper\",{\"1\":{\"782\":1}}],[\"则可以在具有\",{\"1\":{\"526\":1}}],[\"则可以禁用doc值以节省磁盘空间\",{\"1\":{\"440\":1}}],[\"则可能导致待排序集合中每一个元素值映射到一个桶上\",{\"1\":{\"350\":1}}],[\"则可能导致待排序集合中所有元素全部映射到一个桶上\",{\"1\":{\"350\":1}}],[\"则使用随机数备用\",{\"1\":{\"388\":1}}],[\"则持续进行以上的动作直至最高位数为止\",{\"1\":{\"375\":1}}],[\"则无法创建对应的统计数组\",{\"1\":{\"361\":1}}],[\"则无法区间查找\",{\"1\":{\"270\":1}}],[\"则桶排序向计数排序方式演化\",{\"1\":{\"350\":1}}],[\"则桶排序向比较性质排序算法演变\",{\"1\":{\"350\":1}}],[\"则完成排序过程\",{\"1\":{\"348\":1}}],[\"则所有桶中元素构成的集合是已排序的\",{\"1\":{\"348\":1}}],[\"则拆分后形成的多个桶\",{\"1\":{\"348\":1}}],[\"则数据也可能不存在\",{\"1\":{\"334\":1}}],[\"则\",{\"1\":{\"270\":1,\"648\":1,\"1166\":1,\"1354\":1}}],[\"则至少需要两台机器\",{\"1\":{\"166\":1}}],[\"复合索引就是多个列上创建的索引\",{\"1\":{\"498\":1}}],[\"复合索引和单列索引有何区别\",{\"0\":{\"498\":1}}],[\"复合类型主要有对象类型\",{\"1\":{\"449\":1}}],[\"复杂度o\",{\"1\":{\"922\":1}}],[\"复杂度才能找到数据\",{\"1\":{\"270\":1}}],[\"复杂类型\",{\"0\":{\"449\":1},\"1\":{\"441\":1}}],[\"复制算法\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"复制算法等进行回收\",{\"1\":{\"936\":1}}],[\"复制并处理资源文件\",{\"1\":{\"713\":2}}],[\"复制值的函数\",{\"1\":{\"624\":1}}],[\"复制键的函数\",{\"1\":{\"624\":1}}],[\"复制功能就能满足\",{\"1\":{\"594\":1}}],[\"复制\",{\"1\":{\"572\":1,\"573\":1,\"601\":1,\"940\":1,\"1144\":1,\"1335\":1}}],[\"复制的是字段值\",{\"1\":{\"436\":1}}],[\"复制一份到同级目录下\",{\"1\":{\"157\":1}}],[\"非httpservlet环境开发中也可以用其它的key值代替\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"非公平锁在锁被释放时\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"非阻塞式\",{\"1\":{\"1020\":1}}],[\"非线程安全\",{\"1\":{\"922\":1}}],[\"非常简便\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"非常详细的解释\",{\"1\":{\"1008\":1}}],[\"非常正确\",{\"1\":{\"1008\":1}}],[\"非常清楚\",{\"1\":{\"1004\":1}}],[\"非常清晰明了\",{\"1\":{\"990\":1}}],[\"非常有见地\",{\"1\":{\"970\":1}}],[\"非常重要的提醒\",{\"1\":{\"970\":1}}],[\"非常高兴能帮到您\",{\"1\":{\"966\":1}}],[\"非常高兴能与你进行这次交流与探讨\",{\"1\":{\"966\":1}}],[\"非常易于学习和使用\",{\"1\":{\"960\":1}}],[\"非常精彩\",{\"1\":{\"956\":1}}],[\"非常棒\",{\"1\":{\"952\":1,\"968\":1,\"1002\":1}}],[\"非常感谢你的回答\",{\"1\":{\"1000\":1}}],[\"非常感谢你的邀请和提问\",{\"1\":{\"968\":1}}],[\"非常感谢你的时间和分享\",{\"1\":{\"968\":1}}],[\"非常感谢你的分享\",{\"1\":{\"930\":1,\"1002\":1}}],[\"非常感谢您的提问\",{\"1\":{\"1000\":1}}],[\"非常感谢您的夸奖\",{\"1\":{\"984\":1}}],[\"非常感谢您的夸奖和建议\",{\"1\":{\"938\":1}}],[\"非常感谢您的解答\",{\"1\":{\"980\":1}}],[\"非常感谢您的赞赏\",{\"1\":{\"940\":1,\"970\":1}}],[\"非常感谢面试官的赏识\",{\"1\":{\"958\":1}}],[\"非常感谢面试官的肯定与指导\",{\"1\":{\"946\":1}}],[\"非常感谢面试官的提问\",{\"1\":{\"934\":1}}],[\"非常感谢面试官的鼓励\",{\"1\":{\"934\":1}}],[\"非常感谢面试官的指导\",{\"1\":{\"934\":1}}],[\"非常感谢面试官今天的时间\",{\"1\":{\"922\":1}}],[\"非常感谢\",{\"1\":{\"924\":1,\"990\":1,\"998\":1}}],[\"非常好的观点\",{\"1\":{\"970\":1}}],[\"非常好\",{\"1\":{\"924\":2,\"928\":4,\"930\":3,\"980\":1,\"990\":1,\"992\":1,\"1002\":1,\"1010\":2,\"1016\":2}}],[\"非常好记\",{\"1\":{\"589\":1}}],[\"非常适用于开发企业级应用\",{\"1\":{\"950\":1}}],[\"非常适用于这些计数场景\",{\"1\":{\"594\":1}}],[\"非常适合构建微服务\",{\"1\":{\"401\":1}}],[\"非聚簇索引不直接存储实际的数据\",{\"1\":{\"497\":1}}],[\"非聚簇索引是一种基于指针的索引\",{\"1\":{\"497\":1}}],[\"非聚簇索引就是以非主键创建的索引\",{\"1\":{\"495\":1}}],[\"非聚簇索引\",{\"1\":{\"495\":1}}],[\"非字符分割\",{\"1\":{\"411\":1}}],[\"非空性\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"非空\",{\"1\":{\"284\":1}}],[\"非叶子节点的简洁性\",{\"1\":{\"503\":1}}],[\"非叶子节点都只是索引值\",{\"1\":{\"270\":1}}],[\"非叶子节点并不存储真正的\",{\"1\":{\"269\":1}}],[\"非会员逻辑\",{\"1\":{\"200\":1}}],[\"判断bean是否实现了initializingbean接口\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"判断数据库表对应记录的当前版本信息与第一次取出来的\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"判断并保证系统的安全运行\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"判断对象是否存在\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"判断键是否存在\",{\"1\":{\"603\":1}}],[\"判断被领取的代币是否超过总的额度\",{\"1\":{\"488\":1}}],[\"判断是否过期\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"判断是否打卡\",{\"1\":{\"658\":1}}],[\"判断是否领取过\",{\"1\":{\"488\":1}}],[\"判断是否已经有过半机器接受到相同的投票信息\",{\"1\":{\"166\":1}}],[\"判断一个元素是否在集合中\",{\"1\":{\"342\":1}}],[\"判断空队列和清空队列等操作\",{\"1\":{\"287\":1}}],[\"判断线性表是否为空\",{\"1\":{\"284\":1}}],[\"判断\",{\"1\":{\"267\":1,\"288\":1,\"606\":1,\"692\":1}}],[\"节省开发时间\",{\"1\":{\"844\":1}}],[\"节省沟通成本\",{\"1\":{\"185\":1}}],[\"节约内存\",{\"1\":{\"440\":1}}],[\"节点就释放出锁\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"节点下还可以配置多个\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"节点负责不同的slot范围\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"节点保存整个集群中的全部数据\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"节点通过\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"节点需要从\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"节点恢复到新的\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"节点时\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"节点只会为此工作分配一个线程\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"节点进行数据副本复制时\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"节点内存\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"节点使用文档的\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"节点数\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"节点数据\",{\"1\":{\"286\":1}}],[\"节点启动后\",{\"1\":{\"1008\":1}}],[\"节点启动\",{\"1\":{\"1008\":1}}],[\"节点按照成员对象的大小进行排序\",{\"1\":{\"629\":1}}],[\"节点值对比函数\",{\"1\":{\"621\":1}}],[\"节点值释放函数\",{\"1\":{\"621\":1}}],[\"节点值复制函数\",{\"1\":{\"621\":1}}],[\"节点分裂和合并的开销\",{\"1\":{\"503\":1}}],[\"节点\",{\"1\":{\"416\":1,\"417\":1,\"922\":1,\"1070\":2,\"1167\":1,\"1205\":1,\"1244\":2,\"1274\":2,\"1355\":1,\"1385\":1,\"1417\":2}}],[\"节点元素\",{\"1\":{\"286\":1}}],[\"节点的错误恢复将会自动地进行\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"节点的选举过程在\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"节点的值\",{\"1\":{\"621\":1}}],[\"节点的\",{\"1\":{\"267\":1}}],[\"根本无须再去考虑b\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"根本原因是底层lucene的segment段文件不可更新删除\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"根标签\",{\"1\":{\"743\":1,\"744\":1,\"745\":1,\"755\":1,\"763\":1}}],[\"根目录\",{\"1\":{\"597\":1}}],[\"根节点都在内存中\",{\"1\":{\"267\":1}}],[\"根据当前环境中设置的隔离级别\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"根据传入一个唯一的标识来获得bean对象\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"根据表达式的值动态拼接\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"根据表名查询用户信息\",{\"1\":{\"763\":1,\"779\":2}}],[\"根据查找路径找到相应的\",{\"1\":{\"1148\":1,\"1339\":1}}],[\"根据对象存活周期的不同将内存划分为几块\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"根据程序计数器中存储的指令地址执行classes中的指令\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"根据给定的全限定名类名\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"根据业务增量需求\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"根据业务选择恰当的线程模型\",{\"1\":{\"950\":1}}],[\"根据数据量和负载情况\",{\"1\":{\"1002\":1}}],[\"根据数列的最大值确定统计数组的长度\",{\"1\":{\"360\":1}}],[\"根据实际需求设计合理的索引和映射\",{\"1\":{\"1002\":1}}],[\"根据实际情况进行数据分区\",{\"1\":{\"509\":1}}],[\"根据用户的搜索关键字返回相关的商品结果\",{\"1\":{\"1000\":1}}],[\"根据用户给定的经纬度坐标来获取指定范围内的地理位置集合\",{\"1\":{\"660\":1}}],[\"根据方法的注解实现读写分离\",{\"1\":{\"958\":1}}],[\"根据请求找到正确的\",{\"1\":{\"956\":1}}],[\"根据请求返回\",{\"1\":{\"956\":1}}],[\"根据请求信息匹配\",{\"1\":{\"956\":1}}],[\"根据请求信息调用\",{\"1\":{\"956\":2}}],[\"根据注解做相应的操作\",{\"1\":{\"944\":1}}],[\"根据注解改变程序的行为\",{\"1\":{\"944\":1}}],[\"根据应用内存需求适当设置\",{\"1\":{\"942\":1}}],[\"根据应用特点选择合适参数\",{\"1\":{\"942\":1}}],[\"根据标记和card\",{\"1\":{\"940\":1}}],[\"根据标记结果筛选回收区域\",{\"1\":{\"936\":1}}],[\"根据空间利用率与gc时间的平衡\",{\"1\":{\"938\":1}}],[\"根据空间局部性原理\",{\"1\":{\"270\":1}}],[\"根据需要的功能\",{\"1\":{\"922\":1}}],[\"根据hash值定位数组索引\",{\"1\":{\"922\":1}}],[\"根据\",{\"1\":{\"876\":2,\"956\":1,\"958\":1,\"1070\":1,\"1116\":1,\"1123\":1,\"1274\":1,\"1311\":1,\"1318\":1}}],[\"根据自己的实际情况填写\",{\"1\":{\"837\":1}}],[\"根据订单号查询订单用户的信息及订单详情及订单详情对应的商品信息\",{\"1\":{\"795\":1}}],[\"根据订单号查询订单用户的信息及订单详情\",{\"1\":{\"794\":1}}],[\"根据订单号查询订单用户的信息\",{\"1\":{\"793\":1}}],[\"根据id更新用户信息\",{\"1\":{\"763\":1,\"786\":1}}],[\"根据id删除用户信息\",{\"1\":{\"753\":1,\"763\":1}}],[\"根据id查询用户信息\",{\"1\":{\"753\":1,\"763\":1}}],[\"根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合\",{\"1\":{\"660\":1}}],[\"根据商品销售对商品进行排序显示\",{\"1\":{\"657\":1}}],[\"根据键值的大小关系\",{\"1\":{\"499\":1}}],[\"根据键值的每位数字来分配桶\",{\"1\":{\"370\":1}}],[\"根据地理位置修改评分规则等需求\",{\"1\":{\"453\":1}}],[\"根据距离排序\",{\"1\":{\"453\":1}}],[\"根据倒排列表\",{\"1\":{\"424\":1}}],[\"根据完全二叉树的性质\",{\"1\":{\"364\":1}}],[\"根据待排序集合中最大元素和最小元素的差值范围和映射规则\",{\"1\":{\"351\":1}}],[\"根据论文\",{\"1\":{\"339\":1}}],[\"根据这一特点我们可知\",{\"1\":{\"282\":1}}],[\"根据不同操作系统\",{\"1\":{\"246\":1}}],[\"根据操作系统的不同可能是4k或者8k\",{\"1\":{\"106\":1}}],[\"根据硬件调整\",{\"1\":{\"106\":1}}],[\"域都在叶子节点存储\",{\"1\":{\"270\":1}}],[\"域都在根节点\",{\"1\":{\"270\":1}}],[\"域\",{\"1\":{\"267\":1,\"270\":2,\"605\":1}}],[\"域名后缀io属于国家域名\",{\"1\":{\"589\":1}}],[\"域名\",{\"1\":{\"406\":1,\"1136\":1,\"1329\":1}}],[\"域名服务\",{\"1\":{\"154\":1}}],[\"域名根路径下\",{\"1\":{\"106\":1}}],[\"二是有序性\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"二维码\",{\"2\":{\"880\":1}}],[\"二维码可以带logo\",{\"1\":{\"877\":1}}],[\"二维码是我们当今社会非常重要的一项技术\",{\"1\":{\"871\":1}}],[\"二维码是实现原理是什么\",{\"1\":{\"871\":1,\"872\":1}}],[\"二维码的原理是什么\",{\"1\":{\"871\":1,\"872\":1}}],[\"二选一\",{\"1\":{\"763\":1,\"775\":1}}],[\"二号图片\",{\"1\":{\"748\":1}}],[\"二进制日志\",{\"1\":{\"1185\":2,\"1368\":2}}],[\"二进制分帧\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"二进制安全\",{\"1\":{\"620\":1}}],[\"二进制安全的字符串\",{\"1\":{\"603\":1}}],[\"二进制类型\",{\"0\":{\"447\":1},\"1\":{\"447\":1}}],[\"二进制中最高位为1的都是负数\",{\"1\":{\"387\":1}}],[\"二\",{\"0\":{\"411\":1},\"1\":{\"428\":1}}],[\"二叉平衡树\",{\"0\":{\"310\":1}}],[\"二叉排序树\",{\"0\":{\"309\":1}}],[\"二叉树的遍历\",{\"0\":{\"307\":1}}],[\"二叉树的实现\",{\"0\":{\"306\":1}}],[\"二叉树的定义及其主要特征\",{\"0\":{\"305\":1}}],[\"二叉树\",{\"0\":{\"304\":1}}],[\"二叉树一次只能分两个范围\",{\"1\":{\"266\":1}}],[\"二分最快\",{\"1\":{\"267\":1}}],[\"二级缓存与一级缓存其机制相同\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"二级缓存是\",{\"1\":{\"958\":1}}],[\"二级缓存\",{\"0\":{\"790\":1,\"1178\":1,\"1363\":1}}],[\"二级\",{\"0\":{\"56\":1,\"62\":1}}],[\"<数据类型>只能是引用类型\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"<name>\",{\"1\":{\"844\":1}}],[\"<name>demo<\",{\"1\":{\"844\":1}}],[\"<goal>repackage<\",{\"1\":{\"844\":1}}],[\"<goals>\",{\"1\":{\"844\":1}}],[\"<groupid>io\",{\"1\":{\"885\":1}}],[\"<groupid><artifactid>\",{\"1\":{\"844\":1}}],[\"<groupid>\",{\"1\":{\"844\":1}}],[\"<groupid>taglibs<\",{\"1\":{\"812\":1}}],[\"<groupid>javax\",{\"1\":{\"812\":1}}],[\"<groupid>javapub\",{\"1\":{\"812\":1}}],[\"<groupid>jstl<\",{\"1\":{\"812\":1}}],[\"<groupid>junit<\",{\"1\":{\"715\":2,\"756\":1,\"812\":1}}],[\"<groupid>mysql<\",{\"1\":{\"735\":1,\"812\":1,\"862\":1,\"1444\":1}}],[\"<groupid>c3p0<\",{\"1\":{\"812\":1}}],[\"<groupid>ch\",{\"1\":{\"812\":1}}],[\"<groupid>cn\",{\"1\":{\"715\":3}}],[\"<groupid>commons\",{\"1\":{\"812\":1}}],[\"<groupid>com\",{\"1\":{\"708\":1,\"812\":3,\"844\":1,\"874\":2,\"1444\":1}}],[\"<groupid>log4j<\",{\"1\":{\"709\":1}}],[\"<groupid>org\",{\"1\":{\"687\":1,\"708\":1,\"709\":3,\"710\":3,\"715\":4,\"742\":1,\"812\":12,\"844\":5,\"862\":2,\"885\":2,\"1092\":1,\"1293\":1}}],[\"<groupid>redis\",{\"1\":{\"648\":1,\"812\":1}}],[\"<java\",{\"1\":{\"844\":1}}],[\"<junit\",{\"1\":{\"715\":1}}],[\"<hashb>\",{\"1\":{\"917\":1}}],[\"<hasha>\",{\"1\":{\"917\":1}}],[\"<h1>大家好\",{\"1\":{\"832\":1}}],[\"<head>\",{\"1\":{\"832\":1}}],[\"<html>\",{\"1\":{\"832\":1}}],[\"<root\",{\"1\":{\"821\":1}}],[\"<resultmap\",{\"1\":{\"793\":1,\"794\":1,\"795\":1,\"797\":1}}],[\"<relativepath>\",{\"1\":{\"715\":1}}],[\"<load\",{\"1\":{\"820\":1}}],[\"<welcome\",{\"1\":{\"820\":2}}],[\"<web\",{\"1\":{\"820\":1}}],[\"<where>\",{\"1\":{\"786\":1,\"801\":1}}],[\"<when\",{\"1\":{\"785\":2}}],[\"<bpmndi\",{\"1\":{\"865\":16}}],[\"<body\",{\"1\":{\"832\":1}}],[\"<bean\",{\"1\":{\"815\":3,\"818\":1,\"819\":1,\"952\":2,\"1219\":2,\"1396\":2}}],[\"<beans\",{\"1\":{\"815\":1,\"818\":1,\"819\":1}}],[\"<build>\",{\"1\":{\"812\":1,\"844\":2}}],[\"<br>\",{\"1\":{\"388\":3}}],[\"<usertask\",{\"1\":{\"865\":3}}],[\"<url\",{\"1\":{\"820\":1}}],[\"<url><\",{\"1\":{\"812\":1}}],[\"<update\",{\"1\":{\"724\":1,\"727\":1,\"755\":1,\"763\":1,\"786\":1,\"827\":1}}],[\"<a\",{\"1\":{\"832\":1}}],[\"<appender\",{\"1\":{\"821\":2}}],[\"<association\",{\"1\":{\"793\":1,\"794\":1,\"795\":2,\"797\":1}}],[\"<artifactid>flowable\",{\"1\":{\"862\":1}}],[\"<artifactid>\",{\"1\":{\"844\":1}}],[\"<artifactid>demo<\",{\"1\":{\"844\":1}}],[\"<artifactid>micrometer\",{\"1\":{\"885\":1}}],[\"<artifactid>maven\",{\"1\":{\"812\":1,\"844\":1}}],[\"<artifactid>mybatis\",{\"1\":{\"812\":1,\"1444\":1}}],[\"<artifactid>mybatis<\",{\"1\":{\"742\":1,\"812\":1}}],[\"<artifactid>mysql\",{\"1\":{\"735\":1,\"812\":1,\"862\":1,\"1444\":1}}],[\"<artifactid>lombok<\",{\"1\":{\"812\":1}}],[\"<artifactid>logback\",{\"1\":{\"812\":1}}],[\"<artifactid>log4j<\",{\"1\":{\"709\":1}}],[\"<artifactid>core<\",{\"1\":{\"874\":1}}],[\"<artifactid>commons\",{\"1\":{\"812\":1}}],[\"<artifactid>c3p0<\",{\"1\":{\"812\":1}}],[\"<artifactid>protostuff\",{\"1\":{\"812\":2}}],[\"<artifactid>parent<\",{\"1\":{\"715\":2}}],[\"<artifactid>javase<\",{\"1\":{\"874\":1}}],[\"<artifactid>javax\",{\"1\":{\"812\":1}}],[\"<artifactid>jackson\",{\"1\":{\"812\":1}}],[\"<artifactid>jstl<\",{\"1\":{\"812\":1}}],[\"<artifactid>junit<\",{\"1\":{\"715\":2,\"756\":1,\"812\":1}}],[\"<artifactid>jedis<\",{\"1\":{\"648\":1,\"812\":1}}],[\"<artifactid>a<\",{\"1\":{\"708\":1}}],[\"<artifactid>standard<\",{\"1\":{\"812\":1}}],[\"<artifactid>struts2\",{\"1\":{\"709\":1,\"710\":1}}],[\"<artifactid>ssm\",{\"1\":{\"812\":1}}],[\"<artifactid>sm1234\",{\"1\":{\"715\":1}}],[\"<artifactid>slf4j\",{\"1\":{\"708\":1,\"709\":1,\"715\":1}}],[\"<artifactid>spring\",{\"1\":{\"687\":1,\"709\":1,\"710\":2,\"715\":3,\"812\":8,\"844\":4,\"862\":1,\"885\":2,\"1092\":1,\"1293\":1}}],[\"<omgdi\",{\"1\":{\"865\":19}}],[\"<omgdc\",{\"1\":{\"865\":6}}],[\"<otherwise>\",{\"1\":{\"785\":1}}],[\"<optional>true<\",{\"1\":{\"708\":1,\"709\":1}}],[\"<clinit>\",{\"1\":{\"934\":3}}],[\"<code>interrupt<\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"<code>stop<\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"<code>threaddeath<\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"<commithash>\",{\"1\":{\"917\":1}}],[\"<constructor\",{\"1\":{\"1219\":6,\"1396\":6}}],[\"<conditionexpression\",{\"1\":{\"865\":6}}],[\"<configuration\",{\"1\":{\"821\":1}}],[\"<configuration>\",{\"1\":{\"743\":1,\"745\":1,\"812\":1,\"817\":1,\"844\":2}}],[\"<context\",{\"1\":{\"815\":1,\"818\":1,\"819\":1}}],[\"<collection\",{\"1\":{\"794\":1,\"795\":1,\"797\":1}}],[\"<cache\",{\"1\":{\"790\":1}}],[\"<choose>\",{\"1\":{\"785\":1}}],[\"<t\",{\"1\":{\"966\":2}}],[\"<t>\",{\"1\":{\"966\":2,\"1090\":1,\"1291\":1}}],[\"<t>就是类型参数\",{\"1\":{\"966\":2}}],[\"<target>1\",{\"1\":{\"844\":1}}],[\"<target>7<\",{\"1\":{\"812\":1}}],[\"<type>pom<\",{\"1\":{\"844\":1}}],[\"<typealias\",{\"1\":{\"768\":2}}],[\"<typealiases>\",{\"1\":{\"768\":2}}],[\"<title>news\",{\"1\":{\"832\":1}}],[\"<tx\",{\"1\":{\"818\":1}}],[\"<transactionmanager\",{\"1\":{\"743\":2,\"745\":1}}],[\"<trim\",{\"1\":{\"724\":3,\"727\":3,\"755\":1,\"763\":1,\"786\":1}}],[\"<mainclass>\",{\"1\":{\"844\":1}}],[\"<mainclass>com\",{\"1\":{\"844\":1}}],[\"<mappers>\",{\"1\":{\"745\":1,\"755\":1,\"763\":1,\"772\":3,\"782\":1}}],[\"<mapper\",{\"1\":{\"744\":1,\"745\":1,\"755\":3,\"762\":1,\"763\":4,\"772\":9,\"782\":2,\"790\":1,\"793\":1,\"827\":2}}],[\"<meta\",{\"1\":{\"832\":2}}],[\"<mvc\",{\"1\":{\"819\":2}}],[\"<modeler\",{\"1\":{\"865\":1}}],[\"<modelversion>\",{\"1\":{\"844\":1}}],[\"<modelversion>4\",{\"1\":{\"715\":2,\"812\":1,\"844\":1}}],[\"<module>\",{\"1\":{\"716\":3}}],[\"<modules>\",{\"1\":{\"716\":1}}],[\"<documentation>报销流程<\",{\"1\":{\"865\":1}}],[\"<definitions\",{\"1\":{\"865\":1}}],[\"<description>\",{\"1\":{\"844\":1}}],[\"<description>demo<\",{\"1\":{\"844\":1}}],[\"<delete\",{\"1\":{\"755\":1,\"763\":1}}],[\"<dependencies>\",{\"1\":{\"715\":2,\"812\":1,\"844\":3}}],[\"<dependencymanagement>\",{\"1\":{\"706\":1,\"715\":1,\"844\":2}}],[\"<dependency>\",{\"1\":{\"648\":1,\"687\":1,\"708\":2,\"709\":4,\"710\":2,\"715\":6,\"735\":1,\"742\":1,\"756\":1,\"812\":23,\"844\":3,\"862\":3,\"874\":2,\"885\":3,\"1092\":1,\"1293\":1,\"1444\":2}}],[\"<datasource\",{\"1\":{\"743\":2,\"745\":1,\"766\":1}}],[\"<id>repackage<\",{\"1\":{\"844\":1}}],[\"<id\",{\"1\":{\"793\":2,\"794\":3,\"795\":4,\"797\":2}}],[\"<init\",{\"1\":{\"820\":1}}],[\"<insert\",{\"1\":{\"755\":1,\"763\":1,\"827\":1,\"1176\":2,\"1361\":2}}],[\"<include\",{\"1\":{\"724\":1,\"782\":5}}],[\"<item\",{\"1\":{\"727\":1}}],[\"<if>\",{\"1\":{\"801\":1,\"958\":1}}],[\"<if\",{\"1\":{\"724\":1,\"727\":2,\"755\":6,\"763\":6,\"784\":1,\"786\":8,\"800\":2,\"958\":1}}],[\"<flowable\",{\"1\":{\"865\":2}}],[\"<finalname>ssm\",{\"1\":{\"812\":1}}],[\"<filename>\",{\"1\":{\"94\":1}}],[\"<file>\",{\"1\":{\"94\":1}}],[\"<foreach\",{\"1\":{\"724\":2,\"727\":3,\"787\":1}}],[\"<startevent\",{\"1\":{\"865\":1}}],[\"<string\",{\"1\":{\"620\":1}}],[\"<skip>true<\",{\"1\":{\"844\":1}}],[\"<source>1\",{\"1\":{\"844\":1}}],[\"<source>7<\",{\"1\":{\"812\":1}}],[\"<scope>import<\",{\"1\":{\"844\":1}}],[\"<scope>provided<\",{\"1\":{\"812\":1}}],[\"<scope>runtime<\",{\"1\":{\"812\":1,\"1444\":1}}],[\"<scope>test<\",{\"1\":{\"715\":2,\"844\":1}}],[\"<sql\",{\"1\":{\"782\":3}}],[\"<sequenceflow\",{\"1\":{\"865\":8}}],[\"<servlet\",{\"1\":{\"820\":4}}],[\"<servlet>\",{\"1\":{\"820\":1}}],[\"<setting\",{\"1\":{\"767\":1,\"790\":2,\"817\":3}}],[\"<settings>\",{\"1\":{\"767\":1,\"790\":1,\"817\":1}}],[\"<select|update|delete|insert>节点的封装\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"<select\",{\"1\":{\"744\":1,\"755\":3,\"759\":1,\"763\":4,\"779\":7,\"780\":2,\"782\":4,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"793\":2,\"794\":1,\"795\":1,\"827\":3,\"958\":2,\"1175\":1,\"1360\":1}}],[\"<slf4j\",{\"1\":{\"715\":1}}],[\"<spring\",{\"1\":{\"715\":1,\"812\":1,\"844\":1}}],[\"<exclusivegateway\",{\"1\":{\"865\":1}}],[\"<exclusion>\",{\"1\":{\"710\":2}}],[\"<exclusions>\",{\"1\":{\"710\":3}}],[\"<extensionelements>\",{\"1\":{\"865\":3}}],[\"<execution>\",{\"1\":{\"844\":1}}],[\"<executions>\",{\"1\":{\"844\":1}}],[\"<endevent\",{\"1\":{\"865\":1}}],[\"<encoding>utf\",{\"1\":{\"844\":1}}],[\"<encoder>\",{\"1\":{\"821\":1}}],[\"<environment\",{\"1\":{\"743\":2,\"745\":1}}],[\"<environments\",{\"1\":{\"743\":1,\"745\":1}}],[\"<eclusion>\",{\"1\":{\"710\":1}}],[\"<version>6\",{\"1\":{\"862\":1}}],[\"<version>\",{\"1\":{\"844\":1}}],[\"<version>5\",{\"1\":{\"735\":1,\"812\":1,\"862\":1}}],[\"<version>$\",{\"1\":{\"715\":6,\"812\":8,\"844\":2}}],[\"<version>4\",{\"1\":{\"709\":1,\"710\":1,\"756\":1,\"812\":1}}],[\"<version>2\",{\"1\":{\"709\":1,\"710\":1,\"812\":2}}],[\"<version>0\",{\"1\":{\"708\":1,\"715\":3,\"812\":1,\"844\":1}}],[\"<version>1\",{\"1\":{\"708\":1,\"709\":2,\"812\":8}}],[\"<version>3\",{\"1\":{\"648\":1,\"742\":1,\"812\":3,\"844\":1,\"874\":2,\"1444\":1}}],[\"<plugin>\",{\"1\":{\"812\":1,\"844\":2}}],[\"<plugin\",{\"1\":{\"770\":1,\"958\":1}}],[\"<plugins>\",{\"1\":{\"770\":1,\"812\":1,\"844\":2,\"958\":1}}],[\"<pattern>\",{\"1\":{\"821\":1}}],[\"<param\",{\"1\":{\"820\":2}}],[\"<parent>\",{\"1\":{\"715\":1}}],[\"<packaging>war<\",{\"1\":{\"812\":1}}],[\"<packaging>pom<\",{\"1\":{\"715\":1}}],[\"<package\",{\"1\":{\"768\":1,\"782\":1}}],[\"<properties\",{\"1\":{\"766\":1}}],[\"<properties>\",{\"1\":{\"715\":1,\"743\":1,\"812\":1,\"844\":2}}],[\"<property\",{\"1\":{\"743\":12,\"745\":4,\"766\":6,\"770\":1,\"815\":15,\"818\":1,\"819\":4,\"958\":1}}],[\"<project>\",{\"1\":{\"844\":1}}],[\"<project\",{\"1\":{\"715\":2,\"812\":2,\"844\":3}}],[\"<process\",{\"1\":{\"581\":1,\"865\":1}}],[\"<p>checks\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"<p>\",{\"1\":{\"688\":1,\"689\":1}}],[\"<>\",{\"1\":{\"527\":1,\"1192\":1,\"1375\":1}}],[\"<==\",{\"1\":{\"725\":1,\"789\":6,\"790\":1}}],[\"<=\",{\"1\":{\"352\":1,\"364\":2,\"377\":1,\"388\":1,\"487\":1,\"488\":1,\"800\":3,\"801\":3,\"830\":2,\"865\":1,\"1085\":1,\"1286\":1}}],[\"<<\",{\"1\":{\"337\":1,\"388\":7,\"948\":2}}],[\"<\",{\"0\":{\"799\":1},\"1\":{\"266\":4,\"285\":9,\"286\":4,\"288\":1,\"289\":1,\"337\":2,\"352\":4,\"353\":1,\"360\":4,\"364\":2,\"377\":2,\"388\":4,\"487\":2,\"488\":2,\"561\":2,\"567\":2,\"604\":1,\"648\":1,\"687\":1,\"708\":4,\"709\":5,\"710\":3,\"715\":28,\"716\":1,\"724\":6,\"727\":9,\"735\":1,\"742\":1,\"743\":23,\"744\":6,\"745\":12,\"755\":24,\"756\":1,\"759\":1,\"763\":24,\"766\":2,\"767\":1,\"768\":4,\"770\":3,\"772\":6,\"779\":7,\"780\":2,\"782\":11,\"784\":2,\"785\":6,\"786\":13,\"787\":2,\"790\":4,\"793\":9,\"794\":9,\"795\":5,\"797\":4,\"800\":2,\"801\":5,\"812\":56,\"815\":21,\"817\":8,\"818\":7,\"819\":10,\"820\":10,\"821\":6,\"827\":16,\"832\":7,\"844\":20,\"862\":5,\"865\":32,\"874\":3,\"885\":3,\"922\":1,\"928\":1,\"932\":2,\"952\":1,\"958\":5,\"966\":13,\"1008\":1,\"1085\":1,\"1092\":1,\"1104\":1,\"1105\":1,\"1175\":1,\"1176\":1,\"1219\":2,\"1286\":1,\"1293\":1,\"1302\":1,\"1303\":1,\"1360\":1,\"1361\":1,\"1396\":2,\"1444\":2}}],[\"次\",{\"1\":{\"266\":1}}],[\"次数少\",{\"1\":{\"270\":1}}],[\"次数\",{\"1\":{\"266\":2}}],[\"定时去清理过期的缓存\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"定时或定量回写到磁盘\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"定会有很大的提高\",{\"1\":{\"948\":1}}],[\"定期监控查询性能并进行优化\",{\"1\":{\"1002\":1}}],[\"定期压测\",{\"1\":{\"942\":1}}],[\"定期执行\",{\"1\":{\"511\":1}}],[\"定期维护\",{\"1\":{\"511\":1}}],[\"定位数据越快越精确\",{\"1\":{\"266\":1}}],[\"定义状态码枚举\",{\"1\":{\"1431\":1}}],[\"定义完返回结构后\",{\"1\":{\"1431\":1}}],[\"定义api响应结构体\",{\"1\":{\"1431\":1}}],[\"定义对象间的一对多的关系\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"定义对象的属性名\",{\"1\":{\"797\":1}}],[\"定义工厂方法\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"定义了ioc的基本功能\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"定义了文档的结构和字段类型\",{\"1\":{\"1002\":1}}],[\"定义了用于项目构建的插件列表\",{\"1\":{\"844\":1}}],[\"定义资源的加载和解析\",{\"1\":{\"950\":1}}],[\"定义文件\",{\"1\":{\"950\":1}}],[\"定义流程文件\",{\"0\":{\"865\":1}}],[\"定义项目版本\",{\"1\":{\"844\":1}}],[\"定义实际项目模块的名称\",{\"1\":{\"844\":1}}],[\"定义实际项目中的一个模块\",{\"1\":{\"705\":1}}],[\"定义好的视图解析器对该对象解析\",{\"1\":{\"832\":1}}],[\"定义pojo中的单个对象的\",{\"1\":{\"797\":1}}],[\"定义子对象集合映射\",{\"1\":{\"794\":1}}],[\"定义接口\",{\"1\":{\"784\":1,\"785\":1}}],[\"定义commonsql\",{\"1\":{\"782\":1}}],[\"定义该项目的打包方式\",{\"1\":{\"705\":1}}],[\"定义当前\",{\"1\":{\"844\":1}}],[\"定义当前项目的当前版本\",{\"1\":{\"705\":1}}],[\"定义当前maven项目隶属项目\",{\"1\":{\"705\":1}}],[\"定义一个切面类\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"定义一个切点\",{\"1\":{\"689\":1,\"944\":1}}],[\"定义一个注解\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"定义一个接口\",{\"1\":{\"772\":1}}],[\"定义一个属性\",{\"1\":{\"688\":2}}],[\"定义字段的数据类型\",{\"1\":{\"429\":1}}],[\"定义索引中的字段的名称\",{\"1\":{\"429\":1}}],[\"定义只需要知道b\",{\"1\":{\"266\":1}}],[\"定义错误码\",{\"0\":{\"186\":1}}],[\"定义基本数据结构\",{\"1\":{\"182\":1}}],[\"定义负载均衡设备的ip及设备状态\",{\"1\":{\"106\":1}}],[\"定义本虚拟主机的访问日志\",{\"1\":{\"106\":2}}],[\"定义\",{\"1\":{\"78\":1,\"266\":1,\"429\":1,\"438\":1,\"950\":1,\"1103\":1,\"1301\":1}}],[\"索引中的所有段都会被搜索\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"索引或者删除请求\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"索引文档的过程\",{\"0\":{\"1071\":1,\"1275\":1}}],[\"索引文档号\",{\"1\":{\"440\":1}}],[\"索引数据大小\",{\"0\":{\"1068\":1,\"1272\":1}}],[\"索引被分成多个分片\",{\"1\":{\"1012\":1}}],[\"索引就像是我们的图书馆\",{\"1\":{\"1004\":1}}],[\"索引就像是数据库中的表\",{\"1\":{\"998\":1}}],[\"索引上的所有键值对\",{\"1\":{\"625\":1}}],[\"索引半径查询\",{\"1\":{\"601\":1}}],[\"索引固然可以提高相应的\",{\"0\":{\"537\":1}}],[\"索引并不是越多越好\",{\"0\":{\"537\":1}}],[\"索引并非银弹\",{\"1\":{\"500\":1}}],[\"索引篇\",{\"1\":{\"528\":1}}],[\"索引技术等方案\",{\"1\":{\"520\":1}}],[\"索引碎片化的理解\",{\"0\":{\"511\":1}}],[\"索引页的碎片化意味着索引中的数据不再按照顺序存储\",{\"1\":{\"508\":1}}],[\"索引失效\",{\"1\":{\"508\":1}}],[\"索引本身占用存储空间\",{\"1\":{\"508\":1}}],[\"索引本身也很大\",{\"1\":{\"271\":1}}],[\"索引主要是为了优化查询性能而设计的\",{\"1\":{\"508\":1}}],[\"索引包含所需列\",{\"1\":{\"504\":1}}],[\"索引不仅占用存储空间\",{\"1\":{\"502\":1}}],[\"索引列包含\",{\"1\":{\"501\":1}}],[\"索引列参与计算\",{\"1\":{\"501\":1}}],[\"索引将不会生效\",{\"1\":{\"501\":1}}],[\"索引什么时候会失效\",{\"0\":{\"501\":1}}],[\"索引可能会成为锁竞争的瓶颈\",{\"1\":{\"508\":1}}],[\"索引可能不会带来太大的性能提升\",{\"1\":{\"502\":1}}],[\"索引可能导致磁盘的随机访问\",{\"1\":{\"499\":1}}],[\"索引可能是一个好的选择\",{\"1\":{\"499\":1}}],[\"索引在插入和删除操作方面相对简单\",{\"1\":{\"499\":1}}],[\"索引和分片的解释非常清晰\",{\"1\":{\"1004\":1}}],[\"索引和分片\",{\"1\":{\"1004\":1}}],[\"索引和\",{\"0\":{\"499\":1}}],[\"索引才会被使用\",{\"1\":{\"495\":1}}],[\"索引是由多个段组成\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"索引是如何创建和管理的呢\",{\"1\":{\"1004\":1}}],[\"索引是放在磁盘的\",{\"1\":{\"500\":1}}],[\"索引是建立在原数据上的数据结构\",{\"1\":{\"500\":1}}],[\"索引是否越多越好\",{\"0\":{\"500\":1}}],[\"索引是一个文件\",{\"1\":{\"494\":1}}],[\"索引是一种数据结构\",{\"1\":{\"494\":1}}],[\"索引是什么\",{\"0\":{\"494\":1}}],[\"索引题\",{\"1\":{\"493\":1}}],[\"索引结构密切有关\",{\"1\":{\"440\":1}}],[\"索引系统还可以记录除此之外的更多信息\",{\"1\":{\"425\":1}}],[\"索引副本\",{\"1\":{\"422\":1}}],[\"索引\",{\"0\":{\"465\":1},\"1\":{\"418\":1,\"495\":4,\"624\":1,\"1002\":1},\"2\":{\"513\":1}}],[\"索引构建\",{\"1\":{\"394\":1}}],[\"索引效率比整型低\",{\"1\":{\"382\":1}}],[\"索引位置的节点\",{\"1\":{\"286\":1}}],[\"索引位置\",{\"1\":{\"286\":1}}],[\"索引检索需要磁盘i\",{\"1\":{\"274\":1}}],[\"索引一般以文件形式存储在磁盘上\",{\"1\":{\"274\":1}}],[\"索引查找过程中就要产生磁盘i\",{\"1\":{\"271\":1}}],[\"索引的维护需要额外的计算和存储资源\",{\"1\":{\"508\":1}}],[\"索引的维护成本\",{\"1\":{\"502\":1}}],[\"索引的存储是随机的\",{\"1\":{\"499\":1}}],[\"索引的概念下降到等同于数据库表的级别\",{\"1\":{\"418\":1}}],[\"索引的结构组织要尽量减少查找过程中磁盘i\",{\"1\":{\"271\":1}}],[\"索引的原理其实是不断的缩小查找范围\",{\"1\":{\"266\":1}}],[\"索引的效率依赖与磁盘\",{\"1\":{\"266\":1}}],[\"索引值和具体data都在每个节点里\",{\"1\":{\"265\":1}}],[\"了的进程跟其他进程并没有区别\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"了\",{\"1\":{\"266\":1,\"529\":1,\"958\":1,\"1212\":1,\"1389\":1,\"1444\":1}}],[\"了解更多实践应用的案例\",{\"1\":{\"1018\":1}}],[\"了解吗\",{\"1\":{\"956\":1}}],[\"了解自定义初始化和销毁方法的具体应用场景\",{\"1\":{\"952\":1}}],[\"了解\",{\"1\":{\"952\":3}}],[\"了解内容\",{\"1\":{\"705\":1}}],[\"了解一些对你排查问题至关重要\",{\"1\":{\"602\":1}}],[\"了解了什么是\",{\"1\":{\"429\":1}}],[\"了解大数据那是我们\",{\"1\":{\"397\":1}}],[\"了解编程指南知识星球\",{\"1\":{\"210\":1}}],[\"了解详情\",{\"1\":{\"28\":1}}],[\"迎合\",{\"1\":{\"266\":2}}],[\"红黑树是一种常用的平衡二叉搜索树\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"红黑树这类平衡二叉树从设计上无法\",{\"1\":{\"266\":1}}],[\"红黑树等对list实现的影响\",{\"1\":{\"946\":1}}],[\"红黑树等数据结构也可以用来实现索引\",{\"1\":{\"271\":1}}],[\"红黑树等\",{\"1\":{\"266\":1}}],[\"像我们常用的\",{\"1\":{\"1443\":1}}],[\"像在链表的删除操作\",{\"1\":{\"1018\":1}}],[\"像乐观锁\",{\"1\":{\"1018\":1}}],[\"像spring的\",{\"1\":{\"944\":1}}],[\"像jdk自带的jconsole\",{\"1\":{\"942\":1}}],[\"像heap大小\",{\"1\":{\"942\":1}}],[\"像是类名\",{\"1\":{\"934\":1}}],[\"像接口方法\",{\"1\":{\"831\":1}}],[\"像这样\",{\"1\":{\"602\":1}}],[\"像\",{\"1\":{\"266\":1,\"645\":1,\"1018\":3}}],[\"像社会\",{\"1\":{\"225\":1}}],[\"内嵌了\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"内测版\",{\"1\":{\"703\":1}}],[\"内行\",{\"1\":{\"698\":1}}],[\"内部锁扮演了互斥锁\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"内部也使用同一把锁\",{\"1\":{\"988\":1}}],[\"内部使用锁分段技术实现线程安全\",{\"1\":{\"988\":1}}],[\"内部使用锁机制同步访问\",{\"1\":{\"988\":1}}],[\"内部的\",{\"1\":{\"988\":1}}],[\"内部的方法基本相同\",{\"1\":{\"922\":1}}],[\"内部实现对外部是透明的\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"内部实现很多没优化和冗余\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"内部实现更加紧凑高效\",{\"1\":{\"922\":1}}],[\"内部实现了动态扩展机制\",{\"1\":{\"620\":1}}],[\"内部维护着一个双向链表\",{\"1\":{\"922\":1}}],[\"内部节点\",{\"1\":{\"269\":1}}],[\"内置的序列化方式无论从速度还是压缩比都不尽如人意\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"内置的\",{\"1\":{\"703\":1,\"704\":1}}],[\"内置的死锁检测器会在事务等待资源时自动检测死锁\",{\"1\":{\"580\":1}}],[\"内置了\",{\"1\":{\"601\":1}}],[\"内存使用率不高\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"内存使用量只与你配置的精确度相关\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"内存泄漏是指不再被使用的对象或者变量一直被占据在内存中\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"内存分别\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"内存分配是jvm内存模型中非常重要的一部分\",{\"1\":{\"930\":1}}],[\"内存分配\",{\"1\":{\"930\":1}}],[\"内存和带宽\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"内存中的缓冲将被清除\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"内存中的数据结构存储系统\",{\"1\":{\"601\":1}}],[\"内存读写速度也是远高于磁盘的\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"内存映射等\",{\"1\":{\"1020\":1}}],[\"内存位置\",{\"1\":{\"1018\":1}}],[\"内存变化\",{\"1\":{\"942\":1}}],[\"内存模型\",{\"1\":{\"930\":1}}],[\"内存语义实现\",{\"1\":{\"924\":1}}],[\"内存语义\",{\"1\":{\"924\":1}}],[\"内存屏障实现\",{\"1\":{\"924\":1}}],[\"内存屏障可以分为读屏障\",{\"1\":{\"924\":1}}],[\"内存屏障\",{\"1\":{\"924\":1}}],[\"内存的算法\",{\"1\":{\"636\":1}}],[\"内存回收机制\",{\"1\":{\"636\":1}}],[\"内存回收和对象的空转时长涉及到\",{\"1\":{\"636\":1}}],[\"内存回收\",{\"1\":{\"635\":2}}],[\"内存操作\",{\"1\":{\"594\":1}}],[\"内存\",{\"1\":{\"517\":1,\"942\":1,\"1064\":1,\"1270\":1}}],[\"内存能加载更多的数据\",{\"1\":{\"516\":1}}],[\"内存不够用\",{\"1\":{\"266\":1}}],[\"内产生的\",{\"1\":{\"387\":1}}],[\"内容被写入一个新段\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"内容管理系统和商业应用等\",{\"1\":{\"1000\":1}}],[\"内容很详细\",{\"1\":{\"988\":1}}],[\"内容\",{\"1\":{\"29\":1,\"744\":1,\"755\":1,\"763\":1,\"1186\":1,\"1369\":1}}],[\"先有鸡还是先有蛋\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"先有servlet\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"先恢复快照方式保存的文件\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"先得到key的hashcode\",{\"1\":{\"1120\":1,\"1315\":1}}],[\"先测试该进程本次申请的资源数\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"先导入切面需要的依赖包\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"先查后取的过程支持用\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"先写数据库\",{\"1\":{\"1050\":2,\"1259\":2}}],[\"先写到高速缓存\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"先获取分布式锁\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"先获取该分布式锁\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"先获取该记录的x锁\",{\"1\":{\"555\":1}}],[\"先获取该记录的s锁\",{\"1\":{\"555\":1}}],[\"先淘汰缓存之前\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"先淘汰缓存\",{\"1\":{\"1050\":2,\"1259\":2}}],[\"先删除\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"先进后出的原则\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"先进先出\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"先进入lib目录中再安装你下载的那个文件\",{\"1\":{\"898\":1}}],[\"先乐观锁重试几次\",{\"1\":{\"1018\":1}}],[\"先假设可以获取锁\",{\"1\":{\"1018\":1}}],[\"先假设20个随机整数的值是\",{\"1\":{\"359\":1}}],[\"先回去吧\",{\"1\":{\"1010\":1}}],[\"先计算键的hash值得到数组下标\",{\"1\":{\"948\":1}}],[\"先看代码\",{\"1\":{\"829\":1}}],[\"先在spring文件夹里新建spring\",{\"1\":{\"815\":1}}],[\"先直接上个终极版\",{\"1\":{\"724\":1}}],[\"先会扩展空间\",{\"1\":{\"620\":1}}],[\"先\",{\"0\":{\"543\":1}}],[\"先修改配置文件\",{\"1\":{\"406\":1}}],[\"先取a0再取a1和先取a0再取d3的时间消耗是一样的\",{\"1\":{\"273\":1}}],[\"先找首字母缩小范围\",{\"1\":{\"266\":1}}],[\"先来看看为什么会出现b\",{\"1\":{\"266\":1}}],[\"先通过个人实力和面试技巧拿到一个心仪的\",{\"1\":{\"100\":1}}],[\"任意时刻的查询结果都是一致的\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"任意一个超过阈值都会把follower剔除出isr\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"任意参数名可以接收\",{\"1\":{\"763\":1}}],[\"任何文件的变动都需要对此服务程序重新编译\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"任何一个等待锁的线程都有机会获得锁\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"任何一个关键字出现且只出现在一个结点中\",{\"1\":{\"265\":1}}],[\"任何地方都不要使用\",{\"0\":{\"540\":1}}],[\"任然有id重复的风险\",{\"1\":{\"387\":1}}],[\"任务\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"任务队列用于存储等待执行的任务\",{\"1\":{\"926\":1}}],[\"任务队列\",{\"1\":{\"926\":1}}],[\"任务管理器\",{\"1\":{\"77\":1}}],[\"任务列表\",{\"0\":{\"36\":1}}],[\"树化过程\",{\"1\":{\"948\":1}}],[\"树就可以了\",{\"1\":{\"499\":1}}],[\"树索引可能更适合\",{\"1\":{\"499\":1}}],[\"树索引可能更为稳定\",{\"1\":{\"499\":1}}],[\"树索引则更为合适\",{\"1\":{\"499\":1}}],[\"树索引区别是什么\",{\"0\":{\"499\":1}}],[\"树及其基本操作\",{\"0\":{\"316\":1}}],[\"树和森林与二叉树的转换\",{\"0\":{\"313\":1}}],[\"树和森林\",{\"0\":{\"311\":1}}],[\"树和b+树的区别\",{\"0\":{\"270\":1}}],[\"树仅有\",{\"1\":{\"270\":1}}],[\"树磁盘\",{\"1\":{\"270\":1}}],[\"树节点内部每个\",{\"1\":{\"270\":1}}],[\"树每个节点\",{\"1\":{\"270\":1}}],[\"树每次将范围分割为多个区间\",{\"1\":{\"266\":1}}],[\"树只需要一次磁盘\",{\"1\":{\"270\":1}}],[\"树查询时间复杂度不固定\",{\"1\":{\"270\":1}}],[\"树以每个节点为一次磁盘\",{\"1\":{\"267\":1}}],[\"树的定义以及树的存储结构\",{\"0\":{\"312\":1}}],[\"树的查询最好时间复杂度是\",{\"1\":{\"270\":1}}],[\"树的查找\",{\"0\":{\"267\":1},\"1\":{\"267\":1}}],[\"树的每个节点大小一般是相同的\",{\"1\":{\"269\":1}}],[\"树的每个节点是\",{\"1\":{\"266\":1}}],[\"树的不同之处在于\",{\"1\":{\"269\":1}}],[\"树的变体\",{\"1\":{\"269\":1}}],[\"树的\",{\"1\":{\"267\":1}}],[\"树的高度\",{\"1\":{\"266\":1}}],[\"树的高度在\",{\"1\":{\"263\":1,\"266\":1}}],[\"树的设计\",{\"1\":{\"266\":1}}],[\"树这类数据结构\",{\"1\":{\"266\":1}}],[\"树是专门为外部存储器设计的\",{\"1\":{\"266\":1}}],[\"树是一类树\",{\"1\":{\"266\":1}}],[\"树允许每个节点有更多的子节点即可\",{\"1\":{\"266\":1}}],[\"树允许每个节点有更多的子节点\",{\"1\":{\"266\":1}}],[\"树等\",{\"1\":{\"266\":1}}],[\"树\",{\"0\":{\"268\":1,\"503\":1},\"1\":{\"266\":4,\"270\":3}}],[\"树有如下特点\",{\"1\":{\"265\":1}}],[\"正式开始使用\",{\"1\":{\"1439\":1}}],[\"正式发行版\",{\"1\":{\"703\":1}}],[\"正因为如此\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"正因为叶子节点保存了完整的数据以及有指针作为连接\",{\"1\":{\"264\":1}}],[\"正是通过分数来为集合中的成员进行从小到大的排序\",{\"1\":{\"607\":1}}],[\"正确使用锁类型对于优化数据库性能\",{\"1\":{\"567\":1}}],[\"正确使用才能发挥奇效\",{\"1\":{\"500\":1}}],[\"正则表达式\",{\"1\":{\"411\":1}}],[\"正数是0\",{\"1\":{\"388\":1}}],[\"正整数\",{\"1\":{\"374\":1}}],[\"正例\",{\"1\":{\"194\":1,\"195\":1,\"196\":1,\"198\":1,\"201\":1,\"507\":1}}],[\"甚至超过了整数自身空间消耗\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"甚至击垮数据库系统\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"甚至也会影响服务的可靠性和可用性\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"甚至有很多专业薅空投羊毛的专业玩家\",{\"1\":{\"481\":1}}],[\"甚至最好的情况是o\",{\"1\":{\"270\":1}}],[\"甚至可以划分为更多区间\",{\"1\":{\"263\":1}}],[\"甚至在网上买一个盗版项目源码的价格都要比这个高\",{\"1\":{\"212\":1}}],[\"两大类\",{\"1\":{\"1112\":1,\"1307\":1}}],[\"两种类型的队列\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"两种状态笼统的称为\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"两种方案\",{\"1\":{\"960\":1}}],[\"两种方式\",{\"1\":{\"506\":1}}],[\"两者都存在一个类似于\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"两者都能很好地在自己的适用场景发挥作用\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"两者的底层实现相似\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"两者各有优劣\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"两者也可以结合使用\",{\"1\":{\"1018\":1}}],[\"两者主要区别在于对并发冲突的态度\",{\"1\":{\"1018\":1}}],[\"两者之间形成依赖循环\",{\"1\":{\"954\":1}}],[\"两者相比\",{\"1\":{\"922\":1}}],[\"两者不同之处在于\",{\"1\":{\"348\":1}}],[\"两端不一致\",{\"1\":{\"759\":1}}],[\"两个锁的申请必须发生交叉\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"两个很好的疑问\",{\"1\":{\"966\":1}}],[\"两个提交应用到当前分支\",{\"1\":{\"917\":1}}],[\"两个\",{\"1\":{\"828\":1}}],[\"两个条件都要成立\",{\"1\":{\"786\":2}}],[\"两个自媒体账号属于同一个人\",{\"1\":{\"656\":1}}],[\"两个结构组成\",{\"1\":{\"629\":1}}],[\"两个结构定义\",{\"1\":{\"628\":1}}],[\"两个哈希表\",{\"1\":{\"625\":1}}],[\"两个方法\",{\"1\":{\"511\":1}}],[\"两个操作\",{\"1\":{\"288\":1}}],[\"两个状态\",{\"1\":{\"288\":1}}],[\"两次请求\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"两次读同一个范围的时候\",{\"1\":{\"575\":1}}],[\"两次存取的数据的\",{\"1\":{\"273\":1}}],[\"两次不行吗\",{\"1\":{\"104\":1}}],[\"两部分\",{\"1\":{\"263\":1}}],[\"区分选择不同的锁\",{\"1\":{\"567\":1}}],[\"区域的形状可以是任意多边形\",{\"1\":{\"454\":1}}],[\"区间访问性\",{\"1\":{\"269\":1}}],[\"区间越多\",{\"1\":{\"266\":1}}],[\"区间更多的情况下\",{\"1\":{\"263\":1,\"266\":1}}],[\"区别仅仅是选择leader之后的操作有所不同\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"区别如下\",{\"1\":{\"988\":1}}],[\"区别是什么呢\",{\"1\":{\"916\":1}}],[\"区别的是\",{\"1\":{\"589\":1}}],[\"区别\",{\"1\":{\"264\":1,\"541\":1,\"1049\":1,\"1085\":1,\"1129\":1,\"1258\":1,\"1286\":1,\"1322\":1}}],[\"区块链等领域\",{\"1\":{\"223\":1}}],[\"区块链\",{\"0\":{\"68\":1},\"2\":{\"69\":1,\"479\":1,\"480\":1,\"489\":1,\"490\":1}}],[\"百万级别的数据量\",{\"1\":{\"263\":1}}],[\"百度百科\",{\"0\":{\"332\":1},\"1\":{\"154\":1,\"332\":1,\"348\":1,\"364\":2,\"371\":1}}],[\"百度收录\",{\"1\":{\"4\":1}}],[\"层接口\",{\"1\":{\"815\":1}}],[\"层的数量越多\",{\"1\":{\"628\":1}}],[\"层\",{\"1\":{\"628\":1,\"819\":1,\"829\":1,\"831\":2,\"1444\":1}}],[\"层数低\",{\"1\":{\"266\":1}}],[\"层就可满足\",{\"1\":{\"263\":1}}],[\"层左右\",{\"1\":{\"263\":1,\"266\":1}}],[\"平时做的分布式部署\",{\"1\":{\"387\":1}}],[\"平均均为o\",{\"1\":{\"364\":1}}],[\"平均每天\",{\"1\":{\"212\":1,\"1429\":1}}],[\"平衡二叉树是每次将范围分割为两个区间\",{\"1\":{\"266\":1}}],[\"平衡二叉树是通过旋转来保持平衡的\",{\"1\":{\"266\":1}}],[\"平衡\",{\"1\":{\"263\":1}}],[\"创建成功时watcher\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"创建功能方法\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"创建两个模块分别为\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"创建项目\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"创建大量的整数类型redisobject存在内存开销\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"创建会话对象\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"创建statement等复杂的过程\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"创建sqlsessionfactory\",{\"1\":{\"751\":1}}],[\"创建1个计数器\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"创建配置类把拦截器添加到拦截器链中\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"创建容器\",{\"1\":{\"1063\":1,\"1269\":1}}],[\"创建倒排索引\",{\"1\":{\"1012\":2}}],[\"创建子进程\",{\"1\":{\"962\":1}}],[\"创建连接\",{\"1\":{\"958\":1,\"1172\":1,\"1357\":1}}],[\"创建新键值对\",{\"1\":{\"948\":1}}],[\"创建实例\",{\"1\":{\"934\":1}}],[\"创建一个配置类将功能方法类添加到\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"创建一个对象\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"创建一个服务器通道\",{\"1\":{\"1020\":1}}],[\"创建一个选择器\",{\"1\":{\"1020\":1}}],[\"创建一个消费者\",{\"1\":{\"992\":1}}],[\"创建一个生产者\",{\"1\":{\"992\":1}}],[\"创建一个新的\",{\"1\":{\"982\":1}}],[\"创建一个\",{\"1\":{\"982\":1}}],[\"创建一个仓库\",{\"1\":{\"913\":1}}],[\"创建一个我们的博客仓库\",{\"1\":{\"913\":1}}],[\"创建一万个字符串对象\",{\"1\":{\"635\":1}}],[\"创建接口\",{\"0\":{\"849\":1}}],[\"创建接口文档\",{\"1\":{\"182\":1}}],[\"创建order表\",{\"1\":{\"792\":1}}],[\"创建usermapper测试用例\",{\"1\":{\"763\":1}}],[\"创建usermapper\",{\"1\":{\"763\":1}}],[\"创建usermapper接口\",{\"1\":{\"763\":1}}],[\"创建userdaoimpl\",{\"0\":{\"754\":1}}],[\"创建userdao\",{\"0\":{\"753\":1}}],[\"创建表\",{\"1\":{\"736\":1}}],[\"创建数据库\",{\"1\":{\"736\":1}}],[\"创建web项目时\",{\"1\":{\"704\":1}}],[\"创建了一个包含整数值\",{\"1\":{\"635\":1}}],[\"创建锁表\",{\"1\":{\"577\":1}}],[\"创建联合全文索引\",{\"1\":{\"507\":1}}],[\"创建索引就像是在图书馆里开辟一个新的区域\",{\"1\":{\"1004\":1}}],[\"创建索引\",{\"0\":{\"466\":1},\"1\":{\"509\":1}}],[\"创建多长的bit数组比较合适\",{\"1\":{\"339\":1}}],[\"创建\",{\"0\":{\"838\":1,\"839\":1},\"1\":{\"251\":1,\"507\":1,\"958\":1,\"1232\":1,\"1407\":1}}],[\"推迟其实例化时间\",{\"1\":{\"954\":1}}],[\"推断字段的类型\",{\"1\":{\"439\":1}}],[\"推荐一个\",{\"1\":{\"1444\":1}}],[\"推荐一个maven坐标查询网站\",{\"1\":{\"705\":1}}],[\"推荐一篇非常不错的文章\",{\"1\":{\"1184\":1,\"1367\":1}}],[\"推荐\",{\"1\":{\"779\":1}}],[\"推荐阅读\",{\"0\":{\"1053\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1194\":1,\"1207\":1},\"1\":{\"716\":1}}],[\"推荐第二种\",{\"1\":{\"438\":1}}],[\"推荐使用\",{\"1\":{\"251\":1,\"386\":1,\"922\":1}}],[\"推进\",{\"1\":{\"288\":1}}],[\"推流\",{\"1\":{\"146\":1}}],[\"吗\",{\"1\":{\"249\":2,\"844\":1,\"932\":1}}],[\"测试线程是否真的已经中断\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"测试与监控\",{\"1\":{\"950\":1}}],[\"测试访问\",{\"1\":{\"887\":1}}],[\"测试结果\",{\"1\":{\"830\":1}}],[\"测试方法都验证过\",{\"1\":{\"828\":1}}],[\"测试文件\",{\"1\":{\"828\":1}}],[\"测试输出\",{\"1\":{\"779\":1}}],[\"测试和生产环境需要有不同的配置\",{\"1\":{\"771\":1}}],[\"测试字段status\",{\"1\":{\"726\":1}}],[\"测试字段id\",{\"1\":{\"726\":1}}],[\"测试字段\",{\"1\":{\"726\":1}}],[\"测试的classpath都有效\",{\"1\":{\"706\":1}}],[\"测试依赖范围\",{\"1\":{\"706\":1}}],[\"测试完成了\",{\"1\":{\"591\":1}}],[\"测试分词器\",{\"1\":{\"437\":1}}],[\"测试运行\",{\"1\":{\"289\":1}}],[\"测试一下业务层代码\",{\"1\":{\"830\":1}}],[\"测试一下\",{\"1\":{\"288\":1}}],[\"测试响应\",{\"1\":{\"249\":1}}],[\"测试\",{\"0\":{\"248\":1,\"690\":1,\"866\":1},\"1\":{\"388\":1,\"597\":1,\"698\":1,\"706\":2,\"711\":2,\"713\":1,\"784\":1,\"785\":1,\"786\":2,\"787\":1,\"789\":3,\"790\":1,\"793\":2,\"794\":1,\"795\":1,\"831\":1,\"888\":1,\"1439\":3}}],[\"模板方法模式\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"模拟类似于token这种需要设置过期时间的场景\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"模式下产生的循环依赖问题\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"模式\",{\"1\":{\"950\":1}}],[\"模式的数据备份\",{\"1\":{\"592\":1}}],[\"模式时候\",{\"1\":{\"431\":1}}],[\"模型的版本\",{\"1\":{\"844\":1}}],[\"模型\",{\"1\":{\"247\":1,\"251\":1,\"1020\":2}}],[\"模块之间和对象之间的耦合度\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"模块之间低耦合\",{\"1\":{\"950\":1}}],[\"模块负责\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"模块间采用接口隔离\",{\"1\":{\"954\":1}}],[\"模块\",{\"1\":{\"106\":1,\"831\":1,\"1059\":1,\"1265\":1}}],[\"认识\",{\"0\":{\"245\":1}}],[\"支持7种节点类型\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"支持写动态sql语句并可重复使用\",{\"1\":{\"1173\":1,\"1358\":1}}],[\"支持流数据处理等多种特性而被广泛使用\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"支持断点传输\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"支持多种传输类型\",{\"1\":{\"1032\":1}}],[\"支持多种消息发布和订阅模式\",{\"1\":{\"978\":1}}],[\"支持大量的并发连接\",{\"1\":{\"1020\":2}}],[\"支持非阻塞式\",{\"1\":{\"1020\":1}}],[\"支持丰富数据类型\",{\"1\":{\"960\":1}}],[\"支持快速查找\",{\"1\":{\"948\":1}}],[\"支持排序\",{\"1\":{\"922\":1}}],[\"支持高并发的线程安全map\",{\"1\":{\"922\":1}}],[\"支持null\",{\"1\":{\"922\":1}}],[\"支持一次转移多个提交\",{\"1\":{\"917\":1}}],[\"支持一系列著名的模型\",{\"1\":{\"245\":1}}],[\"支持的数据源\",{\"1\":{\"884\":1}}],[\"支持的\",{\"1\":{\"883\":1}}],[\"支持的prometheus\",{\"1\":{\"883\":1}}],[\"支持的最大数据标识id\",{\"1\":{\"388\":1}}],[\"支持的最大机器id\",{\"1\":{\"388\":1}}],[\"支持\",{\"1\":{\"597\":1,\"950\":1,\"1032\":1}}],[\"支持二进制案例的\",{\"1\":{\"593\":1}}],[\"支持数据的备份\",{\"1\":{\"592\":1}}],[\"支持数据的持久化\",{\"1\":{\"592\":1}}],[\"支持主从同步\",{\"1\":{\"589\":1}}],[\"支持各种不同方式的排序\",{\"1\":{\"589\":1}}],[\"支持网络\",{\"1\":{\"589\":1}}],[\"支持参数yes\",{\"1\":{\"440\":1}}],[\"支持先进先出\",{\"1\":{\"282\":1}}],[\"支持模型列表\",{\"1\":{\"241\":1,\"252\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"37\":1}}],[\"历史文章\",{\"1\":{\"808\":1}}],[\"历史表\",{\"1\":{\"779\":1}}],[\"历史网站截图\",{\"1\":{\"226\":1}}],[\"历史图片\",{\"0\":{\"226\":1}}],[\"万一以后成为百万博主\",{\"1\":{\"226\":1}}],[\"木须先生\",{\"1\":{\"225\":1}}],[\"停顿时间等\",{\"1\":{\"942\":1}}],[\"停车等等\",{\"1\":{\"871\":1}}],[\"停用词过滤\",{\"1\":{\"411\":1}}],[\"停滞了很久很久\",{\"1\":{\"225\":1}}],[\"停止容器\",{\"1\":{\"1063\":1,\"1269\":1}}],[\"停止\",{\"1\":{\"114\":1}}],[\"新注入的属性会代替掉默认属性\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"新\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"新加入的follower也会先存放在osr中\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"新创建了一个线程对象\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"新创建一个该类的实例\",{\"1\":{\"934\":1}}],[\"新版本的文档被索引到一个新段\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"新段\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"新键值对\",{\"1\":{\"988\":1}}],[\"新旧aof文件替换采用原子性rename操作\",{\"1\":{\"962\":1}}],[\"新生代基本采用复制算法\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"新生代仍需其他收集器配合\",{\"1\":{\"938\":1}}],[\"新生代用于存储新创建的对象\",{\"1\":{\"936\":1}}],[\"新生代和老年代\",{\"1\":{\"936\":1}}],[\"新生代又分为eden区\",{\"1\":{\"930\":1}}],[\"新生代是java堆中的一部分\",{\"1\":{\"930\":1}}],[\"新生代\",{\"1\":{\"930\":2,\"936\":1}}],[\"新生成一个节点add\",{\"1\":{\"286\":1}}],[\"新手入门教程\",{\"1\":{\"881\":1}}],[\"新增的statement\",{\"1\":{\"763\":1}}],[\"新增用户信息\",{\"1\":{\"763\":1}}],[\"新增用户\",{\"1\":{\"753\":1}}],[\"新建数据库\",{\"0\":{\"863\":1}}],[\"新建枚举类\",{\"1\":{\"829\":1}}],[\"新建俩张表\",{\"1\":{\"824\":1}}],[\"新建一个包叫\",{\"1\":{\"829\":1}}],[\"新建一个\",{\"1\":{\"811\":1}}],[\"新建项目时选择\",{\"1\":{\"838\":1}}],[\"新建项目\",{\"0\":{\"811\":1,\"848\":1}}],[\"新建orderuser实体类继承order\",{\"1\":{\"793\":1}}],[\"新建接口用于测试\",{\"1\":{\"686\":1}}],[\"新建接口\",{\"0\":{\"686\":1}}],[\"新建\",{\"1\":{\"648\":1,\"828\":1,\"839\":1}}],[\"新建分支\",{\"1\":{\"94\":1}}],[\"新打开一个\",{\"1\":{\"597\":1}}],[\"新闻搜索\",{\"2\":{\"1424\":1,\"1428\":1}}],[\"新闻搜索elasticsearch\",{\"0\":{\"1422\":1,\"1425\":1,\"1426\":1},\"2\":{\"1423\":1,\"1427\":1}}],[\"新闻搜索结果页面设计\",{\"1\":{\"394\":1}}],[\"新闻搜索页面设计\",{\"1\":{\"394\":1}}],[\"新鲜感过去后\",{\"1\":{\"225\":1}}],[\"努力是反人性的\",{\"1\":{\"225\":1}}],[\"感觉出现了幻觉\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"感觉一个小宇宙即将爆发\",{\"1\":{\"225\":1}}],[\"感谢夸奖\",{\"1\":{\"1002\":1}}],[\"感谢你的时间\",{\"1\":{\"992\":1}}],[\"感谢每一个支持\",{\"1\":{\"493\":1,\"552\":1}}],[\"感兴趣可以关注公众号javapub追更\",{\"1\":{\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1023\":1}}],[\"感兴趣的同学可以先加入体验\",{\"1\":{\"212\":1}}],[\"基数不大\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"基数排序动图演示\",{\"1\":{\"375\":1}}],[\"基数排序的方式可以采用lsd\",{\"1\":{\"374\":1}}],[\"基数排序的发明可以追溯到1887年赫尔曼\",{\"1\":{\"374\":1}}],[\"基数排序法的效率高于其它的稳定性排序法\",{\"1\":{\"371\":1}}],[\"基数排序法是属于稳定性的排序\",{\"1\":{\"371\":1,\"372\":1}}],[\"基数排序\",{\"0\":{\"369\":1,\"371\":1},\"1\":{\"370\":2,\"371\":1}}],[\"基数排序就是这么容易\",{\"0\":{\"367\":1}}],[\"基本概念\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"基本上还是基于\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"基本上\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"基本类型的值\",{\"1\":{\"1085\":2,\"1286\":2}}],[\"基本功\",{\"1\":{\"924\":1}}],[\"基本用法\",{\"1\":{\"917\":1}}],[\"基本项目结构\",{\"0\":{\"840\":1}}],[\"基本数据类型的操作做了讲解\",{\"1\":{\"647\":1}}],[\"基本数据类型\",{\"1\":{\"613\":1}}],[\"基本的操作方式\",{\"1\":{\"603\":1}}],[\"基本可以做到连续递增\",{\"1\":{\"383\":1}}],[\"基本每天大家都晚上\",{\"1\":{\"225\":1}}],[\"基于当前要开发的是一个用户中心系统\",{\"1\":{\"1443\":1}}],[\"基于用户的名称的查询\",{\"1\":{\"1439\":1}}],[\"基于以上几点\",{\"1\":{\"1431\":1}}],[\"基于zset\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"基于sql语句编程\",{\"1\":{\"1173\":1,\"1358\":1}}],[\"基于springboot+vue的后台管理系统免费开源\",{\"1\":{\"668\":1}}],[\"基于磁盘的随机读写确实很慢\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"基于jdk8\",{\"1\":{\"1141\":1}}],[\"基于io复用模型\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"基于池化思想\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"基于reactor模型\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"基于region分代回收\",{\"1\":{\"936\":1}}],[\"基于word2vec的商品向量还有一个可用之处\",{\"1\":{\"1079\":1,\"1283\":1}}],[\"基于事件驱动的网络应用框架\",{\"1\":{\"1031\":1}}],[\"基于lucene构建\",{\"1\":{\"1002\":1}}],[\"基于哈希表实现\",{\"1\":{\"948\":1}}],[\"基于双向链表实现\",{\"1\":{\"946\":1}}],[\"基于动态数组实现\",{\"1\":{\"946\":1}}],[\"基于红黑树实现\",{\"1\":{\"922\":1,\"948\":1}}],[\"基于github搭建网站\",{\"0\":{\"906\":1}}],[\"基于btc的一个项目\",{\"1\":{\"903\":1}}],[\"基于dockerfile打包一个名为\",{\"1\":{\"854\":1}}],[\"基于注解的\",{\"1\":{\"818\":1}}],[\"基于class的配置方式\",{\"1\":{\"782\":1}}],[\"基于内存\",{\"1\":{\"615\":1}}],[\"基于内存的数据结构存储器\",{\"1\":{\"614\":1}}],[\"基于乐观锁\",{\"0\":{\"579\":1}}],[\"基于排他锁\",{\"0\":{\"578\":1}}],[\"基于唯一索引实现\",{\"0\":{\"577\":1}}],[\"基于游标的方法和基于结果集的方法都可以尝试一下\",{\"1\":{\"546\":1}}],[\"基于集的方法通常更有效\",{\"0\":{\"545\":1}}],[\"基于比较的排序的时间复杂度在理论上的下限是o\",{\"1\":{\"357\":1}}],[\"基于桶排序求解\",{\"1\":{\"353\":1}}],[\"基于\",{\"0\":{\"668\":1},\"1\":{\"352\":1,\"385\":1,\"442\":1,\"604\":1,\"722\":1,\"1079\":1,\"1116\":1,\"1178\":1,\"1199\":1,\"1233\":1,\"1283\":1,\"1311\":1,\"1363\":1,\"1379\":1,\"1408\":1}}],[\"基础镜像通过java8来的\",{\"1\":{\"850\":1}}],[\"基础数据结构\",{\"1\":{\"652\":1}}],[\"基础之上\",{\"1\":{\"400\":1}}],[\"基础介绍\",{\"0\":{\"331\":1}}],[\"基础排序\",{\"0\":{\"294\":1}}],[\"基础知识资料较长\",{\"1\":{\"277\":1}}],[\"基础\",{\"1\":{\"100\":1,\"524\":1,\"1083\":1}}],[\"基础不牢\",{\"1\":{\"100\":1}}],[\"爬虫\",{\"1\":{\"223\":1}}],[\"包部署到容器中\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"包装类的实例\",{\"1\":{\"1085\":2,\"1286\":2}}],[\"包中的并发集合类\",{\"1\":{\"1022\":1}}],[\"包中就有对应方法\",{\"1\":{\"385\":1}}],[\"包上\",{\"1\":{\"944\":1}}],[\"包和\",{\"1\":{\"851\":1}}],[\"包下新建三个文件\",{\"1\":{\"829\":1}}],[\"包下新建\",{\"1\":{\"829\":1,\"830\":1}}],[\"包下新建实体\",{\"1\":{\"825\":1}}],[\"包所有注解\",{\"1\":{\"818\":1}}],[\"包\",{\"1\":{\"401\":1,\"944\":1}}],[\"包含连接点的对象\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"包含很多\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"包含一级缓存和二级缓存\",{\"1\":{\"958\":1}}],[\"包含了各种bean的定义\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"包含了很多静态方法\",{\"1\":{\"1113\":1,\"1308\":1}}],[\"包含了映射语句\",{\"1\":{\"958\":1}}],[\"包含了绝大多数流行的开源java构件\",{\"1\":{\"705\":1}}],[\"包含\",{\"1\":{\"223\":1,\"524\":1,\"956\":2}}],[\"包括前后端完整项目\",{\"1\":{\"1429\":1}}],[\"包括around\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"包括了传入参数映射配置\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"包括延迟时间replica\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"包括网络编程\",{\"1\":{\"1020\":1}}],[\"包括词条化\",{\"1\":{\"1012\":1}}],[\"包括分片和副本的处理\",{\"1\":{\"1012\":3}}],[\"包括类的属性\",{\"1\":{\"1010\":1}}],[\"包括搜索引擎\",{\"1\":{\"1000\":1}}],[\"包括g1\",{\"1\":{\"938\":1}}],[\"包括环境变量里设置的那堆classpath\",{\"1\":{\"934\":1}}],[\"包括时序性的和非时序性的\",{\"1\":{\"884\":1}}],[\"包括项目清理\",{\"1\":{\"711\":1}}],[\"包括清除\",{\"1\":{\"698\":1}}],[\"包括元素成员和元素分值\",{\"1\":{\"607\":1}}],[\"包括string\",{\"1\":{\"589\":1}}],[\"包括死锁检测到的信息\",{\"1\":{\"581\":1}}],[\"包括5位datacenterid和5位workerid<br>\",{\"1\":{\"388\":1}}],[\"包括\",{\"1\":{\"387\":1,\"772\":1,\"1160\":1,\"1348\":1}}],[\"包括数组\",{\"0\":{\"319\":1}}],[\"包括双亲\",{\"0\":{\"312\":1}}],[\"包括顺序和链式存储\",{\"0\":{\"306\":1}}],[\"包括顺序和链式存储结构\",{\"0\":{\"283\":1}}],[\"包括b\",{\"1\":{\"266\":1}}],[\"包括开发和面试中遇到的问题\",{\"1\":{\"211\":1}}],[\"包括请求参数和返回结果\",{\"1\":{\"185\":1}}],[\"包括功能描述\",{\"1\":{\"179\":1}}],[\"包括windows\",{\"1\":{\"122\":1}}],[\"毕业于\",{\"1\":{\"217\":1,\"223\":1}}],[\"毕竟将\",{\"1\":{\"1431\":1}}],[\"毕竟现在这种编号已经不足以承载当今的电商服务\",{\"1\":{\"653\":1}}],[\"毕竟知识学到都是自己的\",{\"1\":{\"212\":1}}],[\"毕竟合不合适也可以先体验\",{\"1\":{\"49\":1}}],[\"生命周期\",{\"0\":{\"1128\":1,\"1321\":1}}],[\"生命周期有清晰理解\",{\"1\":{\"952\":1}}],[\"生命周期的理解\",{\"1\":{\"952\":2}}],[\"生命周期比较熟悉\",{\"1\":{\"952\":1}}],[\"生命周期随着jvm的销毁而结束\",{\"1\":{\"615\":1}}],[\"生动\",{\"1\":{\"920\":1}}],[\"生活的方方面面\",{\"1\":{\"871\":1}}],[\"生活类的\",{\"1\":{\"225\":1}}],[\"生成对应的rdb文件\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"生成带有分页语句的sql\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"生成的class文件中不再带有泛型信息\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"生成的字段类型不正确\",{\"1\":{\"438\":1}}],[\"生成唯一id\",{\"1\":{\"1008\":1}}],[\"生成二维码\",{\"0\":{\"877\":1}}],[\"生成流程图\",{\"1\":{\"866\":1}}],[\"生成项目的站点文档\",{\"1\":{\"714\":1}}],[\"生成项目报告\",{\"1\":{\"711\":1}}],[\"生成序列的掩码\",{\"1\":{\"388\":1}}],[\"生成\",{\"1\":{\"387\":2,\"703\":1,\"704\":1,\"876\":2,\"964\":1}}],[\"生成了字符串\",{\"1\":{\"385\":1}}],[\"生于\",{\"1\":{\"217\":1}}],[\"生产产品\",{\"1\":{\"988\":1}}],[\"生产环境常用\",{\"1\":{\"864\":1}}],[\"生产环境用法\",{\"0\":{\"76\":1}}],[\"生产上使用docker配置一般是一次编译\",{\"1\":{\"387\":1}}],[\"生产者发送消息有缓存的概念\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"生产者发送消息后\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"生产者发送消息后直接算写入成功\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"生产者发送消息\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"生产者发送消息时\",{\"1\":{\"994\":1}}],[\"生产者才认为这条消息是写入成功的\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"生产者以及消费者只与\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"生产者会等待消息被所有的副本\",{\"1\":{\"994\":1}}],[\"生产者会等待消息被kafka集群的leader确认后再发送下一条消息\",{\"1\":{\"994\":1}}],[\"生产者不会等待任何确认\",{\"1\":{\"994\":1}}],[\"生产者需要确保消息能够成功推送到broker节点\",{\"1\":{\"990\":1}}],[\"生产者代码\",{\"1\":{\"990\":1}}],[\"生产者将消息发送到一个或多个主题\",{\"1\":{\"980\":1}}],[\"生产者就像是顾客下单\",{\"1\":{\"974\":1}}],[\"生产者\",{\"1\":{\"159\":1,\"986\":1,\"990\":1,\"1159\":1,\"1347\":1}}],[\"站在\",{\"1\":{\"830\":1}}],[\"站在前人的肩上\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"641\":1,\"698\":1,\"732\":1}}],[\"站点\",{\"1\":{\"711\":1}}],[\"站长是谁\",{\"1\":{\"217\":1}}],[\"站长\",{\"2\":{\"215\":1,\"216\":1,\"220\":1,\"221\":1}}],[\"🎁目录合集\",{\"1\":{\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1023\":1}}],[\"🎈\",{\"1\":{\"212\":1}}],[\"🆚\",{\"1\":{\"192\":1}}],[\"元注解\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"元字段\",{\"1\":{\"457\":1}}],[\"元素是否有序\",{\"1\":{\"1114\":1,\"1309\":1}}],[\"元素是否是集合\",{\"1\":{\"606\":1}}],[\"元素用来配置插件的参数\",{\"1\":{\"844\":1}}],[\"元素来管理子模块中的版本\",{\"1\":{\"844\":1}}],[\"元素中的\",{\"1\":{\"766\":1}}],[\"元素中设置的相应值来替换\",{\"1\":{\"766\":1}}],[\"元素体内指定的属性首先被读取\",{\"1\":{\"766\":1}}],[\"元素的子元素来传递\",{\"1\":{\"766\":1}}],[\"元素的值是几\",{\"1\":{\"359\":1}}],[\"元素从\",{\"1\":{\"606\":1}}],[\"元素\",{\"1\":{\"604\":1}}],[\"元素初始值全为0\",{\"1\":{\"359\":1}}],[\"元素出现的次数为值\",{\"1\":{\"353\":1}}],[\"元素为键\",{\"1\":{\"353\":1}}],[\"元素在每个桶中排序\",{\"1\":{\"351\":1}}],[\"元素分配到不同桶中\",{\"1\":{\"351\":1}}],[\"元素值域的划分\",{\"1\":{\"350\":1}}],[\"元素个数\",{\"1\":{\"285\":1,\"286\":1}}],[\"元\",{\"1\":{\"212\":2}}],[\"付费加入\",{\"0\":{\"212\":1}}],[\"很有可能会在同一个数组位置产生严重的哈希冲突\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"很明显\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"很明显这种写法会造成资源浪费\",{\"1\":{\"79\":1}}],[\"很简单的俩个接口\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"很显然\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"很少符合人的行为\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"很形象的比喻\",{\"1\":{\"1004\":1}}],[\"很聪明的问题\",{\"1\":{\"994\":1}}],[\"很可能引起空指针或者越界异常\",{\"1\":{\"988\":1}}],[\"很容易实现高可用\",{\"1\":{\"960\":1}}],[\"很容易被误用\",{\"1\":{\"692\":1}}],[\"很方便\",{\"1\":{\"958\":1}}],[\"很全面\",{\"1\":{\"952\":1}}],[\"很棒的建议\",{\"1\":{\"970\":1}}],[\"很棒\",{\"1\":{\"950\":2,\"980\":1,\"1000\":1,\"1004\":1}}],[\"很高兴与你的交流\",{\"1\":{\"952\":1}}],[\"很高兴面试官能够欣赏\",{\"1\":{\"934\":1}}],[\"很高兴见到你\",{\"1\":{\"926\":1}}],[\"很高兴今天的交流\",{\"1\":{\"922\":1}}],[\"很高兴有机会进行这样的技术探讨\",{\"1\":{\"922\":1}}],[\"很好奇心\",{\"1\":{\"996\":1}}],[\"很好的问题\",{\"1\":{\"986\":2,\"996\":1}}],[\"很好\",{\"1\":{\"922\":2,\"924\":2,\"930\":1,\"934\":3,\"938\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":2,\"980\":2,\"990\":1,\"992\":1,\"994\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1012\":2,\"1018\":1,\"1022\":9,\"1023\":1}}],[\"很好看\",{\"1\":{\"714\":1}}],[\"很实用\",{\"1\":{\"716\":1}}],[\"很大程度补偿了\",{\"1\":{\"589\":1}}],[\"很多第三方框架\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"很多的j2ee项目均采用了ioc框架产品spring\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"很多数据都查不到从而查数据库\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"很多浏览器都限制一个站点最多保存20个cookie\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"很多公司都有海量的日志数据\",{\"1\":{\"976\":1}}],[\"很多框架使用运行时注解读取注解信息\",{\"1\":{\"944\":1}}],[\"很多框架通过反射来读注解\",{\"1\":{\"944\":1}}],[\"很多构建工具会在构建代码时扫描和读取注解\",{\"1\":{\"944\":1}}],[\"很多\",{\"1\":{\"883\":1}}],[\"很多初学者和爱好者都有用到\",{\"1\":{\"698\":1}}],[\"很多在近期找过工作的同学一定都知道了\",{\"1\":{\"652\":1}}],[\"很多网站都有排行榜应用的\",{\"1\":{\"594\":1}}],[\"很多时候用\",{\"0\":{\"535\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"很多时候还取决于\",{\"1\":{\"528\":1}}],[\"很多查找及定位操作都是以页为单位\",{\"1\":{\"516\":1}}],[\"很多人都知道了个人\",{\"1\":{\"906\":1}}],[\"很多人都是通过空投才接触到了这一领域\",{\"1\":{\"481\":1}}],[\"很多人一定会想到\",{\"1\":{\"664\":1}}],[\"很多人自写连接池工具\",{\"1\":{\"647\":1}}],[\"很多人没有做过企业级项目\",{\"1\":{\"211\":1}}],[\"很多相同结构的文档组成索引\",{\"1\":{\"420\":1}}],[\"很多场景不适用\",{\"1\":{\"385\":1}}],[\"很多开源工具中都对它进行了实现\",{\"1\":{\"342\":1}}],[\"群公告获取\",{\"1\":{\"209\":1}}],[\"资源未找到\",{\"1\":{\"1431\":1}}],[\"资源文件访问\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"资源共享\",{\"0\":{\"878\":1}}],[\"资源\",{\"1\":{\"831\":1}}],[\"资源获取说明\",{\"0\":{\"209\":1}}],[\"资源是宝贵的\",{\"1\":{\"77\":1}}],[\"星球优惠码先到先得\",{\"1\":{\"212\":1}}],[\"星球链接\",{\"1\":{\"212\":1}}],[\"星球初始定价格\",{\"1\":{\"212\":1}}],[\"星球介绍\",{\"0\":{\"208\":1,\"210\":1}}],[\"星球内提供一对一交流\",{\"1\":{\"49\":1}}],[\"遇到什么问题\",{\"1\":{\"1018\":1}}],[\"遇到一种\",{\"1\":{\"383\":1}}],[\"遇到\",{\"1\":{\"200\":1}}],[\"防止加锁方异常无法释放锁时其他客户端无法获取锁\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"防止发生活锁\",{\"1\":{\"1105\":2,\"1303\":2}}],[\"防止指令重排\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"防止数据丢失\",{\"1\":{\"964\":1}}],[\"防止重启时只部分加载新aof的情况发生\",{\"1\":{\"962\":1}}],[\"防止重复领取\",{\"1\":{\"488\":1}}],[\"防止内存泄露\",{\"1\":{\"922\":1}}],[\"防止sql注入\",{\"1\":{\"763\":1}}],[\"防止其他事务在这个范围内插入新行\",{\"1\":{\"558\":1}}],[\"防止幻读\",{\"1\":{\"556\":1}}],[\"防止领超\",{\"1\":{\"488\":1}}],[\"防止中文编码与终端不一致导致打印出现乱码\",{\"1\":{\"199\":1}}],[\"防止出现拖库\",{\"1\":{\"184\":1}}],[\"应尽量避免全表扫描\",{\"1\":{\"1192\":1,\"1375\":1}}],[\"应尽量避免在where子句中对字段进行函数操作\",{\"0\":{\"532\":1}}],[\"应尽量避免在\",{\"0\":{\"526\":1,\"527\":1,\"528\":1,\"531\":1},\"1\":{\"1192\":5,\"1375\":5}}],[\"应当使用cookie\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"应当是不匹配的\",{\"1\":{\"451\":1}}],[\"应一位fans同学要求\",{\"1\":{\"698\":1}}],[\"应先寻找基于集的解决方案来解决问题\",{\"0\":{\"545\":1}}],[\"应先create\",{\"0\":{\"542\":1}}],[\"应改为\",{\"1\":{\"531\":1,\"532\":1}}],[\"应该选择更高效的序列化工具来降低字节数组大小\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"应该返回false\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"应该返回同样的结果\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"应该返回true\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"应该怎么做呢\",{\"1\":{\"1022\":1}}],[\"应该是类型参数和实际类型参数吧\",{\"1\":{\"966\":1}}],[\"应该添加\",{\"1\":{\"831\":1}}],[\"应该会出现\",{\"1\":{\"830\":1}}],[\"应该考虑相应需求是否合理\",{\"0\":{\"548\":1}}],[\"应该建立索引\",{\"1\":{\"502\":1}}],[\"应该直接删掉或者将为\",{\"1\":{\"198\":1}}],[\"应把最常被访问和选择性较高的列放在前面\",{\"1\":{\"498\":1}}],[\"应用服务\",{\"1\":{\"1444\":1}}],[\"应用上下文\",{\"1\":{\"1230\":1,\"1405\":1}}],[\"应用监控\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"应用的开发\",{\"1\":{\"1224\":1,\"1399\":1}}],[\"应用的初始搭建以及开发过程\",{\"1\":{\"401\":1}}],[\"应用缓存\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"应用以及后端的负载情况以及可能出现的问题\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"应用微服务架构\",{\"1\":{\"950\":1}}],[\"应用中使用\",{\"1\":{\"950\":1}}],[\"应用了\",{\"1\":{\"950\":1}}],[\"应用来说\",{\"1\":{\"950\":1}}],[\"应用程序将对象的创建及初始化职责交给工厂对象\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"应用程序\",{\"1\":{\"950\":1}}],[\"应用程序类加载器\",{\"1\":{\"934\":1}}],[\"应用\",{\"1\":{\"950\":6}}],[\"应用于当前分支\",{\"1\":{\"917\":1}}],[\"应用于其他分支\",{\"1\":{\"917\":1}}],[\"应用某个存储\",{\"1\":{\"916\":1}}],[\"应用构建和打包的\",{\"1\":{\"844\":1}}],[\"应用场景了解么\",{\"0\":{\"1033\":1}}],[\"应用场景\",{\"0\":{\"161\":1},\"1\":{\"653\":1,\"654\":1,\"655\":1,\"656\":1,\"657\":1,\"658\":1,\"659\":1,\"660\":1,\"1077\":2,\"1281\":2}}],[\"​每个replica都要为此在zookeeper上注册一个watch\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"​如果宕机的那个broker上的partition比较多\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"​如果有需要\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"​这是由zookeeper的特性引起的\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"​​\",{\"1\":{\"1064\":1}}],[\"​\",{\"1\":{\"198\":1,\"364\":1,\"624\":1,\"911\":1,\"1227\":3,\"1402\":3}}],[\"发完即忘\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"发起io请求\",{\"1\":{\"1088\":2,\"1289\":2}}],[\"发起握手等候响应超时时间\",{\"1\":{\"106\":1}}],[\"发生故障时\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"发生在父类子类之间\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"发生了一个异常\",{\"1\":{\"197\":1}}],[\"发送新建\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"发送消息的分区策略有哪些\",{\"0\":{\"1162\":1,\"1350\":1}}],[\"发送消息的逻辑\",{\"1\":{\"986\":1}}],[\"发送消息到分区p3\",{\"1\":{\"992\":1}}],[\"发送消息到分区p2\",{\"1\":{\"992\":1}}],[\"发送消息到分区p1\",{\"1\":{\"992\":1}}],[\"发送者将消息m1发送到p1\",{\"1\":{\"992\":1}}],[\"发送者将消息发送到一个中间件\",{\"1\":{\"992\":1}}],[\"发送sync命令\",{\"1\":{\"964\":1}}],[\"发送\",{\"1\":{\"964\":2,\"1162\":1,\"1350\":1}}],[\"发展和优化而成的一种高性能垃圾收集器\",{\"1\":{\"940\":1}}],[\"发现缓存不存在时\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"发现更多调优机会\",{\"1\":{\"942\":1}}],[\"发现查不到username的信息\",{\"1\":{\"759\":1}}],[\"发现需要访问表中的其他列数据\",{\"1\":{\"504\":1}}],[\"发布\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"发布数据更新的消息\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"发布的线程安全的\",{\"1\":{\"988\":1}}],[\"发布站点\",{\"1\":{\"711\":1}}],[\"发布到本地仓库或者服务器\",{\"1\":{\"705\":1}}],[\"发布与订阅\",{\"1\":{\"622\":1}}],[\"程序员在企业中是如何做需求的\",{\"1\":{\"1438\":1}}],[\"程序员从👨‍💻\",{\"1\":{\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1022\":1}}],[\"程序启动较慢\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"程序的工作线程会和垃圾收集线程同时运行或者交叉运行\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"程序的可见度\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"程序中所有的工作线程都将会因为\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"程序就gg了\",{\"1\":{\"966\":1}}],[\"程序使用这个类创建实例对象\",{\"1\":{\"934\":1}}],[\"程序计数器等\",{\"1\":{\"936\":1}}],[\"程序计数器是一块较小的内存空间\",{\"1\":{\"930\":1,\"1142\":1,\"1333\":1}}],[\"程序计数器\",{\"1\":{\"930\":1,\"936\":2}}],[\"程序并没有退出\",{\"1\":{\"692\":1}}],[\"程序可以通过跟踪对象的引用计数信息\",{\"1\":{\"635\":1}}],[\"程序可以通过这些层来加快访问其他节点的速度\",{\"1\":{\"628\":1}}],[\"程序会根据新添加元素\",{\"1\":{\"630\":1}}],[\"程序需要将现有哈希表包含的所有键值对\",{\"1\":{\"626\":1}}],[\"程序需要对哈希表的大小进行相应的扩展或者收缩\",{\"1\":{\"625\":1}}],[\"程序将\",{\"1\":{\"625\":1}}],[\"程序除了执行指定的操作以外\",{\"1\":{\"625\":1}}],[\"程序继续运行\",{\"1\":{\"274\":1}}],[\"程序运行期间所需要的数据通常比较集中\",{\"1\":{\"274\":1}}],[\"程序异常\",{\"1\":{\"196\":1}}],[\"程序写挂了\",{\"1\":{\"193\":1}}],[\"业务接口\",{\"1\":{\"830\":1}}],[\"业务接口代码\",{\"0\":{\"830\":1}}],[\"业务层\",{\"0\":{\"829\":1}}],[\"业务清晰\",{\"1\":{\"517\":1}}],[\"业务代码\",{\"1\":{\"196\":1}}],[\"业务逻辑\",{\"1\":{\"195\":1,\"196\":1,\"197\":1,\"201\":2}}],[\"浪费了系统资源\",{\"1\":{\"195\":1}}],[\"反射获取方法上的loginrequred注解\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"反射可以破坏封装性\",{\"1\":{\"1010\":1}}],[\"反射可以用于动态地获取和设置泛型信息\",{\"1\":{\"1010\":1}}],[\"反射可以用于很多方面\",{\"1\":{\"1010\":1}}],[\"反射还可以用于动态地获取和设置泛型类型\",{\"1\":{\"1010\":1}}],[\"反射的了解很深入\",{\"1\":{\"1010\":1}}],[\"反射的了解很不错\",{\"1\":{\"1010\":1}}],[\"反射的优点是可以在运行时动态地获取和操作类的信息\",{\"1\":{\"1010\":1}}],[\"反射是动态代理的基础\",{\"1\":{\"1016\":1}}],[\"反射是一种机制\",{\"1\":{\"1010\":1}}],[\"反射是什么吗\",{\"1\":{\"1010\":1}}],[\"反射有了解吗\",{\"1\":{\"1010\":1}}],[\"反射\",{\"1\":{\"524\":1}}],[\"反而可能因为维护索引而降低整体性能\",{\"1\":{\"508\":1}}],[\"反而可能增加插入\",{\"1\":{\"502\":1}}],[\"反向代理\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"反向代理服务器在转发请求的http头信息中\",{\"1\":{\"106\":1}}],[\"反向填充目标数组\",{\"1\":{\"358\":1}}],[\"反例\",{\"1\":{\"193\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"201\":1}}],[\"空闲链表指针偏移量\",{\"1\":{\"1023\":1}}],[\"空闲链表指针\",{\"1\":{\"1023\":1}}],[\"空闲区整理\",{\"1\":{\"940\":1}}],[\"空值处理\",{\"1\":{\"946\":1}}],[\"空转时间\",{\"1\":{\"636\":1}}],[\"空哈希表\",{\"1\":{\"624\":1}}],[\"空字符串也是有效\",{\"1\":{\"602\":1}}],[\"空投步骤\",{\"0\":{\"486\":1}}],[\"空投一般会是\",{\"1\":{\"484\":1}}],[\"空投什么\",{\"0\":{\"484\":1}}],[\"空投就是一种营销策略\",{\"1\":{\"483\":1}}],[\"空投到底是什么\",{\"0\":{\"483\":1}}],[\"空投作为区块链行业最大的惊喜之一\",{\"1\":{\"481\":1}}],[\"空投\",{\"1\":{\"481\":1},\"2\":{\"489\":1,\"490\":1}}],[\"空投合约代码分为很多种\",{\"1\":{\"485\":1}}],[\"空投合约代码\",{\"0\":{\"485\":1}}],[\"空投合约\",{\"0\":{\"481\":1}}],[\"空间整合\",{\"1\":{\"940\":1}}],[\"空间报警触发minor\",{\"1\":{\"938\":1}}],[\"空间利用率降低\",{\"1\":{\"938\":1}}],[\"空间利用率低是一个缺点\",{\"1\":{\"938\":1}}],[\"空间利用率低\",{\"1\":{\"938\":1}}],[\"空间利用率高\",{\"1\":{\"922\":1}}],[\"空间预分配机制\",{\"1\":{\"620\":1}}],[\"空间不足\",{\"1\":{\"620\":1}}],[\"空间局部性\",{\"1\":{\"503\":1}}],[\"空间局部性原理\",{\"1\":{\"266\":1}}],[\"空间索引是一种针对空间数据类型\",{\"1\":{\"495\":1}}],[\"空间索引\",{\"1\":{\"495\":1}}],[\"空间布隆过滤器\",{\"1\":{\"343\":1}}],[\"空\",{\"1\":{\"284\":1}}],[\"空指针异常在任何代码中都是最常见的异常之一\",{\"1\":{\"193\":1}}],[\"空格分隔\",{\"1\":{\"106\":1}}],[\"链的容器\",{\"1\":{\"1034\":1}}],[\"链表增删元素的效率很高\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"链表转红黑树的条件\",{\"1\":{\"948\":1}}],[\"链表转换为红黑树\",{\"1\":{\"922\":1}}],[\"链表在查询元素的时候只能通过遍历的方式查询\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"链表在碰撞场景下使用\",{\"1\":{\"948\":1}}],[\"链表在冲突发生时\",{\"1\":{\"922\":1}}],[\"链表情况\",{\"1\":{\"922\":1}}],[\"链表被广泛用于实现\",{\"1\":{\"622\":1}}],[\"链表重点\",{\"0\":{\"622\":1}}],[\"链表所包含的节点数量\",{\"1\":{\"621\":1}}],[\"链表节点\",{\"1\":{\"621\":1}}],[\"链表是\",{\"1\":{\"621\":1}}],[\"链表和链表节点\",{\"0\":{\"621\":1}}],[\"链表\",{\"1\":{\"589\":1,\"922\":1,\"946\":1}}],[\"链队结点\",{\"1\":{\"289\":1}}],[\"链队的实现很简单\",{\"1\":{\"289\":1}}],[\"链队实现\",{\"1\":{\"289\":1}}],[\"链式栈\",{\"0\":{\"292\":1}}],[\"链式队列\",{\"0\":{\"289\":1}}],[\"链式存储实现\",{\"0\":{\"286\":1}}],[\"链式存储结构是依靠指针\",{\"1\":{\"284\":1}}],[\"链路标识\",{\"1\":{\"192\":1}}],[\"链接\",{\"1\":{\"20\":1,\"934\":1}}],[\"时会收到\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"时会获取被\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"时从内存读取\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"时常犯的几个错误\",{\"1\":{\"950\":1}}],[\"时常犯哪些错误\",{\"1\":{\"950\":1}}],[\"时常分享优质学习资源\",{\"1\":{\"211\":1}}],[\"时使用\",{\"1\":{\"624\":1,\"626\":1}}],[\"时有可能会重建索引\",{\"1\":{\"537\":1}}],[\"时需要遍历的节点数量较少\",{\"1\":{\"503\":1}}],[\"时候\",{\"1\":{\"431\":1}}],[\"时我们就不能进行自增操作了\",{\"1\":{\"288\":1}}],[\"时间之间\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"时间戳\",{\"1\":{\"445\":1,\"569\":1}}],[\"时间戳改变\",{\"1\":{\"388\":1}}],[\"时间截向左移22位\",{\"1\":{\"388\":1}}],[\"时间复杂度只需要\",{\"1\":{\"620\":1}}],[\"时间复杂度是\",{\"1\":{\"495\":1}}],[\"时间复杂度为\",{\"1\":{\"372\":1}}],[\"时间复杂度o\",{\"1\":{\"286\":3}}],[\"时间复杂度固定为\",{\"1\":{\"270\":1}}],[\"时间等信息\",{\"1\":{\"191\":1}}],[\"时\",{\"1\":{\"195\":1,\"431\":1,\"501\":1,\"844\":1,\"932\":5,\"1006\":1,\"1071\":1,\"1076\":1,\"1078\":1,\"1116\":1,\"1119\":1,\"1164\":1,\"1219\":1,\"1275\":1,\"1280\":1,\"1282\":1,\"1311\":1,\"1314\":1,\"1352\":1,\"1396\":1}}],[\"时杀手锏\",{\"1\":{\"192\":1}}],[\"时长取决于文件大小\",{\"1\":{\"143\":1}}],[\"时长1分钟\",{\"1\":{\"134\":1}}],[\"警告日志\",{\"1\":{\"191\":1}}],[\"错误时的构造器\",{\"1\":{\"830\":1}}],[\"错误信息\",{\"1\":{\"830\":1}}],[\"错误写法\",{\"1\":{\"830\":3,\"831\":1}}],[\"错误日志\",{\"1\":{\"191\":1,\"1185\":2,\"1368\":2}}],[\"错误码\",{\"1\":{\"186\":1}}],[\"错误码作为程序重要的参考\",{\"1\":{\"186\":1}}],[\"个人了\",{\"1\":{\"1439\":1}}],[\"个人站点\",{\"1\":{\"2\":1}}],[\"个时\",{\"1\":{\"1074\":1,\"1278\":1}}],[\"个选了另一个\",{\"0\":{\"1074\":1,\"1278\":1}}],[\"个选了一个\",{\"0\":{\"1074\":1,\"1278\":1}}],[\"个阶段\",{\"1\":{\"952\":1}}],[\"个线程\",{\"1\":{\"932\":2}}],[\"个简单的命令\",{\"1\":{\"659\":1}}],[\"个元素\",{\"1\":{\"604\":1,\"655\":1}}],[\"个请求\",{\"1\":{\"591\":1}}],[\"个并发执行\",{\"1\":{\"591\":1}}],[\"个别图片粘贴有丢失\",{\"1\":{\"586\":1}}],[\"个文档\",{\"1\":{\"451\":2}}],[\"个节点\",{\"1\":{\"387\":1}}],[\"个毫秒的值\",{\"1\":{\"387\":1}}],[\"个高频元素\",{\"1\":{\"353\":1}}],[\"个桶中\",{\"1\":{\"348\":1}}],[\"个数字\",{\"1\":{\"387\":3}}],[\"个数据均匀的分配到\",{\"1\":{\"348\":1}}],[\"个数\",{\"1\":{\"347\":1}}],[\"个数量级\",{\"1\":{\"266\":1}}],[\"个区间\",{\"1\":{\"267\":1}}],[\"个区间来进行索引\",{\"1\":{\"266\":1}}],[\"个\",{\"0\":{\"1074\":1,\"1278\":1},\"1\":{\"267\":1,\"270\":2,\"387\":1,\"658\":5,\"1205\":1,\"1385\":1}}],[\"个有序的序列\",{\"1\":{\"266\":1}}],[\"个好建议～\",{\"1\":{\"190\":1}}],[\"没添加拦截器之前成功访问\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"没写\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"没错\",{\"1\":{\"976\":1,\"978\":4,\"986\":4,\"992\":2,\"998\":1,\"1002\":1,\"1006\":1,\"1012\":1}}],[\"没问题\",{\"1\":{\"974\":1}}],[\"没人阻止您一定要用更短的键值节省一丁点儿空间\",{\"1\":{\"602\":1}}],[\"没有的话选择擅长和熟悉的技术栈\",{\"1\":{\"1439\":1}}],[\"没有的话再查询数据库\",{\"1\":{\"958\":1}}],[\"没有数据库的事务支持\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"没有循环依赖\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"没有使用\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"没有使用私服的仓库构件下载\",{\"1\":{\"705\":1}}],[\"没有进入真正的业务处理\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"没有必要因为是多线程而用\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"没有缓存数值\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"没有方法\",{\"1\":{\"944\":1}}],[\"没有人比中国人更懂\",{\"1\":{\"922\":1}}],[\"没有问题\",{\"1\":{\"828\":1}}],[\"没有分离\",{\"1\":{\"772\":1}}],[\"没有起作用\",{\"1\":{\"692\":1}}],[\"没有实际的例子代码\",{\"1\":{\"692\":1}}],[\"没有实际的数据\",{\"1\":{\"270\":1}}],[\"没有找到\",{\"1\":{\"648\":1}}],[\"没有\",{\"1\":{\"648\":1}}],[\"没有直接使用\",{\"1\":{\"619\":1}}],[\"没有其他事务可以对这张表进行读写操作\",{\"1\":{\"561\":1}}],[\"没有索引\",{\"1\":{\"501\":2}}],[\"没有新建字段\",{\"1\":{\"436\":1}}],[\"没有形成开箱即用的工具类\",{\"1\":{\"387\":1}}],[\"没有网络消耗\",{\"1\":{\"385\":1}}],[\"没有任何元素的队列则称为空队\",{\"1\":{\"287\":1}}],[\"没有打印系统异常\",{\"1\":{\"197\":1}}],[\"没有日志的程序运行起来就如同脱缰的野🐎\",{\"1\":{\"190\":1}}],[\"没关系\",{\"1\":{\"90\":1}}],[\"撕b\",{\"1\":{\"190\":1}}],[\"甩锅\",{\"1\":{\"190\":1}}],[\"击穿等p0问题\",{\"1\":{\"184\":1}}],[\"存盘可以有意无意的对数据进行写操作\",{\"1\":{\"589\":1}}],[\"存在以下的特点\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"存在\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"存在死锁的风险\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"存在的意义仅在于用来减少类完全限定名的冗余\",{\"1\":{\"768\":1}}],[\"存在的问题\",{\"1\":{\"387\":1}}],[\"存在就不做任何操作\",{\"1\":{\"664\":1}}],[\"存在单库读写\",{\"1\":{\"518\":1}}],[\"存在新增字段的数据写入\",{\"1\":{\"431\":1}}],[\"存在比其小的数\",{\"1\":{\"352\":1}}],[\"存入osr\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"存入数组c的第i项\",{\"1\":{\"358\":1}}],[\"存入对应的数组下标\",{\"1\":{\"353\":1}}],[\"存储的数据就是消息队列中的消息内容\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"存储的对象我们需要用\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"存储的方式是以\",{\"1\":{\"615\":1}}],[\"存储有条件使用\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"存储文档\",{\"1\":{\"1012\":1}}],[\"存储在索引中\",{\"1\":{\"1000\":1}}],[\"存储在叶节点导致查询时间复杂度固定为\",{\"1\":{\"270\":1}}],[\"存储和分发这些日志数据\",{\"1\":{\"976\":1}}],[\"存储元素的数组\",{\"1\":{\"946\":1}}],[\"存储键值对的数组\",{\"1\":{\"928\":1}}],[\"存储结构\",{\"1\":{\"615\":1}}],[\"存储系统\",{\"1\":{\"589\":1,\"1158\":1,\"1198\":1,\"1346\":1,\"1378\":1}}],[\"存储性能瓶颈\",{\"1\":{\"518\":1}}],[\"存储引擎\",{\"1\":{\"511\":3,\"526\":1,\"558\":1}}],[\"存储空间\",{\"1\":{\"508\":1}}],[\"存储总代币数\",{\"1\":{\"488\":1}}],[\"存储已领取代币数\",{\"1\":{\"488\":1}}],[\"存储\",{\"1\":{\"450\":1,\"594\":1,\"653\":1,\"916\":1,\"1116\":1,\"1178\":1,\"1311\":1,\"1363\":1}}],[\"存储长度因子和索引时boost\",{\"1\":{\"440\":1}}],[\"存储过长\",{\"1\":{\"385\":1}}],[\"存储与实现\",{\"0\":{\"303\":1}}],[\"存储容器初始大小\",{\"1\":{\"285\":1}}],[\"存储容器\",{\"1\":{\"285\":1}}],[\"存储数据最小单元\",{\"0\":{\"272\":1}}],[\"存储知识\",{\"0\":{\"271\":1}}],[\"存放的内容\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"存放一批连接\",{\"1\":{\"647\":1}}],[\"存放\",{\"1\":{\"183\":1}}],[\"存为jpeg图片\",{\"0\":{\"141\":1}}],[\"从项目创建\",{\"1\":{\"1429\":1}}],[\"从设计模式角度来理解\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"从properties中获取到enableautoconfiguration\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"从锁的类别上来讲\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"从锁的类别上分mysql都有哪些锁呢\",{\"0\":{\"1193\":1,\"1376\":1}}],[\"从其他\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"从zookeeper中读取当前分区的所有isr\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"从副本\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"从分区p3读取消息\",{\"1\":{\"992\":1}}],[\"从分区p2读取消息\",{\"1\":{\"992\":1}}],[\"从分区p1读取消息\",{\"1\":{\"992\":1}}],[\"从kafka中获取准确的信息有什么要注意的地方吗\",{\"1\":{\"984\":1}}],[\"从柜台上拿走订单\",{\"1\":{\"974\":1}}],[\"从gc\",{\"1\":{\"936\":1,\"938\":1,\"940\":1}}],[\"从上图我们就可以看出\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"从上图可以看出相同大小的区域\",{\"1\":{\"270\":1}}],[\"从上图可以看出\",{\"1\":{\"270\":1}}],[\"从上面可以看到\",{\"1\":{\"917\":1}}],[\"从列表中删除这个存储\",{\"1\":{\"916\":1}}],[\"从列表中弹出一个值\",{\"1\":{\"604\":1}}],[\"从主内存中拷贝到自己的线程工作内存\",{\"1\":{\"692\":1}}],[\"从黑铁到王者\",{\"1\":{\"652\":1}}],[\"从大到小\",{\"1\":{\"607\":1}}],[\"从表尾开始向表头搜索\",{\"1\":{\"604\":1}}],[\"从表头开始向表尾搜索\",{\"1\":{\"604\":1}}],[\"从右边\",{\"1\":{\"604\":1}}],[\"从右至左调整结构\",{\"1\":{\"364\":1}}],[\"从形如\",{\"1\":{\"602\":1}}],[\"从2013年5月开始\",{\"1\":{\"589\":1}}],[\"从2010年3月15日起\",{\"1\":{\"589\":1}}],[\"从每种锁的锁粒度\",{\"1\":{\"563\":1}}],[\"从细到粗\",{\"1\":{\"561\":1,\"567\":1}}],[\"从多个角度分析\",{\"1\":{\"525\":1}}],[\"从这个方法点进来可以看到\",{\"1\":{\"1444\":1}}],[\"从这2段代码可以看出\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"从这三个维度可以很好的应用在你的开发工作中\",{\"1\":{\"499\":1}}],[\"从这点来看b+树相对b\",{\"1\":{\"270\":1}}],[\"从图中可以看出核心类型可以划分为字符串类型\",{\"1\":{\"442\":1}}],[\"从\",{\"1\":{\"429\":1,\"692\":1,\"1150\":1,\"1159\":2,\"1166\":1,\"1177\":1,\"1186\":2,\"1341\":1,\"1347\":2,\"1354\":1,\"1362\":1,\"1369\":2,\"1429\":1}}],[\"从而在表盘上产生正确的时间\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"从而在受害者并未授权的情况下执行受害者权限下的各种操作\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"从而丢失\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"从而抛出异常\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"从而返回\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"从而更新本地缓存\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"从而实现分页\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"从而实现最终一致性\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"从而实现多路复用\",{\"1\":{\"1020\":2}}],[\"从而实现更加灵活和强大的功能\",{\"1\":{\"1010\":1,\"1016\":1}}],[\"从而可以直接访问文件的内容\",{\"1\":{\"1020\":1}}],[\"从而精确控制\",{\"1\":{\"952\":1}}],[\"从而应对可能遇到的面试题和实际开发中的相关问题\",{\"1\":{\"934\":1}}],[\"从而避免aba问题\",{\"1\":{\"1018\":1}}],[\"从而避免资源消耗\",{\"1\":{\"934\":1}}],[\"从而避免了线程安全问题\",{\"1\":{\"928\":2}}],[\"从而影响其生命周期\",{\"1\":{\"952\":1}}],[\"从而影响程序的正确性\",{\"1\":{\"926\":1}}],[\"从而影响系统的性能\",{\"1\":{\"926\":1}}],[\"从而影响性能\",{\"1\":{\"570\":1}}],[\"从而退出循环\",{\"1\":{\"924\":1}}],[\"从而保证了可见性\",{\"1\":{\"924\":1}}],[\"从而打破死锁状态\",{\"1\":{\"581\":1}}],[\"从而维护数据的顺序性和一致性\",{\"1\":{\"558\":1}}],[\"从而使访问压力被多服务器负载\",{\"1\":{\"520\":2}}],[\"从而使得单个表的数据量变小\",{\"1\":{\"519\":1}}],[\"从而使开发人员不再需要定义样板化的配置\",{\"1\":{\"401\":1}}],[\"从而达到多个服务器共同分摊压力的效果\",{\"1\":{\"517\":1}}],[\"从而达到提升数据库性能的目的\",{\"1\":{\"515\":2}}],[\"从而提供较高的并发性\",{\"1\":{\"564\":1}}],[\"从而提供比表锁更细粒度的并发控制\",{\"1\":{\"561\":1}}],[\"从而提升了数据库性能\",{\"1\":{\"516\":1}}],[\"从而提高读写速度\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"从而提高系统的并发性能\",{\"1\":{\"1020\":2}}],[\"从而提高系统的性能和资源利用率\",{\"1\":{\"926\":1}}],[\"从而提高代码的可重用性和可维护性\",{\"1\":{\"1016\":1}}],[\"从而提高整体吞吐量\",{\"1\":{\"982\":1}}],[\"从而提高查询性能\",{\"1\":{\"510\":1}}],[\"从而提高了更新操作的效率\",{\"1\":{\"503\":1}}],[\"从而帮助我们快速定位符合某个条件的行\",{\"1\":{\"505\":1}}],[\"从而降低了解决问题的复杂度\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"从而降低出现缓存雪崩的情况\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"从而降低并发性\",{\"1\":{\"574\":1}}],[\"从而降低索引的效率\",{\"1\":{\"508\":1}}],[\"从而降低树的高度\",{\"1\":{\"503\":1}}],[\"从而降低磁盘的利用效率和查询效率\",{\"1\":{\"499\":1}}],[\"从而减少回表\",{\"1\":{\"504\":1}}],[\"从而减少磁盘的io次数\",{\"1\":{\"499\":1}}],[\"从而减少查询时候需要的io次数\",{\"1\":{\"270\":1}}],[\"从而建立表之间的关系\",{\"1\":{\"496\":1}}],[\"从1开始\",{\"1\":{\"383\":1}}],[\"从最低位开始\",{\"1\":{\"374\":1}}],[\"从第一个非叶子结点从下至上\",{\"1\":{\"364\":1}}],[\"从第几帧到第几帧之间进行提取\",{\"1\":{\"141\":1}}],[\"从下至上进行调整\",{\"1\":{\"364\":1}}],[\"从下标为1的元素开始选择合适的位置插入\",{\"1\":{\"352\":1}}],[\"从左至右\",{\"1\":{\"364\":1}}],[\"从左到右的顺序进行编号\",{\"1\":{\"364\":1}}],[\"从c中的第一个元素开始\",{\"1\":{\"358\":1}}],[\"从已经排序的序列最右边的开始比较\",{\"1\":{\"352\":1}}],[\"从待排序集合中元素映射到各个桶上的过程\",{\"1\":{\"350\":1}}],[\"从值域上看是处于有序状态的\",{\"1\":{\"348\":1}}],[\"从抽象角度看\",{\"1\":{\"273\":1}}],[\"从需求到部署上线\",{\"1\":{\"205\":1}}],[\"从零到一写代码\",{\"1\":{\"205\":1}}],[\"从服务器得到\",{\"1\":{\"964\":1}}],[\"从服务器载入\",{\"1\":{\"964\":1}}],[\"从服务器连接主服务器\",{\"1\":{\"964\":2}}],[\"从服务器处理读请求\",{\"1\":{\"964\":1}}],[\"从服务器可以顶上继续提供服务\",{\"1\":{\"964\":1}}],[\"从服务器可以是关联其他从服务器的主服务器\",{\"1\":{\"589\":1}}],[\"从服务器删除资源\",{\"1\":{\"178\":1}}],[\"从服务器取出资源\",{\"1\":{\"178\":1}}],[\"协同工作\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"协议不同的是\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"协议中\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"协议\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"协议由哪几部分组成\",{\"1\":{\"1027\":1}}],[\"协议为例\",{\"1\":{\"177\":1}}],[\"协调节点需要根据\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"协调节点给持有相关文档的每个分片创建一个\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"协调节点首先决定哪些文档\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"协调节点返回结果给客户端\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"协调节点辨别出哪些文档需要被取回并向相关的分片提交多个\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"协调节点默认使用文档\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"协调节点向客户端报告成功\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"协调器会将索引请求发送给相关的分片和副本\",{\"1\":{\"1012\":1}}],[\"协调作用\",{\"1\":{\"153\":1}}],[\"配合\",{\"1\":{\"950\":1}}],[\"配合请求时参数来调用\",{\"1\":{\"177\":1}}],[\"配置是\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"配置在应用程序上下文的引导阶段生效\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"配置在\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"配置对象\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"配置日志\",{\"1\":{\"942\":1}}],[\"配置环境变量\",{\"1\":{\"899\":1}}],[\"配置信息\",{\"1\":{\"885\":1,\"1244\":2,\"1417\":2}}],[\"配置信息同步\",{\"1\":{\"153\":1}}],[\"配置项目名\",{\"1\":{\"838\":1}}],[\"配置项目b依赖于项目a\",{\"1\":{\"708\":1}}],[\"配置tomcat\",{\"1\":{\"832\":1}}],[\"配置了\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"配置了动态扫描\",{\"1\":{\"827\":1}}],[\"配置了properties\",{\"1\":{\"743\":1}}],[\"配置说明\",{\"0\":{\"822\":1},\"1\":{\"864\":1}}],[\"配置一些简单的日志\",{\"1\":{\"821\":1}}],[\"配置dispatcherservlet\",{\"1\":{\"820\":1}}],[\"配置spring和junit整合\",{\"1\":{\"828\":1}}],[\"配置springmvc需要加载的配置文件\",{\"1\":{\"820\":1}}],[\"配置springmvc\",{\"1\":{\"819\":1}}],[\"配置sqlsessionfactory对象\",{\"1\":{\"815\":1}}],[\"配置jsp\",{\"1\":{\"819\":2}}],[\"配置基于注解的声明式事务\",{\"1\":{\"818\":1}}],[\"配置事务管理器\",{\"1\":{\"818\":2}}],[\"配置全局属性\",{\"1\":{\"817\":1}}],[\"配置连接池属性\",{\"1\":{\"815\":1}}],[\"配置数据库相关参数properties的属性\",{\"1\":{\"815\":1}}],[\"配置数据库连接池\",{\"1\":{\"815\":1}}],[\"配置整合mybatis过程\",{\"1\":{\"815\":1}}],[\"配置扫描dao接口包\",{\"1\":{\"815\":1}}],[\"配置扫描\",{\"1\":{\"815\":1}}],[\"配置ordermapper\",{\"1\":{\"793\":1}}],[\"配置有关\",{\"1\":{\"768\":1}}],[\"配置mybaties全局配置文件\",{\"1\":{\"815\":1}}],[\"配置mybatis\",{\"1\":{\"751\":1}}],[\"配置map\",{\"0\":{\"744\":1}}],[\"配置为true时不向下传递此依赖\",{\"1\":{\"708\":1,\"709\":1}}],[\"配置为你自己的maven路径\",{\"1\":{\"702\":1}}],[\"配置本地仓库\",{\"1\":{\"702\":1}}],[\"配置该节点会与哪些候选地址进行通信\",{\"1\":{\"406\":1}}],[\"配置没有解决\",{\"1\":{\"387\":1}}],[\"配置文件放在了非上下文目录\",{\"1\":{\"950\":1}}],[\"配置文件\",{\"0\":{\"162\":1,\"814\":1},\"1\":{\"636\":1,\"698\":1,\"1179\":2,\"1364\":2}}],[\"配置文件解读\",{\"1\":{\"157\":1}}],[\"配置维护\",{\"1\":{\"154\":1}}],[\"配置生效\",{\"1\":{\"125\":1}}],[\"配置中心\",{\"1\":{\"113\":1}}],[\"配置看板步骤\",{\"1\":{\"109\":1}}],[\"配置\",{\"0\":{\"28\":1,\"702\":1},\"1\":{\"109\":2,\"244\":1,\"770\":1,\"786\":2,\"787\":1,\"815\":1,\"839\":1,\"1232\":1,\"1407\":1}}],[\"力求言简意赅\",{\"1\":{\"176\":1,\"179\":1}}],[\"顾名思义\",{\"1\":{\"176\":1,\"371\":1,\"498\":1}}],[\"顾名思义就是投票选举\",{\"1\":{\"166\":1}}],[\"多一个或少一个字段\",{\"1\":{\"1431\":1}}],[\"多例\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"多路复用\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"多读取一次数据库\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"多谢面试官的提问\",{\"1\":{\"988\":2}}],[\"多次minorgc后仍存活进入老年代\",{\"1\":{\"936\":1}}],[\"多对一的复合属性\",{\"1\":{\"825\":1}}],[\"多对多查询\",{\"0\":{\"795\":1},\"1\":{\"795\":1}}],[\"多模块项目是现在开发中比较常用的方式\",{\"1\":{\"716\":1}}],[\"多列查询的前导列\",{\"1\":{\"502\":1}}],[\"多列索引没有最左匹配\",{\"1\":{\"501\":1}}],[\"多边形等\",{\"1\":{\"495\":1}}],[\"多面等几何类型\",{\"1\":{\"454\":1}}],[\"多线程之间需要协调工作\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"多线程就是同时运行多个线程\",{\"1\":{\"988\":1}}],[\"多线程环境下\",{\"1\":{\"922\":1,\"988\":1}}],[\"多线程\",{\"1\":{\"524\":1,\"1115\":1,\"1310\":1}}],[\"多线\",{\"1\":{\"454\":1}}],[\"多点\",{\"1\":{\"454\":1}}],[\"多层对象\",{\"1\":{\"450\":1}}],[\"多环境配置\",{\"1\":{\"394\":1}}],[\"多叉的好处非常明显\",{\"1\":{\"266\":1}}],[\"多叉树\",{\"1\":{\"266\":1}}],[\"多数书籍翻译成\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"多数的都是一些理论讲解\",{\"1\":{\"692\":1}}],[\"多数中小公司只用\",{\"1\":{\"178\":1}}],[\"多数情况都是给别人提供接口\",{\"1\":{\"175\":1}}],[\"多个类加载器都去加载这个类到内存中\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"多个连接共用同一个阻塞对象\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"多个甚至全部分片\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"多个\",{\"1\":{\"958\":1,\"1205\":1,\"1385\":1}}],[\"多个线程并行回收\",{\"1\":{\"936\":1}}],[\"多个参数时\",{\"1\":{\"779\":1}}],[\"多个字段更新\",{\"1\":{\"727\":1}}],[\"多个节点可以包含\",{\"1\":{\"629\":1}}],[\"多个哈希表节点可以用\",{\"1\":{\"624\":1}}],[\"多个事务对同一数据对象的并发操作会产生冲突\",{\"1\":{\"570\":1}}],[\"多个事务在同一时间对同一数据对象进行操作的可能性很小\",{\"1\":{\"569\":1}}],[\"多个事务在执行过程中\",{\"1\":{\"562\":1}}],[\"多个域名\",{\"1\":{\"106\":1}}],[\"多个窗口还要保证一致性\",{\"1\":{\"77\":1}}],[\"老六的接口不通啦\",{\"1\":{\"1431\":2}}],[\"老年代采用标记整理算法\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"老年代使用标记\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"老年代使用mark\",{\"1\":{\"936\":1}}],[\"老年代的对象通过晋升至永久代\",{\"1\":{\"936\":1}}],[\"老年代空间不足触发major\",{\"1\":{\"936\":1}}],[\"老年代中存放老化对象\",{\"1\":{\"936\":1}}],[\"老年代主要用于存放长生命周期的对象\",{\"1\":{\"930\":1}}],[\"老年代\",{\"1\":{\"930\":1,\"936\":1}}],[\"老年代和永久代\",{\"1\":{\"930\":1}}],[\"老版本中提供的\",{\"1\":{\"922\":1}}],[\"老读者都知道\",{\"1\":{\"906\":1}}],[\"老板审批\",{\"1\":{\"865\":1}}],[\"老板让我这样写接口\",{\"1\":{\"175\":1}}],[\"老吕发现刚刚把小耀安排走了\",{\"1\":{\"153\":1}}],[\"老吕发现小耀最近没有项目安排\",{\"1\":{\"153\":1}}],[\"｜\",{\"1\":{\"175\":1}}],[\"跟随者状态\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"跟别人没有任何关系\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"跟缓存击穿解决思路一致\",{\"1\":{\"1203\":2,\"1383\":2}}],[\"跟踪技术\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"跟\",{\"1\":{\"988\":1}}],[\"跟我聊聊垃圾回收机制吧\",{\"1\":{\"936\":1}}],[\"跟我聊聊classes是如何加载到jvm中的\",{\"1\":{\"934\":1}}],[\"跟我们生活中的排队类似\",{\"1\":{\"282\":1}}],[\"跟provided\",{\"1\":{\"706\":1}}],[\"跟用户之间保持心跳通信以感知用户的状态\",{\"1\":{\"167\":1}}],[\"跟着下面视频一学就会\",{\"1\":{\"90\":1}}],[\"三个分区副本都是\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"三个方面\",{\"1\":{\"830\":1}}],[\"三次握手\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"三次握手和四次挥手\",{\"0\":{\"1134\":1,\"1327\":1}}],[\"三种快速创建springboot项目的方式\",{\"0\":{\"835\":1,\"836\":1}}],[\"三套\",{\"1\":{\"711\":1}}],[\"三\",{\"0\":{\"428\":1},\"1\":{\"460\":1}}],[\"三大功能\",{\"0\":{\"167\":1}}],[\"三级\",{\"0\":{\"57\":1,\"63\":1}}],[\"余下的非observer服务器都会讲自己的服务器状态变更为looking\",{\"1\":{\"166\":1}}],[\"优点\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"优势\",{\"0\":{\"593\":1},\"1\":{\"1165\":1,\"1353\":1}}],[\"优化\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"优化的基础是要了解\",{\"1\":{\"600\":1}}],[\"优化的磁盘i\",{\"1\":{\"503\":1}}],[\"优化器\",{\"1\":{\"527\":1}}],[\"优化单一表数据量过大而产生的性能问题\",{\"1\":{\"519\":1}}],[\"优化索引\",{\"1\":{\"515\":1}}],[\"优化索引的列顺序\",{\"1\":{\"510\":1}}],[\"优化迫在眉睫\",{\"1\":{\"515\":1}}],[\"优化表的操作可能会消耗大量的系统资源\",{\"1\":{\"511\":1}}],[\"优化表的存储引擎\",{\"1\":{\"511\":1}}],[\"优化查询语句\",{\"1\":{\"509\":1}}],[\"优化查询逻辑\",{\"1\":{\"504\":1}}],[\"优化if\",{\"0\":{\"172\":1}}],[\"优\",{\"1\":{\"501\":1}}],[\"优雅永不过时\",{\"1\":{\"172\":1}}],[\"优先加载\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"优先副本选举\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"优先比较zxid\",{\"1\":{\"166\":1}}],[\"优先检查zxid\",{\"1\":{\"166\":1}}],[\"优质原创资源会在这里归档\",{\"1\":{\"1\":1}}],[\"处理该请求并用\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"处理机制是通过类型擦除\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"处理读事件\",{\"1\":{\"1020\":1}}],[\"处理连接事件\",{\"1\":{\"1020\":1}}],[\"处理副本\",{\"1\":{\"1012\":2}}],[\"处理器和\",{\"1\":{\"956\":1}}],[\"处理\",{\"1\":{\"952\":1}}],[\"处理请求\",{\"1\":{\"950\":1,\"956\":2}}],[\"处理结果集\",{\"1\":{\"737\":1}}],[\"处理能力都有限\",{\"1\":{\"515\":1}}],[\"处理为一个个词项\",{\"1\":{\"443\":1}}],[\"处理投票\",{\"1\":{\"166\":2}}],[\"处理后的视频样式是在过滤处加磨砂处理\",{\"1\":{\"140\":1}}],[\"接受编译好的代码\",{\"1\":{\"713\":1}}],[\"接受\",{\"1\":{\"447\":1}}],[\"接受来自各个服务器的投票\",{\"1\":{\"166\":1}}],[\"接着就是给这个bean对象进行属性填充\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"接着返回文档给协调节点\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"接着说一下文档从接收到写入磁盘过程\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"接着\",{\"1\":{\"657\":1,\"898\":1}}],[\"接着再进行一次分配\",{\"1\":{\"375\":1}}],[\"接着继续进行上述过程\",{\"1\":{\"267\":1}}],[\"接下来我们拆解一下\",{\"1\":{\"1431\":1}}],[\"接下来用key的hash值与数组长度减一的值进行按位与操作\",{\"1\":{\"1120\":1,\"1315\":1}}],[\"接下来jvm该干嘛\",{\"1\":{\"934\":1}}],[\"接下来\",{\"1\":{\"913\":1,\"944\":1,\"1012\":1,\"1092\":1,\"1293\":1}}],[\"接下来可以写你想要展示的内容\",{\"1\":{\"910\":1}}],[\"接下来初始化网站目录\",{\"1\":{\"910\":1}}],[\"接下来实操如何发现处理死锁\",{\"1\":{\"581\":1}}],[\"接下来定义一个子文档\",{\"1\":{\"457\":1}}],[\"接下来对\",{\"1\":{\"429\":1}}],[\"接下来将这些桶子中的数值重新串接起来\",{\"1\":{\"375\":2}}],[\"接下来登陆进来\",{\"1\":{\"251\":1}}],[\"接下来给大家演示一些文件的操作\",{\"1\":{\"90\":1}}],[\"接口绑定有两种实现方式\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"接口绑定\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"接口里的方法是不能重载的\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"接口方法内的参数就是传递给\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"接口就是人们常说的\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"接口就能自定义分区策略\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"接口与之对应\",{\"0\":{\"1175\":1,\"1360\":1}}],[\"接口或者配置\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"接口呢\",{\"1\":{\"1022\":1}}],[\"接口之间的区别吗\",{\"1\":{\"1022\":1}}],[\"接口和一个\",{\"1\":{\"1016\":1}}],[\"接口来操作数据库\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"接口来编写插件\",{\"1\":{\"958\":1}}],[\"接口来自定义线程的创建方式\",{\"1\":{\"926\":1}}],[\"接口是\",{\"1\":{\"958\":1,\"1022\":1}}],[\"接口是做什么的\",{\"1\":{\"176\":1}}],[\"接口的执行方法中有一个\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"接口的方法名就是映射文件中\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"接口的方法就可以执行对应的\",{\"1\":{\"958\":1}}],[\"接口的全限名\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"接口的全路径一致\",{\"1\":{\"762\":1}}],[\"接口的工作原理是什么\",{\"0\":{\"1175\":1,\"1360\":1}}],[\"接口的一些特点包括\",{\"1\":{\"1022\":1}}],[\"接口的一些特点吗\",{\"1\":{\"1022\":1}}],[\"接口的代理对象\",{\"1\":{\"1016\":1}}],[\"接口的\",{\"1\":{\"826\":1,\"952\":2}}],[\"接口参数\",{\"1\":{\"689\":1}}],[\"接口日志\",{\"1\":{\"689\":1}}],[\"接口响应速度是每一个系统发展到中后期都会面临的一个问题\",{\"1\":{\"525\":1}}],[\"接口\",{\"1\":{\"591\":1,\"761\":1,\"786\":2,\"787\":1,\"793\":1,\"794\":1,\"795\":1,\"828\":1,\"830\":1,\"832\":1,\"924\":1,\"944\":2,\"952\":4,\"958\":2,\"1016\":2,\"1022\":1,\"1034\":1,\"1175\":1,\"1217\":1,\"1360\":1,\"1394\":1},\"2\":{\"187\":1,\"188\":1}}],[\"接口测试\",{\"0\":{\"185\":1}}],[\"接口安全\",{\"0\":{\"184\":1}}],[\"接口文档\",{\"1\":{\"183\":1,\"186\":1}}],[\"接口文档也要做出相应调整\",{\"1\":{\"182\":1}}],[\"接口文档需要提供接口示例\",{\"1\":{\"180\":1}}],[\"接口实例是为了帮助调用者理解接口的使用方法和调用流程\",{\"1\":{\"180\":1}}],[\"接口详细说明\",{\"0\":{\"179\":1}}],[\"接口地址的命名也要可以大概看出接口的作用\",{\"1\":{\"177\":1}}],[\"接口地址\",{\"1\":{\"177\":1}}],[\"接口路径规整\",{\"0\":{\"177\":1}}],[\"接口名称清晰\",{\"0\":{\"176\":1}}],[\"接口设计\",{\"1\":{\"1439\":1}}],[\"接口设计规范javapub\",{\"1\":{\"175\":1}}],[\"接口设计军规\",{\"1\":{\"175\":1}}],[\"接口设计这11点要注意\",{\"0\":{\"175\":1},\"1\":{\"175\":1}}],[\"接收消息\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"接收消息的逻辑\",{\"1\":{\"986\":1}}],[\"接收者可以从这些分区中读取消息\",{\"1\":{\"992\":1}}],[\"接收请求并相应结果\",{\"1\":{\"956\":1}}],[\"接收请求后会转交给\",{\"1\":{\"950\":1}}],[\"接收参数\",{\"1\":{\"763\":1}}],[\"接收来自各个服务器的投票\",{\"1\":{\"166\":1}}],[\"接收server2的投票为\",{\"1\":{\"166\":1}}],[\"若干\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"若能满足则按当前的申请量分配资源\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"若超过则拒绝分配资源\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"若有多个限定<\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"若有限定类型<\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"若有人说到了\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"若泛型类型没有指定具体类型\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"若添加多个\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"若节点已存在\",{\"1\":{\"922\":1}}],[\"若链表长度大于8\",{\"1\":{\"922\":1}}],[\"若产生冲突\",{\"1\":{\"922\":1}}],[\"若i位置为空\",{\"1\":{\"922\":1}}],[\"若开启驼峰\",{\"1\":{\"793\":1,\"794\":1}}],[\"若结果为\",{\"1\":{\"648\":1}}],[\"若等待超时抛出\",{\"1\":{\"648\":1}}],[\"若赋值\",{\"1\":{\"648\":1}}],[\"若数据量过大\",{\"0\":{\"548\":1}}],[\"若数据量极大\",{\"1\":{\"520\":1}}],[\"若只含数值信息的字段尽量不要设计为字符型\",{\"0\":{\"538\":1}}],[\"若太多则应考虑一些不常使用到的列上建的索引是否有必要\",{\"1\":{\"537\":1}}],[\"若映射规则设计的过于具体\",{\"1\":{\"350\":1}}],[\"若规则设计的过于模糊\",{\"1\":{\"350\":1}}],[\"若我们访问节点\",{\"1\":{\"270\":1}}],[\"若搜索\",{\"1\":{\"267\":1}}],[\"若部分加载到内存中则无法完成旋转操作\",{\"1\":{\"266\":1}}],[\"若某一时刻leader挂了\",{\"1\":{\"166\":1}}],[\"若进行leader选举\",{\"1\":{\"166\":1}}],[\"若设置为1有一个绿色的矩形\",{\"1\":{\"140\":1}}],[\"经典的鸡与鸡蛋场景\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"经典三连问\",{\"1\":{\"1046\":1,\"1255\":1}}],[\"经历了大型项目的使用和考验\",{\"1\":{\"1032\":1}}],[\"经理审批\",{\"1\":{\"865\":1}}],[\"经过重排序后如下\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"经过第一次minor\",{\"1\":{\"936\":1}}],[\"经过水平切分的优化\",{\"1\":{\"518\":1}}],[\"经过如上分析\",{\"1\":{\"82\":1}}],[\"经纬度类型可以表达一个点\",{\"1\":{\"454\":1}}],[\"经纬度类型字段\",{\"1\":{\"453\":1}}],[\"经纬度类型\",{\"0\":{\"453\":1}}],[\"经纬度类型和地理区域类型\",{\"1\":{\"452\":1}}],[\"经测试\",{\"1\":{\"388\":1}}],[\"经常温习查阅\",{\"1\":{\"1026\":1,\"1030\":1,\"1041\":1,\"1056\":1,\"1067\":1,\"1083\":1,\"1097\":1,\"1111\":1,\"1126\":1,\"1141\":1,\"1155\":1,\"1171\":1,\"1184\":1,\"1197\":1,\"1210\":1,\"1223\":1,\"1236\":1,\"1249\":1}}],[\"经常会出现对象之间的多重依赖性关系\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"经常会遇到线程安全的问题\",{\"1\":{\"924\":1}}],[\"经常会使用blockingqueue来充当缓冲区的角色\",{\"1\":{\"164\":1}}],[\"经常组合查询的列放在一张表中\",{\"1\":{\"516\":1}}],[\"经常根据username或email字段查询的用户表\",{\"1\":{\"502\":1}}],[\"经常需要全局唯一的id作为数据库主键\",{\"1\":{\"382\":1}}],[\"跨站请求伪造\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"跨域资源共享\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"跨域指的是浏览器不能执行其它网站的脚本\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"跨平台\",{\"1\":{\"699\":1}}],[\"跨度\",{\"1\":{\"628\":1}}],[\"跨网络的共享资源似乎就无能为力了\",{\"1\":{\"163\":1}}],[\"跨主机\",{\"1\":{\"163\":1}}],[\"场景\",{\"0\":{\"723\":1},\"1\":{\"779\":1,\"783\":1,\"784\":1,\"785\":1,\"787\":1,\"916\":1}}],[\"场景四\",{\"0\":{\"165\":1}}],[\"场景三\",{\"0\":{\"164\":1}}],[\"场景二\",{\"0\":{\"163\":1},\"1\":{\"786\":1,\"1092\":1,\"1293\":1}}],[\"场景一\",{\"0\":{\"162\":1},\"1\":{\"786\":1,\"1092\":1,\"1293\":1}}],[\"消耗内存\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"消耗法力\",{\"1\":{\"329\":1}}],[\"消除了冗余代码\",{\"1\":{\"1173\":1,\"1358\":1}}],[\"消除\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"消费端的消费线程数是和分区数挂钩的\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"消费产品\",{\"1\":{\"988\":1}}],[\"消费者只能消费到这四条消息\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"消费者组之间互不影响\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"消费者组内每个消费者负责消费不同分区的数据\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"消费者组\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"消费者组id和反序列化器\",{\"1\":{\"990\":1}}],[\"消费者需要定期拉取消息以确保不会错过任何重要的数据\",{\"1\":{\"990\":1}}],[\"消费者代码\",{\"1\":{\"990\":1}}],[\"消费者可以订阅一个或多个topic\",{\"1\":{\"984\":1}}],[\"消费者\",{\"1\":{\"159\":1,\"986\":1,\"1159\":1,\"1347\":1}}],[\"消息广播\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"消息实际上是分布式存储在一个一个小的\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"消息发送的方式\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"消息偏移量\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"消息m3发送到p3\",{\"1\":{\"992\":1}}],[\"消息m2发送到p2\",{\"1\":{\"992\":1}}],[\"消息进行处理\",{\"1\":{\"990\":1}}],[\"消息队列是大型网站必用中间件\",{\"1\":{\"594\":1}}],[\"消息系统\",{\"1\":{\"594\":1,\"1158\":1,\"1199\":1,\"1346\":1,\"1379\":1}}],[\"消息的发布与订阅\",{\"1\":{\"153\":1}}],[\"状态信息\",{\"1\":{\"1431\":1}}],[\"状态标识\",{\"1\":{\"829\":1}}],[\"状态\",{\"1\":{\"158\":1,\"723\":1,\"918\":1,\"1239\":1,\"1412\":1}}],[\"组织\",{\"1\":{\"705\":1,\"838\":1,\"839\":1}}],[\"组成了\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"组成一个\",{\"1\":{\"658\":1}}],[\"组成\",{\"1\":{\"416\":1,\"712\":1,\"1159\":1,\"1160\":1,\"1347\":1,\"1348\":1}}],[\"组服务等\",{\"1\":{\"154\":1}}],[\"组件\",{\"0\":{\"39\":1,\"46\":1},\"1\":{\"46\":1,\"837\":1}}],[\"能直接关联到的对象\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"能keyword类型尽量keyword\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"能够将一个客户端应用于\",{\"1\":{\"1245\":1,\"1418\":1}}],[\"能够轻松地提供先入先出的操作\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"能够使用极少的内存来统计巨量的数据\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"能够在\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"能够提供数据强一致性\",{\"1\":{\"153\":1}}],[\"能和真正缓存的数据区分开\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"能解释清楚cas的aba问题\",{\"1\":{\"1018\":1}}],[\"能给我解释一下吗\",{\"1\":{\"986\":1}}],[\"能给出源码分析吗\",{\"1\":{\"964\":1}}],[\"能在方法中完成什么样的逻辑处理\",{\"1\":{\"952\":1}}],[\"能达到如此水平的理解\",{\"1\":{\"940\":1}}],[\"能看出g1的创新之处\",{\"1\":{\"940\":1}}],[\"能否简单提一下\",{\"1\":{\"948\":1}}],[\"能否解析一下\",{\"1\":{\"948\":1}}],[\"能否解释什么是位图索引\",{\"0\":{\"505\":1}}],[\"能否直接写接口\",{\"1\":{\"761\":1}}],[\"能对maven有一个完整的了解\",{\"1\":{\"698\":1}}],[\"能对不同业务的数据进行分级管理\",{\"1\":{\"517\":1}}],[\"能实现一个简单的消息队列系统\",{\"1\":{\"594\":1}}],[\"能读的速度是110000次\",{\"1\":{\"593\":1}}],[\"能读出的索引值更多\",{\"1\":{\"270\":1}}],[\"能用\",{\"1\":{\"529\":1}}],[\"能不会使用索引\",{\"1\":{\"501\":1}}],[\"能胜任上百个服务节点的扩展\",{\"1\":{\"400\":1}}],[\"能自动剔除\",{\"1\":{\"106\":1}}],[\"谁知道\",{\"1\":{\"917\":1}}],[\"谁干\",{\"1\":{\"917\":1}}],[\"谁能顶得住\",{\"0\":{\"551\":1},\"1\":{\"551\":1}}],[\"谁能顶住\",{\"0\":{\"492\":1},\"1\":{\"492\":1}}],[\"谁能把这个数据同步的时间压缩的更短\",{\"1\":{\"153\":1}}],[\"谁就更出色\",{\"1\":{\"153\":1}}],[\"谁的请求响应就更快\",{\"1\":{\"153\":1}}],[\"再看\",{\"1\":{\"1431\":2}}],[\"再提交offset\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"再交由\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"再把字节码加载到内存中\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"再把修改后的结果放回到主内存中\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"再打印c\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"再继续执行\",{\"1\":{\"1104\":2,\"1302\":2}}],[\"再判断这个请求所用到的缓存是否过期\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"再更新缓存\",{\"1\":{\"1050\":2,\"1259\":2}}],[\"再写数据库\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"再回写到内存\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"再悲观锁\",{\"1\":{\"1018\":1}}],[\"再用这个临时文件替换上次持久化好的文件\",{\"1\":{\"962\":1}}],[\"再由\",{\"1\":{\"956\":1}}],[\"再从\",{\"1\":{\"954\":1}}],[\"再进行业务操作\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"再进行resize\",{\"1\":{\"922\":1}}],[\"再进行修改\",{\"1\":{\"620\":1}}],[\"再使用\",{\"1\":{\"916\":1}}],[\"再使用此配置创建索引\",{\"1\":{\"438\":1}}],[\"再通过项目里指定的路径及可找到日志文件\",{\"1\":{\"856\":1}}],[\"再次感谢面试官\",{\"1\":{\"922\":1}}],[\"再次强调它们是相互独立的\",{\"1\":{\"711\":1}}],[\"再次修改我们的代码\",{\"1\":{\"692\":1}}],[\"再谈redis\",{\"0\":{\"614\":1}}],[\"再将后续的操作以aof的格式存入文件当中\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"再将工作区的内容取出来\",{\"1\":{\"916\":1}}],[\"再将结果保存成新的字符串\",{\"1\":{\"603\":1}}],[\"再将堆顶元素8与末尾元素5进行交换\",{\"1\":{\"364\":1}}],[\"再高大上的框架\",{\"1\":{\"522\":1}}],[\"再考虑水平分库水平分表方案\",{\"1\":{\"520\":1}}],[\"再加一次校验\",{\"1\":{\"488\":1}}],[\"再加上机械运动耗费\",{\"1\":{\"274\":1}}],[\"再简单总结下堆排序的基本思路\",{\"1\":{\"364\":1}}],[\"再分别对两个桶进行排序\",{\"1\":{\"348\":1}}],[\"再找对应位置是否为1即可\",{\"1\":{\"333\":1,\"339\":1}}],[\"再第二个字母等等\",{\"1\":{\"266\":1}}],[\"再比较myid\",{\"1\":{\"166\":2}}],[\"再给查询请求返回信息\",{\"1\":{\"153\":1}}],[\"再在工作中茁壮成长\",{\"1\":{\"100\":1}}],[\"小的账户上的锁\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"小的数据集精度是非常高的\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"小结\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"小王\",{\"1\":{\"972\":1,\"994\":1,\"1219\":1,\"1396\":1,\"1431\":1}}],[\"小伙子\",{\"1\":{\"936\":1,\"938\":1,\"942\":1,\"946\":1,\"948\":1,\"952\":1,\"954\":1,\"966\":1,\"984\":1}}],[\"小李马不停蹄\",{\"1\":{\"916\":1}}],[\"小明\",{\"1\":{\"736\":1,\"986\":1,\"994\":1,\"996\":2,\"1177\":3,\"1219\":1,\"1362\":3,\"1396\":1}}],[\"小薅养活妻儿\",{\"1\":{\"481\":1}}],[\"小写处理\",{\"1\":{\"411\":3}}],[\"小顶堆\",{\"1\":{\"364\":1}}],[\"小于500元\",{\"1\":{\"865\":1}}],[\"小于号引起的问题\",{\"1\":{\"800\":1}}],[\"小于号\",{\"1\":{\"800\":1}}],[\"小于\",{\"1\":{\"267\":1}}],[\"小于设置值的文件将不会压缩\",{\"1\":{\"106\":1}}],[\"小西过来问leader02要人\",{\"1\":{\"153\":1}}],[\"同其他的代码块一样\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"同为\",{\"1\":{\"940\":1}}],[\"同意\",{\"1\":{\"866\":1}}],[\"同整数集合一样压缩列表也不是基础数据结构\",{\"1\":{\"632\":1}}],[\"同步队列\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"同步和异步\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"同步和异步在于第二个\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"同步非阻塞io\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"同步阻塞io\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"同步工作的流程如下\",{\"1\":{\"964\":1}}],[\"同步阶段+命令传播阶段\",{\"1\":{\"964\":1}}],[\"同步块大家都比较熟悉\",{\"1\":{\"692\":1}}],[\"同步块\",{\"1\":{\"692\":1}}],[\"同步对读取操作的可扩展性和数据冗余很有帮助\",{\"1\":{\"589\":1}}],[\"同步\",{\"1\":{\"589\":1}}],[\"同义词词库\",{\"1\":{\"414\":1}}],[\"同一分区的不同副本保存的是相同的消息\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"同一个\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"同一个位置上出现8个元素的概率已经接近千分之一了\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"同一个类中\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"同一个事务\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"同一个地方不能同时存在两个同名注解\",{\"1\":{\"944\":1}}],[\"同一个namespace中查询sql可以从缓存中命中\",{\"1\":{\"790\":1}}],[\"同一个session中\",{\"1\":{\"789\":1}}],[\"同一个字段的值\",{\"1\":{\"440\":1}}],[\"同一时间只让一个线程构建缓存\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"同一时间截\",{\"1\":{\"388\":1}}],[\"同一时刻只能有一个线程能够用\",{\"1\":{\"692\":1}}],[\"同一机器\",{\"1\":{\"388\":1}}],[\"同一台服务器所有生成的id按时间趋势递增\",{\"1\":{\"387\":1}}],[\"同样是在需要乐观锁控制的table中增加一个字段\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"同样地\",{\"1\":{\"924\":1}}],[\"同样需要使用hash函数\",{\"1\":{\"333\":1}}],[\"同样的sql再另一台数据库再执行一次\",{\"1\":{\"383\":1}}],[\"同样的\",{\"1\":{\"153\":1}}],[\"同时在数据库中也不存在\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"同时负责查询缓存的维护\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"同时减少代码中的硬编码\",{\"1\":{\"1002\":1}}],[\"同时处理多个客户端请求等等\",{\"1\":{\"988\":1}}],[\"同时下载多个文件\",{\"1\":{\"988\":1}}],[\"同时还支持消息的批量处理和压缩\",{\"1\":{\"980\":1}}],[\"同时还提供\",{\"1\":{\"592\":1}}],[\"同时开始缓冲从服务器断开期间产生的写命令\",{\"1\":{\"964\":1}}],[\"同时主服务器也发送从服务器连接后产生的写命令给从服务器\",{\"1\":{\"964\":1}}],[\"同时清空survivor区1\",{\"1\":{\"930\":1}}],[\"同时也会诞生各种各样的奇葩需求\",{\"1\":{\"1439\":1}}],[\"同时也会写入到\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"同时也可以在集群中再使用\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"同时也可以自定义开发非官方提供的exporter\",{\"1\":{\"883\":1}}],[\"同时也提高了数据操作的并行度\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"同时也发送缓冲的写命令\",{\"1\":{\"964\":1}}],[\"同时也方便进行删除操作\",{\"1\":{\"922\":1}}],[\"同时也解决了\",{\"1\":{\"288\":1}}],[\"同时将多个\",{\"1\":{\"605\":1}}],[\"同时redis\",{\"1\":{\"593\":1}}],[\"同时能提高整体架构的业务清晰度\",{\"1\":{\"520\":1}}],[\"同时记录下哪些文档包含这个单词\",{\"1\":{\"425\":1}}],[\"同时shard分布在多台node上\",{\"1\":{\"421\":1}}],[\"同时相隔\",{\"1\":{\"387\":1}}],[\"同时可以自主选择恰当的排序算法对桶进行排序\",{\"1\":{\"348\":1}}],[\"同时\",{\"1\":{\"348\":1,\"926\":1,\"1049\":1,\"1206\":1,\"1258\":1,\"1386\":1}}],[\"同时加上\",{\"1\":{\"134\":1}}],[\"同时每个页面包含\",{\"1\":{\"23\":1}}],[\"人会停止翻页\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"人家自动给你按照时间排序了\",{\"1\":{\"657\":1}}],[\"人都被你们产品要走了\",{\"1\":{\"153\":1}}],[\"人工智能\",{\"0\":{\"64\":1}}],[\"于是用了转义字符把>和<替换掉\",{\"1\":{\"800\":1}}],[\"于是就想到了特殊符号\",{\"1\":{\"800\":1}}],[\"于是就跟小西说\",{\"1\":{\"153\":1}}],[\"于是我们可以建立一个长度为11的数组\",{\"1\":{\"359\":1}}],[\"于是更新自己的投票为\",{\"1\":{\"166\":1}}],[\"于是进入leader选举过程\",{\"1\":{\"166\":1}}],[\"于是把小耀安排给了小饼的项目\",{\"1\":{\"153\":1}}],[\"过程中\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"过程不影响服务\",{\"1\":{\"962\":1}}],[\"过程并不是一次性地完成的\",{\"1\":{\"625\":1,\"626\":1}}],[\"过于复杂或\",{\"1\":{\"950\":1}}],[\"过期的话就去底层系统得到新数据并更新缓存\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"过期\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"过期机制\",{\"1\":{\"615\":1}}],[\"过期等等特性\",{\"1\":{\"593\":1}}],[\"过多的索引会增加数据库的维护成本\",{\"1\":{\"510\":1}}],[\"过完这个节\",{\"1\":{\"493\":1,\"552\":1}}],[\"过滤器\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"过滤器类型\",{\"1\":{\"455\":1}}],[\"过滤器的使用\",{\"0\":{\"137\":1}}],[\"过了一会\",{\"1\":{\"153\":1}}],[\"看需求有没有技术难点\",{\"1\":{\"1439\":1}}],[\"看作是一把锁\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"看日志可以发现就是直接把值拼接上去了\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"看日志我们可以看到解析时将\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"看做一台\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"看一下官方说明\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"看一下我们的仓库\",{\"1\":{\"913\":1}}],[\"看过可能在短暂的面试后又马上忘记了\",{\"1\":{\"1026\":1,\"1030\":1,\"1041\":1,\"1056\":1,\"1067\":1,\"1083\":1,\"1097\":1,\"1111\":1,\"1126\":1,\"1141\":1,\"1155\":1,\"1171\":1,\"1184\":1,\"1197\":1,\"1210\":1,\"1223\":1,\"1236\":1,\"1249\":1}}],[\"看起来很简单\",{\"1\":{\"986\":1}}],[\"看起来很简单明了\",{\"1\":{\"970\":1}}],[\"看来你使用的很好\",{\"1\":{\"1022\":1}}],[\"看来你对\",{\"1\":{\"954\":1,\"956\":1}}],[\"看来你之前真的有认真研读与理解\",{\"1\":{\"946\":1}}],[\"看来你在这方面下了不少功夫\",{\"1\":{\"940\":1}}],[\"看来有点东西\",{\"1\":{\"938\":1}}],[\"看成是一个\",{\"1\":{\"658\":1}}],[\"看到\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"看到这个名字就知道是经纬度坐标相关\",{\"1\":{\"660\":1}}],[\"看到这里\",{\"1\":{\"628\":1}}],[\"看到一个比较靠谱的例子\",{\"1\":{\"153\":1}}],[\"看后不忘三连\",{\"1\":{\"608\":1}}],[\"看哪一种方法的效果更好\",{\"1\":{\"546\":1}}],[\"看\",{\"1\":{\"488\":1,\"1165\":1,\"1353\":1}}],[\"看下边一个例子\",{\"1\":{\"358\":1}}],[\"看下边原理很容易理解\",{\"1\":{\"357\":1}}],[\"看名字就知是数据目录\",{\"1\":{\"157\":1}}],[\"看看他有哪些功能\",{\"1\":{\"112\":1}}],[\"欢迎使用\",{\"1\":{\"1431\":1}}],[\"欢迎来到我们的面试\",{\"1\":{\"968\":1,\"974\":1,\"980\":1,\"998\":1,\"1000\":1,\"1004\":1,\"1006\":1}}],[\"欢迎来我公众号\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"648\":1,\"698\":1}}],[\"欢迎观赏\",{\"1\":{\"668\":1}}],[\"欢迎大家前来白嫖pdf\",{\"1\":{\"586\":1}}],[\"欢迎大家分享\",{\"1\":{\"521\":1}}],[\"欢迎关注公众号\",{\"1\":{\"368\":1,\"732\":1}}],[\"欢迎加入\",{\"1\":{\"49\":1}}],[\"声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"声明式事务管理建立在aop之上的\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"声明式事务\",{\"1\":{\"818\":1}}],[\"声明该类为一个注解类\",{\"1\":{\"689\":1}}],[\"声明队列接口queue\",{\"1\":{\"287\":1}}],[\"声明\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"641\":1,\"698\":1,\"732\":1}}],[\"直播视频和源码详细介绍\",{\"1\":{\"1429\":1}}],[\"直播相关\",{\"0\":{\"146\":1}}],[\"直至第一次使用调用getbean方法才会抛出异常\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"直至容器关闭\",{\"1\":{\"950\":1}}],[\"直到最后一个到达\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"直到该锁被释放\",{\"1\":{\"1022\":4,\"1023\":1}}],[\"直到达到最大重试次数\",{\"1\":{\"994\":1}}],[\"直到有产品生产\",{\"1\":{\"988\":1}}],[\"直到产品被消费\",{\"1\":{\"988\":1}}],[\"直到其他线程调用\",{\"1\":{\"988\":1}}],[\"直到所有线程都到达这个点后再一起继续执行\",{\"1\":{\"932\":1}}],[\"直到看到\",{\"1\":{\"913\":1}}],[\"直到事务完成\",{\"1\":{\"575\":1}}],[\"直到事务结束才释放锁\",{\"1\":{\"570\":1,\"573\":1}}],[\"直到锁被释放\",{\"1\":{\"565\":1}}],[\"直到持有排他锁的事务结束\",{\"1\":{\"555\":1}}],[\"直到当前事务结束\",{\"1\":{\"555\":1}}],[\"直到获得新的时间戳\",{\"1\":{\"388\":1}}],[\"直到找到该\",{\"1\":{\"267\":1}}],[\"直接往arraylist中添加元素的时间复杂度是o\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"直接读取的就是缓存的数据\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"直接返回\",{\"1\":{\"1023\":2}}],[\"直接返回对象\",{\"1\":{\"82\":1}}],[\"直接发送下一条消息\",{\"1\":{\"994\":1}}],[\"直接点下一道菜\",{\"1\":{\"994\":1}}],[\"直接从\",{\"1\":{\"954\":1}}],[\"直接清除\",{\"1\":{\"938\":1}}],[\"直接清除标记的垃圾对象\",{\"1\":{\"938\":1}}],[\"直接新建节点添加\",{\"1\":{\"922\":1}}],[\"直接\",{\"1\":{\"917\":1}}],[\"直接使用注解指定传入参数名称\",{\"1\":{\"763\":2,\"779\":4}}],[\"直接使用下面方式\",{\"1\":{\"132\":1}}],[\"直接按照类别排除\",{\"1\":{\"710\":1}}],[\"直接根据id去到对应的内容页即可\",{\"1\":{\"594\":1}}],[\"直接用\",{\"1\":{\"499\":1}}],[\"直接将输入当作输出\",{\"1\":{\"411\":1}}],[\"直接遍历数组\",{\"1\":{\"359\":1}}],[\"直接插入排序\",{\"0\":{\"296\":1}}],[\"直接申请页大小的空间\",{\"1\":{\"266\":1}}],[\"表达式\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"表达式直接获取上下文中对象的属性值\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"表达式可以定义为切某个注解\",{\"1\":{\"689\":1}}],[\"表明当前服务器角色是\",{\"1\":{\"1239\":3,\"1412\":3}}],[\"表明这是一个切面类\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"表明这个类不能有任何的子类\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"表明事务有意向在id为10到20的范围内插入新行\",{\"1\":{\"558\":1}}],[\"表现逻辑的分离\",{\"1\":{\"950\":1}}],[\"表方案\",{\"1\":{\"922\":1}}],[\"表实现\",{\"1\":{\"922\":1}}],[\"表关系说明\",{\"0\":{\"792\":1}}],[\"表被用作列表键和哈希键的底层实现之一\",{\"1\":{\"633\":1}}],[\"表是redis为节约内存自己设计的一种顺序型数据结构\",{\"1\":{\"633\":1}}],[\"表尾节点指针\",{\"1\":{\"622\":1}}],[\"表尾节点\",{\"1\":{\"621\":1,\"629\":1}}],[\"表头节点和表尾节点\",{\"1\":{\"628\":1}}],[\"表头节点\",{\"1\":{\"621\":1}}],[\"表锁是一种粗粒度的锁\",{\"1\":{\"574\":1}}],[\"表锁是锁定整个表\",{\"1\":{\"565\":1}}],[\"表锁是锁定整个表的锁\",{\"1\":{\"561\":1}}],[\"表锁适用于全表操作\",{\"1\":{\"567\":1}}],[\"表锁最低\",{\"1\":{\"567\":1}}],[\"表锁期间\",{\"1\":{\"565\":1}}],[\"表锁影响整个表的所有数据\",{\"1\":{\"561\":1}}],[\"表锁通常用于批量操作\",{\"1\":{\"561\":1}}],[\"表锁和页锁是两种不同粒度的锁\",{\"1\":{\"561\":1}}],[\"表锁\",{\"0\":{\"561\":1,\"563\":1,\"565\":1},\"1\":{\"561\":2,\"567\":1}}],[\"表粒度锁\",{\"1\":{\"557\":1}}],[\"表\",{\"1\":{\"511\":1}}],[\"表来获取索引信息\",{\"1\":{\"506\":1}}],[\"表里的\",{\"1\":{\"501\":1}}],[\"表式使用\",{\"1\":{\"145\":1}}],[\"表式无损压缩\",{\"1\":{\"145\":1}}],[\"表示收到客户端取消请求\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"表示让一个线程进入睡眠状态\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"表示该线程已经执行完毕\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"表示线程阻塞于锁\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"表示消息在该分区中的位置\",{\"1\":{\"984\":1}}],[\"表示任何类型\",{\"1\":{\"966\":1}}],[\"表示从t到父类型的范围\",{\"1\":{\"966\":1}}],[\"表示从t到子类型的范围\",{\"1\":{\"966\":1}}],[\"表示从\",{\"1\":{\"966\":1}}],[\"表示从其它的pom中导入dependency的配置\",{\"1\":{\"706\":1}}],[\"表示全类型通配\",{\"1\":{\"966\":1}}],[\"表示接受任何类型\",{\"1\":{\"966\":1}}],[\"表示转移该分支的最新提交\",{\"1\":{\"917\":1}}],[\"表示使用什么编程语言\",{\"1\":{\"837\":1}}],[\"表示使用什么构建工具\",{\"1\":{\"837\":1}}],[\"表示使nginx阻止http应答代码为400或者更高的应答\",{\"1\":{\"106\":1}}],[\"表示更新的记录行数\",{\"1\":{\"826\":1}}],[\"表示集中的存储的元素类型\",{\"1\":{\"797\":1}}],[\"表示删除开头的或结尾的\",{\"1\":{\"724\":1}}],[\"表示会用\",{\"1\":{\"724\":1}}],[\"表示在\",{\"1\":{\"724\":1}}],[\"表示向下传递\",{\"1\":{\"708\":1}}],[\"表示一个元素的二值状态\",{\"1\":{\"658\":1}}],[\"表示永不超时\",{\"1\":{\"648\":1}}],[\"表示不被限制\",{\"1\":{\"648\":1}}],[\"表示支持\",{\"1\":{\"488\":1}}],[\"表示\",{\"1\":{\"166\":1,\"625\":2,\"966\":2}}],[\"表示这个服务器与集群中的leader服务器交换信息的端口\",{\"1\":{\"157\":1}}],[\"表示这个是第几号服务器\",{\"1\":{\"157\":1}}],[\"表示音频编码器\",{\"1\":{\"145\":1}}],[\"表示视频编码器\",{\"1\":{\"145\":1}}],[\"表示每一秒几帧\",{\"1\":{\"141\":1}}],[\"表示要切多少\",{\"1\":{\"129\":1}}],[\"表示开始切割时间\",{\"1\":{\"129\":1}}],[\"桌面的输入对帧率没有要求\",{\"1\":{\"145\":1}}],[\"而类b通过构造函数注入需要类a的实例\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"而applicationcontext则是自动注册\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"而arraylist在并发环境下可能会出现线程安全问题\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"而预期的回调doinstatement\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"而数据根据\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"而数据节点则负责存储和处理数据\",{\"1\":{\"1004\":1}}],[\"而查询数据量巨大\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"而老的主题分区不会分配在该\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"而这时\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"而这个过程中需要调用其他语言的本地库接口\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"而这些子任务之间是相互独立的\",{\"1\":{\"932\":1}}],[\"而字节码文件只是\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"而本地方法栈则是为虚拟机使用到的native方法服务\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"而虚拟机栈\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"而拦截器能够深入到方法前后\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"而拦截器是在\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"而拦截器既可以用于web程序\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"而jsp无需配置\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"而servlet主要用在控制层\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"而servlet并没有将两者分开\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"而servlet是在java代码中写html代码\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"而fast\",{\"1\":{\"1246\":1,\"1419\":1}}],[\"而fail\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"而filter则不能\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"而follower副本则用于备份和提供冗余\",{\"1\":{\"986\":1}}],[\"而linkedlist常常被用作queue队列的实现类\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"而linux的namespace机制是一种资源隔离方案\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"而非物理分页\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"而非公平锁则不能保证这一点\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"而非叶子节点只保存索引值\",{\"1\":{\"264\":1}}],[\"而后再进行io操作\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"而i3和i4则是分别指向不同的对象\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"而i3和i4指向的是不同的对象\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"而int则是直接存储数据值\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"而int变量不需要\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"而没办法去知道具体的内容是什么\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"而另一个\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"而进>程中有相应的消费者消费该消息\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"而实际业务场景下\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"而实际类型参数apple是在实例化box时实际替换类型参数t的类型\",{\"1\":{\"966\":1}}],[\"而我们平时说的缓存\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"而我对它们的理解还远未充分\",{\"1\":{\"948\":1}}],[\"而一个eventloopgroup会包含多个eventloop\",{\"1\":{\"1034\":1}}],[\"而锁标志位则被存储在一个单独的数据结构中\",{\"1\":{\"1022\":1}}],[\"而服务器可以使用一个选择器来监控所有的通道\",{\"1\":{\"1020\":2}}],[\"而乐观锁由cas这样的原子操作实现\",{\"1\":{\"1018\":1}}],[\"而乐观锁可以让多个线程同时访问数据\",{\"1\":{\"1018\":1}}],[\"而动态代理可以代理多个类或接口\",{\"1\":{\"1016\":1}}],[\"而动态代理可以自动生成代理类\",{\"1\":{\"1016\":1}}],[\"而动态代理是在运行时动态地创建代理对象\",{\"1\":{\"1016\":1}}],[\"而副本则是分片的复制\",{\"1\":{\"1012\":1}}],[\"而elasticsearch倒排索引就是搜索引擎的一种核心技术\",{\"1\":{\"1006\":1}}],[\"而分片就像是把一本大书分成多个小册子\",{\"1\":{\"1004\":1}}],[\"而映射则定义了文档的结构和字段类型\",{\"1\":{\"998\":1}}],[\"而当我们搜索关键字时\",{\"1\":{\"1004\":1}}],[\"而当设置为all时\",{\"1\":{\"994\":1}}],[\"而当consumer请求消息时\",{\"1\":{\"986\":1}}],[\"而每个分区又可以有多个副本\",{\"1\":{\"984\":1}}],[\"而每个哈希表节点就保存了字典中的一个键值对\",{\"1\":{\"624\":1}}],[\"而消费者\",{\"1\":{\"990\":1}}],[\"而消费者则订阅这些主题并从中读取消息\",{\"1\":{\"980\":1}}],[\"而消费者就像是咖啡师\",{\"1\":{\"974\":1}}],[\"而kafka可以作为事件的中心枢纽\",{\"1\":{\"976\":1}}],[\"而kafka可以作为数据流的中转站\",{\"1\":{\"976\":1}}],[\"而kafka可以帮助我们高效地收集\",{\"1\":{\"976\":1}}],[\"而从节点负责复制主节点的数据\",{\"1\":{\"968\":1}}],[\"而在直接引用直接指向内存中的地址\",{\"1\":{\"1148\":1,\"1339\":1}}],[\"而在非阻塞方式里\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"而在使用pull模式时\",{\"1\":{\"990\":1}}],[\"而在消费者部分\",{\"1\":{\"990\":1}}],[\"而在一些读操作的泛型方法中\",{\"1\":{\"966\":1}}],[\"而在表的后端进行插入操作\",{\"1\":{\"282\":1}}],[\"而泛型方法的类型参数只在这个方法内有效\",{\"1\":{\"966\":1}}],[\"而泛型类不能有静态方法和静态属性\",{\"1\":{\"966\":1}}],[\"而泛型类是在定义类本身时指定类型参数\",{\"1\":{\"966\":1}}],[\"而泛型类在实例化的时候才能确定类型参数的实际类型\",{\"1\":{\"966\":1}}],[\"而<\",{\"1\":{\"966\":1}}],[\"而其他作用域的\",{\"1\":{\"952\":1}}],[\"而双向链表用于存储等待线程的队列\",{\"1\":{\"932\":1}}],[\"而唤醒线程的操作是通过\",{\"1\":{\"932\":1}}],[\"而如果发生宕机的\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"而如果我们有一个任务需要分成多个阶段来执行\",{\"1\":{\"932\":1}}],[\"而如果整个队列全部存满数据那么\",{\"1\":{\"288\":1}}],[\"而又积极主动寻求解决之道\",{\"1\":{\"922\":1}}],[\"而使用\",{\"1\":{\"916\":1}}],[\"而第二段则是\",{\"1\":{\"838\":1,\"839\":1}}],[\"而maven本身还支持多种插件\",{\"1\":{\"698\":1}}],[\"而msd则相反\",{\"1\":{\"374\":1}}],[\"而并非从主内存中取值\",{\"1\":{\"692\":1}}],[\"而并发场景一定会发生资源竞争\",{\"1\":{\"552\":1}}],[\"而vt线程在进行判断flag的时候拿到的仍然是false\",{\"1\":{\"692\":1}}],[\"而检查一个键的类型就是检查键的值对象的类型\",{\"1\":{\"636\":1}}],[\"而无需去读取\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"而无需进行同步操作\",{\"1\":{\"1022\":3,\"1023\":2}}],[\"而无需进行繁琐的读写操作\",{\"1\":{\"1020\":1}}],[\"而无需进行回表操作\",{\"1\":{\"504\":1}}],[\"而无须为\",{\"1\":{\"619\":1}}],[\"而磁盘的速度相对内存来说慢很多\",{\"1\":{\"616\":1}}],[\"而磁盘在\",{\"1\":{\"266\":1}}],[\"而对于数字型而言只需要比较一次就够了\",{\"1\":{\"538\":1}}],[\"而对于我们的innodb存储引擎也有自己的最小储存单元\",{\"1\":{\"272\":1}}],[\"而大字段占用空间大\",{\"1\":{\"516\":1}}],[\"而二叉树需要进行中序遍历才能得到有序的结果\",{\"1\":{\"503\":1}}],[\"而二叉树不具备这种空间局部性\",{\"1\":{\"503\":1}}],[\"而二叉树在最坏情况下\",{\"1\":{\"503\":1}}],[\"而唯一索引则不能被其他表用作外键\",{\"1\":{\"496\":1}}],[\"而单词在某个文档中出现的位置信息并非索引系统一定要记录的\",{\"1\":{\"425\":1}}],[\"而不用从头重建索引\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"而不用二叉树\",{\"0\":{\"503\":1}}],[\"而不需要使用锁\",{\"1\":{\"1022\":1}}],[\"而不需要遍历所有文档\",{\"1\":{\"1006\":1}}],[\"而不需要一页一页地找\",{\"1\":{\"1006\":1}}],[\"而不需要逐个文档地搜索\",{\"1\":{\"1006\":1}}],[\"而不需要花费精力去处理加载驱动\",{\"1\":{\"958\":1}}],[\"而不需要访问数据表的行\",{\"1\":{\"504\":1}}],[\"而不直接与间隙锁冲突\",{\"1\":{\"558\":1}}],[\"而不是程序出错\",{\"1\":{\"1431\":1}}],[\"而不是全表扫描\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"而不是数据窃取\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"而不是仅仅依赖于消息的key\",{\"1\":{\"996\":1}}],[\"而不是立即将其传递给接收者\",{\"1\":{\"992\":1}}],[\"而不是最新的值\",{\"1\":{\"924\":1}}],[\"而不是等到线程结束或者\",{\"1\":{\"924\":1}}],[\"而不是使用\",{\"1\":{\"924\":1}}],[\"而不是使用select\",{\"1\":{\"504\":1}}],[\"而不是把时间浪费在学习如何在不同的环境中去依赖jar包\",{\"1\":{\"698\":1}}],[\"而不是从一个线程调用\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"而不是从\",{\"1\":{\"692\":1}}],[\"而不是新创建对象\",{\"1\":{\"635\":1}}],[\"而不是检测冲突\",{\"1\":{\"570\":1}}],[\"而不是整个表\",{\"1\":{\"561\":1}}],[\"而不是直接通过索引就能获取到所需的数据\",{\"1\":{\"504\":1}}],[\"而不是指向数据的指针\",{\"1\":{\"497\":1}}],[\"而不是\",{\"1\":{\"436\":1}}],[\"而不是1\",{\"1\":{\"387\":1}}],[\"而不能删除数据\",{\"1\":{\"334\":1}}],[\"而重建堆的过程中\",{\"1\":{\"364\":1}}],[\"而是一种思想\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"而是一个\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"而是依次去请求父类加载器加载\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"而是将主内存上变量的副本放进自己的工作内存中\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"而是在\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"而是在每个\",{\"1\":{\"375\":1}}],[\"而是属于某个特定的namespace\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"而是通过公共接口来访问类的属性和方法\",{\"1\":{\"1010\":1}}],[\"而是通过其他方式\",{\"1\":{\"569\":1}}],[\"而是受限于操作系统的内存大小\",{\"1\":{\"930\":1}}],[\"而是直接被编译成机器码\",{\"1\":{\"930\":1}}],[\"而是直接修改副本变量的值\",{\"1\":{\"692\":1}}],[\"而是渐进式地完成的\",{\"1\":{\"626\":1}}],[\"而是\",{\"1\":{\"625\":1,\"632\":1}}],[\"而是自己构建了一种名为简单动态字符串\",{\"1\":{\"619\":1}}],[\"而是由\",{\"1\":{\"594\":1}}],[\"而是用来描述与外键约束相关的锁定行为\",{\"1\":{\"560\":1}}],[\"而是指与外键约束相关的锁定行为\",{\"1\":{\"560\":1}}],[\"而是存储时间截的差值\",{\"1\":{\"388\":1}}],[\"而是利用\",{\"1\":{\"359\":1}}],[\"而是每次都会预读\",{\"1\":{\"274\":1}}],[\"而是zookeeper服务器集群中连接到leader的follower\",{\"1\":{\"157\":1}}],[\"而文件系统\",{\"1\":{\"272\":1}}],[\"而broker则是消息的存储和传输中心\",{\"1\":{\"986\":1}}],[\"而b+树有\",{\"1\":{\"270\":1}}],[\"而b+树只有叶子节点存data\",{\"1\":{\"270\":1}}],[\"而b+树节点只存储\",{\"1\":{\"270\":1}}],[\"而b+树由于只有叶子节点保存了data\",{\"1\":{\"270\":1}}],[\"而b\",{\"1\":{\"269\":1,\"270\":2}}],[\"而b树\",{\"1\":{\"266\":1}}],[\"而b树的范围查询相对较差\",{\"1\":{\"264\":1}}],[\"而旋转是对整棵树的操作\",{\"1\":{\"266\":1}}],[\"而zookeeper不仅仅可以作为分布式集群的服务注册调度中心\",{\"1\":{\"165\":1}}],[\"而\",{\"1\":{\"145\":1,\"263\":1,\"371\":1,\"372\":1,\"454\":1,\"628\":1,\"629\":1,\"652\":1,\"692\":1,\"932\":4,\"954\":1,\"966\":3,\"1022\":2,\"1115\":3,\"1159\":1,\"1161\":1,\"1205\":1,\"1243\":2,\"1310\":3,\"1347\":1,\"1349\":1,\"1385\":1,\"1416\":2}}],[\"而且用户中心作为一个系统中必不可少的模块\",{\"1\":{\"1429\":1}}],[\"而且可以灵活地被重用和扩展\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"而且可以重复使用\",{\"1\":{\"932\":1}}],[\"而且cpu不会成为瓶颈\",{\"1\":{\"1200\":1,\"1380\":1}}],[\"而且如果不使用这种双亲委派模型将会给虚拟机的安全带来隐患\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"而且它内部实现了自动扩容机制\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"而且它还可以与kibana等工具结合使用\",{\"1\":{\"998\":1}}],[\"而且系统的性能开销也是巨大的\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"而且很多开源项目都使用到了\",{\"1\":{\"1032\":1}}],[\"而且容易破坏封装性\",{\"1\":{\"1010\":1}}],[\"而且对磁盘的使用较高\",{\"1\":{\"978\":1}}],[\"而且即使在节点故障的情况下\",{\"1\":{\"978\":1}}],[\"而且你对每个组件的职责也描述得非常透彻\",{\"1\":{\"956\":1}}],[\"而且只能等待固定数量的线程\",{\"1\":{\"932\":1}}],[\"而且计数器的值可以被重置\",{\"1\":{\"932\":1}}],[\"而且计数器的值不能被重置\",{\"1\":{\"932\":1}}],[\"而且简单易上手\",{\"1\":{\"906\":1}}],[\"而且不想学编程\",{\"1\":{\"906\":1}}],[\"而且\",{\"1\":{\"711\":1}}],[\"而且项目需要的这些依赖的版本和传递依赖的不相符\",{\"1\":{\"710\":1}}],[\"而且在数据中查找这类键值的计算成本很高\",{\"1\":{\"602\":1}}],[\"而且传统的关系数据库类型不适合存储这种类型的数据\",{\"1\":{\"594\":1}}],[\"而且这些操作都是原子性的\",{\"1\":{\"589\":1}}],[\"而且磁盘争用情况减少\",{\"1\":{\"516\":1}}],[\"而且时间复杂度也随之升高\",{\"1\":{\"361\":1}}],[\"而且当\",{\"1\":{\"357\":1}}],[\"而且当前ffmpeg也是放在mplayer项目组的服务器上\",{\"1\":{\"122\":1}}],[\"而且他们在磁盘里是顺序存储的\",{\"1\":{\"270\":1}}],[\"而且他的回答最靠谱\",{\"1\":{\"153\":1}}],[\"而且每个节点不止有两个子节点\",{\"1\":{\"263\":1}}],[\"而且非常基础\",{\"1\":{\"100\":1}}],[\"采取bulk批量写入\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"采取curator进行索引的生命周期管理\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"采取冷热分离机制\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"采取基于日期模板创建索引\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"采用其读锁来提高并发度\",{\"1\":{\"1018\":1}}],[\"采用重构手段\",{\"1\":{\"954\":1}}],[\"采用提前暴露对象的方式解决循环依赖\",{\"1\":{\"954\":1}}],[\"采用分布式和微服务架构\",{\"1\":{\"950\":1}}],[\"采用模块化设计\",{\"1\":{\"950\":1}}],[\"采用监控工具\",{\"1\":{\"942\":1}}],[\"采用free\",{\"1\":{\"938\":2}}],[\"采用整型作为id时\",{\"1\":{\"382\":1}}],[\"采用lgpl或gpl许可证\",{\"1\":{\"122\":1}}],[\"采集数据\",{\"1\":{\"145\":2}}],[\"录音\",{\"1\":{\"145\":1}}],[\"录视频\",{\"1\":{\"145\":1}}],[\"录屏+声音\",{\"1\":{\"145\":1}}],[\"录屏\",{\"1\":{\"145\":1}}],[\"录制\",{\"0\":{\"145\":1}}],[\"计数存在一定的误差\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"计数器偏移量\",{\"1\":{\"1023\":1}}],[\"计数器\",{\"1\":{\"594\":1,\"1023\":1,\"1199\":1,\"1379\":1}}],[\"计数排序可以用在基数排序中的算法来排序数据范围很大的数组\",{\"1\":{\"357\":1}}],[\"计数排序是一个简单的排序算法\",{\"1\":{\"357\":1}}],[\"计数排序是一个非基于比较的排序算法\",{\"1\":{\"357\":1}}],[\"计数排序是用来排序0到100之间的数字的最好的算法\",{\"1\":{\"357\":1}}],[\"计数排序是比较容易的排序算法\",{\"1\":{\"356\":1}}],[\"计数排序就是这么容易\",{\"0\":{\"356\":1}}],[\"计数排序的升级版\",{\"1\":{\"348\":1}}],[\"计数排序\",{\"0\":{\"357\":1},\"1\":{\"347\":1,\"370\":2}}],[\"计算数组位置的算法是\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"计算数组位置的效率\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"计算key在数组中的下标时\",{\"1\":{\"1121\":1,\"1316\":1}}],[\"计算key的hash值\",{\"1\":{\"922\":2}}],[\"计算过程是\",{\"1\":{\"1120\":1,\"1315\":1}}],[\"计算出\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"计算下一个索引\",{\"1\":{\"928\":1}}],[\"计算键值对的索引\",{\"1\":{\"928\":1}}],[\"计算两个位置之间的距离\",{\"1\":{\"660\":1}}],[\"计算哈希值的函数\",{\"1\":{\"624\":1}}],[\"计算给定的一个或多个有序集的并集\",{\"1\":{\"607\":1}}],[\"计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合\",{\"1\":{\"607\":1}}],[\"计算在有序集合中指定区间分数的成员数\",{\"1\":{\"607\":1}}],[\"计算查询和文档相似度是很重要的一个计算因子\",{\"1\":{\"425\":1}}],[\"计算hash函数个数\",{\"1\":{\"340\":1}}],[\"计算\",{\"1\":{\"340\":1,\"659\":1,\"660\":1}}],[\"计算方式\",{\"1\":{\"339\":1}}],[\"计算机中正数包含0\",{\"1\":{\"387\":1}}],[\"计算机的每次请求都要经过防火墙的过滤判断请求url是否在黑名单中\",{\"1\":{\"330\":1}}],[\"计算机内存分配是按页对齐的\",{\"1\":{\"266\":1}}],[\"计算每个流的帧数\",{\"1\":{\"143\":1}}],[\"计划\",{\"1\":{\"36\":2,\"1439\":1}}],[\"计划运营到\",{\"1\":{\"1\":1}}],[\"读请求转发到slave\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"读已提交\",{\"1\":{\"1187\":1,\"1220\":1,\"1370\":1,\"1397\":1}}],[\"读未提交\",{\"1\":{\"1187\":1,\"1220\":1,\"1370\":1,\"1397\":1}}],[\"读到了并一定最终存在的数据\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"读到\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"读到这里我们对布隆过滤器有了一定了解\",{\"1\":{\"336\":1}}],[\"读数据\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"读数据时\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"读写锁等\",{\"1\":{\"1022\":2}}],[\"读写比例\",{\"1\":{\"1018\":1}}],[\"读写分离和分库分表\",{\"1\":{\"525\":1}}],[\"读写分离\",{\"1\":{\"520\":1,\"958\":1}}],[\"读次数多\",{\"1\":{\"1018\":1}}],[\"读操作\",{\"1\":{\"966\":1}}],[\"读\",{\"1\":{\"966\":1}}],[\"读的速度是\",{\"1\":{\"591\":1,\"960\":1}}],[\"读多写少\",{\"1\":{\"569\":1}}],[\"读取其他事务已经提交的数据\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"读取其他事务未提交的数据\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"读取\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"读取数据的时候配合\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"读取数据库\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"读取阶段\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"读取缓存\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"读取注解\",{\"1\":{\"944\":1}}],[\"读取配置文件\",{\"1\":{\"746\":1,\"747\":1,\"757\":1,\"763\":1}}],[\"读取archetype\",{\"1\":{\"703\":1,\"704\":1}}],[\"读取实际的数据行\",{\"1\":{\"497\":1}}],[\"读取帧数需要文件解码\",{\"1\":{\"143\":1}}],[\"读完本篇\",{\"1\":{\"121\":1}}],[\"说几个\",{\"0\":{\"1241\":1,\"1414\":1}}],[\"说出这几种类型当然已经回答了问题\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"说一说jvm的主要组成部分\",{\"0\":{\"1142\":1,\"1333\":1}}],[\"说一下springboot的自动装配原理\",{\"0\":{\"1228\":1,\"1403\":1}}],[\"说一下类加载的执行过程\",{\"0\":{\"1148\":1,\"1339\":1}}],[\"说一下堆栈的区别\",{\"0\":{\"1144\":1,\"1335\":1}}],[\"说一下java注解\",{\"0\":{\"1092\":1,\"1293\":1}}],[\"说一下自己的看法\",{\"0\":{\"1032\":1}}],[\"说一下\",{\"0\":{\"1116\":1,\"1143\":1,\"1147\":1,\"1311\":1,\"1334\":1,\"1338\":1},\"1\":{\"104\":2,\"1027\":1}}],[\"说起死锁\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"说到缓存\",{\"1\":{\"1041\":1}}],[\"说到\",{\"1\":{\"1033\":1}}],[\"说到分布式锁\",{\"1\":{\"664\":1}}],[\"说的太好了\",{\"1\":{\"966\":1}}],[\"说的不错\",{\"1\":{\"960\":1}}],[\"说的很清楚\",{\"1\":{\"934\":1}}],[\"说听说你jvm调优挺在行\",{\"1\":{\"942\":1}}],[\"说g1是\",{\"1\":{\"940\":1}}],[\"说白了\",{\"1\":{\"938\":1}}],[\"说说你们公司\",{\"0\":{\"1068\":1,\"1272\":1}}],[\"说说你对多线程的理解\",{\"1\":{\"988\":1}}],[\"说说\",{\"1\":{\"988\":1,\"1018\":1}}],[\"说说rdb吧\",{\"1\":{\"962\":1}}],[\"说说resize的实现过程\",{\"1\":{\"922\":1}}],[\"说说spring中常见的注解\",{\"1\":{\"944\":1}}],[\"说说g1的垃圾回收过程\",{\"1\":{\"940\":1}}],[\"说说cms\",{\"1\":{\"938\":1}}],[\"说说并发标记和最终标记的区别\",{\"1\":{\"938\":1}}],[\"说说hashmap的缺点\",{\"1\":{\"922\":1}}],[\"说说hashmap的扩容机制\",{\"1\":{\"922\":1}}],[\"说自己在面试准备过程中感觉抓不住重点\",{\"1\":{\"920\":1}}],[\"说些题外话\",{\"1\":{\"640\":1}}],[\"说实话\",{\"1\":{\"212\":1,\"966\":1}}],[\"说明在自己项目中如何使用\",{\"0\":{\"1131\":1,\"1324\":1}}],[\"说明该\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"说明elasticsearch和lucene在实际应用中的作用吗\",{\"1\":{\"1000\":1}}],[\"说明的很详细\",{\"1\":{\"934\":1}}],[\"说明系统时钟回退过这个时候应当抛出异常\",{\"1\":{\"388\":1}}],[\"说明\",{\"0\":{\"600\":1,\"683\":1},\"1\":{\"143\":1,\"186\":1,\"604\":1,\"827\":1,\"1020\":1}}],[\"每当进行增删元素等操作时\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"每天凌晨定时对索引做force\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"每天出门都要给房子上锁\",{\"1\":{\"553\":1}}],[\"每本书都有一个唯一的编号\",{\"1\":{\"1004\":1}}],[\"每种类型的对象至少都有两种或以上的编码方式\",{\"1\":{\"636\":1}}],[\"每次请求数据库\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"每次文件操作也是直接操作的\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"每次写入后必须立即同步回主内存当中\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"每次写入都立即写入内存\",{\"1\":{\"924\":1}}],[\"每次读取前必须先从主内存刷新最新的值\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"每次读写缓存时可以直接操作\",{\"1\":{\"654\":1}}],[\"每次选举每个节点都把自己所知道节点排一次序\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"每次变量更新的时候把version++\",{\"1\":{\"1018\":1}}],[\"每次获取下一个元素的时候都会去检查\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"每次获取\",{\"1\":{\"952\":1}}],[\"每次修改这个变量时\",{\"1\":{\"924\":1}}],[\"每次访问这个变量时\",{\"1\":{\"924\":1}}],[\"每次迭代的顺序可能不同\",{\"1\":{\"922\":1}}],[\"每次扩容时\",{\"1\":{\"922\":1}}],[\"每次测试方法都继承它\",{\"1\":{\"828\":1}}],[\"每次使用完要将连接返回给连接池\",{\"1\":{\"648\":1}}],[\"每次对字典执行添加\",{\"1\":{\"625\":1}}],[\"每次浏览都得给+1\",{\"1\":{\"594\":1}}],[\"每次更新记录时\",{\"1\":{\"579\":1}}],[\"每次更新数据时\",{\"1\":{\"573\":1}}],[\"每次投票后\",{\"1\":{\"166\":1}}],[\"每次投票会包含所推举的服务器的myid和zxid\",{\"1\":{\"166\":1}}],[\"每页包含一定数量的行\",{\"1\":{\"561\":1}}],[\"每条记录称为一个倒排项\",{\"1\":{\"424\":1}}],[\"每部分用\",{\"1\":{\"388\":1}}],[\"每一次getbean\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"每一条指令构建一层\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"每一个方法被调用直至执行完成的过程\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"每一个线程都有一个独有的工作内存\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"每一个线程运行时都有一个线程栈\",{\"1\":{\"692\":1}}],[\"每一个客户端连接\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"每一个单独的线程能够像创建了一个自己的\",{\"1\":{\"645\":1}}],[\"每一个整数按照其值对号入座\",{\"1\":{\"359\":1}}],[\"每一项和前一项相加\",{\"1\":{\"358\":1}}],[\"每放一个元素就将c\",{\"1\":{\"358\":1}}],[\"每台机器都试图找到leader\",{\"1\":{\"166\":1}}],[\"每隔1s就抓一帧\",{\"1\":{\"141\":1}}],[\"每个容器中只有一个bean的实例\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"每个redisobject内部结构至少占16字节\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"每个文件对应数据库中的一张表\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"每个文档根据\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"每个文档就转换为由单词序列构成的数据流\",{\"1\":{\"425\":1}}],[\"每个日志数据段都会分配两个文件\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"每个方法被执行的时候都会同时创建一个栈帧\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"每个方法在执行的同时都会创建一个栈帧\",{\"1\":{\"930\":1}}],[\"每个jsp页面就是一个servlet实例\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"每个乘客\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"每个人要到达某个目的地可以认为是一个线程\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"每个人告诉售票员自己的目的地\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"每个人负责一部分\",{\"1\":{\"1004\":1}}],[\"每个shard会在本地执行查询请求后会生成一个命中文档的优先级队列\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"每个server会发出一个投票\",{\"1\":{\"166\":1}}],[\"每个server发出一个投票给集群其他机器\",{\"1\":{\"166\":1}}],[\"每个server发出一个投票\",{\"1\":{\"166\":1}}],[\"每个对象都有一个\",{\"1\":{\"1023\":1}}],[\"每个对象都有一个监视器锁\",{\"1\":{\"1022\":1}}],[\"每个对象的引用计数信息由\",{\"1\":{\"635\":1}}],[\"每个客户端都可以使用一个通道来进行数据的读写操作\",{\"1\":{\"1020\":2}}],[\"每个elasticsearch节点在启动时都会尝试与zookeeper建立连接\",{\"1\":{\"1008\":1}}],[\"每个生产者都会生成一个唯一的序列号\",{\"1\":{\"996\":1}}],[\"每个topic可以有多个分区\",{\"1\":{\"984\":1}}],[\"每个分区的多个副本中的\",{\"1\":{\"1159\":2,\"1347\":2}}],[\"每个分区都可以独立地处理读写请求\",{\"1\":{\"986\":1}}],[\"每个分区都可以并行处理消息\",{\"1\":{\"982\":1}}],[\"每个分区都有一个leader和多个follower副本\",{\"1\":{\"986\":1}}],[\"每个分区都有一个唯一的偏移量\",{\"1\":{\"984\":1}}],[\"每个分片加载并\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"每个分片返回各自优先队列中所有文档的\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"每个分片在本地执行查询并添加结果到大小为\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"每个分片存储了索引的一部分数据\",{\"1\":{\"1012\":1}}],[\"每个分片存储在不同的redis节点上\",{\"1\":{\"968\":1}}],[\"每个分片都有一个唯一的shardid\",{\"1\":{\"1004\":1}}],[\"每个分片都有一个主节点和多个从节点\",{\"1\":{\"968\":1}}],[\"每个分片都是一个独立的存储单元\",{\"1\":{\"1004\":1}}],[\"每个槽位对应一个分片\",{\"1\":{\"968\":1}}],[\"每个作用域适合的场景是什么\",{\"1\":{\"952\":1}}],[\"每个全局\",{\"1\":{\"952\":1}}],[\"每个模块保持高内聚\",{\"1\":{\"950\":1}}],[\"每个线程都只操作自己工作内存中的变量\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"每个线程都有一个独立的程序计数器\",{\"1\":{\"930\":1}}],[\"每个线程不直接操作在主内存中的变量\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"每个线程需要不断的轮询\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"每个线程执行完后就将计数器的值减\",{\"1\":{\"932\":1}}],[\"每个线程执行完当前阶段后就调用\",{\"1\":{\"932\":2}}],[\"每个阶段都需要等待所有线程都完成后才能继续执行\",{\"1\":{\"932\":1}}],[\"每个子任务执行完后就将计数器的值减\",{\"1\":{\"932\":1}}],[\"每个数组元素是一个单链表结构的头节点\",{\"1\":{\"922\":1}}],[\"每个pojo类都要去配置\",{\"1\":{\"768\":1}}],[\"每个用户每天的签到用\",{\"1\":{\"658\":1}}],[\"每个用户可以领取的代币数量\",{\"1\":{\"487\":1,\"488\":1}}],[\"每个跳跃表节点的层高都是\",{\"1\":{\"629\":1}}],[\"每个元素都包含一个指向其他节点的指针\",{\"1\":{\"628\":1}}],[\"每个字典带有两个哈希表\",{\"1\":{\"626\":1}}],[\"每个字段可以被索引与搜索\",{\"1\":{\"400\":1}}],[\"每个哈希表节点都有一个\",{\"1\":{\"624\":1}}],[\"每个链表节点包含四个字段\",{\"1\":{\"922\":1}}],[\"每个链表节点由一个\",{\"1\":{\"622\":1}}],[\"每个链表使用一个\",{\"1\":{\"622\":1}}],[\"每个实例都需要各自保存一份缓存\",{\"1\":{\"615\":1}}],[\"每个集合可存储40多亿个成员\",{\"1\":{\"607\":1}}],[\"每个列表超过40亿个元素\",{\"1\":{\"604\":1,\"655\":1}}],[\"每个页包含多行数据\",{\"1\":{\"566\":1}}],[\"每个事务都在等待下一个事务所持有的资源\",{\"1\":{\"562\":1}}],[\"每个事务都在等待其他事务释放资源\",{\"1\":{\"562\":1}}],[\"每个表只有这个表的部分数据\",{\"1\":{\"520\":1}}],[\"每个表存储其中一部分字段\",{\"1\":{\"516\":1}}],[\"每个库只有这个表的部分数据\",{\"1\":{\"520\":1}}],[\"每个库可以放在不同的服务器上\",{\"1\":{\"517\":1,\"518\":1}}],[\"每个位表示某个值是否存在于该列中\",{\"1\":{\"505\":1}}],[\"每个嵌套的对象都能够独立地被搜索\",{\"1\":{\"451\":1}}],[\"每个桶存储一定范围的数值\",{\"1\":{\"370\":1}}],[\"每个桶只存储单一键值\",{\"1\":{\"370\":1}}],[\"每个桶子再个别排序\",{\"1\":{\"348\":1}}],[\"每个结点的值都大于或等于其左右孩子结点的值\",{\"1\":{\"364\":1}}],[\"每个存储块称为一页\",{\"1\":{\"274\":1}}],[\"每个存储单元有唯一的地址\",{\"1\":{\"273\":1}}],[\"每个存储单元存储固定大小的数据\",{\"1\":{\"273\":1}}],[\"每个扇区是磁盘的最小存储单元\",{\"1\":{\"274\":1}}],[\"每个段叫做一个扇区\",{\"1\":{\"274\":1}}],[\"每个同心环叫做一个磁道\",{\"1\":{\"274\":1}}],[\"每个磁头同一时刻也必须是同轴的\",{\"1\":{\"274\":1}}],[\"每个磁头负责存取一个磁盘的内容\",{\"1\":{\"274\":1}}],[\"每个节点会生成一个唯一的id\",{\"1\":{\"1008\":1}}],[\"每个节点可以保存一个字节数组或者整数值\",{\"1\":{\"633\":1}}],[\"每个节点都有自己的角色\",{\"1\":{\"1004\":1}}],[\"每个节点都有一个指向前置节点和后置节点的指针\",{\"1\":{\"622\":1}}],[\"每个节点都存储了一定的范围区间\",{\"1\":{\"263\":1}}],[\"每个节点能索引的范围更大更精确\",{\"1\":{\"270\":1}}],[\"每个节点区确定的范围更精确\",{\"1\":{\"266\":1}}],[\"每个节点就较大了\",{\"1\":{\"266\":1}}],[\"每个服务器上的zxid可能不同\",{\"1\":{\"166\":1}}],[\"每个服务器就会更新自己的状态\",{\"1\":{\"166\":1}}],[\"每个设备的状态设置为\",{\"1\":{\"106\":1}}],[\"每个请求按访问ip的hash结果分配\",{\"1\":{\"106\":1}}],[\"每个请求按时间顺序逐一分配到不同的后端服务器\",{\"1\":{\"106\":1}}],[\"每个进程允许的最多连接数\",{\"1\":{\"106\":1}}],[\"每个\",{\"1\":{\"46\":1,\"267\":1,\"621\":1,\"624\":1,\"658\":1,\"771\":1,\"952\":2,\"1159\":1,\"1166\":3,\"1167\":1,\"1205\":1,\"1243\":1,\"1347\":1,\"1354\":3,\"1355\":1,\"1385\":1,\"1416\":1}}],[\"即所谓的配置中心\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"即所有的\",{\"1\":{\"1034\":1}}],[\"即对于的每一个请求\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"即保证一致性和网络分区容错性\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"即同时加载多个配置文件\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"即连接点join\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"即增强的逻辑\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"即redis加锁的value\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"即为数据增加一个版本标识\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"即为分区的\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"即通过常用的\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"即指的是使用悲观锁\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"即当有多个\",{\"1\":{\"1246\":1,\"1419\":1}}],[\"即当系统数据发生更新操作之后\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"即当使用\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"即当一个线程修改了变量的值后\",{\"1\":{\"1022\":1}}],[\"即分区存储到不同\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"即消费者组是逻辑上的一个订阅者\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"即初始标记阶段\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"即新生代使用复制算法\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"即引用instance指向内存memory时\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"即只有当大多数分片可用时才允许写操作\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"即该字段的distinct或者unique值的数目\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"即它的\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"即被锁定的对象\",{\"1\":{\"1023\":2}}],[\"即扩容与重新哈希\",{\"1\":{\"948\":1}}],[\"即时编译器编译后的代码等数据\",{\"1\":{\"930\":1,\"1142\":1,\"1333\":1}}],[\"即一个线程修改了共享变量的值\",{\"1\":{\"924\":1}}],[\"即spring\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"即stash\",{\"1\":{\"916\":2}}],[\"即scale=960\",{\"1\":{\"138\":1}}],[\"即成功返回结果\",{\"1\":{\"829\":1,\"830\":1}}],[\"即在\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"即在接口方法上使用注解\",{\"1\":{\"772\":1}}],[\"即在一个事务中\",{\"1\":{\"575\":1}}],[\"即告诉\",{\"1\":{\"772\":1}}],[\"即生成maven项目最基本的目录结构\",{\"1\":{\"703\":1,\"704\":1}}],[\"即\",{\"1\":{\"592\":1,\"837\":1,\"1087\":1,\"1177\":1,\"1191\":2,\"1288\":1,\"1362\":1,\"1374\":2}}],[\"即英属印度洋领地\",{\"1\":{\"589\":1}}],[\"即远程字典服务\",{\"1\":{\"589\":1}}],[\"即没有命中任何索引\",{\"1\":{\"575\":1}}],[\"即列中有限的不同值\",{\"1\":{\"505\":1}}],[\"即列中的值分布广泛\",{\"1\":{\"502\":1}}],[\"即检索不出任何结果\",{\"1\":{\"451\":1}}],[\"即使开启了二级缓存\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"即使这样\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"即使在\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"即使写数据库发生异常\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"即使分布式缓存挂了\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"即使发送相同的消息\",{\"1\":{\"996\":1}}],[\"即使添加从库\",{\"1\":{\"515\":1}}],[\"即使其中某些条件带有索引\",{\"1\":{\"501\":1}}],[\"即使\",{\"1\":{\"450\":1}}],[\"即使是格式化的日期字符串\",{\"1\":{\"445\":1}}],[\"即使只需要一个字节\",{\"1\":{\"274\":1}}],[\"即空值\",{\"1\":{\"434\":1}}],[\"即每个单词对应的\",{\"1\":{\"425\":1}}],[\"即这个单词在某个文档中的出现次数\",{\"1\":{\"425\":1}}],[\"即子结点的键值或索引总是小于\",{\"1\":{\"364\":1}}],[\"即gi\",{\"1\":{\"339\":1}}],[\"即可在其他项目引入\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"即可获知哪些文档包含某个单词\",{\"1\":{\"424\":1}}],[\"即可\",{\"1\":{\"406\":1,\"837\":1}}],[\"即可以用\",{\"1\":{\"387\":2}}],[\"即可以接受的误判率fpp和元素总个数n\",{\"1\":{\"339\":1}}],[\"即可完成查找\",{\"1\":{\"270\":1}}],[\"即队头和队尾相连\",{\"1\":{\"288\":1}}],[\"即确定要读的数据在哪个磁道\",{\"1\":{\"274\":1}}],[\"即从正上方向下看\",{\"1\":{\"274\":1}}],[\"即内存满了\",{\"1\":{\"196\":1}}],[\"即便当有非leader服务器宕机或新加入\",{\"1\":{\"166\":1}}],[\"即20~30s这10秒钟之间\",{\"1\":{\"141\":1}}],[\"抓取视频的一些帧\",{\"0\":{\"141\":1}}],[\"矩形边缘的厚度默认值4\",{\"1\":{\"140\":1}}],[\"咋办\",{\"1\":{\"140\":1}}],[\"右边包装类型\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"右边\",{\"1\":{\"604\":1}}],[\"右下角\",{\"1\":{\"139\":1}}],[\"右上角\",{\"1\":{\"139\":1}}],[\"左边基本类型\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"左边\",{\"1\":{\"604\":2}}],[\"左边进行函数\",{\"0\":{\"533\":1}}],[\"左右\",{\"1\":{\"266\":1}}],[\"左下角\",{\"1\":{\"139\":1}}],[\"左上角\",{\"1\":{\"139\":1}}],[\"将这个痛点转换成需求\",{\"1\":{\"1439\":1}}],[\"将所有微服务的\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"将所有待比较数值\",{\"1\":{\"374\":1}}],[\"将事务处理的功能编织到拦截的方法中\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"将datasource设置成不同的数据源\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"将delete的next指针指向null\",{\"1\":{\"286\":1}}],[\"将开发者做的事让容器做\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"将面临\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"将运行时间超过该值的所有sql语句都记录到慢查询的日志文件中\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"将pojo映射成数据库中的记录\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"将prev节点的next指针指向add\",{\"1\":{\"286\":1}}],[\"将prev的next指针指向delete的下一个节点\",{\"1\":{\"286\":1}}],[\"将旧副本清除\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"将消息发送到\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"将字节码翻译成底层系统指令\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"将请求分发到部署相应项目的\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"将请求发送给适合的\",{\"1\":{\"956\":1}}],[\"将要请求的路径和302重定向的状态码发给客户端浏览器\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"将要排序的元素分配至某些\",{\"1\":{\"371\":1}}],[\"将登陆信息等重要信息存放为session\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"将count值减1\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"将当前线程和一个map绑定\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"将当前文件中所有\",{\"1\":{\"850\":1}}],[\"将前面对象的内容全部拷贝进去\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"将查询请求转发到索引的每个主分片或副本分片中\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"将向协调节点报告成功\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"将缓存可能存在的并行写\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"将缓存堆栈中的对应stash删除\",{\"1\":{\"916\":1}}],[\"将服务器通道注册到选择器上\",{\"1\":{\"1020\":1}}],[\"将id和版本号发送给zookeeper\",{\"1\":{\"1008\":1}}],[\"将index文件的内容\",{\"1\":{\"916\":1}}],[\"将index之后的元素往前面移动一位\",{\"1\":{\"284\":1}}],[\"将用户的查询语句解析成查询对象\",{\"1\":{\"1002\":1}}],[\"将索引分成多个分片\",{\"1\":{\"1002\":1}}],[\"将索引健的值按照顺序保存在树节点中\",{\"1\":{\"499\":1}}],[\"将商品的属性\",{\"1\":{\"1000\":1}}],[\"将新的文档增量地添加到索引中\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"将新aof发送给主进程\",{\"1\":{\"962\":1}}],[\"将新构建的aof发送给主进程\",{\"1\":{\"962\":1}}],[\"将结果响应给用户\",{\"1\":{\"956\":1}}],[\"将结果集映射为java的对象类型\",{\"1\":{\"775\":1}}],[\"将逻辑视图名解析为具体\",{\"1\":{\"956\":1}}],[\"将循环依赖的\",{\"1\":{\"954\":1}}],[\"将系统拆分为多个单一职责的服务\",{\"1\":{\"950\":1}}],[\"将单体应用拆分成职责单一\",{\"1\":{\"950\":1}}],[\"将整个堆内存分割成多个大小相等的region\",{\"1\":{\"940\":1}}],[\"将它简单归类为\",{\"1\":{\"940\":1}}],[\"将清理过程分为并发和stw两个阶段\",{\"1\":{\"938\":1}}],[\"将eden区中无用的对象清除掉\",{\"1\":{\"930\":1}}],[\"将oldtable的值赋给newtable\",{\"1\":{\"922\":1}}],[\"将节点添加到链表尾部\",{\"1\":{\"922\":1}}],[\"将不会包含在\",{\"1\":{\"917\":1}}],[\"将工作区内容\",{\"1\":{\"916\":1}}],[\"将抛出异常\",{\"1\":{\"864\":1}}],[\"将压缩包下载后\",{\"1\":{\"837\":1}}],[\"将我们需要渲染的数据存储传输到对应视图\",{\"1\":{\"832\":1}}],[\"将按照下面的顺序来加载\",{\"1\":{\"766\":1}}],[\"将会执行lnitializingbean的afeterpropertiesset\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"将会由\",{\"1\":{\"766\":1}}],[\"将会被忽略\",{\"1\":{\"440\":1}}],[\"将生成的站点文档部署到特定的服务器上\",{\"1\":{\"714\":1}}],[\"将最终的包复制到远程的仓库\",{\"1\":{\"713\":1}}],[\"将最常用作查询条件的列放在索引的前面\",{\"1\":{\"510\":1}}],[\"将包安装至本地仓库\",{\"1\":{\"713\":1}}],[\"将项目打包并安装到本地仓库\",{\"1\":{\"705\":1}}],[\"将线程内存中的\",{\"1\":{\"692\":1}}],[\"将多个\",{\"1\":{\"659\":1}}],[\"将被删除并开始一个新的\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"将被废弃不推荐使用\",{\"1\":{\"648\":1}}],[\"将被共享的值对象的引用计数增一\",{\"1\":{\"635\":1}}],[\"将数据从一个系统传输到另一个系统\",{\"1\":{\"974\":1}}],[\"将数据库键的值指针指向一个现有的值对象\",{\"1\":{\"635\":1}}],[\"将数据大表拆分成若干数据表组成\",{\"1\":{\"515\":1}}],[\"将\",{\"1\":{\"606\":1,\"658\":1,\"854\":1,\"950\":2,\"952\":1,\"1191\":1,\"1205\":1,\"1374\":1,\"1385\":1}}],[\"将哈希表\",{\"1\":{\"605\":1}}],[\"将一个值插入到已存在的列表头部\",{\"1\":{\"604\":1}}],[\"将一个或多个值插入到列表头部\",{\"1\":{\"604\":1}}],[\"将一个表按照字段分成多表\",{\"1\":{\"516\":1}}],[\"将弹出的元素插入到另外一个列表中并返回它\",{\"1\":{\"604\":1}}],[\"将其纳入spring容器来管理\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"将其放在运行时数据区\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"将其值设置为\",{\"1\":{\"960\":1}}],[\"将其读入内存\",{\"1\":{\"934\":1}}],[\"将其加一\",{\"1\":{\"603\":1}}],[\"将其与末尾元素进行交换\",{\"1\":{\"364\":1}}],[\"将文件夹重新命名为\",{\"1\":{\"597\":1}}],[\"将热门字段\",{\"1\":{\"516\":1}}],[\"将原来独立的数据库拆分成若干数据库组成\",{\"1\":{\"515\":1}}],[\"将电商数据库拆分为若干独立的数据库\",{\"1\":{\"515\":1}}],[\"将键值换算成新的哈希值\",{\"1\":{\"495\":1}}],[\"将空投代币发送到制定地址\",{\"1\":{\"488\":1}}],[\"将打算发放空投的代币转入空投合约地址\",{\"1\":{\"486\":1}}],[\"将堆顶元素与末尾元素进行交换\",{\"1\":{\"364\":1}}],[\"将堆顶元素9和末尾元素4进行交\",{\"1\":{\"364\":1}}],[\"将待排序序列构造成一个大顶堆\",{\"1\":{\"364\":1}}],[\"将每次执行会改变数据库的命令记录下来\",{\"1\":{\"962\":1}}],[\"将每个文档中的关键词提取出来\",{\"1\":{\"1006\":1}}],[\"将每个用户以及其对应的什么分数写入进去\",{\"1\":{\"657\":1}}],[\"将每个桶子中的数值按照下一数位的值分配到\",{\"1\":{\"375\":1}}],[\"将每个元素i放在新数组的第c\",{\"1\":{\"358\":1}}],[\"将每一个元素移动到对应的桶中\",{\"1\":{\"351\":1}}],[\"将频率作为数组下标\",{\"1\":{\"353\":1}}],[\"将add节点的next指针指向after\",{\"1\":{\"286\":1}}],[\"将位置index的元素赋值\",{\"1\":{\"284\":1}}],[\"将插入位置index的元素和之后的元素往后移动一位\",{\"1\":{\"284\":1}}],[\"将该节点从磁盘读入内存\",{\"1\":{\"267\":1}}],[\"将简单易用的接口和性能高效\",{\"1\":{\"154\":1}}],[\"将输出格式\",{\"1\":{\"143\":1}}],[\"将输入的1920x1080缩小到960x540输出\",{\"0\":{\"138\":1}}],[\"将从upstream服务器传\",{\"1\":{\"106\":1}}],[\"更大的挑战\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"更改前的记录相同的记录行\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"更适合于单线程环境\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"更精确\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"更加节省内容\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"更高的并发量\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"更低的资源消耗和更少的内存复制\",{\"1\":{\"1032\":1}}],[\"更低的延迟\",{\"1\":{\"1032\":1}}],[\"更容易扩展和升级\",{\"1\":{\"950\":1}}],[\"更可扩展\",{\"1\":{\"950\":1}}],[\"更准确的说法应是\",{\"1\":{\"940\":1}}],[\"更准确的来说\",{\"1\":{\"940\":1}}],[\"更是在spring中发扬光大\",{\"1\":{\"682\":1}}],[\"更有效\",{\"1\":{\"511\":1}}],[\"更能的索引也意味着更多的存储空间\",{\"1\":{\"500\":1}}],[\"更节省资源\",{\"1\":{\"428\":1}}],[\"更新到缓存中\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"更新频繁\",{\"1\":{\"1018\":1}}],[\"更新频率\",{\"1\":{\"502\":1}}],[\"更新次数少\",{\"1\":{\"1018\":1}}],[\"更新数组对应位置\",{\"1\":{\"948\":1}}],[\"更新yum到最新版本\",{\"1\":{\"852\":1}}],[\"更新的statement\",{\"1\":{\"763\":1}}],[\"更新用户信息\",{\"1\":{\"753\":1}}],[\"更新这是大多数人做法\",{\"1\":{\"723\":1}}],[\"更新和删除文档的过程\",{\"0\":{\"1076\":1,\"1280\":1}}],[\"更新和删除时\",{\"1\":{\"510\":1}}],[\"更新和删除操作的开销\",{\"1\":{\"502\":1}}],[\"更新锁竞争\",{\"1\":{\"508\":1}}],[\"更新操作\",{\"1\":{\"503\":1,\"579\":1}}],[\"更新操作的效率\",{\"1\":{\"503\":1}}],[\"更新\",{\"0\":{\"474\":1},\"1\":{\"1050\":1,\"1259\":1}}],[\"更新了一段时间\",{\"1\":{\"225\":1}}],[\"更新时间轴\",{\"1\":{\"225\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"23\":1}}],[\"更新时间\",{\"1\":{\"20\":1}}],[\"更换底层的日志框架\",{\"1\":{\"194\":1}}],[\"更换自己的选票并告诉其他server\",{\"1\":{\"166\":1}}],[\"更多内存\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"更多的是为了提升读性能\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"更多的索引意味着更多的维护成本\",{\"1\":{\"500\":1}}],[\"更多方法\",{\"1\":{\"986\":1}}],[\"更多数据源\",{\"1\":{\"884\":1}}],[\"更多查询集群状态的命令\",{\"1\":{\"462\":1}}],[\"更多扩展词库\",{\"0\":{\"414\":1}}],[\"更多阅读阅读维基百科英文\",{\"1\":{\"343\":1}}],[\"更多阅读下面链接\",{\"1\":{\"136\":1}}],[\"更多\",{\"1\":{\"136\":1,\"219\":1}}],[\"只执行一次\",{\"1\":{\"1128\":4,\"1321\":4}}],[\"只可以使用一次\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"只操作工作内存中的数据\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"只在真正外部环境准备好了才唤醒\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"只在提交操作时检查是否违反数据完整性\",{\"1\":{\"1018\":1}}],[\"只存在于源码\",{\"1\":{\"944\":1}}],[\"只适用于老年代回收\",{\"1\":{\"938\":1}}],[\"只标记gc\",{\"1\":{\"938\":1}}],[\"只使用构造器注入\",{\"1\":{\"954\":1}}],[\"只使用一个线程\",{\"1\":{\"936\":1}}],[\"只使用在\",{\"1\":{\"706\":1}}],[\"只读操作不需要事务控制\",{\"1\":{\"830\":1}}],[\"只编写接口和mapping\",{\"1\":{\"761\":1}}],[\"只对于测试classpath有效\",{\"1\":{\"706\":1}}],[\"只提供了\",{\"1\":{\"659\":1}}],[\"只提取视频es数据\",{\"0\":{\"136\":1}}],[\"只支持升级\",{\"1\":{\"630\":1}}],[\"只能用于web程序中\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"只能作为对象的判断\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"只能修改为唯一的一个\",{\"1\":{\"1074\":1,\"1278\":1}}],[\"只能\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"只能添加fruit的父类型\",{\"1\":{\"966\":1}}],[\"只能添加fruit的子类型\",{\"1\":{\"966\":1}}],[\"只能算入门\",{\"1\":{\"948\":1}}],[\"只能算入门水平\",{\"1\":{\"946\":1}}],[\"只能在实际应用中去慢慢体会\",{\"1\":{\"440\":1}}],[\"只能搜索\",{\"1\":{\"440\":1}}],[\"只能取余数\",{\"1\":{\"387\":1}}],[\"只有leader才能提交proposer具体算法可见fast\",{\"1\":{\"1246\":1,\"1419\":1}}],[\"只有第\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"只有新的主题分区会分配在该\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"只有原来的一半\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"只有对象不会再被程序用到了\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"只有调用了start\",{\"1\":{\"1098\":1,\"1296\":1}}],[\"只有从第91个开始的10个结果需要被取回\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"只有最后的\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"只有把\",{\"1\":{\"958\":1}}],[\"只有父类加载器在它的搜索范围内无法找到所需的类时\",{\"1\":{\"934\":1}}],[\"只有git\",{\"1\":{\"916\":1}}],[\"只有在使用到某个bean时\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"只有在提交更新时才会检查并发冲突\",{\"1\":{\"1018\":1}}],[\"只有在方法调用时传入了\",{\"1\":{\"958\":1}}],[\"只有在字段\",{\"1\":{\"605\":1}}],[\"只有在查询条件中使用了创建索引时的第一个字段\",{\"1\":{\"495\":1}}],[\"只有当版本号匹配时才更新\",{\"1\":{\"579\":1}}],[\"只有\",{\"1\":{\"571\":1,\"1160\":1,\"1348\":1}}],[\"只有都是共享锁时\",{\"1\":{\"555\":1}}],[\"只有string可以使用\",{\"1\":{\"440\":1}}],[\"只有需要的数据才加载到内存中\",{\"1\":{\"266\":1}}],[\"只记录\",{\"1\":{\"433\":1}}],[\"只要服务端写消息时出现任何问题\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"只要\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"只要有一个不相同\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"只要序列号不同\",{\"1\":{\"996\":1}}],[\"只要能够逐项进行深入学习\",{\"1\":{\"948\":1}}],[\"只要你能够有计划和耐心地向这个清单上的每一项知识点进发\",{\"1\":{\"946\":1}}],[\"只要不重复即可\",{\"1\":{\"762\":1}}],[\"只要不是刚好相隔\",{\"1\":{\"387\":1}}],[\"只要对w计算hash\",{\"1\":{\"333\":1,\"339\":1}}],[\"只要理解了链表的操作和队列的特点即可\",{\"1\":{\"289\":1}}],[\"只允许在栈顶进行数据元素的插入或删除操作\",{\"1\":{\"282\":1}}],[\"只需在配置文件中做相关的事务规则声明或通过\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"只需要实现这个\",{\"1\":{\"1444\":1}}],[\"只需要导入指定应用启动器\",{\"1\":{\"1229\":1,\"1404\":1}}],[\"只需要将\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"只需要把对应的数据保留策略设置为\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"只需要调整对应位置的指针即可\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"只需要调用\",{\"1\":{\"928\":1}}],[\"只需要12k内存就能统计2^64个数据\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"只需要6个命令就可以满足基本所有需求\",{\"1\":{\"960\":1}}],[\"只需要合并一次或几次提交\",{\"1\":{\"917\":1}}],[\"只需要在\",{\"1\":{\"812\":1}}],[\"只需要放在仓库即可\",{\"1\":{\"700\":1}}],[\"只需要\",{\"1\":{\"658\":1,\"918\":1}}],[\"只需要通过哈希函数确定存储位置即可\",{\"1\":{\"499\":1}}],[\"只需要安装\",{\"1\":{\"157\":1}}],[\"只需很少的旋转时间\",{\"1\":{\"274\":1}}],[\"只保存索引\",{\"1\":{\"264\":1}}],[\"只希望多多转发支持\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"648\":1,\"698\":1,\"732\":1}}],[\"只显示读取的帧数\",{\"1\":{\"143\":1}}],[\"只是活动线程不需要直接指向一个睡眠线程\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"只是简单打印日志\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"只是获得一个或者多个初始化的地址\",{\"1\":{\"1075\":1,\"1279\":1}}],[\"只是在springboot中简单了很多\",{\"1\":{\"944\":1}}],[\"只是进行了线程安全的同步处理\",{\"1\":{\"922\":1}}],[\"只是想改一下注释\",{\"1\":{\"918\":1}}],[\"只是表示占位\",{\"1\":{\"779\":1}}],[\"只是替换\",{\"1\":{\"779\":1}}],[\"只是基于\",{\"1\":{\"659\":1}}],[\"只是再次向集群中所有机器发出上一次投票信息即可\",{\"1\":{\"166\":1}}],[\"只是加了一些包装\",{\"1\":{\"121\":1}}],[\"只是我们平时很少使用而已\",{\"1\":{\"90\":1}}],[\"想象一下\",{\"1\":{\"980\":1}}],[\"想象你是一名新手java程序员\",{\"1\":{\"934\":1}}],[\"想请你简单介绍一下\",{\"1\":{\"950\":1}}],[\"想加深学习的内容\",{\"1\":{\"948\":1}}],[\"想全面深入理解g1还需要我继续努力\",{\"1\":{\"940\":1}}],[\"想都撤回\",{\"1\":{\"918\":1}}],[\"想撤回commit\",{\"1\":{\"918\":1}}],[\"想要加入星球\",{\"1\":{\"212\":1}}],[\"想问关于这个团队的一切事情\",{\"1\":{\"153\":1}}],[\"想用h264编码\",{\"1\":{\"135\":1}}],[\"想把文件弄小一点\",{\"1\":{\"134\":1}}],[\"让缓存失效的时间点尽量均匀\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"让用户感觉很魔幻\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"让所有存活的对象都向一端移动\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"让多个线程协作\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"让多个键共享同一个值对象需要执行以下两个步骤\",{\"1\":{\"635\":1}}],[\"让当前线程进入不可运行状态\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"让当前线程等待\",{\"1\":{\"988\":1}}],[\"让编译器在源代码级别上\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"让它们根据事件来做出相应的响应\",{\"1\":{\"976\":1}}],[\"让它们实时地进行计算和分析\",{\"1\":{\"976\":1}}],[\"让这个过程变得非常有价值\",{\"1\":{\"966\":1}}],[\"让代码更健壮\",{\"1\":{\"966\":1}}],[\"让其占用连续的region\",{\"1\":{\"940\":1}}],[\"让我给讲讲公司里边做项目是什么流程\",{\"1\":{\"1439\":1}}],[\"让我给你展示一段简单的源码\",{\"1\":{\"1004\":1}}],[\"让我给你展示一段java代码来说明kafka的push和pull模式\",{\"1\":{\"990\":1}}],[\"让我给你展示一下\",{\"1\":{\"998\":1}}],[\"让我完全明白了\",{\"1\":{\"956\":1}}],[\"让我对这两种锁有了更深的认识\",{\"1\":{\"1018\":1}}],[\"让我对cas和aba问题有了更全面和深入的认识\",{\"1\":{\"1018\":1}}],[\"让我对java多线程和线程安全有一个比较全面和系统的复习\",{\"1\":{\"988\":1}}],[\"让我对\",{\"1\":{\"954\":1,\"956\":1,\"988\":1}}],[\"让我有点晕\",{\"1\":{\"950\":1}}],[\"让我有机会梳理和总结这些关键点\",{\"1\":{\"940\":1}}],[\"让我有机会深入梳理cms以及java垃圾收集机制\",{\"1\":{\"938\":1}}],[\"让我们开始吧\",{\"1\":{\"1012\":1}}],[\"让我们在处理大规模数据流时更加放心\",{\"1\":{\"996\":1}}],[\"让我们来看看它是如何工作的\",{\"1\":{\"992\":1}}],[\"让我们来看一下\",{\"1\":{\"984\":1}}],[\"让我们深入了解一下broker的内部结构\",{\"1\":{\"986\":1}}],[\"让我们继续讨论类加载过程中另一个重要概念\",{\"1\":{\"934\":1}}],[\"让我们有了很强的满足感\",{\"1\":{\"397\":1}}],[\"让我们先遍历这个无序的随机数组\",{\"1\":{\"359\":1}}],[\"让人容易理解\",{\"1\":{\"934\":1}}],[\"让字典同时持有\",{\"1\":{\"625\":1}}],[\"让列表只保留指定区间内的元素\",{\"1\":{\"604\":1}}],[\"让大家在面试的时候碰到这个知识点一往无前\",{\"1\":{\"262\":1}}],[\"让下游知道什么时候做什么动作\",{\"1\":{\"186\":1}}],[\"让调用者有一个预期\",{\"1\":{\"185\":1}}],[\"让使用这一眼就能知道这个接口在做什么\",{\"1\":{\"176\":1}}],[\"让你的接口设计无可挑剔\",{\"1\":{\"175\":1}}],[\"让整体的码率更趋近于希望的值\",{\"1\":{\"134\":1}}],[\"让更多攻城狮在极客之路提供一点点思路\",{\"1\":{\"84\":1}}],[\"控制权颠倒过来了\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"控制权都在自己手上\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"控制倒置\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"控制反向\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"控制反转是目标\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"控制反转\",{\"1\":{\"1212\":3,\"1213\":1,\"1389\":3,\"1390\":1}}],[\"控制key的数量\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"控制逻辑\",{\"1\":{\"950\":1}}],[\"控制一个连接池最多有多少个状态为空闲的\",{\"1\":{\"648\":1}}],[\"控制键值排序依据在哪一位\",{\"1\":{\"377\":1}}],[\"控制平均码率\",{\"1\":{\"134\":1}}],[\"控制码率主要还是为了缩小文件大小\",{\"1\":{\"134\":1}}],[\"控制台\",{\"1\":{\"109\":1}}],[\"码率就是\",{\"1\":{\"134\":1}}],[\"码率是什么\",{\"1\":{\"134\":1}}],[\"码率控制对于在线视频比较重要\",{\"1\":{\"134\":1}}],[\"码率控制\",{\"0\":{\"134\":1}}],[\"因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"因为redis的惰性删除机制\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"因为redis是基于内存的操作\",{\"1\":{\"1200\":1,\"1380\":1}}],[\"因为是基于内存\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"因为是全限名+方法名的保存和寻找策略\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"因为攻击者无法查看对伪造请求的响应\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"因为封装了许多易用的api\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"因为线程安全的问题\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"因为线程调度机制恢复线程的运行也需要时间\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"因为加锁和解锁自动进行\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"因为矛盾\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"因为泛型在编译阶段就已经被处理成普通的类和方法\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"因为内存地址不同\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"因为内节点并不存储\",{\"1\":{\"269\":1}}],[\"因为from越大\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"因为分片\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"因为先淘汰缓存\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"因为此时\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"因为任何时候只能有一个线程访问数据\",{\"1\":{\"1018\":1}}],[\"因为倒排索引可以直接定位到包含关键词的文档\",{\"1\":{\"1006\":1}}],[\"因为需要对数据进行压缩和解压缩操作\",{\"1\":{\"972\":1}}],[\"因为编译器无法确定它到底是哪种类型\",{\"1\":{\"966\":1}}],[\"因为string不符合约束\",{\"1\":{\"966\":1}}],[\"因为<\",{\"1\":{\"966\":1}}],[\"因为擦除后所有的类型参数都被替换为object类型\",{\"1\":{\"966\":1}}],[\"因为java在1\",{\"1\":{\"966\":1}}],[\"因为age键原来不存在\",{\"1\":{\"960\":1}}],[\"因为构造器是在\",{\"1\":{\"954\":1}}],[\"因为循环依赖导致一个\",{\"1\":{\"954\":1}}],[\"因为每个线程都需要获取锁才能访问被修饰的代码\",{\"1\":{\"1022\":2}}],[\"因为每个线程都需要维护自己的变量副本\",{\"1\":{\"928\":1}}],[\"因为每次测试都要加载配置文件\",{\"1\":{\"828\":1}}],[\"因为每次更新都可能导致索引的重新构建\",{\"1\":{\"502\":1}}],[\"因为我们要引入各种各样的依赖\",{\"1\":{\"844\":1}}],[\"因为业务\",{\"1\":{\"800\":1}}],[\"因为再dao\",{\"1\":{\"761\":1}}],[\"因为由容器已经提供\",{\"1\":{\"706\":1}}],[\"因为存储日活数据所需要的内存只有\",{\"1\":{\"659\":1}}],[\"因为官方在高版本\",{\"1\":{\"648\":1}}],[\"因为链表表头节点的前置节点和表尾节点的后置节点都指向\",{\"1\":{\"622\":1}}],[\"因为游标的效率较差\",{\"0\":{\"544\":1}}],[\"因为首先变长字段存储空间小\",{\"0\":{\"539\":1}}],[\"因为数据还是始终限制在一台服务器\",{\"1\":{\"517\":1}}],[\"因为数据库可以更有效地使用这些列来过滤数据\",{\"1\":{\"510\":1}}],[\"因为数据库可能需要读取多个不连续的页面来满足查询条件\",{\"1\":{\"508\":1}}],[\"因为索引的设计需要平衡查询性能和存储空间的利用\",{\"1\":{\"504\":1}}],[\"因为索引可以帮助快速检查重复的数据\",{\"1\":{\"502\":1}}],[\"因为相邻的数据在物理存储上也是相邻的\",{\"1\":{\"503\":1}}],[\"因为这样能够提高根据\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"因为这样的索引可能不会带来显著的性能提升\",{\"1\":{\"510\":1}}],[\"因为这样的索引可以更有效地缩小搜索范围\",{\"1\":{\"502\":1}}],[\"因为这个原因\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"因为这个信息对于搜索系统来说并非必需的\",{\"1\":{\"425\":1}}],[\"因为null值无法与其他值进行比较或匹配\",{\"1\":{\"501\":1}}],[\"因为它们已经创建好了\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"因为它们需要在更细的粒度上管理锁\",{\"1\":{\"564\":1}}],[\"因为它可以访问私有属性和方法\",{\"1\":{\"1010\":2}}],[\"因为它需要在运行时进行类型检查和方法调用\",{\"1\":{\"1010\":1,\"1016\":1}}],[\"因为它看不到\",{\"1\":{\"924\":1}}],[\"因为它不依赖于数据库的锁定机制\",{\"1\":{\"579\":1}}],[\"因为它允许高并发\",{\"1\":{\"569\":1}}],[\"因为它更有利于磁盘的顺序访问\",{\"1\":{\"499\":1}}],[\"因为它的非叶子节点不存储数据\",{\"1\":{\"264\":1}}],[\"因为哈希碰撞会导致性能下降\",{\"1\":{\"499\":1}}],[\"因为哈希算法会导致数据随机分布\",{\"1\":{\"499\":1}}],[\"因为他是按照顺序存储数据\",{\"1\":{\"499\":1}}],[\"因为他知道的最多\",{\"1\":{\"153\":1}}],[\"因为可以直接计算出存储位置\",{\"1\":{\"499\":1}}],[\"因为可能会出现两个key值经过k个hash函数之后\",{\"1\":{\"333\":1,\"339\":1}}],[\"因为有datacenterid和workerid来做区分\",{\"1\":{\"387\":1}}],[\"因为范围太小\",{\"1\":{\"382\":1}}],[\"因为下标为0的只有一个元素\",{\"1\":{\"352\":1}}],[\"因为不存在机械操作\",{\"1\":{\"273\":1}}],[\"因为\",{\"1\":{\"267\":1,\"501\":1,\"537\":1,\"635\":1,\"966\":2,\"988\":3,\"1018\":1,\"1032\":1,\"1047\":1,\"1256\":1}}],[\"因为公司十点以后走\",{\"1\":{\"225\":1}}],[\"因为在线视频需要考虑其能提供的带宽\",{\"1\":{\"134\":1}}],[\"因此需要进入\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"因此需要特定的命令解析器执行引擎\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"因此支持国际化\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"因此开发中在满足需求的前提下\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"因此如果在\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"因此必须在事务中使用\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"因此达到锁的效果\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"因此其他并发执行的\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"因此要先确保获取锁成功再进行业务操作\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"因此为了修正并发标记期间\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"因此为了提高效率\",{\"1\":{\"274\":1}}],[\"因此该区更关注的是数据的存储\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"因此大小不固定\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"因此大大提升了系统复杂度\",{\"1\":{\"518\":1}}],[\"因此性能慢些\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"因此拦截器的使用具有更大的弹性\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"因此能使用\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"因此是一个有效请求一个线程\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"因此会直接从cache中取已经存在的对象\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"因此会升级为表锁\",{\"1\":{\"574\":1}}],[\"因此不能被删除或者改动以展示其变更\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"因此每一条指令的内容\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"因此每个表还是竞争同一个物理机的cpu\",{\"1\":{\"517\":1}}],[\"因此也被称为gc堆\",{\"1\":{\"930\":1}}],[\"因此也没有电话号码\",{\"1\":{\"526\":1}}],[\"因此mybatis提供了接口的动态代理\",{\"1\":{\"761\":1}}],[\"因此它的应用范围受到一定的限制\",{\"1\":{\"1016\":1}}],[\"因此它的查询时间固定为\",{\"1\":{\"264\":1}}],[\"因此它在事务开始时就对数据对象加锁\",{\"1\":{\"570\":1}}],[\"因此它允许多个事务同时进行\",{\"1\":{\"569\":1}}],[\"因此并发性较低\",{\"1\":{\"565\":1}}],[\"因此粒度较小\",{\"1\":{\"561\":1}}],[\"因此粒度较大\",{\"1\":{\"561\":1}}],[\"因此io效率较低\",{\"1\":{\"516\":1}}],[\"因此对于具有局部性的程序来说\",{\"1\":{\"274\":1}}],[\"因此磁盘i\",{\"1\":{\"274\":1}}],[\"因此索引往往以索引文件的形式存储的磁盘上\",{\"1\":{\"271\":1}}],[\"因此建议加上日志开关判断\",{\"1\":{\"195\":1}}],[\"因此我们需要另一个关键字volatile保证对象实例化过程中的顺序性\",{\"1\":{\"84\":1}}],[\"因此可以借助于\",{\"1\":{\"29\":1}}],[\"因此\",{\"1\":{\"26\":1,\"106\":1,\"422\":1,\"498\":1,\"511\":1,\"766\":1,\"934\":2,\"1010\":1,\"1016\":1,\"1034\":1,\"1115\":1,\"1166\":1,\"1212\":1,\"1310\":1,\"1354\":1,\"1389\":1}}],[\"剪辑原视频input\",{\"1\":{\"129\":1}}],[\"掐头去尾\",{\"0\":{\"129\":1}}],[\"音频参数\",{\"1\":{\"127\":1}}],[\"开往\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"开销更小\",{\"1\":{\"1018\":1}}],[\"开销更大\",{\"1\":{\"1018\":1}}],[\"开心能听到你如此谦逊好学的态度\",{\"1\":{\"940\":1}}],[\"开篇\",{\"0\":{\"920\":1}}],[\"开源的java项目依赖的构件都可以在这里下载到\",{\"1\":{\"705\":1}}],[\"开源在\",{\"1\":{\"597\":1}}],[\"开发用户中心\",{\"1\":{\"1429\":1}}],[\"开发者也可以自定义\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"开发时只需要关注sql语句本身\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"开发时常用\",{\"1\":{\"864\":1}}],[\"开发即可\",{\"1\":{\"837\":1}}],[\"开发团队达成一致约定\",{\"1\":{\"830\":1}}],[\"开发环境\",{\"0\":{\"808\":1}}],[\"开发\",{\"1\":{\"771\":1,\"950\":1,\"1429\":1,\"1439\":1}}],[\"开发人员不需要编写原生态sql\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"开发人员在使用\",{\"1\":{\"950\":2}}],[\"开发人员信息等\",{\"1\":{\"699\":1}}],[\"开发人员的主要任务应该是关注业务逻辑并去实现它\",{\"1\":{\"698\":1}}],[\"开发日志\",{\"1\":{\"191\":1}}],[\"开放性题目\",{\"1\":{\"1027\":1}}],[\"开放性问题\",{\"1\":{\"510\":1}}],[\"开放源码的分布式应用程序协调服务\",{\"1\":{\"154\":1}}],[\"开头的模式匹配意味着匹配的字符串可以在任何位置\",{\"1\":{\"501\":1}}],[\"开头时\",{\"1\":{\"501\":1}}],[\"开头\",{\"1\":{\"501\":1}}],[\"开关判断逻辑通常放在日志工具类中\",{\"1\":{\"195\":1}}],[\"开始写我们的代码\",{\"1\":{\"829\":1}}],[\"开始\",{\"1\":{\"429\":1,\"801\":1,\"865\":1}}],[\"开始阅读\",{\"1\":{\"205\":1}}],[\"开始处理非会员逻辑\",{\"1\":{\"200\":1}}],[\"开始处理会员逻辑\",{\"1\":{\"200\":1}}],[\"开始选举\",{\"1\":{\"166\":1}}],[\"开始时间截\",{\"1\":{\"388\":2}}],[\"开始时间\",{\"1\":{\"127\":1}}],[\"开启了自动配置功能\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"开启\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"开启打印\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"开启组件扫描\",{\"1\":{\"944\":1}}],[\"开启springboot的自动配置\",{\"1\":{\"944\":1}}],[\"开启springmvc注解模式\",{\"1\":{\"819\":2}}],[\"开启事务功能\",{\"1\":{\"944\":1}}],[\"开启某个功能\",{\"1\":{\"944\":1}}],[\"开启驼峰命名转换\",{\"1\":{\"817\":2}}],[\"开启驼峰匹配\",{\"1\":{\"767\":1,\"790\":1}}],[\"开启二级缓存\",{\"1\":{\"790\":3}}],[\"开启mapper接口的包扫描\",{\"1\":{\"782\":1}}],[\"开启主键回写\",{\"1\":{\"763\":1,\"776\":1}}],[\"开启外网访问\",{\"1\":{\"673\":1}}],[\"开启限制ip连接数的时候需要使用\",{\"1\":{\"106\":1}}],[\"开启gzip\",{\"1\":{\"106\":1}}],[\"开启目录列表访问\",{\"1\":{\"106\":1}}],[\"开启高效文件传输模式\",{\"1\":{\"106\":1}}],[\"前提是他们要被同一个类加载器加载\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"前提是字符串的取值为\",{\"1\":{\"446\":1}}],[\"前后起作用\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"前者针对某一\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"前端控制器\",{\"1\":{\"956\":1}}],[\"前置通知\",{\"1\":{\"689\":1,\"944\":1}}],[\"前置节点\",{\"1\":{\"621\":1}}],[\"前文推荐阅读\",{\"1\":{\"641\":1}}],[\"前进指针\",{\"1\":{\"628\":1}}],[\"前\",{\"1\":{\"353\":1,\"1049\":1,\"1258\":1}}],[\"前面我们已经讲了很多了\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"前面这几个大家一定很熟悉\",{\"1\":{\"844\":1}}],[\"前面加上\",{\"1\":{\"692\":1}}],[\"前面讲了redis入门篇\",{\"1\":{\"647\":1}}],[\"前面讲了计数排序\",{\"1\":{\"370\":1}}],[\"前面已经更新过一部分\",{\"1\":{\"521\":1}}],[\"前面写了一个简单的demo\",{\"1\":{\"339\":1}}],[\"前面说过磁盘是分\",{\"1\":{\"270\":1}}],[\"前面的\",{\"1\":{\"122\":1}}],[\"前沿技术分享\",{\"1\":{\"211\":1}}],[\"前言引入\",{\"0\":{\"647\":1}}],[\"前言\",{\"0\":{\"109\":1,\"121\":1,\"150\":1,\"190\":1,\"250\":1,\"347\":1,\"368\":1,\"381\":1,\"482\":1,\"493\":1,\"552\":1,\"587\":1,\"613\":1,\"632\":1,\"641\":1,\"669\":1,\"682\":1,\"732\":1,\"872\":1,\"907\":1},\"1\":{\"664\":1}}],[\"转而执行接口方法所对应的mappedstatement所代表的sql\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"转而去做别的事情\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"转发\",{\"1\":{\"1132\":1,\"1136\":1,\"1325\":1,\"1329\":1}}],[\"转发和重定向的联系和区别\",{\"0\":{\"1132\":1,\"1325\":1}}],[\"转移多个提交\",{\"1\":{\"917\":1}}],[\"转移到当前分支\",{\"1\":{\"917\":1}}],[\"转化成单位年则是\",{\"1\":{\"387\":1}}],[\"转化为数组\",{\"1\":{\"284\":1}}],[\"转流\",{\"1\":{\"146\":1}}],[\"转换为小写等\",{\"1\":{\"1012\":1}}],[\"转换为布尔类型存储\",{\"1\":{\"446\":1}}],[\"转换以及流化音视频的完整解决方案\",{\"1\":{\"122\":1}}],[\"转换数字音频\",{\"1\":{\"122\":1}}],[\"转载更没有限制\",{\"1\":{\"97\":1}}],[\"转载请在文章头部注明出处\",{\"1\":{\"49\":1}}],[\"转载说明\",{\"1\":{\"49\":1}}],[\"官话来说就是\",{\"1\":{\"614\":1}}],[\"官网下载地址\",{\"1\":{\"643\":1}}],[\"官网参考\",{\"1\":{\"431\":1}}],[\"官网\",{\"1\":{\"244\":1}}],[\"官网地址\",{\"1\":{\"122\":1}}],[\"官方提供了\",{\"1\":{\"960\":1}}],[\"官方定义是这样的\",{\"1\":{\"112\":1}}],[\"官方文档\",{\"1\":{\"112\":1,\"739\":1}}],[\"官方网站\",{\"1\":{\"1\":1}}],[\"硌牙\",{\"1\":{\"121\":1}}],[\"执行beanpostprocessor的后置处理方法postprocessafterinitialization\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"执行beanpostprocessor的前置处理方法postprocessbeforelnitialization\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"执行用户自定义的初始化方法\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"执行aware接口的方法\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"执行relay\",{\"1\":{\"1186\":1,\"1369\":1}}],[\"执行重写后的sql\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"执行器\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"执行原理\",{\"0\":{\"1177\":1,\"1362\":1}}],[\"执行的时候将被触发\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"执行的sql语句\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"执行的拦截了\",{\"1\":{\"958\":1}}],[\"执行引擎\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"执行起来会在同步上消耗一定的性能\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"执行写命令\",{\"1\":{\"964\":1}}],[\"执行映射语句并得到结果\",{\"1\":{\"958\":1}}],[\"执行相关逻辑\",{\"1\":{\"944\":1}}],[\"执行相应逻辑\",{\"1\":{\"944\":1}}],[\"执行类构造器\",{\"1\":{\"934\":1}}],[\"执行任务\",{\"1\":{\"926\":1}}],[\"执行完commit后\",{\"1\":{\"918\":1}}],[\"执行存储时\",{\"1\":{\"916\":1}}],[\"执行命令\",{\"1\":{\"912\":1}}],[\"执行命令java\",{\"1\":{\"850\":1}}],[\"执行一遍\",{\"1\":{\"896\":1}}],[\"执行一些需要在生成站点文档之后完成的工作\",{\"1\":{\"714\":1}}],[\"执行一些需要在生成站点文档之前完成的工作\",{\"1\":{\"714\":1}}],[\"执行一些需要在clean之后立刻完成的工作\",{\"1\":{\"712\":1}}],[\"执行一些需要在clean之前完成的工作\",{\"1\":{\"712\":1}}],[\"执行一些更新操作\",{\"1\":{\"555\":1}}],[\"执行预约操作\",{\"1\":{\"830\":1}}],[\"执行queryuserall\",{\"1\":{\"762\":1}}],[\"执行查询\",{\"1\":{\"737\":1}}],[\"执行后结果\",{\"1\":{\"703\":1,\"704\":1}}],[\"执行以下cmd命令\",{\"1\":{\"703\":1,\"704\":1}}],[\"执行时间过长等\",{\"1\":{\"958\":1}}],[\"执行时间\",{\"1\":{\"689\":1}}],[\"执行时长\",{\"1\":{\"689\":1}}],[\"执行方法\",{\"1\":{\"689\":1}}],[\"执行结果\",{\"1\":{\"116\":1}}],[\"执行\",{\"1\":{\"116\":1,\"692\":1,\"789\":1,\"815\":1,\"956\":2,\"964\":1,\"1130\":1,\"1165\":1,\"1323\":1,\"1353\":1}}],[\"写一个配置类实现\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"写不同的构造函数用于初始化不同的参数\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"写个管理界面\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"写个修复数据脚本\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"写数据时\",{\"1\":{\"1042\":2,\"1251\":2}}],[\"写操作\",{\"1\":{\"966\":1}}],[\"写操作和所有操作的有序性\",{\"1\":{\"924\":1}}],[\"写屏障和全屏障\",{\"1\":{\"924\":1}}],[\"写完代码后\",{\"1\":{\"918\":1}}],[\"写代码\",{\"1\":{\"915\":1}}],[\"写文档\",{\"0\":{\"911\":1}}],[\"写\",{\"1\":{\"828\":1,\"966\":1}}],[\"写在\",{\"1\":{\"815\":1}}],[\"写在前面\",{\"0\":{\"262\":1}}],[\"写进去的时候给一个分数\",{\"1\":{\"657\":1}}],[\"写的速度是81000次\",{\"1\":{\"593\":1}}],[\"写的速度是\",{\"1\":{\"591\":1,\"960\":1}}],[\"写的好可以获得很大的加分\",{\"1\":{\"211\":1}}],[\"写的好不好使你得重视起来\",{\"1\":{\"175\":1}}],[\"写多读少\",{\"1\":{\"570\":1}}],[\"写冲突较多时可以使用悲观锁\",{\"1\":{\"573\":1}}],[\"写冲突较多\",{\"1\":{\"570\":1}}],[\"写冲突较少\",{\"1\":{\"569\":1}}],[\"写于家中床边\",{\"1\":{\"525\":1}}],[\"写主存的过程类似\",{\"1\":{\"273\":1}}],[\"写点业务逻辑\",{\"1\":{\"198\":1}}],[\"写成\",{\"1\":{\"138\":1}}],[\"写入数据的时候由于单个partion是末尾添加所以速度最优\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"写入到\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"写入后恢复副本数和刷新间隔\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"写入过程中\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"写入前关闭refresh\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"写入前副本数设置为0\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"写入调优\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"写入问题\",{\"1\":{\"1046\":1,\"1255\":1}}],[\"写入去重map\",{\"1\":{\"488\":1}}],[\"写入文档\",{\"1\":{\"439\":1}}],[\"写入一些样本数据\",{\"1\":{\"438\":1}}],[\"写入\",{\"1\":{\"115\":1}}],[\"写作日期为\",{\"1\":{\"44\":1}}],[\"与典型情况\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"与软件系统中对象之间的耦合关系非常相似\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"与spring完美集成\",{\"1\":{\"1173\":1,\"1358\":1}}],[\"与分区之间的映射关系了\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"与此同时\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"与本地方法库交互\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"与虚拟机栈所发挥的作用是非常相似的\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"与eventloop一起用来参与io处理\",{\"1\":{\"1034\":1}}],[\"与传统消息系统不同\",{\"1\":{\"992\":1}}],[\"与用户线程共享运行\",{\"1\":{\"938\":1}}],[\"与用户线程一起工作\",{\"1\":{\"936\":1,\"938\":3,\"940\":2}}],[\"与范围查询\",{\"1\":{\"601\":1}}],[\"与其他\",{\"1\":{\"592\":1}}],[\"与其他类型的索引相比\",{\"1\":{\"505\":1}}],[\"与任何其他类型的锁都不兼容\",{\"1\":{\"575\":1}}],[\"与临时表一样\",{\"0\":{\"546\":1}}],[\"与存储策略相关的参数\",{\"1\":{\"440\":1}}],[\"与索引相关的参数\",{\"1\":{\"440\":1}}],[\"与域数据格式及约束相关的参数\",{\"1\":{\"440\":1}}],[\"与上图的基本索引系统比\",{\"1\":{\"425\":1}}],[\"与计数排序不同\",{\"1\":{\"351\":1}}],[\"与主存不同\",{\"1\":{\"274\":1}}],[\"与模型对话\",{\"1\":{\"249\":1}}],[\"与启动时过程相同\",{\"1\":{\"166\":4}}],[\"与参数的名字无关\",{\"1\":{\"779\":1}}],[\"与参数\",{\"1\":{\"145\":2}}],[\"与\",{\"0\":{\"115\":1},\"1\":{\"270\":1,\"589\":1,\"660\":1,\"692\":1,\"1160\":1,\"1348\":1}}],[\"与nginx进程数相除\",{\"1\":{\"106\":1}}],[\"卸载该类的字节码\",{\"1\":{\"934\":1}}],[\"卸载旧版本\",{\"1\":{\"852\":1}}],[\"卸载\",{\"1\":{\"114\":1,\"934\":1}}],[\"检测到死锁后\",{\"1\":{\"581\":1}}],[\"检测是否安装成功\",{\"1\":{\"109\":1}}],[\"检查加载的\",{\"1\":{\"1148\":1,\"1339\":1}}],[\"检查\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"检查项目b的依赖包\",{\"1\":{\"708\":1}}],[\"检查并更新\",{\"1\":{\"573\":1}}],[\"检查版本号或时间戳是否与读取时的值相同\",{\"1\":{\"573\":1,\"579\":1}}],[\"检查节点状态\",{\"0\":{\"463\":1}}],[\"检查集群状态\",{\"0\":{\"462\":1}}],[\"检查位置是否合法\",{\"1\":{\"285\":1,\"286\":1}}],[\"检查工具是否安装\",{\"1\":{\"115\":1}}],[\"检查状态\",{\"1\":{\"114\":1}}],[\"搭建项目的脚手架\",{\"1\":{\"1439\":1}}],[\"搭建项目\",{\"1\":{\"1439\":1}}],[\"搭建项目框架\",{\"1\":{\"1439\":1}}],[\"搭建网站这种事\",{\"1\":{\"906\":1}}],[\"搭建\",{\"0\":{\"114\":1,\"246\":1,\"251\":1},\"1\":{\"251\":1}}],[\"服务实例\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"服务节点或\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"服务阶段\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"服务端的一颗子树相对应\",{\"1\":{\"1245\":1,\"1418\":1}}],[\"服务端在很多组件中都维护了分区级别的缓存\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"服务端都会对应一个处理线程\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"服务端密码\",{\"1\":{\"648\":1}}],[\"服务治理\",{\"1\":{\"950\":1}}],[\"服务及内存数据库管理\",{\"1\":{\"594\":1}}],[\"服务\",{\"1\":{\"594\":1,\"1142\":1,\"1333\":1}}],[\"服务发现\",{\"1\":{\"113\":1}}],[\"服务器内部错误\",{\"1\":{\"1431\":1}}],[\"服务器作为数据源同步给集群中的其他角色服务器\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"服务器作为数据源同步给集群中的多台\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"服务器上不同\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"服务器上事务的执行发生在\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"服务器中的大多数可以执行会话请求后\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"服务器开始与新的\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"服务器完成数据同步之后\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"服务器进行数据同步\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"服务器保持正常通信时\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"服务器具有四种状态\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"服务器端需要使用的内存就越多\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"服务器端的跳转\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"服务器推送\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"服务器向客户端发出确认取消信息\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"服务器向客户端返回一个响应\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"服务器向客户端返回一个响应告诉客户端收到了请求\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"服务器会调用\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"服务器调用\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"服务器创建针对此次请求的一个\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"服务器创建一个servlet实例\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"服务器启动之后\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"服务器启动时期的leader选举\",{\"1\":{\"166\":1}}],[\"服务器可要以处理常见的\",{\"1\":{\"1033\":1}}],[\"服务器的话\",{\"1\":{\"1033\":1}}],[\"服务器设为从服务器\",{\"1\":{\"964\":1}}],[\"服务器设为主服务器\",{\"1\":{\"964\":1}}],[\"服务器在执行某些命令之前\",{\"1\":{\"636\":1}}],[\"服务器就会使用这些共享对象\",{\"1\":{\"635\":1}}],[\"服务器环境\",{\"0\":{\"403\":1}}],[\"服务器运行时期的leader选举\",{\"1\":{\"166\":1}}],[\"服务器运行期间无法和leader保持连接\",{\"1\":{\"166\":1}}],[\"服务器都会统计投票信息\",{\"1\":{\"166\":1}}],[\"服务器都需要将别人的投票和自己的投票进行pk\",{\"1\":{\"166\":1}}],[\"服务器初始化启动\",{\"1\":{\"166\":1}}],[\"服务器还没有收到客户端的返回信息\",{\"1\":{\"157\":1}}],[\"服务器名字的hash表大小\",{\"1\":{\"106\":1}}],[\"服务器\",{\"1\":{\"90\":1,\"157\":1,\"962\":1,\"1033\":2,\"1136\":1,\"1159\":1,\"1242\":2,\"1243\":2,\"1329\":1,\"1347\":1,\"1415\":2,\"1416\":2}}],[\"完美\",{\"1\":{\"988\":1}}],[\"完整的例子\",{\"0\":{\"763\":1}}],[\"完整增删查改操作\",{\"0\":{\"752\":1}}],[\"完整代码地址\",{\"1\":{\"832\":1}}],[\"完整代码\",{\"1\":{\"747\":1}}],[\"完全由操作系统来完成请求的处理\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"完全实例化后\",{\"1\":{\"954\":1}}],[\"完全免费提供\",{\"1\":{\"920\":1}}],[\"完全正确\",{\"1\":{\"692\":1}}],[\"完全拷贝shard的内容\",{\"1\":{\"422\":1}}],[\"完全可以\",{\"1\":{\"98\":1}}],[\"完成这一步就要开始编写代码\",{\"1\":{\"1439\":1}}],[\"完成逻辑判断和动态拼接\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"完成最后任务\",{\"1\":{\"1104\":3,\"1302\":3}}],[\"完成\",{\"1\":{\"964\":1}}],[\"完成子对象的自动映射\",{\"1\":{\"793\":1,\"794\":1}}],[\"完成子对象的映射\",{\"1\":{\"793\":1,\"794\":1}}],[\"完成之后\",{\"1\":{\"351\":1}}],[\"完成后\",{\"1\":{\"109\":1}}],[\"选几个下面的经典场景\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"选主成功\",{\"1\":{\"1008\":1}}],[\"选主结果\",{\"1\":{\"1008\":1}}],[\"选主的过程可以分为以下几个关键步骤\",{\"1\":{\"1008\":1}}],[\"选主的稳定性和可靠性对于集群的正常运行至关重要\",{\"1\":{\"1008\":1}}],[\"选主是elasticsearch中至关重要的一个操作\",{\"1\":{\"1008\":1}}],[\"选项\",{\"1\":{\"913\":1}}],[\"选项卡\",{\"0\":{\"32\":1}}],[\"选举状态\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"选举的\",{\"0\":{\"1070\":1,\"1274\":1}}],[\"选举过程如下\",{\"1\":{\"166\":2}}],[\"选举机制\",{\"0\":{\"166\":1},\"1\":{\"166\":1}}],[\"选举只有java版本\",{\"1\":{\"154\":1}}],[\"选举\",{\"1\":{\"154\":1,\"1164\":1,\"1237\":1,\"1244\":1,\"1352\":1,\"1410\":1,\"1417\":1}}],[\"选择器用于实现多路复用\",{\"1\":{\"1020\":1}}],[\"选择器\",{\"1\":{\"1020\":2}}],[\"选择不同作用域会对\",{\"1\":{\"952\":1}}],[\"选择高性能存储\",{\"1\":{\"950\":1}}],[\"选择高性能技术栈\",{\"1\":{\"950\":1}}],[\"选择支持高并发的语言\",{\"1\":{\"950\":1}}],[\"选择性回收新生代和老年代\",{\"1\":{\"940\":1}}],[\"选择性是指不同值的数量与总行数的比率\",{\"1\":{\"502\":1}}],[\"选择满足需求的收集频率\",{\"1\":{\"938\":1}}],[\"选择包\",{\"1\":{\"838\":1}}],[\"选择我们的项目\",{\"1\":{\"832\":1}}],[\"选择create\",{\"1\":{\"756\":1}}],[\"选择正确的索引类型\",{\"1\":{\"510\":1}}],[\"选择何种比较排序算法对于性能的影响至关重要\",{\"1\":{\"348\":1}}],[\"选择对应的安装包进行安装\",{\"1\":{\"246\":1}}],[\"选择合适的日志等级\",{\"0\":{\"191\":1}}],[\"选择\",{\"1\":{\"109\":2,\"811\":1,\"913\":1,\"1049\":1,\"1258\":1}}],[\"图4\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"图3\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"图2\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"图1中描述的就是这样的一个齿轮组\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"图1\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"图文并茂\",{\"1\":{\"881\":1}}],[\"图书实体\",{\"1\":{\"825\":1}}],[\"图书名称\",{\"1\":{\"824\":1,\"825\":1}}],[\"图书id\",{\"1\":{\"824\":2,\"825\":2,\"829\":1}}],[\"图书表\",{\"1\":{\"824\":2}}],[\"图书管理系统\",{\"0\":{\"823\":1}}],[\"图的典型应用\",{\"0\":{\"321\":1}}],[\"图的遍历\",{\"0\":{\"320\":1}}],[\"图的实现\",{\"0\":{\"319\":1}}],[\"图的定义和基本概念\",{\"0\":{\"318\":1}}],[\"图\",{\"0\":{\"317\":1}}],[\"图7是磁盘结构的示意图\",{\"1\":{\"274\":1}}],[\"图6是磁盘的整体结构示意图\",{\"1\":{\"274\":1}}],[\"图5展示了一个4\",{\"1\":{\"273\":1}}],[\"图标\",{\"1\":{\"109\":1}}],[\"图片二十二\",{\"1\":{\"796\":1}}],[\"图片二十一\",{\"1\":{\"795\":1}}],[\"图片十九\",{\"1\":{\"792\":1}}],[\"图片十八\",{\"1\":{\"790\":1}}],[\"图片十七\",{\"1\":{\"790\":1}}],[\"图片十六\",{\"1\":{\"789\":1}}],[\"图片十三\",{\"1\":{\"781\":1}}],[\"图片十二\",{\"1\":{\"781\":1}}],[\"图片十一\",{\"1\":{\"770\":1}}],[\"图片十\",{\"1\":{\"768\":1}}],[\"图片九\",{\"1\":{\"767\":1}}],[\"图片八\",{\"1\":{\"765\":1}}],[\"图片七\",{\"1\":{\"763\":1}}],[\"图片6\",{\"1\":{\"762\":1}}],[\"图片五\",{\"1\":{\"762\":1}}],[\"图片四\",{\"1\":{\"758\":1}}],[\"图片三\",{\"1\":{\"756\":1}}],[\"图片缓存时间设置\",{\"1\":{\"106\":1}}],[\"图片引入\",{\"1\":{\"45\":1}}],[\"图片增强\",{\"0\":{\"37\":1}}],[\"点赞\",{\"1\":{\"594\":1}}],[\"点评\",{\"1\":{\"266\":1,\"270\":3}}],[\"点以后回家\",{\"1\":{\"225\":1}}],[\"点击在线阅读\",{\"1\":{\"1249\":1,\"1419\":1}}],[\"点击放大看\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"点击完成即可\",{\"1\":{\"838\":1,\"839\":1}}],[\"点击下一步\",{\"1\":{\"838\":1}}],[\"点击领取就可以获取到对应空投\",{\"1\":{\"485\":1}}],[\"点击传送\",{\"1\":{\"352\":1}}],[\"点击了解\",{\"1\":{\"219\":1}}],[\"点击了解星球🌍\",{\"1\":{\"205\":1}}],[\"点击加群\",{\"1\":{\"209\":1}}],[\"点击\",{\"1\":{\"109\":1,\"251\":1,\"860\":1,\"913\":1}}],[\"点击左侧菜单的\",{\"1\":{\"109\":1}}],[\"点个下载连同项目一起打包你的本地\",{\"1\":{\"97\":1}}],[\"启动的程序已经构造完成\",{\"1\":{\"1230\":1,\"1405\":1}}],[\"启动自动配置\",{\"1\":{\"1227\":1,\"1402\":1}}],[\"启动器自动依赖其他组件\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"启动springboot\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"启动springboot应用\",{\"1\":{\"885\":1}}],[\"启动容器\",{\"1\":{\"1063\":1,\"1269\":1}}],[\"启动类加载器\",{\"1\":{\"934\":1}}],[\"启动grafana\",{\"1\":{\"888\":1}}],[\"启动prometheus\",{\"1\":{\"887\":1}}],[\"启动成功后\",{\"1\":{\"832\":1}}],[\"启动界面如下\",{\"1\":{\"643\":1}}],[\"启动方式参考上文\",{\"1\":{\"598\":1}}],[\"启动\",{\"0\":{\"158\":1,\"407\":1,\"674\":1},\"1\":{\"109\":3,\"114\":1,\"158\":1,\"408\":1}}],[\"启用是需要额外的配置\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"启用反向代理\",{\"1\":{\"106\":1}}],[\"启用gzip压缩的最小文件\",{\"1\":{\"106\":1}}],[\"预编译处理\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"预编译的方式preparedstatement\",{\"1\":{\"763\":1}}],[\"预热对应的数据到缓存中\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"预测分析\",{\"1\":{\"940\":1}}],[\"预约业务异常\",{\"1\":{\"829\":1}}],[\"预约业务异常类\",{\"1\":{\"829\":1}}],[\"预约未知错误异常\",{\"1\":{\"829\":1}}],[\"预约失败的构造器\",{\"1\":{\"829\":1}}],[\"预约成功的构造器\",{\"1\":{\"829\":1}}],[\"预约成功对象\",{\"1\":{\"829\":1}}],[\"预约成功\",{\"1\":{\"829\":1,\"830\":2}}],[\"预约图书\",{\"1\":{\"830\":1}}],[\"预约图书实体\",{\"1\":{\"825\":1}}],[\"预约图书表\",{\"1\":{\"824\":2}}],[\"预约时间\",{\"1\":{\"824\":1,\"825\":1}}],[\"预防和解决缓存雪崩的问题\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"预防冲突\",{\"1\":{\"570\":1}}],[\"预防一个工作进程在传递文件时阻塞太长\",{\"1\":{\"106\":1}}],[\"预读的长度一般为页\",{\"1\":{\"274\":1}}],[\"预读可以提高i\",{\"1\":{\"274\":1}}],[\"预加载\",{\"0\":{\"79\":1},\"1\":{\"79\":1}}],[\"代价太大\",{\"1\":{\"940\":1}}],[\"代替了cms收集器\",{\"1\":{\"940\":1}}],[\"代替\",{\"0\":{\"535\":1,\"539\":1,\"542\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"代币\",{\"1\":{\"484\":1}}],[\"代码逆向生成工具\",{\"1\":{\"1444\":1}}],[\"代码评审\",{\"1\":{\"1439\":2}}],[\"代码转换成字节码\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"代码复杂度增大\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"代码维护复杂\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"代码维护简单\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"代码的实现\",{\"0\":{\"1044\":1,\"1253\":1}}],[\"代码写的很好\",{\"1\":{\"1020\":1}}],[\"代码示例\",{\"1\":{\"936\":1}}],[\"代码库就变成了下面的样子\",{\"1\":{\"917\":1}}],[\"代码仓库有master和feature两个分支\",{\"1\":{\"917\":1}}],[\"代码中用驼峰式\",{\"1\":{\"724\":1}}],[\"代码中循环写入\",{\"1\":{\"723\":1}}],[\"代码➕案例\",{\"0\":{\"722\":1}}],[\"代码会被编译\",{\"1\":{\"713\":1}}],[\"代码3\",{\"1\":{\"692\":1}}],[\"代码块\",{\"1\":{\"692\":1}}],[\"代码讲解\",{\"0\":{\"684\":1}}],[\"代码开源协议\",{\"1\":{\"488\":1}}],[\"代码详解\",{\"0\":{\"488\":1}}],[\"代码解析\",{\"0\":{\"487\":1}}],[\"代码基于\",{\"1\":{\"377\":1}}],[\"代码是基于\",{\"1\":{\"364\":1}}],[\"代码逻辑很好理解\",{\"1\":{\"352\":1}}],[\"代码\",{\"0\":{\"352\":1,\"360\":1,\"376\":1}}],[\"代码在$zookeeper\",{\"1\":{\"154\":1}}],[\"代表当前是一个配置类\",{\"1\":{\"1227\":1,\"1402\":1}}],[\"代表即将要写入消息的偏移量\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"代表这个日志文件可以消费的区间\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"代表这个日志文件的开始\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"代表切点名称\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"代表一个未知的类型\",{\"1\":{\"966\":1}}],[\"代表了一个链接\",{\"1\":{\"1034\":1}}],[\"代表了在文档集合中有多少个文档包含某个单词\",{\"1\":{\"425\":1}}],[\"代表了数列中对应整数的出现次数\",{\"1\":{\"359\":1}}],[\"代表的声音索相号\",{\"1\":{\"145\":1}}],[\"代表的屏幕索引号\",{\"1\":{\"145\":1}}],[\"代表的是什么\",{\"1\":{\"104\":1}}],[\"代表\",{\"1\":{\"122\":1,\"1157\":1,\"1345\":1}}],[\"代理模式\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"代理模式等\",{\"1\":{\"950\":1}}],[\"代理对象proxy会拦截接口方法\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"代理类的字节码中包含了对被代理对象的引用\",{\"1\":{\"1016\":1}}],[\"代理类的生成过程是通过字节码生成器来实现的\",{\"1\":{\"1016\":1}}],[\"代理\",{\"1\":{\"986\":1}}],[\"代理循环依赖\",{\"1\":{\"954\":1}}],[\"代理接收超时\",{\"1\":{\"106\":1}}],[\"代理发送超时\",{\"1\":{\"106\":1}}],[\"代理连接超时\",{\"1\":{\"106\":1}}],[\"都将会被限制在其自己的命名空间下\",{\"1\":{\"1245\":1,\"1418\":1}}],[\"都直接影响投票结果\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"都去操作\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"都创建新事务进行执行\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"都能实现权限检查\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"都在睡觉\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"都返回\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"都返回500\",{\"1\":{\"106\":1}}],[\"都可以当做spring的容器\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"都可以构建缓存\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"都可以做并且更好\",{\"1\":{\"1033\":1}}],[\"都可以找到\",{\"1\":{\"808\":1}}],[\"都做旧数组到新数组的迁移工作\",{\"1\":{\"988\":1}}],[\"都重新扩容了数组\",{\"1\":{\"988\":1}}],[\"都有哪些生命周期阶段\",{\"1\":{\"952\":1}}],[\"都有一定的纠错功能\",{\"1\":{\"787\":1}}],[\"都为垃圾\",{\"1\":{\"936\":1}}],[\"都需要扫码\",{\"1\":{\"871\":1}}],[\"都需要继承\",{\"1\":{\"829\":1}}],[\"都选了默认设置\",{\"1\":{\"844\":1}}],[\"都会产生一个新的bean\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"都会新建一个sqlsession\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"都会写一个\",{\"0\":{\"1175\":1,\"1360\":1}}],[\"都会对应磁盘文件系统的一个目录\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"都会导致消息丢失\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"都会创建一个新的实例\",{\"1\":{\"952\":1}}],[\"都会立即将新值写入内存\",{\"1\":{\"924\":1}}],[\"都会从内存中读取最新的值\",{\"1\":{\"924\":1}}],[\"都会从在资源的竞争\",{\"1\":{\"553\":1}}],[\"都会用类型处理器将获取的值以合适的方式转换成\",{\"1\":{\"769\":1}}],[\"都会被运行\",{\"1\":{\"712\":1}}],[\"都会读取变量修改后的最的值\",{\"1\":{\"692\":1}}],[\"都会唤醒和阻塞线程\",{\"1\":{\"82\":1}}],[\"都不能超过\",{\"1\":{\"387\":1}}],[\"都是由于全干工程师一人搞定\",{\"1\":{\"1439\":1}}],[\"都是持否定态度的\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"都是会话\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"都是sun公司推出的动态网页技术\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"都是\",{\"1\":{\"932\":1,\"966\":1}}],[\"都是行锁的形式\",{\"1\":{\"556\":1}}],[\"都是基于元素之间的比较来进行排序的\",{\"1\":{\"359\":1}}],[\"都是存多个值的\",{\"1\":{\"266\":1}}],[\"都根据选择的排序算法不同而不同\",{\"1\":{\"350\":1}}],[\"都带着\",{\"1\":{\"270\":1}}],[\"都统计出集群中已经有两台机器接受了\",{\"1\":{\"166\":1}}],[\"都很正常\",{\"1\":{\"106\":1}}],[\"允许事务在执行过程中\",{\"1\":{\"1220\":2,\"1397\":2}}],[\"允许一组线程相互之间等待\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"允许一个或多个线程\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"允许在编译时检测到非法的类型\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"允许在定义索引的列中插入重复值和空值\",{\"1\":{\"495\":1}}],[\"允许\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"允许使用\",{\"1\":{\"819\":1}}],[\"允许使用插件来拦截的方法调用包括\",{\"1\":{\"770\":1}}],[\"允许你在已映射语句执行过程中的某一点进行拦截调用\",{\"1\":{\"770\":1}}],[\"允许多个事务并发访问不同的数据页\",{\"1\":{\"561\":1}}],[\"允许有空值\",{\"1\":{\"495\":1}}],[\"允许出的的一端称为队头\",{\"1\":{\"287\":1}}],[\"允许客户端请求的最大单文件字节数\",{\"1\":{\"106\":1}}],[\"允许请求失败的次数默认为1\",{\"1\":{\"106\":1}}],[\"返回的数据\",{\"1\":{\"1431\":1}}],[\"返回的值不合理\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"返回方法地址等信息\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"返回失败\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"返回true\",{\"1\":{\"1087\":3,\"1288\":3}}],[\"返回值类型\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"返回值类型必须相同\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"返回值类型可以相同也可以不同\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"返回值为移除的元素\",{\"1\":{\"604\":1}}],[\"返回处理结果\",{\"1\":{\"956\":1}}],[\"返回\",{\"1\":{\"956\":3,\"1084\":1,\"1285\":1}}],[\"返回给浏览器\",{\"1\":{\"950\":1}}],[\"返回给定\",{\"1\":{\"659\":1}}],[\"返回给定所有集合的交集并存储在\",{\"1\":{\"606\":1}}],[\"返回给定所有集合的交集\",{\"1\":{\"606\":1}}],[\"返回给定所有集合的差集并存储在\",{\"1\":{\"606\":1}}],[\"返回给定所有集合的差集\",{\"1\":{\"606\":1}}],[\"返回类型\",{\"1\":{\"830\":1}}],[\"返回假\",{\"1\":{\"692\":1}}],[\"返回一个线程安全的\",{\"1\":{\"988\":1}}],[\"返回一个\",{\"1\":{\"956\":2}}],[\"返回一个或多个位置对象的\",{\"1\":{\"660\":1}}],[\"返回一个错误\",{\"1\":{\"604\":1}}],[\"返回有序集中\",{\"1\":{\"607\":1}}],[\"返回有序集中指定分数区间内的成员\",{\"1\":{\"607\":1}}],[\"返回有序集中指定区间内的成员\",{\"1\":{\"607\":1}}],[\"返回有序集合中指定成员的排名\",{\"1\":{\"607\":1}}],[\"返回有序集合中指定成员的索引\",{\"1\":{\"607\":1}}],[\"返回所有给定集合的并集\",{\"1\":{\"606\":1}}],[\"返回集合中一个或多个随机数\",{\"1\":{\"606\":1}}],[\"返回集合中的所有成员\",{\"1\":{\"606\":1}}],[\"返回原值\",{\"1\":{\"603\":1}}],[\"返回以毫秒为单位的当前时间\",{\"1\":{\"388\":1}}],[\"返回其中出现频率前\",{\"1\":{\"353\":1}}],[\"返回结果\",{\"1\":{\"352\":1,\"360\":1,\"364\":1,\"377\":1,\"1144\":1,\"1335\":1}}],[\"返回数组\",{\"1\":{\"284\":1}}],[\"返回哪些值\",{\"1\":{\"179\":1}}],[\"返回proxy\",{\"1\":{\"106\":1}}],[\"返回顶部按钮\",{\"1\":{\"20\":1,\"23\":1}}],[\"例子\",{\"1\":{\"505\":1,\"555\":1,\"557\":1,\"573\":1,\"916\":1,\"1099\":1,\"1176\":1,\"1297\":1,\"1361\":1}}],[\"例\",{\"1\":{\"106\":1}}],[\"例如数据库连接信息\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"例如下面user3\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"例如说\",{\"1\":{\"1043\":1,\"1048\":1,\"1050\":1,\"1252\":1,\"1257\":1,\"1259\":1}}],[\"例如锁的持有者\",{\"1\":{\"1023\":1}}],[\"例如可重入锁\",{\"1\":{\"1022\":2}}],[\"例如日志记录\",{\"1\":{\"1016\":2}}],[\"例如t\",{\"1\":{\"966\":1}}],[\"例如缓存\",{\"1\":{\"948\":1}}],[\"例如在usermapper\",{\"1\":{\"782\":1}}],[\"例如servlet\",{\"1\":{\"706\":1}}],[\"例如1024字节的键值就不是个好主意\",{\"1\":{\"602\":1}}],[\"例如上例中的商品描述\",{\"1\":{\"516\":1}}],[\"例如定义一个\",{\"1\":{\"457\":1}}],[\"例如文档\",{\"1\":{\"450\":1,\"451\":1}}],[\"例如主机名\",{\"1\":{\"443\":1}}],[\"例如新闻正文\",{\"1\":{\"443\":1}}],[\"例如倒排索引等内容\",{\"1\":{\"394\":1,\"423\":1}}],[\"例如快速排序\",{\"1\":{\"359\":1}}],[\"例如arraylist\",{\"0\":{\"285\":1}}],[\"例如xfs\",{\"1\":{\"272\":1}}],[\"例如添加\",{\"1\":{\"181\":1}}],[\"例如dubbo\",{\"1\":{\"165\":1}}],[\"例如查询dubbo\",{\"1\":{\"159\":1}}],[\"例如256k\",{\"1\":{\"106\":1}}],[\"例如\",{\"1\":{\"106\":2,\"273\":1,\"330\":1,\"339\":1,\"357\":1,\"438\":1,\"444\":1,\"445\":1,\"498\":1,\"501\":2,\"502\":2,\"504\":1,\"510\":1,\"511\":1,\"527\":1,\"530\":1,\"541\":1,\"556\":1,\"558\":1,\"561\":1,\"566\":1,\"580\":1,\"602\":1,\"603\":1,\"706\":1,\"723\":1,\"762\":1,\"766\":2,\"771\":1,\"772\":1,\"930\":3,\"934\":1,\"960\":4,\"966\":1,\"978\":1,\"1010\":5,\"1016\":1,\"1020\":1,\"1022\":3,\"1042\":1,\"1048\":1,\"1072\":1,\"1086\":1,\"1087\":1,\"1128\":1,\"1133\":1,\"1166\":1,\"1177\":1,\"1217\":1,\"1219\":1,\"1251\":1,\"1257\":1,\"1276\":1,\"1287\":1,\"1288\":1,\"1321\":1,\"1326\":1,\"1354\":1,\"1362\":1,\"1394\":1,\"1396\":1}}],[\"例如创建\",{\"1\":{\"77\":1}}],[\"后释放这个锁\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"后俩点不懂可以先说有一定了解\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"后俩个分别再出一个demo\",{\"1\":{\"683\":1}}],[\"后者则是很多\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"后来在一些只读的方法上使用可重入锁reentrantreadwritelock\",{\"1\":{\"1018\":1}}],[\"后来在我不懈的努力之下总算研究出一些成果\",{\"1\":{\"692\":1}}],[\"后来变成了y\",{\"1\":{\"1018\":1}}],[\"后再发送下一条消息\",{\"1\":{\"994\":1}}],[\"后续的遍历行为在新数组上进行\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"后续的when则不会执行\",{\"1\":{\"785\":1}}],[\"后续一篇代码分析\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"后续补充\",{\"1\":{\"798\":1}}],[\"后续过程\",{\"1\":{\"364\":1}}],[\"后置最终通知\",{\"1\":{\"689\":1}}],[\"后置通知\",{\"1\":{\"689\":1,\"944\":1}}],[\"后置节点\",{\"1\":{\"621\":1}}],[\"后台启动\",{\"1\":{\"674\":1}}],[\"后出现异常宕机\",{\"1\":{\"664\":1}}],[\"后退指针\",{\"1\":{\"628\":1}}],[\"后记\",{\"0\":{\"521\":1}}],[\"后\",{\"1\":{\"429\":1,\"924\":1,\"950\":1,\"1212\":1,\"1389\":1}}],[\"后期可以修改\",{\"1\":{\"422\":1}}],[\"后期不能修改\",{\"1\":{\"422\":1}}],[\"后进先出\",{\"1\":{\"282\":2,\"946\":1}}],[\"后端返回值结构体定义\",{\"0\":{\"1430\":1}}],[\"后端开发中\",{\"1\":{\"1045\":1,\"1254\":1}}],[\"后端开发\",{\"1\":{\"1033\":1}}],[\"后端服务器响应时间\",{\"1\":{\"106\":1}}],[\"后端服务器数据回传时间\",{\"1\":{\"106\":2}}],[\"后端服务器连接的超时时间\",{\"1\":{\"106\":1}}],[\"后端服务器为缓存时比较有效\",{\"1\":{\"106\":1}}],[\"后端的web服务器可以通过x\",{\"1\":{\"106\":1}}],[\"后面带该注解的全类名\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"后面加stash\",{\"1\":{\"916\":1}}],[\"后面在\",{\"1\":{\"829\":1}}],[\"后面跟随一个表达式\",{\"1\":{\"689\":1}}],[\"后面单独一篇详细讲解\",{\"1\":{\"636\":1}}],[\"后面单开一篇讲解\",{\"1\":{\"499\":1}}],[\"后面的篇章\",{\"1\":{\"608\":1}}],[\"后面的用冒号分割\",{\"1\":{\"94\":1}}],[\"后面代码中会讲解使用方式\",{\"1\":{\"414\":1}}],[\"后面会在公众号单独发出\",{\"1\":{\"343\":1}}],[\"后面学不会怎么办等\",{\"1\":{\"98\":1}}],[\"按序取出即可\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"按region进行内存分块\",{\"1\":{\"940\":1}}],[\"按多个id查询\",{\"1\":{\"787\":1}}],[\"按姓名模糊查询\",{\"1\":{\"783\":1}}],[\"按住alt+enter\",{\"1\":{\"756\":1}}],[\"按数据行\",{\"1\":{\"520\":2}}],[\"按照阶段理解spring中的bean的生命周期主要包含四个阶段\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"按照顺序消费\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"按照顺序存储\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"按照容量划分二个大小相等的内存区域\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"按照\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"按照内存块做了分段\",{\"1\":{\"940\":1}}],[\"按照多个id查询用户信息\",{\"1\":{\"787\":1}}],[\"按照年龄进行查询\",{\"1\":{\"786\":2}}],[\"按照插入顺序排序\",{\"1\":{\"604\":1}}],[\"按照不同的行进行分片\",{\"1\":{\"509\":1}}],[\"按照业务维度拆分\",{\"1\":{\"509\":1}}],[\"按照空格切分\",{\"1\":{\"411\":1}}],[\"按照非字母切分\",{\"1\":{\"411\":1}}],[\"按词切分\",{\"1\":{\"411\":1}}],[\"按ffmpeg官方文档说\",{\"1\":{\"145\":1}}],[\"按访问url的hash结果来分配请求\",{\"1\":{\"106\":1}}],[\"按后端服务器的响应时间来分配请求\",{\"1\":{\"106\":1}}],[\"响应\",{\"1\":{\"1128\":2,\"1321\":2}}],[\"响应对象\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"响应用户\",{\"1\":{\"956\":2}}],[\"响应时间短的优先分配\",{\"1\":{\"106\":1}}],[\"响应码\",{\"1\":{\"104\":1}}],[\"轮询\",{\"1\":{\"106\":1,\"1162\":1,\"1350\":1}}],[\"权值越高被分配到的几率越大\",{\"1\":{\"106\":1}}],[\"传递的参数动态地生成需要执行的\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"传递性\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"传递性依赖\",{\"0\":{\"707\":1}}],[\"传输效率高\",{\"1\":{\"1135\":1,\"1328\":1}}],[\"传输效率低\",{\"1\":{\"1135\":1,\"1328\":1}}],[\"传输快但比较消耗cpu\",{\"1\":{\"106\":1}}],[\"传入的参数类型\",{\"1\":{\"777\":1,\"778\":1}}],[\"传入参数类型\",{\"1\":{\"775\":1}}],[\"传送一篇不错的跳跃表介绍文章\",{\"1\":{\"628\":1}}],[\"传送门\",{\"1\":{\"1\":1,\"49\":1}}],[\"传统消息系统使用中间件作为消息的中转站\",{\"1\":{\"992\":1}}],[\"传统消息系统通常采用点对点或发布\",{\"1\":{\"992\":1}}],[\"传统消息系统是怎么工作的\",{\"1\":{\"992\":1}}],[\"传统方式1\",{\"0\":{\"896\":1}}],[\"传统方式管理jar依赖的问题\",{\"1\":{\"700\":1}}],[\"传统方法可以参考子标题下面的伪代码\",{\"1\":{\"286\":1}}],[\"传统用来搜索的平衡二叉树有很多\",{\"1\":{\"266\":1}}],[\"记忆会更深刻\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"记得在学习和工作中保持好奇心\",{\"1\":{\"996\":1}}],[\"记住这幅图\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"记住\",{\"1\":{\"986\":1,\"994\":1}}],[\"记录机制实现\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"记录下所有改变了数据库数据的语句\",{\"1\":{\"1186\":1,\"1369\":1}}],[\"记录对数据库执行更改的所有操作\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"记录对象数据在关键处理步骤中的变化情况\",{\"1\":{\"191\":1}}],[\"记录所有对数据库请求的信息\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"记录出错信息\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"记录帖子的阅读量\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"记录词条在文档中的位置信息\",{\"1\":{\"1012\":1}}],[\"记录了每个关键词在哪些文档中出现过\",{\"1\":{\"1006\":1}}],[\"记录不同region之间的引用关系\",{\"1\":{\"940\":2}}],[\"记录内容越多\",{\"1\":{\"433\":1}}],[\"记录\",{\"1\":{\"429\":1,\"433\":3,\"619\":2}}],[\"记录要插入的数据\",{\"1\":{\"352\":1}}],[\"记录日志并不是要把所有信息都记录下来\",{\"1\":{\"192\":1}}],[\"记录客户浏览器的相关信息\",{\"1\":{\"106\":1}}],[\"记录发送给客户端文件主体内容大小\",{\"1\":{\"106\":1}}],[\"记一次redis线上问题\",{\"0\":{\"71\":1}}],[\"成百上千的场景\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"成熟稳定\",{\"1\":{\"1032\":1}}],[\"成为主节点\",{\"1\":{\"1008\":1}}],[\"成为以下的数列\",{\"1\":{\"375\":2}}],[\"成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发\",{\"1\":{\"1031\":1}}],[\"成功次数偏移量\",{\"1\":{\"1023\":1}}],[\"成功次数\",{\"1\":{\"1023\":1}}],[\"成功时的构造器\",{\"1\":{\"830\":1}}],[\"成功时返回的数据\",{\"1\":{\"830\":1}}],[\"成功\",{\"1\":{\"829\":1,\"852\":1,\"1431\":1}}],[\"成功是200\",{\"1\":{\"106\":1}}],[\"成员变量\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"成员对象\",{\"1\":{\"628\":1}}],[\"成员的分数值\",{\"1\":{\"607\":1}}],[\"成长\",{\"0\":{\"10\":1},\"2\":{\"11\":1}}],[\"x版本以后\",{\"1\":{\"1198\":1,\"1378\":1}}],[\"x版本已经被copy\",{\"1\":{\"436\":1}}],[\"x中只支持replica\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"xclass2\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"xclass1\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"xclass\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"xx\",{\"1\":{\"942\":5,\"1151\":7,\"1342\":7}}],[\"xxxautoconfiguration\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"xxxx\",{\"1\":{\"779\":3}}],[\"xxxoverides\",{\"1\":{\"724\":1}}],[\"xxx\",{\"1\":{\"94\":1,\"597\":1}}],[\"x=\",{\"1\":{\"865\":25}}],[\"xsd\",{\"1\":{\"715\":4,\"812\":2,\"815\":2,\"818\":3,\"819\":3,\"820\":1,\"844\":2}}],[\"xsi\",{\"1\":{\"715\":2,\"812\":1,\"815\":1,\"818\":1,\"819\":1,\"820\":1,\"844\":1,\"865\":6}}],[\"xsi=\",{\"1\":{\"715\":2,\"812\":1,\"815\":1,\"818\":1,\"819\":1,\"820\":1,\"844\":1,\"865\":1}}],[\"xzf\",{\"1\":{\"598\":1}}],[\"x64\",{\"1\":{\"597\":1}}],[\"xeon\",{\"1\":{\"591\":1}}],[\"x3320\",{\"1\":{\"591\":1}}],[\"x锁\",{\"1\":{\"555\":1,\"575\":1}}],[\"xy\",{\"1\":{\"451\":4}}],[\"xget\",{\"1\":{\"436\":1}}],[\"xpath\",{\"1\":{\"865\":1}}],[\"xpack\",{\"1\":{\"406\":2}}],[\"xput\",{\"1\":{\"436\":2}}],[\"xms\",{\"1\":{\"942\":1}}],[\"xms4096m\",{\"1\":{\"942\":1}}],[\"xms256m\",{\"1\":{\"702\":1}}],[\"xms200m\",{\"1\":{\"406\":1}}],[\"xmx\",{\"1\":{\"942\":1}}],[\"xmx4096m\",{\"1\":{\"942\":1}}],[\"xmx512m\",{\"1\":{\"702\":1}}],[\"xmx200m\",{\"1\":{\"406\":1}}],[\"xml节点时\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"xmlbeandefinitionreader\",{\"1\":{\"950\":4}}],[\"xml<\",{\"1\":{\"820\":1}}],[\"xml讲究严格的顺序\",{\"1\":{\"765\":1}}],[\"xml详解\",{\"0\":{\"765\":1}}],[\"xml引入usermapper\",{\"1\":{\"763\":1}}],[\"xml即可\",{\"1\":{\"761\":1}}],[\"xml的sql\",{\"1\":{\"761\":1}}],[\"xml的文件中\",{\"1\":{\"698\":1}}],[\"xml配置\",{\"1\":{\"745\":1}}],[\"xml配置文件\",{\"1\":{\"701\":1,\"1216\":1,\"1393\":1}}],[\"xml需要设置父工程\",{\"1\":{\"715\":1}}],[\"xmlschema\",{\"1\":{\"715\":2,\"812\":1,\"815\":1,\"818\":1,\"819\":1,\"820\":1,\"844\":1,\"865\":2}}],[\"xmlns\",{\"1\":{\"715\":2,\"812\":1,\"815\":2,\"818\":3,\"819\":3,\"820\":4,\"844\":1,\"865\":6}}],[\"xmlns=\",{\"1\":{\"715\":2,\"812\":1,\"815\":1,\"818\":1,\"819\":1,\"820\":1,\"844\":1,\"865\":1}}],[\"xml中配置\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"xml中引入该外部配置文件\",{\"1\":{\"782\":1}}],[\"xml中使用它\",{\"1\":{\"782\":1}}],[\"xml中定义如下片段\",{\"1\":{\"782\":1}}],[\"xml中\",{\"1\":{\"705\":1}}],[\"xml中修改指定自定义的仓库路径\",{\"1\":{\"702\":1}}],[\"xml文件中如\",{\"1\":{\"782\":1}}],[\"xml文件详解\",{\"0\":{\"773\":1}}],[\"xml文件添加junit依赖\",{\"1\":{\"756\":1}}],[\"xml文件的相对路径\",{\"1\":{\"715\":2}}],[\"xml文件的位置\",{\"1\":{\"703\":1,\"704\":1}}],[\"xml文件\",{\"1\":{\"702\":1,\"703\":1,\"815\":1,\"817\":1}}],[\"xml\",{\"0\":{\"724\":1,\"742\":1,\"743\":1,\"744\":2,\"745\":1,\"747\":1,\"755\":1,\"815\":1,\"817\":1,\"818\":1,\"819\":1,\"820\":1,\"843\":1,\"1175\":1,\"1360\":1},\"1\":{\"648\":2,\"701\":1,\"704\":1,\"715\":1,\"743\":1,\"744\":1,\"745\":2,\"746\":1,\"747\":1,\"751\":1,\"755\":4,\"757\":2,\"759\":1,\"761\":1,\"762\":2,\"763\":7,\"768\":1,\"770\":1,\"772\":10,\"782\":3,\"790\":1,\"800\":1,\"812\":2,\"815\":5,\"817\":1,\"818\":2,\"819\":3,\"820\":7,\"821\":2,\"827\":8,\"828\":2,\"839\":1,\"844\":4,\"865\":2,\"885\":1,\"950\":1,\"958\":4,\"1128\":1,\"1177\":1,\"1179\":3,\"1321\":1,\"1362\":1,\"1364\":3,\"1444\":2}}],[\"x86\",{\"1\":{\"405\":2}}],[\"x整合prometheus+grafana\",{\"0\":{\"847\":1,\"881\":1},\"1\":{\"881\":1,\"885\":1}}],[\"x整合springboot\",{\"1\":{\"394\":1}}],[\"x整合elasticsearch7\",{\"0\":{\"394\":1,\"397\":1,\"411\":1,\"428\":1,\"460\":1},\"1\":{\"397\":1,\"411\":2,\"428\":2,\"460\":2}}],[\"x实战目录\",{\"1\":{\"397\":1,\"411\":1,\"428\":1,\"460\":1}}],[\"x实战\",{\"0\":{\"394\":1,\"397\":1,\"411\":1,\"428\":1,\"460\":1},\"1\":{\"411\":1,\"428\":1,\"460\":1}}],[\"xiaopeng9275\",{\"1\":{\"388\":1}}],[\"xn\",{\"1\":{\"266\":1}}],[\"x2\",{\"1\":{\"266\":1}}],[\"x264\",{\"1\":{\"145\":1}}],[\"x1<\",{\"1\":{\"266\":1}}],[\"xr\",{\"1\":{\"159\":8}}],[\"x等\",{\"1\":{\"122\":1}}],[\"x\",{\"1\":{\"106\":8,\"140\":1,\"159\":8,\"273\":1,\"333\":1,\"339\":4,\"443\":2,\"457\":1,\"555\":1,\"558\":2,\"603\":1,\"705\":1,\"808\":1,\"924\":8,\"950\":1,\"1087\":4,\"1288\":4,\"1444\":1}}],[\"合并分支\",{\"1\":{\"915\":1}}],[\"合并到主分支\",{\"1\":{\"915\":1}}],[\"合并为一个\",{\"1\":{\"659\":1}}],[\"合理的设置分词器\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"合理的利用缓存不仅能够提升网站访问速度\",{\"1\":{\"594\":1}}],[\"合理使用索引别名\",{\"1\":{\"1002\":1}}],[\"合理使用数据结构\",{\"1\":{\"942\":1}}],[\"合理设置分片和副本的数量\",{\"1\":{\"1002\":1}}],[\"合理设计索引和映射\",{\"1\":{\"1002\":1}}],[\"合理配置kafka的参数\",{\"1\":{\"980\":1}}],[\"合理分配\",{\"1\":{\"950\":1}}],[\"合理地建立索引可以大幅提高查询效率\",{\"1\":{\"502\":1}}],[\"合计\",{\"1\":{\"546\":1}}],[\"合约名\",{\"1\":{\"488\":1}}],[\"合约中设置条件\",{\"1\":{\"486\":1}}],[\"合适下载服务器\",{\"1\":{\"106\":1}}],[\"合作才有未来\",{\"1\":{\"49\":1}}],[\"来判断\",{\"1\":{\"1431\":1}}],[\"来增强被代理类的功能\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"来装载class文件到运行时数据区中的方法区中\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"来支持线程局部变量\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"来源\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"来源网络\",{\"1\":{\"562\":1,\"1179\":1,\"1364\":1}}],[\"来设置去重需要的固定内存使用量\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"来设置超时时间\",{\"1\":{\"603\":1}}],[\"来找到被包含在\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"来说更加易用\",{\"1\":{\"1032\":1}}],[\"来说明一下分片的工作原理\",{\"1\":{\"1004\":1}}],[\"来原子更新变量值\",{\"1\":{\"1018\":1}}],[\"来获取\",{\"1\":{\"1010\":4,\"1116\":1,\"1311\":1}}],[\"来测试一下你的熟练程度\",{\"1\":{\"960\":1}}],[\"来聊点具体的吧\",{\"1\":{\"950\":1}}],[\"来吧\",{\"1\":{\"936\":1,\"960\":1}}],[\"来\",{\"1\":{\"934\":1}}],[\"来实现整个程序的功能\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"来实现多个客户端之间的通信\",{\"1\":{\"1020\":2}}],[\"来实现对事件调度状态的修改\",{\"1\":{\"1018\":1}}],[\"来实现链表节点的非阻塞追加等操作\",{\"1\":{\"1018\":1}}],[\"来实现幂等性\",{\"1\":{\"996\":1}}],[\"来实现高吞吐量和可伸缩性\",{\"1\":{\"986\":1}}],[\"来实现\",{\"1\":{\"932\":2,\"1233\":1,\"1408\":1}}],[\"来做的\",{\"1\":{\"1033\":1}}],[\"来做\",{\"1\":{\"1033\":1}}],[\"来做区别\",{\"1\":{\"919\":1}}],[\"来做到环境的分离\",{\"1\":{\"771\":1}}],[\"来学习\",{\"1\":{\"903\":1}}],[\"来完成\",{\"1\":{\"818\":1}}],[\"来完成映射\",{\"1\":{\"793\":1}}],[\"来管理项目的构建\",{\"1\":{\"698\":1}}],[\"来解决键冲突\",{\"1\":{\"624\":1}}],[\"来解析\",{\"1\":{\"29\":1}}],[\"来打印出\",{\"1\":{\"619\":1}}],[\"来代替\",{\"1\":{\"602\":1}}],[\"来保证自增值的唯一性和连续性\",{\"1\":{\"575\":1}}],[\"来显式地锁定需要的资源\",{\"1\":{\"570\":1}}],[\"来确定分区\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"来确定元素的正确位置\",{\"1\":{\"359\":1}}],[\"来确保消息的顺序性\",{\"1\":{\"984\":1}}],[\"来确保数据一致性\",{\"1\":{\"569\":1}}],[\"来连接条件\",{\"0\":{\"528\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"来搭建全文搜索引擎\",{\"1\":{\"507\":1}}],[\"来选择所有列\",{\"1\":{\"504\":1}}],[\"来存储数据\",{\"1\":{\"632\":1}}],[\"来存储\",{\"1\":{\"444\":1}}],[\"来存储的\",{\"1\":{\"387\":1}}],[\"来操作\",{\"1\":{\"436\":1}}],[\"来查询主分片\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"来查询\",{\"1\":{\"436\":1}}],[\"来读取磁盘中的文件\",{\"1\":{\"403\":1}}],[\"来表现数据元素之间的逻辑关系\",{\"1\":{\"284\":1}}],[\"来表示同一机器同一时间截\",{\"1\":{\"387\":1}}],[\"来表示不同的\",{\"1\":{\"387\":1}}],[\"来表示\",{\"1\":{\"166\":1}}],[\"来回答系统下各个节点的提问\",{\"1\":{\"153\":1}}],[\"来自被代理服务器\",{\"1\":{\"106\":1}}],[\"来提交任意小于256k的图片\",{\"1\":{\"106\":1}}],[\"来输出文件\",{\"1\":{\"106\":1}}],[\"方\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"方言\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"方便开发时状态码搞混\",{\"1\":{\"1431\":1}}],[\"方便前端直接将接口响应状态展示\",{\"1\":{\"1431\":1}}],[\"方便很多\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"方便我们快速找到需要的信息\",{\"1\":{\"1004\":1}}],[\"方便我们查阅遗忘的知识点\",{\"1\":{\"920\":1}}],[\"方便对时间敏感应用进行分析\",{\"1\":{\"942\":1}}],[\"方便后续调用\",{\"1\":{\"934\":1}}],[\"方便查找\",{\"1\":{\"916\":1}}],[\"方便统一管控项目的依赖版本问题\",{\"1\":{\"715\":1}}],[\"方便定位问题\",{\"0\":{\"197\":1}}],[\"方案三\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"方案2\",{\"1\":{\"515\":1}}],[\"方案1\",{\"1\":{\"515\":1}}],[\"方案一\",{\"0\":{\"385\":1},\"1\":{\"1047\":1,\"1048\":1,\"1049\":1,\"1256\":1,\"1257\":1,\"1258\":1}}],[\"方案二\",{\"0\":{\"386\":1},\"1\":{\"209\":1,\"1047\":1,\"1048\":1,\"1049\":1,\"1256\":1,\"1257\":1,\"1258\":1}}],[\"方式进行入队和出队操作\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"方式\",{\"1\":{\"106\":1,\"603\":1,\"1073\":1,\"1277\":1}}],[\"方法内\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"方法也是一个模板方法\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"方法进行实例化\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"方法进行同步操作\",{\"1\":{\"1023\":2}}],[\"方法从\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"方法从主题中拉取消息\",{\"1\":{\"990\":1}}],[\"方法用于将线程由\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"方法用于暂停线程指定时间\",{\"1\":{\"988\":1}}],[\"方法2\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"方法1\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"方法里面的代码交替执行\",{\"1\":{\"1098\":1,\"1296\":1}}],[\"方法里面的代码\",{\"1\":{\"1098\":1,\"1296\":1}}],[\"方法里面的代码全部执行完毕之后\",{\"1\":{\"1098\":1,\"1296\":1}}],[\"方法执行结束\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"方法体\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"方法注册一个\",{\"1\":{\"1034\":1}}],[\"方法注入\",{\"1\":{\"954\":1}}],[\"方法都被\",{\"1\":{\"1022\":1}}],[\"方法将消息推送到名为my\",{\"1\":{\"990\":1}}],[\"方法睡醒后直接继续执行\",{\"1\":{\"988\":1}}],[\"方法被唤醒后必须重新获取锁\",{\"1\":{\"988\":1}}],[\"方法必须指定等待时间\",{\"1\":{\"988\":1}}],[\"方法通常被用于线程间通信\",{\"1\":{\"988\":1}}],[\"方法通知\",{\"1\":{\"988\":1}}],[\"方法不释放锁\",{\"1\":{\"988\":1}}],[\"方法释放锁\",{\"1\":{\"988\":1}}],[\"方法有什么区别\",{\"1\":{\"988\":1}}],[\"方法在产品就绪时唤醒等待线程\",{\"1\":{\"988\":1}}],[\"方法使生产线程和消费线程在产品未就绪时等待\",{\"1\":{\"988\":1}}],[\"方法实现了等价关系\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"方法实现\",{\"1\":{\"954\":1}}],[\"方法又注入\",{\"1\":{\"954\":1}}],[\"方法对象\",{\"1\":{\"952\":1}}],[\"方法加载\",{\"1\":{\"950\":1}}],[\"方法初始化\",{\"1\":{\"950\":1}}],[\"方法动态扩容\",{\"1\":{\"946\":1}}],[\"方法参数\",{\"1\":{\"944\":1}}],[\"方法上添加我们的登录注解\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"方法上\",{\"1\":{\"944\":1}}],[\"方法退出后\",{\"1\":{\"936\":1}}],[\"方法的线程会被挂起\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"方法的使用效果并不像for+break语句那样\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"方法的区别\",{\"0\":{\"1098\":1,\"1296\":1}}],[\"方法的参数列表一定不一样\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"方法的参数上\",{\"1\":{\"944\":1}}],[\"方法的字节码\",{\"1\":{\"934\":2}}],[\"方法的返回值\",{\"1\":{\"689\":1}}],[\"方法分别对应着获取锁和释放锁的操作\",{\"1\":{\"932\":1}}],[\"方法等待其他线程\",{\"1\":{\"932\":2}}],[\"方法区与java堆一样\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"方法区和堆是所有线程共享的内存区域\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"方法区也被称为永久代\",{\"1\":{\"930\":1}}],[\"方法区也是被所有线程共享的一块内存区域\",{\"1\":{\"930\":1}}],[\"方法区\",{\"1\":{\"930\":1,\"936\":3}}],[\"方法出口等信息\",{\"1\":{\"930\":1}}],[\"方法时\",{\"1\":{\"928\":2,\"1016\":1}}],[\"方法来说\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"方法来判断对象的值是否相等\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"方法来调用这个方法\",{\"1\":{\"1010\":1}}],[\"方法来获取这个字段的泛型类型\",{\"1\":{\"1010\":1}}],[\"方法来获取\",{\"1\":{\"1010\":3}}],[\"方法来获取当前线程的变量值即可\",{\"1\":{\"928\":1}}],[\"方法来创建一个实现了\",{\"1\":{\"1016\":1}}],[\"方法来创建\",{\"1\":{\"1010\":2}}],[\"方法来实现的\",{\"1\":{\"932\":2}}],[\"方法来实现自定义的线程池行为\",{\"1\":{\"926\":1}}],[\"方法来设置当前线程的变量值\",{\"1\":{\"928\":1}}],[\"方法来保证分布均匀\",{\"1\":{\"922\":1}}],[\"方法会立即看到\",{\"1\":{\"924\":1}}],[\"方法可以调用其他方法来处理请求\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"方法可以在没有指定时间的情况下一直等待\",{\"1\":{\"988\":1}}],[\"方法可以通过\",{\"1\":{\"831\":1}}],[\"方法可能会一直等待下去\",{\"1\":{\"924\":1}}],[\"方法后\",{\"1\":{\"924\":2}}],[\"方法计算\",{\"1\":{\"922\":1}}],[\"方法大致分为以下几步\",{\"1\":{\"922\":1}}],[\"方法即可\",{\"1\":{\"839\":1,\"928\":1}}],[\"方法定义粒度\",{\"1\":{\"830\":1}}],[\"方法只有一个参数\",{\"1\":{\"826\":1}}],[\"方法和run\",{\"0\":{\"1098\":1,\"1296\":1}}],[\"方法和\",{\"1\":{\"826\":1,\"932\":1,\"988\":1}}],[\"方法和要点\",{\"0\":{\"405\":1},\"1\":{\"394\":1}}],[\"方法一键启动应用\",{\"1\":{\"1224\":1,\"1399\":1}}],[\"方法一般是跟notify方法连用的\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"方法一\",{\"1\":{\"793\":1,\"1101\":1,\"1299\":1}}],[\"方法调用\",{\"1\":{\"770\":1}}],[\"方法中做标识符\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"方法中断线程\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"方法中添加了日志记录的逻辑\",{\"1\":{\"1016\":1}}],[\"方法中注入\",{\"1\":{\"954\":1}}],[\"方法中执行清理工作\",{\"1\":{\"952\":1}}],[\"方法中执行初始化逻辑\",{\"1\":{\"952\":1}}],[\"方法中实现的\",{\"1\":{\"952\":2,\"964\":1}}],[\"方法中\",{\"1\":{\"766\":1,\"924\":1,\"934\":1}}],[\"方法最后执行\",{\"1\":{\"689\":1}}],[\"方法异常时执行\",{\"1\":{\"689\":1}}],[\"方法名称\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"方法名必须相同\",{\"1\":{\"1086\":2,\"1287\":2}}],[\"方法名\",{\"1\":{\"689\":1,\"934\":1}}],[\"方法理解\",{\"1\":{\"352\":1}}],[\"方法二\",{\"1\":{\"94\":1,\"793\":1,\"1101\":1,\"1299\":1}}],[\"方法\",{\"1\":{\"82\":1,\"195\":1,\"692\":1,\"762\":1,\"825\":2,\"932\":1,\"944\":2,\"950\":2,\"952\":5,\"954\":1,\"1010\":1,\"1016\":1,\"1022\":1,\"1087\":1,\"1092\":2,\"1098\":2,\"1100\":2,\"1105\":1,\"1107\":1,\"1128\":3,\"1214\":1,\"1228\":1,\"1288\":1,\"1293\":2,\"1296\":2,\"1298\":2,\"1303\":1,\"1305\":1,\"1321\":3,\"1391\":1,\"1403\":1}}],[\"函数出口打印返回值及时间等\",{\"1\":{\"192\":1}}],[\"函数\",{\"1\":{\"106\":1,\"619\":1}}],[\"函数可以保证线程安全\",{\"1\":{\"82\":1}}],[\"注\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"注入功能类进行方法调用\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"注入到拦截器即可\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"注入到spring容器中\",{\"1\":{\"815\":1}}],[\"注入service依赖\",{\"1\":{\"830\":1}}],[\"注入sqlsessionfactory\",{\"1\":{\"815\":1}}],[\"注入数据库连接池\",{\"1\":{\"815\":1,\"818\":1}}],[\"注释是\",{\"1\":{\"944\":1}}],[\"注释是写给人看的\",{\"1\":{\"944\":1}}],[\"注释不会对程序产生任何影响\",{\"1\":{\"944\":1}}],[\"注释写错了\",{\"1\":{\"918\":1}}],[\"注释式日志切面\",{\"1\":{\"689\":1}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"42\":1}}],[\"注解来实现\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"注解处理器\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"注解声明\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"注解声明切面\",{\"1\":{\"689\":1}}],[\"注解三要素是哪些\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"注解大致分为以下三种\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"注解非常常见\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"注解不会继承\",{\"1\":{\"944\":1}}],[\"注解不能作用于变量\",{\"1\":{\"944\":1}}],[\"注解不能继承其他注解或接口\",{\"1\":{\"944\":1}}],[\"注解中的成员变量只能是基本类型\",{\"1\":{\"944\":1}}],[\"注解只有成员变量\",{\"1\":{\"944\":1}}],[\"注解有一个非常常见的使用场景\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"注解有以下几个限制\",{\"1\":{\"944\":1}}],[\"注解有哪些限制\",{\"1\":{\"944\":1}}],[\"注解可以放在\",{\"1\":{\"944\":1}}],[\"注解在哪些地方可以使用\",{\"1\":{\"944\":1}}],[\"注解生命周期有3种\",{\"1\":{\"944\":1}}],[\"注解的本质是什么\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"注解的生命周期有几种\",{\"1\":{\"944\":1}}],[\"注解的用处主要三个\",{\"1\":{\"944\":1}}],[\"注解会影响程序的编译\",{\"1\":{\"944\":1}}],[\"注解和注释有什么区别吧\",{\"1\":{\"944\":1}}],[\"注解方式可以使用如下配置方式\",{\"1\":{\"772\":1}}],[\"注解方式\",{\"1\":{\"772\":2}}],[\"注解定义切点\",{\"1\":{\"689\":1}}],[\"注解名为log\",{\"1\":{\"688\":1}}],[\"注解名为\",{\"1\":{\"688\":1}}],[\"注解是\",{\"1\":{\"944\":1}}],[\"注解是写给机器看的\",{\"1\":{\"944\":1}}],[\"注解是否将包含在\",{\"1\":{\"688\":2}}],[\"注解是javaee的基础\",{\"1\":{\"682\":1}}],[\"注解用于什么地方\",{\"1\":{\"688\":2}}],[\"注解\",{\"0\":{\"688\":1},\"1\":{\"812\":1,\"825\":2,\"826\":1,\"831\":1,\"944\":1,\"952\":2,\"1227\":1,\"1402\":1}}],[\"注意一点\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"注意完成这个操作后\",{\"1\":{\"918\":1}}],[\"注意自己的密码\",{\"1\":{\"816\":1}}],[\"注意\",{\"1\":{\"106\":1,\"145\":1,\"267\":1,\"388\":1,\"561\":1,\"604\":1,\"675\":1,\"702\":2,\"705\":1,\"710\":1,\"779\":1,\"801\":1,\"917\":1,\"918\":1,\"1031\":1,\"1085\":1,\"1091\":1,\"1243\":1,\"1286\":1,\"1292\":1,\"1416\":1}}],[\"以防止系统出现不可预期的数据结构和类型\",{\"1\":{\"1431\":1}}],[\"以防万一出现问题\",{\"1\":{\"511\":1}}],[\"以非事务方式执行\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"以非事务方式执行操作\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"以java为例\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"以标签的形式编写动态\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"以受害者名义伪造请求发送给受攻击站点\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"以多线程的方式处理客户端请求的小程序\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"以此来完成动态\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"以此使程序运行效率不受影响\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"以此达到循环队列的效果\",{\"1\":{\"288\":1}}],[\"以达到切换数据源的目的\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"以达到找到目的地的结果\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"以达到在保证查询效率的同时\",{\"1\":{\"946\":1}}],[\"以缩减存储\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"以释放空间\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"以释放内存空间\",{\"1\":{\"972\":2}}],[\"以实现负载均衡和高可用性\",{\"1\":{\"1002\":1}}],[\"以实现数据的分布式存储和处理\",{\"1\":{\"1002\":1}}],[\"以实现数据的冗余和负载均衡\",{\"1\":{\"1000\":1}}],[\"以方便通过反射来读取和使用注解信息\",{\"1\":{\"944\":1}}],[\"以方便后续排序时进行分值计算\",{\"1\":{\"425\":1}}],[\"以保证可见性和有序性\",{\"1\":{\"924\":1}}],[\"以保证指令不会被重排序\",{\"1\":{\"924\":2}}],[\"以进一步加深理解\",{\"1\":{\"922\":1}}],[\"以让其它开发人员与项目共享\",{\"1\":{\"713\":1}}],[\"以让其它项目依赖\",{\"1\":{\"713\":1}}],[\"以struts2\",{\"1\":{\"709\":1}}],[\"以配置顺序上方的版本为准\",{\"1\":{\"709\":1}}],[\"以配置顺序下方的版本为准\",{\"1\":{\"709\":1}}],[\"以直接依赖的版本为准\",{\"1\":{\"709\":1}}],[\"以为使用这个关键字\",{\"1\":{\"692\":1}}],[\"以最大长度为标准\",{\"1\":{\"632\":1}}],[\"以二进制的方式来处理sds存放在buf数组里的数据\",{\"1\":{\"620\":1}}],[\"以空字符结尾\",{\"1\":{\"619\":1}}],[\"以空字符结尾的字符数组\",{\"1\":{\"619\":1}}],[\"以下都是\",{\"1\":{\"1111\":1,\"1184\":1}}],[\"以下都是java的并发基础面试题\",{\"1\":{\"1097\":1}}],[\"以下都是java的基础面试题\",{\"1\":{\"1083\":1}}],[\"以下案例是在生产环境中最常使用的git组合命令集\",{\"1\":{\"914\":1}}],[\"以下简称\",{\"1\":{\"619\":1}}],[\"以下是\",{\"1\":{\"1023\":1,\"1026\":1,\"1030\":1,\"1041\":1,\"1056\":1,\"1067\":1,\"1126\":1,\"1141\":1,\"1155\":1,\"1171\":1,\"1197\":1,\"1210\":1,\"1223\":1,\"1236\":1}}],[\"以下是这几个组件的详细说明\",{\"1\":{\"956\":1}}],[\"以下是我为您继续写的文章\",{\"1\":{\"932\":1}}],[\"以下是一些docker的基础面试题\",{\"1\":{\"1056\":1}}],[\"以下是一些性能优化的技巧\",{\"1\":{\"1002\":1}}],[\"以下是一些反向代理的配置\",{\"1\":{\"106\":1}}],[\"以下是一个简单的示例代码\",{\"1\":{\"1020\":1}}],[\"以下是一个简单的自定义锁的示例代码\",{\"1\":{\"932\":1}}],[\"以下是一个简化的选主源码示例\",{\"1\":{\"1008\":1}}],[\"以下是一个使用\",{\"1\":{\"932\":2}}],[\"以下是哈希表渐进式\",{\"1\":{\"625\":1}}],[\"以下是面试场景\",{\"1\":{\"262\":1}}],[\"以减少过期键值对的清理频率\",{\"1\":{\"972\":1}}],[\"以减少死锁的可能性\",{\"1\":{\"581\":1}}],[\"以减少系统开销和提高性能\",{\"1\":{\"574\":1}}],[\"以减少系统表资源的消耗\",{\"0\":{\"541\":1}}],[\"以识别是否存在死锁\",{\"1\":{\"581\":1}}],[\"以表明事务将在更细粒度上请求锁\",{\"1\":{\"575\":1}}],[\"以确保新版本不会被旧版本覆盖\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"以确保在同一时间只有一个线程可以访问被修饰的代码\",{\"1\":{\"1022\":1}}],[\"以确保在rr隔离级别下\",{\"1\":{\"575\":1}}],[\"以确保数据的实时性\",{\"1\":{\"972\":1}}],[\"以确保数据的完整性和一致性\",{\"1\":{\"560\":1}}],[\"以确保查询性能\",{\"0\":{\"508\":1}}],[\"以提高分布式锁的可用性和容错性\",{\"1\":{\"970\":1}}],[\"以提高性能和可扩展性\",{\"1\":{\"968\":1}}],[\"以提高程序的性能\",{\"1\":{\"924\":1}}],[\"以提高速度\",{\"0\":{\"542\":1}}],[\"以提高冗余\",{\"1\":{\"422\":1}}],[\"以至于优化器选择全表扫描\",{\"1\":{\"527\":1}}],[\"以目录为结论\",{\"1\":{\"525\":1}}],[\"以后便不再执行\",{\"1\":{\"648\":1}}],[\"以后\",{\"1\":{\"515\":1}}],[\"以后每新出一个项目加一次价格\",{\"1\":{\"212\":1}}],[\"以加快连接操作的速度\",{\"1\":{\"502\":1}}],[\"以太坊为例\",{\"1\":{\"484\":1}}],[\"以取代淘汰的\",{\"1\":{\"457\":1}}],[\"以及和投票相关的能力\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"以及对应的实现\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"以及对代理方法的调用逻辑\",{\"1\":{\"1016\":1}}],[\"以及软件系统和硬件系统之间\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"以及一个\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"以及一个存储文档的列表\",{\"1\":{\"1004\":1}}],[\"以及一些调优手段\",{\"0\":{\"1068\":1,\"1272\":1}}],[\"以及它们与\",{\"1\":{\"988\":1}}],[\"以及它在mysql中的使用场景\",{\"0\":{\"505\":1}}],[\"以及如何处理死锁和锁竞争的情况\",{\"1\":{\"970\":1}}],[\"以及如何保证可见性和有序性\",{\"1\":{\"924\":1}}],[\"以及各自的优劣\",{\"1\":{\"946\":1}}],[\"以及子列表的修改如何影响原列表\",{\"1\":{\"946\":1}}],[\"以及两者对调优的影响\",{\"1\":{\"942\":1}}],[\"以及stw与并发相结合\",{\"1\":{\"940\":1}}],[\"以及vm指定的其他jar包\",{\"1\":{\"934\":1}}],[\"以及源码\",{\"1\":{\"705\":1}}],[\"以及指向\",{\"1\":{\"628\":1}}],[\"以及链表长度等信息\",{\"1\":{\"622\":1}}],[\"以及哪些事务持有其他事务正在等待的锁\",{\"1\":{\"580\":1}}],[\"以及在不需要频繁锁定和解锁单个行的场景中\",{\"1\":{\"561\":1}}],[\"以及在倒排列表中记录单词在某个文档出现的位置信息\",{\"1\":{\"425\":1}}],[\"以及可能的下一个键值\",{\"1\":{\"556\":1}}],[\"以及较低的维护成本\",{\"1\":{\"503\":1}}],[\"以及\",{\"1\":{\"448\":1,\"950\":1,\"1032\":1}}],[\"以存储更多的数据\",{\"1\":{\"421\":1}}],[\"以上是数组和链表的通俗对比\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"以上是我们最最常使用的git命令\",{\"1\":{\"915\":1}}],[\"以上就是\",{\"1\":{\"936\":1}}],[\"以上就是g1收集器的整个工作流程\",{\"1\":{\"936\":1}}],[\"以上代码定义了一个\",{\"1\":{\"932\":1}}],[\"以上代码创建了一个\",{\"1\":{\"932\":2}}],[\"以上部分整个\",{\"1\":{\"824\":1}}],[\"以上配置是整合\",{\"1\":{\"822\":1}}],[\"以上几点是环境搭建的基础\",{\"1\":{\"403\":1}}],[\"以上日志不会打印\",{\"1\":{\"195\":1}}],[\"以前只是看过介绍\",{\"1\":{\"692\":1}}],[\"以前的用法是\",{\"1\":{\"436\":1}}],[\"以前称为\",{\"1\":{\"400\":1}}],[\"以前\",{\"1\":{\"364\":1}}],[\"以\",{\"1\":{\"177\":1,\"251\":1,\"375\":1,\"525\":1}}],[\"以毫秒为单位\",{\"1\":{\"157\":1}}],[\"以平衡磁盘与网络io处理速度\",{\"1\":{\"106\":1}}],[\"以平衡磁盘与网络i\",{\"1\":{\"106\":1}}],[\"以便简化缓存机制\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"以便为路由提供合适的分片\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"以便在后续的操作中与主节点进行通信\",{\"1\":{\"1008\":1}}],[\"以便在发生线程切换时恢复执行位置\",{\"1\":{\"930\":1}}],[\"以便全面掌握map及各实现类\",{\"1\":{\"948\":1}}],[\"以便全面掌握list及其相关接口与实现类\",{\"1\":{\"946\":1}}],[\"以便进一步熟练掌握类加载机制的相关原理\",{\"1\":{\"934\":1}}],[\"以便于以后的查询能够获取更好的性能\",{\"1\":{\"440\":1}}],[\"以便\",{\"1\":{\"26\":1}}],[\"可简单了解\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"可简化创建\",{\"1\":{\"1057\":1,\"1263\":1}}],[\"可重复读指的是在一个事务内\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"可重复读\",{\"1\":{\"1187\":1,\"1188\":1,\"1220\":1,\"1370\":1,\"1371\":1,\"1397\":1}}],[\"可重用的组件\",{\"1\":{\"699\":1}}],[\"可参考第四问\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"可恢复性等功能\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"可水平扩展\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"可持久化\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"可见的\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"可见性是性对于线程而言\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"可见性\",{\"1\":{\"692\":1}}],[\"可配置的精度\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"可配置启动incremental\",{\"1\":{\"938\":1}}],[\"可列举如下\",{\"1\":{\"1046\":1,\"1255\":1}}],[\"可先写到内存\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"可扩展和高效\",{\"1\":{\"1002\":1}}],[\"可扩展的搜索和分析平台\",{\"1\":{\"1000\":1}}],[\"可扩展的bloom过滤器\",{\"1\":{\"343\":1}}],[\"可扩展\",{\"1\":{\"978\":1}}],[\"可扩展性和可靠性是kafka的强项\",{\"1\":{\"978\":1}}],[\"可靠\",{\"1\":{\"1135\":1,\"1328\":1}}],[\"可靠的分布式消息系统\",{\"1\":{\"978\":1}}],[\"可靠性和可扩展性让它成为了很多公司的首选\",{\"1\":{\"976\":1}}],[\"可靠地将消息递送给不同的系统\",{\"1\":{\"974\":1}}],[\"可尝试\",{\"1\":{\"896\":1}}],[\"可是\",{\"1\":{\"800\":1}}],[\"可是奇怪的事情发生了\",{\"1\":{\"692\":1}}],[\"可作为了解部份\",{\"1\":{\"706\":1}}],[\"可跳过\",{\"1\":{\"705\":1}}],[\"可订阅一个频道并接收主服务器完整的消息发布记录\",{\"1\":{\"589\":1}}],[\"可执行单层树复制\",{\"1\":{\"589\":1}}],[\"可基于内存亦可持久化的日志型\",{\"1\":{\"589\":1}}],[\"可用性\",{\"1\":{\"1078\":2,\"1240\":1,\"1282\":1,\"1413\":1}}],[\"可用性指某个库出问题\",{\"1\":{\"518\":1}}],[\"可用于程序化配置或布署\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"可用于满足特定场景\",{\"1\":{\"436\":1}}],[\"可用连接实例最大数目\",{\"1\":{\"648\":1}}],[\"可视化使用的是\",{\"1\":{\"460\":1}}],[\"可填ip\",{\"1\":{\"406\":1}}],[\"可不受此限制\",{\"1\":{\"274\":1}}],[\"可使用在范围查询等\",{\"1\":{\"270\":1}}],[\"可能选出多个领导\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"可能只有一个\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"可能有一丢丢多\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"可能有一部分用户\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"可能有不准确之处\",{\"1\":{\"440\":1}}],[\"可能\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"可能需要一些时间来理解和掌握\",{\"1\":{\"978\":1}}],[\"可能出现classcastexception\",{\"1\":{\"966\":1}}],[\"可能表明表存在碎片化问题\",{\"1\":{\"511\":1}}],[\"可能会受到其他事务的影响\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"可能会在某些时间点被超高并发地访问\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"可能会看到旧值\",{\"1\":{\"924\":1}}],[\"可能会引发连锁更新操作\",{\"1\":{\"633\":1}}],[\"可能会遇到什么问题\",{\"1\":{\"509\":1}}],[\"可能会发生锁等待\",{\"1\":{\"508\":1}}],[\"可能会造成泄露\",{\"1\":{\"385\":1}}],[\"可能不会选择使用索引\",{\"1\":{\"501\":1}}],[\"可能进行节点的拆分和合并\",{\"1\":{\"499\":1}}],[\"可能导致磁盘的随机访问\",{\"1\":{\"499\":1}}],[\"可能在集合中\",{\"1\":{\"342\":1}}],[\"可能对接口做出修改更新\",{\"1\":{\"181\":1}}],[\"可能还有些公司只用\",{\"1\":{\"178\":1}}],[\"可选依赖\",{\"0\":{\"708\":1}}],[\"可选\",{\"1\":{\"106\":1,\"1063\":2,\"1269\":2}}],[\"可设置为off\",{\"1\":{\"106\":2}}],[\"可以来\",{\"1\":{\"1444\":1}}],[\"可以增强代码的可维护性\",{\"1\":{\"1439\":1}}],[\"可以增加x\",{\"1\":{\"106\":1}}],[\"可以展示一个\",{\"1\":{\"1431\":1}}],[\"可以迭代出整个对象的结构图\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"可以存取对象的属性和调用对象的方法\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"可以存储大量元素\",{\"1\":{\"922\":1}}],[\"可以存储\",{\"1\":{\"605\":1}}],[\"可以存储经纬度相关信息\",{\"1\":{\"453\":1}}],[\"可以有效的防止sql注入\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"可以有选择性地\",{\"1\":{\"940\":1}}],[\"可以严格控制sql执行性能\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"可以与垃圾收集线程一起并发运行\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"可以防止内存中出现多份同样的字节码\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"可以防止sql注入\",{\"1\":{\"779\":1}}],[\"可以放在cookie中\",{\"1\":{\"1131\":2,\"1324\":2}}],[\"可以顺带谈谈多线程环境下arraylist的替代品\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"可以中断等待\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"可以多次使用\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"可以保证线程之间的顺序执行把线程从并发状态调整为串行状态保证了线程的执行顺序\",{\"1\":{\"1104\":2,\"1302\":2}}],[\"可以处理不同类型的方法\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"可以处理大量的数据流\",{\"1\":{\"978\":1}}],[\"可以认为一个io操作包含两个部分\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"可以认为是elasticsearch的服务进程\",{\"1\":{\"417\":1}}],[\"可以成为master节点数n\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"可以手动点击\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"可以引入消息队列\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"可以从以下多个方面进行共同着手\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"可以做的事情\",{\"1\":{\"1033\":1}}],[\"可以先基于时间敲定索引再检索\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"可以先运行一个\",{\"1\":{\"1030\":1}}],[\"可以先学习之前的\",{\"1\":{\"652\":1}}],[\"可以避免\",{\"1\":{\"1022\":1}}],[\"可以支持高效的\",{\"1\":{\"1020\":1}}],[\"可以支持大量的并发连接\",{\"1\":{\"1020\":1}}],[\"可以支持很多主流数据源\",{\"1\":{\"884\":1}}],[\"可以同时监控多个通道的\",{\"1\":{\"1020\":1}}],[\"可以缓存频繁使用的查询结果\",{\"1\":{\"1002\":1}}],[\"可以轻松地处理大量的消息和高并发\",{\"1\":{\"992\":1}}],[\"可以改变\",{\"1\":{\"988\":1}}],[\"可以向kafka发送确认消息\",{\"1\":{\"984\":1}}],[\"可以实现多个条件变量\",{\"1\":{\"1022\":1}}],[\"可以实现超时锁和可中断锁\",{\"1\":{\"1022\":1}}],[\"可以实现公平锁和非公平锁\",{\"1\":{\"1022\":1}}],[\"可以实现更细粒度的锁控制\",{\"1\":{\"1022\":1}}],[\"可以实现高效的文件读写操作\",{\"1\":{\"1020\":1}}],[\"可以实现高性能的服务器和客户端\",{\"1\":{\"1020\":1}}],[\"可以实现高可用和负载均衡\",{\"1\":{\"950\":1}}],[\"可以实现消息的负载均衡和故障恢复\",{\"1\":{\"980\":1}}],[\"可以比单独存储每个键值对更节省内存\",{\"1\":{\"972\":1}}],[\"可以减少网络往返次数\",{\"1\":{\"970\":1}}],[\"可以出现在读和写的操作中\",{\"1\":{\"966\":1}}],[\"可以装任何东西\",{\"1\":{\"966\":1}}],[\"可以彻底压缩aof文件体积\",{\"1\":{\"962\":1}}],[\"可以是\",{\"1\":{\"958\":1}}],[\"可以是一个规则表达式\",{\"1\":{\"944\":1}}],[\"可以开发微服务架构的系统\",{\"1\":{\"950\":1}}],[\"可以应用在很多实际场景中\",{\"1\":{\"950\":1}}],[\"可以添加属性\",{\"1\":{\"944\":1}}],[\"可以更加灵活地控制线程的等待和唤醒\",{\"1\":{\"1022\":1}}],[\"可以更好运用g1收集器\",{\"1\":{\"940\":1}}],[\"可以更着做一些项目\",{\"1\":{\"101\":1}}],[\"可以分为多个\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"可以分为5种\",{\"1\":{\"448\":1}}],[\"可以分布到多个\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"可以分代增量回收\",{\"1\":{\"940\":1}}],[\"可以这样理解\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"可以这样查询\",{\"1\":{\"528\":1}}],[\"可以这么总结\",{\"1\":{\"936\":1}}],[\"可以采用linkedhashmap\",{\"1\":{\"922\":1}}],[\"可以动态调整容量和提高查询性能\",{\"1\":{\"922\":1}}],[\"可以选择hashtable或者concurrenthashmap\",{\"1\":{\"922\":1}}],[\"可以选择并发版的concurrenthashmap\",{\"1\":{\"922\":1}}],[\"可以选择以下替代方案\",{\"1\":{\"922\":1}}],[\"可以高效地进行插入操作\",{\"1\":{\"922\":1}}],[\"可以高效的支持范围查询和排序操作\",{\"1\":{\"499\":1}}],[\"可以快速定位到相应的位置\",{\"1\":{\"922\":1}}],[\"可以给我简单介绍一下它的内部实现机制吗\",{\"1\":{\"922\":1}}],[\"可以理解为就是一个文件\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"可以理解为\",{\"1\":{\"917\":1,\"966\":1}}],[\"可以理解为一本书的目录\",{\"1\":{\"494\":1}}],[\"可以发现\",{\"1\":{\"916\":1}}],[\"可以基于\",{\"1\":{\"903\":1,\"1079\":1,\"1283\":1}}],[\"可以方便的预览\",{\"1\":{\"912\":1}}],[\"可以方便的监控很多应用\",{\"1\":{\"883\":1}}],[\"可以方便更灵活的控制项目\",{\"1\":{\"698\":1}}],[\"可以强制清除缓存\",{\"1\":{\"789\":1}}],[\"可以省略\",{\"1\":{\"775\":1,\"777\":1,\"778\":1}}],[\"可以配置成适应多种环境\",{\"1\":{\"771\":1}}],[\"可以配置多个\",{\"1\":{\"743\":1,\"745\":1}}],[\"可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型\",{\"1\":{\"769\":1}}],[\"可以大大简化命令行的输入\",{\"1\":{\"712\":1}}],[\"可以仅仅调用clean来清理工作目录\",{\"1\":{\"711\":1}}],[\"可以标识平面中唯一的一点\",{\"1\":{\"705\":1}}],[\"可以修改\",{\"1\":{\"705\":1}}],[\"可以自己想想\",{\"1\":{\"1022\":1}}],[\"可以自由控制sql\",{\"1\":{\"827\":1}}],[\"可以自动创建文件结构和自动生成pom\",{\"1\":{\"703\":1}}],[\"可以自主选择合适的排序算法\",{\"1\":{\"350\":1}}],[\"可以不配置\",{\"1\":{\"702\":1}}],[\"可以作为一个单项或者双向队列\",{\"1\":{\"655\":1}}],[\"可以很好的利用cpu缓存访问数据\",{\"1\":{\"632\":1}}],[\"可以直接在方法上\",{\"1\":{\"818\":1}}],[\"可以直接跳过前面基础引入部分\",{\"1\":{\"732\":1}}],[\"可以直接重用一部分\",{\"1\":{\"619\":1}}],[\"可以直接从物化视图或汇总表中获取\",{\"1\":{\"504\":1}}],[\"可以利用\",{\"1\":{\"594\":1}}],[\"可以利用shard很好的横向扩展\",{\"1\":{\"421\":1}}],[\"可以将对象序列化成二进制数组\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"可以将文件映射到内存中\",{\"1\":{\"1020\":1}}],[\"可以将消息均匀地分布在不同的节点上\",{\"1\":{\"984\":1}}],[\"可以将内存中的数据写入磁盘\",{\"1\":{\"960\":1}}],[\"可以将内存中的数据保存在磁盘中\",{\"1\":{\"592\":1}}],[\"可以将用户\",{\"1\":{\"658\":1}}],[\"可以将\",{\"1\":{\"658\":1}}],[\"可以将表按字段切开\",{\"1\":{\"516\":1}}],[\"可以节省存储空间\",{\"0\":{\"539\":1}}],[\"可以把所有的可能存在的key放到一个大的bitmap中\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"可以把运行时的问题提前到编译时期\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"可以把pom中很多相同的配置提取出来\",{\"1\":{\"715\":1}}],[\"可以把一个表的数据\",{\"1\":{\"520\":2}}],[\"可以把一个宽表的字段按访问频次\",{\"1\":{\"520\":1}}],[\"可以把多个表按业务耦合松紧归类\",{\"1\":{\"520\":1}}],[\"可以把文章下载到本地吗\",{\"0\":{\"97\":1}}],[\"可以获取表的碎片化信息\",{\"1\":{\"511\":1}}],[\"可以获取表的状态信息\",{\"1\":{\"511\":1}}],[\"可以参考\",{\"1\":{\"505\":1}}],[\"可以考虑将登录信息等重要信息存放为session\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"可以考虑将它们分开处理\",{\"1\":{\"504\":1}}],[\"可以考虑读写锁\",{\"1\":{\"1018\":1}}],[\"可以考虑使用物化视图或汇总表来存储查询结果\",{\"1\":{\"504\":1}}],[\"可以考虑创建一个包含这些列的复合索引\",{\"1\":{\"504\":1}}],[\"可以使用内存映射来提高文件的读取速度\",{\"1\":{\"1020\":1}}],[\"可以使用下面的语法\",{\"1\":{\"917\":1}}],[\"可以使用下面的简便语法\",{\"1\":{\"917\":1}}],[\"可以使用命令git\",{\"1\":{\"916\":1}}],[\"可以使用一部分\",{\"1\":{\"620\":1}}],[\"可以使用这个\",{\"1\":{\"614\":1}}],[\"可以使用information\",{\"1\":{\"580\":1}}],[\"可以使用乐观锁\",{\"1\":{\"573\":1}}],[\"可以使用lock\",{\"1\":{\"565\":1}}],[\"可以使用\",{\"1\":{\"511\":1,\"819\":1,\"918\":1,\"988\":1,\"1020\":1,\"1033\":1}}],[\"可以使用69年\",{\"1\":{\"388\":1}}],[\"可以使得每个节点包含更多的键值\",{\"1\":{\"503\":1}}],[\"可以领取回\",{\"1\":{\"488\":1}}],[\"可以看做一个独立的\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"可以看出转换后的\",{\"1\":{\"451\":1}}],[\"可以看到指令重排之后\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"可以看到用户在排行榜里的排名\",{\"1\":{\"657\":1}}],[\"可以看到\",{\"1\":{\"555\":1,\"911\":1,\"940\":1}}],[\"可以看到他的类型是\",{\"1\":{\"488\":1}}],[\"可以看到我们的es版本信息\",{\"1\":{\"407\":1}}],[\"可以看到dubbo服务地外提供的接口\",{\"1\":{\"159\":1}}],[\"可以看到很多脚本文件\",{\"1\":{\"159\":1}}],[\"可以让我们拿到spring容器的些资源\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"可以让我们在\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"可以让我们的开发进一步\",{\"1\":{\"601\":1}}],[\"可以让我们的搜索引擎更高效\",{\"1\":{\"428\":1}}],[\"可以让对象数组独立检索\",{\"1\":{\"451\":1}}],[\"可以转换为\",{\"1\":{\"444\":1}}],[\"可以优先考虑使用\",{\"1\":{\"444\":1}}],[\"可以用于多线程计算数据\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"可以用于线程间的同步\",{\"1\":{\"988\":1}}],[\"可以用于过滤\",{\"1\":{\"443\":1}}],[\"可以用在类型参数的位置\",{\"1\":{\"966\":1}}],[\"可以用来会横切多个对象\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"可以用来开发网站\",{\"1\":{\"950\":1}}],[\"可以用来实现诸如查找在指定地理区域内相关的文档\",{\"1\":{\"453\":1}}],[\"可以用作数据库\",{\"1\":{\"614\":1}}],[\"可以用2个哈希函数来模拟k个哈希函数\",{\"1\":{\"339\":1}}],[\"可以通过下标直接定位元素\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"可以通过版本号使用乐观并发控制\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"可以通过反射读取\",{\"1\":{\"944\":1}}],[\"可以通过提高初始容量和负载因子来减少冲突及拉链长度\",{\"1\":{\"922\":1}}],[\"可以通过一小段描述信息\",{\"1\":{\"698\":1}}],[\"可以通过优化语法或者配置优化器\",{\"1\":{\"527\":1}}],[\"可以通过对象类型来存储二级文档\",{\"1\":{\"450\":1}}],[\"可以通过设置最少投票通过数量\",{\"1\":{\"1074\":1,\"1278\":1}}],[\"可以通过设置来转换成合适的类型\",{\"1\":{\"439\":1}}],[\"可以通过设定该值设定字段的默认值\",{\"1\":{\"434\":1}}],[\"可以通过\",{\"1\":{\"436\":1,\"511\":1,\"601\":1,\"1176\":1,\"1361\":1}}],[\"可以通过上面的命令查询设备索引号\",{\"1\":{\"145\":1}}],[\"可以设计一个高性能\",{\"1\":{\"950\":1}}],[\"可以设成\",{\"1\":{\"431\":1}}],[\"可以设置\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"可以设置消息的确认级别\",{\"1\":{\"994\":1}}],[\"可以设置较长的过期时间\",{\"1\":{\"972\":1}}],[\"可以设置较短的过期时间\",{\"1\":{\"972\":1}}],[\"可以设置在多值字段的数据上火分词字段上\",{\"1\":{\"440\":1}}],[\"可以设置maxrate\",{\"1\":{\"134\":1}}],[\"可以设置最多3层目录\",{\"1\":{\"106\":1}}],[\"可以对一个字段提供多种索引模式\",{\"1\":{\"440\":1}}],[\"可以对\",{\"1\":{\"431\":1}}],[\"可以提升性能和并发\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"可以提升集群整体的吞吐量和性能\",{\"1\":{\"421\":1}}],[\"可以提高数据的读写效率\",{\"1\":{\"1020\":1}}],[\"可以提高并发性\",{\"1\":{\"571\":1}}],[\"可以提示它跳转到注册页面\",{\"1\":{\"186\":1}}],[\"可以非常方便\",{\"1\":{\"401\":1}}],[\"可以说是当下最先进\",{\"1\":{\"400\":1}}],[\"可以跟着整个教程做一个练习\",{\"1\":{\"397\":1,\"411\":1,\"428\":1,\"460\":1}}],[\"可以表示的最大正整数是\",{\"1\":{\"387\":2}}],[\"可以表示的数值范围是\",{\"1\":{\"387\":1}}],[\"可以部署在1024个节点\",{\"1\":{\"388\":1}}],[\"可以部署在\",{\"1\":{\"387\":1}}],[\"可以得到k个key被hash过后的数\",{\"1\":{\"339\":1}}],[\"可以得到n个key被hash过后的数\",{\"1\":{\"333\":1}}],[\"可以判断数据绝对不存在\",{\"1\":{\"334\":1}}],[\"可以在sql内直接书写带有物理分页的参数来完成物理分页功能\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"可以在哪些cpu上运行等等\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"可以在哪些实际场景中使用\",{\"1\":{\"950\":1}}],[\"可以在等待\",{\"1\":{\"1020\":1}}],[\"可以在各种场景下发挥作用\",{\"1\":{\"976\":1}}],[\"可以在静态方法内使用类型参数\",{\"1\":{\"966\":1}}],[\"可以在非泛型类上使用\",{\"1\":{\"966\":1}}],[\"可以在程序运行期间动态的将某段代码切入到指定的方法\",{\"1\":{\"950\":1}}],[\"可以在公众号回复\",{\"1\":{\"886\":1}}],[\"可以在公众号留言\",{\"1\":{\"212\":1}}],[\"可以在下面引用\",{\"1\":{\"844\":1}}],[\"可以在切入点前后织入代码\",{\"1\":{\"689\":1}}],[\"可以在\",{\"1\":{\"526\":1,\"952\":1}}],[\"可以在这些列上建立组合索引\",{\"1\":{\"502\":1}}],[\"可以在常数时间复杂度内定位到目标数据\",{\"1\":{\"499\":1}}],[\"可以在不修改代码的情况下\",{\"1\":{\"194\":1}}],[\"可以解耦具体的日志实现\",{\"1\":{\"194\":1}}],[\"可以解决session的问题\",{\"1\":{\"106\":1}}],[\"可以google一下\",{\"1\":{\"135\":1}}],[\"可以进行重定向或者进行新的代理\",{\"1\":{\"106\":1}}],[\"可以讲client\",{\"1\":{\"106\":1}}],[\"可以根据环境部署不同的\",{\"1\":{\"950\":1}}],[\"可以根据单词快速获取包含这个单词的文档列表\",{\"1\":{\"424\":1}}],[\"可以根据机器配置定义权重\",{\"1\":{\"106\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"26\":1}}],[\"可以联系我和我交流一下我的联系方式\",{\"1\":{\"98\":1}}],[\"可以学吗\",{\"0\":{\"98\":1}}],[\"可以的\",{\"1\":{\"97\":1,\"950\":1}}],[\"可以前往代码仓库点个免费的\",{\"1\":{\"1\":1}}],[\"它已经帮我们把大多数的常用工具都做好了\",{\"1\":{\"1444\":1}}],[\"它负责存储和管理大家都关心的数据\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"它不是一种技术\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"它不仅能够提升你的技术能力\",{\"1\":{\"978\":1}}],[\"它不仅需要解决跨库带来的所有复杂问题\",{\"1\":{\"520\":1}}],[\"它起到了一种类似\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"它拥有多个独立的齿轮\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"它被广泛地实现在各种并发容器集合中\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"它被广泛应用于各种应用程序中\",{\"1\":{\"1000\":1}}],[\"它以高吞吐\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"它以高吞吐量和低延迟而闻名\",{\"1\":{\"992\":1}}],[\"它以银行借贷系统的分配策略为基础\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"它更像是一个线程内部的通信\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"它提供一个字段的基数\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"它提供了对集合对象进行基本操作的通用接口方法\",{\"1\":{\"1113\":1,\"1308\":1}}],[\"它提供了一种基于缓冲区和通道的\",{\"1\":{\"1020\":1}}],[\"它提供了一个分布式的\",{\"1\":{\"1000\":1}}],[\"它提供了一系列用于索引和搜索文档的api\",{\"1\":{\"1000\":1}}],[\"它提供了强大的全文搜索功能和实时数据分析能力\",{\"1\":{\"1000\":1}}],[\"它提供了java\",{\"1\":{\"589\":1}}],[\"它提供了录制\",{\"1\":{\"122\":1}}],[\"它并不是一个原子操作\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"它并不加入到集群中\",{\"1\":{\"1075\":1,\"1279\":1}}],[\"它并发执行与用户程序\",{\"1\":{\"938\":1}}],[\"它就组装这些结果为单个响应返回给客户端\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"它就像是一个日志的快递小哥\",{\"1\":{\"976\":1}}],[\"它就像是一个强壮的邮递员\",{\"1\":{\"974\":1}}],[\"它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"它实现了\",{\"1\":{\"1016\":2}}],[\"它实际上是一个很长的二进制向量和一系列随机映射函数\",{\"1\":{\"332\":1}}],[\"它使用容器来打包应用程序及其依赖项\",{\"1\":{\"1057\":1,\"1263\":1}}],[\"它使用\",{\"1\":{\"1018\":1}}],[\"它使用了\",{\"1\":{\"932\":2}}],[\"它使得elasticsearch能够在分布式环境中处理大规模的数据\",{\"1\":{\"1012\":1}}],[\"它决定了集群中哪个节点将成为主节点\",{\"1\":{\"1008\":1}}],[\"它还可以用于日志分析\",{\"1\":{\"1002\":1}}],[\"它还具有持久性存储和消息回溯的能力\",{\"1\":{\"978\":1}}],[\"它采用了push和pull的结合方式来实现消息传递\",{\"1\":{\"990\":1}}],[\"它能够自动处理故障\",{\"1\":{\"986\":1}}],[\"它将根据\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"它将请求并行转发到\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"它将每个词与包含该词的文档建立关联\",{\"1\":{\"1002\":1}}],[\"它将索引划分为多个分片\",{\"1\":{\"1000\":1}}],[\"它将消息以topic的形式进行组织和存储\",{\"1\":{\"984\":1}}],[\"它将会完整加载这个字段所有\",{\"1\":{\"440\":1}}],[\"它需要大量的磁盘空间来存储消息\",{\"1\":{\"978\":1}}],[\"它需要为类中的静态变量分配内存并设置默认初始值\",{\"1\":{\"934\":1}}],[\"它没有任何限制\",{\"1\":{\"966\":1}}],[\"它代表的上界类型可能是t\",{\"1\":{\"966\":1}}],[\"它给t一个明确的类型\",{\"1\":{\"966\":1}}],[\"它把类型检查的工作从运行时提前到了编译时\",{\"1\":{\"966\":1}}],[\"它允许开发人员在\",{\"1\":{\"958\":1}}],[\"它允许存储的数据大小不同\",{\"1\":{\"632\":1}}],[\"它内部封装了jdbc\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"它内部封装了\",{\"1\":{\"958\":1}}],[\"它如何用于构建\",{\"1\":{\"950\":1}}],[\"它通过拉链法处理碰撞\",{\"1\":{\"948\":1}}],[\"它通过stw去修正并发阶段的错误\",{\"1\":{\"938\":1}}],[\"它和构造方法的不同之处在于\",{\"1\":{\"934\":1}}],[\"它优先于构造方法执行\",{\"1\":{\"934\":1}}],[\"它主要包括\",{\"1\":{\"934\":1}}],[\"它主要用于存放新创建的对象\",{\"1\":{\"930\":1}}],[\"它包含很多portlet\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"它包含了对象的监视器锁的状态信息\",{\"1\":{\"1023\":1}}],[\"它包含了非常先进的音频\",{\"1\":{\"122\":1}}],[\"它包括哪几个阶段\",{\"1\":{\"934\":1}}],[\"它要执行类构造器\",{\"1\":{\"934\":1}}],[\"它要占用物理空间\",{\"1\":{\"494\":1}}],[\"它得解析类文件里的符号引用\",{\"1\":{\"934\":1}}],[\"它得确定这个类里写的是否都是正确的java语法\",{\"1\":{\"934\":1}}],[\"它继承了\",{\"1\":{\"932\":1}}],[\"它定义了java程序中各种变量\",{\"1\":{\"930\":1}}],[\"它存储的内容是键值对\",{\"1\":{\"922\":1}}],[\"它在所有broker中选出一个controller\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"它在大数据领域中得到了广泛的应用\",{\"1\":{\"992\":1}}],[\"它在大数据处理和实时流处理方面有着广泛的应用\",{\"1\":{\"986\":1}}],[\"它在开发中有何作用\",{\"1\":{\"948\":1}}],[\"它在\",{\"1\":{\"820\":1}}],[\"它只和\",{\"1\":{\"768\":1}}],[\"它只允许在表的前端进行删除操作\",{\"1\":{\"282\":1}}],[\"它前面的所有阶段都会被运行\",{\"1\":{\"713\":1}}],[\"它之前的所有阶段都会被运行\",{\"1\":{\"712\":1}}],[\"它跟数组不同的一点是\",{\"1\":{\"632\":1}}],[\"它跟普通的平衡二叉树的不同是\",{\"1\":{\"263\":1}}],[\"它有以下优点\",{\"1\":{\"1079\":1,\"1283\":1}}],[\"它有以下几个作用\",{\"1\":{\"429\":1}}],[\"它有什么用\",{\"1\":{\"964\":1}}],[\"它有许多实现类\",{\"1\":{\"948\":1}}],[\"它有哪些线程安全的替代方案呢\",{\"1\":{\"922\":1}}],[\"它有点儿类似数组\",{\"1\":{\"632\":1}}],[\"它支持多种类型的数据结构\",{\"1\":{\"601\":1}}],[\"它支持存储的\",{\"1\":{\"589\":1}}],[\"它们代表什么含义\",{\"1\":{\"1027\":1}}],[\"它们会竞选成为主节点\",{\"1\":{\"1008\":1}}],[\"它们到底有什么用\",{\"1\":{\"944\":1}}],[\"它们让g1不需要像cms那样全堆回收\",{\"1\":{\"940\":1}}],[\"它们的工作可以简述为\",{\"1\":{\"940\":1}}],[\"它们都实现了list接口\",{\"1\":{\"946\":1}}],[\"它们都可以用于协调多个线程的执行顺序\",{\"1\":{\"932\":1}}],[\"它们都是大小写不敏感的\",{\"1\":{\"768\":1}}],[\"它们不会像java方法那样被编译成字节码\",{\"1\":{\"930\":1}}],[\"它们必须按照正确的顺序放置\",{\"1\":{\"917\":1}}],[\"它们什么场景会用\",{\"0\":{\"568\":1}}],[\"它们在innodb存储引擎中是如何工作的\",{\"0\":{\"497\":1}}],[\"它用的不正是你刚才提到的那套铁子数据结构吗\",{\"1\":{\"940\":1}}],[\"它用于等待其他线程的终止\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"它用于存储已被虚拟机加载的类信息\",{\"1\":{\"930\":1,\"1142\":1,\"1333\":1}}],[\"它用于维护两个表之间的链接\",{\"1\":{\"560\":1}}],[\"它用起来像单机一样\",{\"1\":{\"153\":1}}],[\"它表示\",{\"1\":{\"966\":1}}],[\"它表示表中未使用的空间百分比\",{\"1\":{\"511\":1}}],[\"它表明一个事务有意向在某个间隙中插入新行\",{\"1\":{\"558\":1}}],[\"它锁定一个范围内的间隙\",{\"1\":{\"558\":1}}],[\"它会认为当前集群中没有leader\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"它会等待直到count值为0才继续执行\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"它会释放该对象的监视器锁\",{\"1\":{\"1022\":1}}],[\"它会尝试获取该对象的重量级锁\",{\"1\":{\"1022\":1}}],[\"它会尝试获取该对象的轻量级锁\",{\"1\":{\"1022\":1}}],[\"它会尝试获取该对象的偏向锁\",{\"1\":{\"1022\":1}}],[\"它会尝试获取该对象的监视器锁\",{\"1\":{\"1022\":3}}],[\"它会将主节点的信息广播给所有的节点\",{\"1\":{\"1008\":1}}],[\"它会维护一个有序的节点列表\",{\"1\":{\"1008\":1}}],[\"它会根据倒排索引快速找到相关的网页\",{\"1\":{\"1006\":1}}],[\"它会根据新的节点数量重新计算哈希槽的分布\",{\"1\":{\"968\":1}}],[\"它会遍历分片中的文档\",{\"1\":{\"1004\":1}}],[\"它会被存储在对应的分片中\",{\"1\":{\"1004\":1}}],[\"它会产生大量空间碎片\",{\"1\":{\"938\":1}}],[\"它会把这个请求委派给它的父类加载器去完成\",{\"1\":{\"934\":1}}],[\"它会进行类文件的验证\",{\"1\":{\"934\":1}}],[\"它会去找\",{\"1\":{\"934\":1}}],[\"它会直接抛出\",{\"1\":{\"926\":1}}],[\"它会首先在该范围内设置一个插入意向锁\",{\"1\":{\"558\":1}}],[\"它会首先在更粗力度上设置意向锁\",{\"1\":{\"557\":1}}],[\"它会先在表级别加上意向排他锁\",{\"1\":{\"557\":1}}],[\"它会使用large\",{\"1\":{\"106\":1}}],[\"它仅仅作为水平分库的一个补充优化\",{\"1\":{\"520\":1}}],[\"它带来的提升是\",{\"1\":{\"516\":1,\"517\":1,\"519\":1}}],[\"它默认配置了很多框架的使用方式\",{\"1\":{\"401\":1}}],[\"它可以帮我快速的生成\",{\"1\":{\"1444\":1}}],[\"它可以帮助我们快速地存储\",{\"1\":{\"998\":1}}],[\"它可以帮助我们解决各种有趣的问题\",{\"1\":{\"976\":1}}],[\"它可以分为这样的步骤\",{\"1\":{\"1439\":1}}],[\"它可以\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"它可以实现更细粒度的锁控制\",{\"1\":{\"1022\":1}}],[\"它可以根据指定的接口或类\",{\"1\":{\"1016\":1}}],[\"它可以在集群扩容\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"它可以在指定的时间后自行返回\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"它可以在不修改原有代码的情况下\",{\"1\":{\"1016\":2}}],[\"它可以在运行时动态地创建一个实现了指定接口的代理类\",{\"1\":{\"1016\":1}}],[\"它可以在运行时动态地获取类的信息\",{\"1\":{\"1010\":1,\"1016\":1}}],[\"它可以在需要时创建线程\",{\"1\":{\"926\":1}}],[\"它可以选择等待消息被确认\",{\"1\":{\"994\":1}}],[\"它可以选择将消息标记为已处理或者进行重试\",{\"1\":{\"980\":1}}],[\"它可以轻松地扩展到成百上千台服务器\",{\"1\":{\"978\":1}}],[\"它可以用来修饰方法或代码块\",{\"1\":{\"1022\":2}}],[\"它可以用于日志收集\",{\"1\":{\"974\":1}}],[\"它可以用作数据库\",{\"1\":{\"601\":1}}],[\"它可以让多个线程在某个点上等待\",{\"1\":{\"932\":1}}],[\"它可以让一个或多个线程等待其他线程完成某些操作后再执行\",{\"1\":{\"932\":1}}],[\"它可以让每个线程都拥有自己的变量副本\",{\"1\":{\"928\":1}}],[\"它可以看作是当前线程所执行的字节码的行号指示器\",{\"1\":{\"930\":1}}],[\"它可以保存类型为\",{\"1\":{\"630\":1}}],[\"它可以支持a\",{\"1\":{\"498\":1}}],[\"它可以被下面这样准确地形容\",{\"1\":{\"400\":1}}],[\"它可能是全局使用\",{\"1\":{\"77\":1}}],[\"它也是\",{\"1\":{\"364\":1}}],[\"它适用于一定范围的整数排序\",{\"1\":{\"359\":1}}],[\"它利用了函数的映射关系\",{\"1\":{\"348\":1}}],[\"它的底层实现都是由n个对象组成的\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"它的值同\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"它的作用可以看做是当前线程所执行的字节码的行号指示器\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"它的作用是测试它左边的对象是否是它右边的类的实例\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"它的作用是记录当前线程执行的位置\",{\"1\":{\"930\":1}}],[\"它的原理是\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"它的原理其实很简单\",{\"1\":{\"1006\":1}}],[\"它的不可变性\",{\"1\":{\"1089\":1,\"1290\":1}}],[\"它的size等于from+size的和\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"它的标记字会被设置为锁定状态\",{\"1\":{\"1022\":1}}],[\"它的设计目标是简单\",{\"1\":{\"1002\":1}}],[\"它的设计之巧妙令人颇感佩服与惊叹\",{\"1\":{\"940\":1}}],[\"它的架构设计非常有趣\",{\"1\":{\"986\":1}}],[\"它的活跃社区和丰富的生态系统也为开发者提供了很多便利\",{\"1\":{\"978\":1}}],[\"它的部署和配置可能会有一些复杂性\",{\"1\":{\"978\":1}}],[\"它的高吞吐量\",{\"1\":{\"976\":1}}],[\"它的核心特性有\",{\"1\":{\"950\":1}}],[\"它的核心特性是什么\",{\"1\":{\"950\":1}}],[\"它的核心理念是专库专用\",{\"1\":{\"517\":1}}],[\"它的主要用途有\",{\"1\":{\"964\":1}}],[\"它的主要作用是根据键快速获取值\",{\"1\":{\"948\":1}}],[\"它的主要实现类有\",{\"1\":{\"946\":1}}],[\"它的源码如下\",{\"1\":{\"946\":1}}],[\"它的源码能不能讲解一下\",{\"1\":{\"946\":1}}],[\"它的目标是达到更高的吞吐量和更短的gc停顿时间\",{\"1\":{\"940\":1}}],[\"它的目的是使全文检索变得简单\",{\"1\":{\"400\":1}}],[\"它的关键思想值得我们学习\",{\"1\":{\"938\":1}}],[\"它的工作原理是\",{\"1\":{\"962\":1}}],[\"它的工作原理是什么\",{\"1\":{\"962\":1}}],[\"它的工作流程如下\",{\"1\":{\"938\":1}}],[\"它的工作方式是被监控的服务需要公开一个prometheus端点\",{\"1\":{\"883\":1}}],[\"它的\",{\"1\":{\"932\":1}}],[\"它的实现机制相当精巧\",{\"1\":{\"948\":1}}],[\"它的实现原理与代理模式\",{\"1\":{\"948\":1}}],[\"它的实现原理与线程安全机制\",{\"1\":{\"946\":1}}],[\"它的实现原理就是基于\",{\"1\":{\"932\":1}}],[\"它的实现远不止这些\",{\"1\":{\"946\":1}}],[\"它的实现方式是通过一个计数器和一个屏障点来实现的\",{\"1\":{\"932\":1}}],[\"它的实现方式是通过一个计数器来实现的\",{\"1\":{\"932\":1}}],[\"它的大小不再受限于jvm内存大小\",{\"1\":{\"930\":1}}],[\"它的生命周期与线程相同\",{\"1\":{\"930\":1,\"1142\":1,\"1333\":1}}],[\"它的内部使用的是\",{\"1\":{\"400\":1}}],[\"它的结构如下图\",{\"1\":{\"387\":1}}],[\"它的最坏\",{\"1\":{\"364\":1}}],[\"它的父节点\",{\"1\":{\"364\":1}}],[\"它的性能在某些情况甚至快过那些o\",{\"1\":{\"359\":1}}],[\"它的复杂度为\",{\"1\":{\"357\":1}}],[\"它的优点还是非常突出的\",{\"1\":{\"978\":1}}],[\"它的优点是空间效率和查询时间都比一般的算法要好的多\",{\"1\":{\"332\":1}}],[\"它的优势在于在对一定范围内的整数排序时\",{\"1\":{\"357\":1}}],[\"它的投票是\",{\"1\":{\"166\":1}}],[\"它对于读取和写入大块数据有良好的性能\",{\"1\":{\"266\":1}}],[\"它类似普通的平衡二叉树\",{\"1\":{\"266\":1}}],[\"它与自增字段\",{\"1\":{\"559\":1}}],[\"它与\",{\"1\":{\"264\":1,\"269\":1}}],[\"它是给状态做一个文字说明\",{\"1\":{\"1431\":1}}],[\"它是接口的核心数据\",{\"1\":{\"1431\":1}}],[\"它是在容器启动时\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"它是在第一次执行maven命令的时候才被创建\",{\"1\":{\"705\":1}}],[\"它是针对resultset结果集执行的内存分页\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"它是由浏览器的同源策略造成的\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"它是由开发人员创建的接口\",{\"1\":{\"958\":1}}],[\"它是基于hll算法的\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"它是如何处理大规模数据流的呢\",{\"1\":{\"986\":1}}],[\"它是\",{\"1\":{\"956\":1,\"1077\":1,\"1281\":1}}],[\"它是被所有线程共享的一块内存区域\",{\"1\":{\"930\":1}}],[\"它是通过一个\",{\"1\":{\"928\":1}}],[\"它是架设在局域网内的仓库\",{\"1\":{\"705\":1}}],[\"它是行锁和间隙锁的组合\",{\"1\":{\"575\":1}}],[\"它是这样实现的\",{\"1\":{\"374\":1}}],[\"它是透过键值的部份资讯\",{\"1\":{\"371\":1}}],[\"它是一条\",{\"1\":{\"1018\":1}}],[\"它是一种将数据分布在多个redis节点上的方式\",{\"1\":{\"968\":1}}],[\"它是一种多路的平衡搜索树\",{\"1\":{\"263\":1}}],[\"它是一个高吞吐量的分布式消息系统\",{\"1\":{\"978\":1}}],[\"它是一个为分布式应用提供一致性服务的软件\",{\"1\":{\"154\":1,\"1237\":1,\"1410\":1}}],[\"它是一个文件索引号\",{\"1\":{\"145\":1}}],[\"它是作用使用\",{\"1\":{\"177\":1}}],[\"客户机首次向servlet发出请求时会加载\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"客户端再次发送确认消息\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"客户端浏览器将再次向服务器发出请求\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"客户端的跳转\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"客户端和channel进行通信\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"客户端和服务端的引导类\",{\"1\":{\"1034\":1}}],[\"客户端在和集群连接时\",{\"0\":{\"1075\":1,\"1279\":1}}],[\"客户端发送一个\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"客户端向服务器发出取消连接请求\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"客户端向服务器发出连接请求等待服务器确认\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"客户端向服务器再次发出确认信息\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"客户端向\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"客户端\",{\"0\":{\"642\":1},\"1\":{\"1061\":1,\"1166\":1,\"1267\":1,\"1354\":1}}],[\"客户端连接\",{\"1\":{\"597\":1}}],[\"客户端连接后整体使用和linux很相似\",{\"1\":{\"160\":1}}],[\"客户端提供改变的属性\",{\"1\":{\"178\":1}}],[\"客户端提供改变后的完整资源\",{\"1\":{\"178\":1}}],[\"客户端请求头部的缓冲区大小\",{\"1\":{\"106\":2}}],[\"客户请求头缓冲大小\",{\"1\":{\"106\":1}}],[\"或初始化bean的时候需要注入另一个尚末初始化的依赖时\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"或启用主题日志压缩功能\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"或重新装入\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"或其他方法\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"或其子类型\",{\"1\":{\"966\":1}}],[\"或经过指定的时间后重新等待\",{\"1\":{\"988\":1}}],[\"或注解\",{\"1\":{\"958\":1}}],[\"或注解来配置\",{\"1\":{\"958\":1}}],[\"或注解的配置文件得到映射语句\",{\"1\":{\"958\":1}}],[\"或错误使用\",{\"1\":{\"950\":1}}],[\"或是想更深入学习的内容\",{\"1\":{\"946\":1}}],[\"或是0\",{\"1\":{\"361\":1}}],[\"或第三方工具\",{\"1\":{\"942\":1}}],[\"或为静态变量赋值\",{\"1\":{\"934\":1}}],[\"或元空间\",{\"1\":{\"930\":3}}],[\"或类名和包名等\",{\"1\":{\"772\":1}}],[\"或完全限定资源定位符\",{\"1\":{\"772\":1}}],[\"或页面的\",{\"1\":{\"659\":1}}],[\"或切分后数据量行数巨大\",{\"1\":{\"518\":1}}],[\"或以上版本环境\",{\"1\":{\"403\":1}}],[\"或趋势递增\",{\"1\":{\"385\":1}}],[\"或主键冲突问题\",{\"1\":{\"383\":1}}],[\"或msd\",{\"1\":{\"374\":1}}],[\"或所谓的箱排序\",{\"1\":{\"348\":1}}],[\"或rear需要在\",{\"1\":{\"288\":1}}],[\"或者前端在判断时也可以写更简洁的代码\",{\"1\":{\"1431\":1}}],[\"或者称为\",{\"1\":{\"1431\":1}}],[\"或者该key对应的数据insert之后清理缓存\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"或者时间戳\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"或者多个密钥共享一个hashcode\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"或者直接发送下一条消息而不等待确认\",{\"1\":{\"994\":1}}],[\"或者用于构建实时分析和监控系统\",{\"1\":{\"974\":1}}],[\"或者垃圾对象未被清除\",{\"1\":{\"938\":1}}],[\"或者在全局的mybatis\",{\"1\":{\"790\":1}}],[\"或者首先需要干活的人\",{\"1\":{\"652\":1}}],[\"或者从集群中断开\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"或者从压缩列表中删除节点\",{\"1\":{\"633\":1}}],[\"或者从script访问字段值\",{\"1\":{\"440\":1}}],[\"或者哈希键的底层实现时\",{\"1\":{\"626\":1}}],[\"或者更新已存在成员的分数\",{\"1\":{\"607\":1}}],[\"或者尾部\",{\"1\":{\"604\":1}}],[\"或者使用临时表来存储中间结果\",{\"1\":{\"504\":1}}],[\"或者完成某个任务\",{\"1\":{\"486\":1}}],[\"或者是其接口的实现类\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"或者是其直接或间接子类\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"或者是同步回写\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"或者是自定义的路由键\",{\"1\":{\"1012\":1}}],[\"或者是\",{\"1\":{\"484\":1}}],[\"或者大于\",{\"1\":{\"364\":1}}],[\"或者每个结点的值都小于或等于其左右孩子结点的值\",{\"1\":{\"364\":1}}],[\"或者存在\",{\"1\":{\"334\":1}}],[\"或者\",{\"1\":{\"200\":1,\"214\":1,\"431\":1,\"446\":1,\"456\":1,\"630\":1,\"658\":1,\"692\":1,\"916\":1,\"944\":1,\"966\":1,\"988\":1,\"1071\":1,\"1093\":1,\"1176\":1,\"1212\":1,\"1219\":1,\"1226\":3,\"1275\":1,\"1294\":1,\"1361\":1,\"1389\":1,\"1396\":1,\"1401\":3}}],[\"或者修改返回值的格式\",{\"1\":{\"181\":1}}],[\"或者防止出现异常\",{\"1\":{\"132\":1}}],[\"或\",{\"1\":{\"106\":1,\"288\":2,\"371\":1,\"387\":1,\"511\":1,\"515\":1,\"526\":1,\"537\":1,\"779\":1,\"1048\":1,\"1163\":1,\"1178\":1,\"1192\":1,\"1257\":1,\"1351\":1,\"1363\":1,\"1375\":1}}],[\"值来代表当前的\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"值相等\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"值相同时\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"值进行比对\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"值加一\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"值与数组长度减1的值进行按位与操作\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"值将\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"值存在\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"值是我们设置的变量值\",{\"1\":{\"928\":1}}],[\"值是二进制安全的\",{\"1\":{\"602\":1}}],[\"值得一提的是\",{\"1\":{\"635\":1}}],[\"值得注意的\",{\"1\":{\"604\":1}}],[\"值对象\",{\"1\":{\"635\":1}}],[\"值有字符串\",{\"1\":{\"619\":1}}],[\"值问题\",{\"1\":{\"526\":1}}],[\"值的\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"值的长度不能超过512mb\",{\"1\":{\"603\":1}}],[\"值的列上添加索引\",{\"1\":{\"526\":1}}],[\"值的比较有特殊性\",{\"1\":{\"501\":1}}],[\"值判断\",{\"0\":{\"526\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"值时的处理策略\",{\"1\":{\"434\":1}}],[\"值为\",{\"1\":{\"624\":1}}],[\"值为1\",{\"1\":{\"422\":1}}],[\"值为5\",{\"1\":{\"422\":1}}],[\"值在\",{\"1\":{\"270\":1}}],[\"值紧跟着\",{\"1\":{\"267\":1}}],[\"值\",{\"1\":{\"106\":1,\"501\":2,\"526\":2,\"597\":2,\"602\":1,\"605\":1,\"619\":1,\"624\":1,\"658\":1,\"660\":1,\"1072\":1,\"1116\":1,\"1157\":1,\"1175\":1,\"1192\":1,\"1276\":1,\"1311\":1,\"1345\":1,\"1360\":1,\"1375\":1}}],[\"第6问中我们提到了生产者发送消息有三种方式\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"第0位\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"第三个\",{\"1\":{\"944\":1}}],[\"第三\",{\"1\":{\"516\":1,\"1212\":1,\"1389\":1}}],[\"第三步\",{\"1\":{\"375\":1,\"913\":1}}],[\"第三方注解\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"第三方\",{\"1\":{\"106\":2,\"1212\":3,\"1389\":3}}],[\"第二类\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"第二种setter方法\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"第二种的缺点就是每次用户请求过来都要判断缓存失效\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"第二季会从大白话源码的角度出发\",{\"1\":{\"920\":1}}],[\"第二阶段\",{\"0\":{\"898\":1}}],[\"第二次读到之前不存在的行\",{\"1\":{\"575\":1}}],[\"第二次是在存储单元中查找键\",{\"1\":{\"106\":1}}],[\"第二个\",{\"1\":{\"944\":1}}],[\"第二个参数\",{\"1\":{\"747\":2}}],[\"第二个的含义可以视为\",{\"1\":{\"526\":1}}],[\"第二个语句将\",{\"1\":{\"526\":1}}],[\"第二个整数是3\",{\"1\":{\"359\":1}}],[\"第二是跨页\",{\"1\":{\"516\":1}}],[\"第二步\",{\"1\":{\"375\":1,\"525\":1,\"913\":1}}],[\"第二天可以晚半小时来\",{\"1\":{\"225\":1}}],[\"第一版\",{\"0\":{\"1249\":1}}],[\"第一类\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"第一种构造方法注入的情况\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"第一种构造方法注入的情况下\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"第一种的缺点是维护大量缓存的\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"第一阶段\",{\"0\":{\"897\":1}}],[\"第一是由于数据量本身大\",{\"1\":{\"516\":1}}],[\"第一步\",{\"1\":{\"375\":1,\"913\":1}}],[\"第一个想到的一定是保证内存可见性\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"第一个\",{\"1\":{\"944\":1}}],[\"第一个参数\",{\"1\":{\"747\":2}}],[\"第一个的含义可以视为\",{\"1\":{\"526\":1}}],[\"第一个非叶子结点\",{\"1\":{\"364\":1}}],[\"第一个新创建的账户拥有管理员权限\",{\"1\":{\"251\":1}}],[\"第一次调用这个接口的同学可能并不知道返回的状态码含义\",{\"1\":{\"1431\":1}}],[\"第一次提交\",{\"1\":{\"915\":1}}],[\"第一次类加载时执行\",{\"1\":{\"648\":1}}],[\"第一次查询某个字段时\",{\"1\":{\"440\":1}}],[\"第一次查找到元素的位置\",{\"1\":{\"284\":1}}],[\"第一次\",{\"1\":{\"289\":1}}],[\"第一次进来没有账户\",{\"1\":{\"251\":1}}],[\"第一次是确定存储单元的地址\",{\"1\":{\"106\":1}}],[\"第一行已经读完\",{\"1\":{\"94\":1}}],[\"那岂不是得来回变换形态\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"那这个节点就是master\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"那这样搜索的速度会更快\",{\"1\":{\"1006\":1}}],[\"那反射具体有什么作用呢\",{\"1\":{\"1010\":1}}],[\"那倒排索引有什么应用场景呢\",{\"1\":{\"1006\":1}}],[\"那倒排索引是怎么构建的呢\",{\"1\":{\"1006\":1}}],[\"那kafka是如何保证幂等性的呢\",{\"1\":{\"996\":1}}],[\"那kafka是如何保证消息的可靠性传输的呢\",{\"1\":{\"974\":1}}],[\"那kafka是怎么实现幂等性的呢\",{\"1\":{\"996\":1}}],[\"那如何进行搜索呢\",{\"1\":{\"998\":1}}],[\"那如何解决\",{\"1\":{\"988\":1}}],[\"那如果我想要发送相同的消息\",{\"1\":{\"996\":1}}],[\"那如果我想要查看kafka的源码\",{\"1\":{\"974\":1}}],[\"那什么是线程安全的\",{\"1\":{\"988\":1}}],[\"那最后两点疑问\",{\"1\":{\"966\":1}}],[\"那泛型中最容易搞混的两个概念是什么\",{\"1\":{\"966\":1}}],[\"那aof又是什么\",{\"1\":{\"962\":1}}],[\"那setex\",{\"1\":{\"960\":1}}],[\"那很好\",{\"1\":{\"958\":1}}],[\"那\",{\"1\":{\"954\":1}}],[\"那销毁方法哪些\",{\"1\":{\"952\":1}}],[\"那好\",{\"1\":{\"948\":1,\"954\":1}}],[\"那日常工作用的最多的是哪个实现类\",{\"1\":{\"946\":1}}],[\"那日志存储就要大到上天\",{\"1\":{\"192\":1}}],[\"那谈谈你了解的jvm内存结构和垃圾回收之间的关系\",{\"1\":{\"936\":1}}],[\"那说说\",{\"1\":{\"936\":1}}],[\"那java垃圾收集器都有哪些\",{\"1\":{\"936\":1}}],[\"那静态代码块是在哪个阶段执行的\",{\"1\":{\"934\":1}}],[\"那还不如让我直接读jvm的源码来找呢\",{\"1\":{\"934\":1}}],[\"那我来思考下当初我第一次运行java程序的时候的内心活动\",{\"1\":{\"934\":1}}],[\"那我们同样属性的俩个用户一定是不相等的\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"那我们来看一下具体的索引文档的底层过程\",{\"1\":{\"1012\":1}}],[\"那我们先从kafka的基本概念开始吧\",{\"1\":{\"986\":1}}],[\"那我们就来聊聊redis分布式锁的原理吧\",{\"1\":{\"970\":1}}],[\"那我们继续聊聊类加载过程中最重要的几个类吧\",{\"1\":{\"934\":1}}],[\"那我们如何能让\",{\"1\":{\"692\":1}}],[\"那我们为什么不用\",{\"1\":{\"615\":1}}],[\"那你在项目中用过这两种锁吗\",{\"1\":{\"1018\":1}}],[\"那你说说redis有什么优点\",{\"1\":{\"960\":1}}],[\"那你说说\",{\"1\":{\"956\":1}}],[\"那你能举个例子来说明一下动态代理的使用吗\",{\"1\":{\"1016\":1}}],[\"那你能举个例子来说明一下动态地调用方法吗\",{\"1\":{\"1010\":1}}],[\"那你能举个例子来说明一下吗\",{\"1\":{\"1010\":1}}],[\"那你能举个例子来说明它们的使用场景吗\",{\"1\":{\"932\":1}}],[\"那你能简单地介绍一下\",{\"1\":{\"1010\":1}}],[\"那你能具体说一下\",{\"1\":{\"1020\":1}}],[\"那你能具体说一下它们的区别吗\",{\"1\":{\"932\":1}}],[\"那你能具体解释一下kafka的push和pull模式吗\",{\"1\":{\"990\":1}}],[\"那你能告诉我\",{\"1\":{\"984\":2}}],[\"那你能给我一个简单的例子来解释一下吗\",{\"1\":{\"1006\":1}}],[\"那你能给我一些具体的例子吗\",{\"1\":{\"982\":1}}],[\"那你能给我一些关于redis内存优化的实用技巧吗\",{\"1\":{\"972\":1}}],[\"那你能给我分享一些关于elasticsearch性能优化的技巧吗\",{\"1\":{\"1002\":1}}],[\"那你能给我简单介绍一下elasticsearch的核心组件吗\",{\"1\":{\"1002\":1}}],[\"那你能给我举个例子\",{\"1\":{\"1000\":1,\"1020\":1}}],[\"那你能给我举几个kafka的使用场景吗\",{\"1\":{\"976\":1}}],[\"那你能给我演示一下如何创建一个索引并插入文档吗\",{\"1\":{\"998\":1}}],[\"那你能给我们看一段简单的代码来说明这个过程吗\",{\"1\":{\"990\":1}}],[\"那你能给我解释一下elasticsearch的搜索原理吗\",{\"1\":{\"1002\":1}}],[\"那你能给我解释一下elasticsearch的核心概念吗\",{\"1\":{\"998\":1}}],[\"那你能给我解释一下lucene是什么吗\",{\"1\":{\"1000\":1}}],[\"那你能给我解释一下kafka的消息传递机制吗\",{\"1\":{\"980\":1}}],[\"那你能给我解释一下kafka的消息发布和订阅模型吗\",{\"1\":{\"974\":1}}],[\"那你能给我解释一下kafka的性能是如何实现的吗\",{\"1\":{\"980\":1}}],[\"那你能给我解释一下redis分片集群的工作原理吗\",{\"1\":{\"968\":1}}],[\"那你能解释一下\",{\"1\":{\"956\":1}}],[\"那你能写一段代码来演示一下\",{\"1\":{\"932\":1}}],[\"那你能写一段代码来演示一下吗\",{\"1\":{\"932\":1}}],[\"那你能说一下动态代理的实现原理吗\",{\"1\":{\"1016\":1}}],[\"那你能说一下动态代理的优缺点吗\",{\"1\":{\"1016\":1}}],[\"那你能说一下动态代理和静态代理的区别吗\",{\"1\":{\"1016\":1}}],[\"那你能说一下反射和动态代理的关系吗\",{\"1\":{\"1016\":1}}],[\"那你能说一下反射和安全性的关系吗\",{\"1\":{\"1010\":1}}],[\"那你能说一下反射和泛型的关系吗\",{\"1\":{\"1010\":1}}],[\"那你能说一下反射的优缺点吗\",{\"1\":{\"1010\":1}}],[\"那你能说一下\",{\"1\":{\"932\":3,\"1020\":2}}],[\"那你能否简单介绍一下java堆的内存结构\",{\"1\":{\"930\":1}}],[\"那你能否简单介绍一下jvm内存模型的组成部分\",{\"1\":{\"930\":1}}],[\"那你能否解释一下\",{\"1\":{\"928\":2}}],[\"那你能否详细介绍一下\",{\"1\":{\"928\":1}}],[\"那你知道如何自定义线程池吗\",{\"1\":{\"926\":1}}],[\"那你知道线程池的优缺点吗\",{\"1\":{\"926\":1}}],[\"那你知道线程池的拒绝策略有哪些吗\",{\"1\":{\"926\":1}}],[\"那你知道线程池的参数有哪些吗\",{\"1\":{\"926\":1}}],[\"那你知道线程池的工作原理吗\",{\"1\":{\"926\":1}}],[\"那它是什么\",{\"1\":{\"958\":1}}],[\"那它的核心组件有哪些\",{\"1\":{\"958\":1}}],[\"那它内部具体是如何实现的呢\",{\"1\":{\"922\":1}}],[\"那它还能干什么\",{\"1\":{\"698\":1}}],[\"那只能一点一点往新分支迁移\",{\"1\":{\"917\":1}}],[\"那一定会发现\",{\"1\":{\"829\":1}}],[\"那则需要对多个项目模块进行聚合\",{\"1\":{\"716\":1}}],[\"那是因为你的jvm没有优化造成的\",{\"1\":{\"692\":1}}],[\"那就顺理成章地采用单线程的方案了\",{\"1\":{\"1200\":1,\"1380\":1}}],[\"那就直接表演\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"那就很难保证\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"那就给我简单介绍下jvm调优的方法和手段吧\",{\"1\":{\"942\":1}}],[\"那就增加\",{\"1\":{\"727\":1}}],[\"那就是异步\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"那就是因为vt线程每次判断flag标记的时候是从它自己的\",{\"1\":{\"692\":1}}],[\"那就是对我最大的支持\",{\"1\":{\"97\":1}}],[\"那就是对资源的浪费\",{\"1\":{\"77\":1}}],[\"那就让我们把程序运行起来看看效果吧\",{\"1\":{\"692\":1}}],[\"那就需要给每个节点增加一个\",{\"1\":{\"632\":1}}],[\"那就需要用\",{\"1\":{\"632\":1}}],[\"那就开始\",{\"1\":{\"587\":1}}],[\"那个阶段是毕业后成长非常快的\",{\"1\":{\"225\":1}}],[\"那时几个同学一块在那里实习\",{\"1\":{\"225\":1}}],[\"那修改起来会特别的麻烦\",{\"1\":{\"162\":1}}],[\"那到时两个产品就要打架了\",{\"1\":{\"153\":1}}],[\"那也是可以的\",{\"1\":{\"138\":1}}],[\"那也可以用外部的编码器来编码\",{\"1\":{\"135\":1}}],[\"那么该客户端对服务器的任何操作\",{\"1\":{\"1245\":1,\"1418\":1}}],[\"那么全局变量需要存储在global\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"那么对象a在初始化或者运行到某一点的时候\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"那么对数据库的压力非常大\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"那么恢复时间也就越长\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"那么为什么说超过了一定限度\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"那么为该字段创建索引可能不会带来预期的性能提升\",{\"1\":{\"508\":1}}],[\"那么分区将会变得不可用\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"那么类之间的比较结果及类的唯一性将无法保证\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"那么都是非同源\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"那么链表和红黑树之间的切换范围值就太小了\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"那么代码还是同步执行的\",{\"1\":{\"1098\":1,\"1296\":1}}],[\"那么其中所有的成员方法都无法进行覆盖重写\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"那么司机停车\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"那么怎么理解同步和阻塞\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"那么反复调用x\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"那么x\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"那么y\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"那么子类可以重写父类所有方法\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"那么这个对数组长度取余的方法就等价于对数组长度减一的值进行按位与操作\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"那么这个变量也照样是不可变\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"那么这个变量就不能进行更改\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"那么这个队列的size就是20\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"那么这些整数的值肯定是在0到10这11个数里面\",{\"1\":{\"359\":1}}],[\"那么a\",{\"1\":{\"1018\":1}}],[\"那么elasticsearch和lucene之间有什么关系呢\",{\"1\":{\"1000\":1}}],[\"那么生产者可以选择放弃发送或者采取其他措施\",{\"1\":{\"994\":1}}],[\"那么可能会出现点菜遗漏的情况\",{\"1\":{\"994\":1}}],[\"那么可以在索引上设置默认值\",{\"1\":{\"1192\":1,\"1375\":1}}],[\"那么可以在依赖节点中设置排除依赖节点\",{\"1\":{\"710\":1}}],[\"那么可以写入进去的时候用某个时间作为分数\",{\"1\":{\"657\":1}}],[\"那么可以使用\",{\"0\":{\"542\":1}}],[\"那么你能够从\",{\"1\":{\"1022\":1}}],[\"那么你可以确保每道菜都被正确记录下来\",{\"1\":{\"994\":1}}],[\"那么你对hashmap的源码熟悉吗\",{\"1\":{\"948\":1}}],[\"那么redis如何保证数据的持久化\",{\"1\":{\"962\":1}}],[\"那么redis就会使用压缩列表来做哈希的底层实现\",{\"1\":{\"633\":1}}],[\"那么redis就会使用压缩列表来做列表的底层实现\",{\"1\":{\"633\":1}}],[\"那么需要通过重构来避免循环依赖\",{\"1\":{\"954\":1}}],[\"那么如何使基于\",{\"1\":{\"950\":1}}],[\"那么如果在a中对log4j依赖的optional配置成false时\",{\"1\":{\"708\":1}}],[\"那么如果节点为区间范围\",{\"1\":{\"266\":1}}],[\"那么默认的classloader又有哪几个\",{\"1\":{\"934\":1}}],[\"那么使用\",{\"1\":{\"924\":1}}],[\"那么冲突的概率会大大减少\",{\"1\":{\"922\":1}}],[\"那么最终的版本为1\",{\"1\":{\"709\":1}}],[\"那么称\",{\"1\":{\"707\":1}}],[\"那么按照我们上面所讲的\",{\"1\":{\"692\":1}}],[\"那么获取字符串的长度时\",{\"1\":{\"620\":1}}],[\"那么我们也可以将\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"那么我们可以直接使用\",{\"1\":{\"619\":1}}],[\"那么我们如何提高程序性能\",{\"1\":{\"266\":1}}],[\"那么在选举后新的\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"那么在子类中重写该方法就不能声明为protected\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"那么在一个redis分片集群中\",{\"1\":{\"968\":1}}],[\"那么在另一个线程中调用\",{\"1\":{\"924\":1}}],[\"那么在另一个线程中读取\",{\"1\":{\"924\":2}}],[\"那么在了解完jvm在运行时候的内存分配过程以后\",{\"1\":{\"692\":1}}],[\"那么在rr隔离级别下\",{\"1\":{\"575\":1}}],[\"那么在查找键的时候\",{\"1\":{\"106\":1}}],[\"那么即使在\",{\"1\":{\"536\":1}}],[\"那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引\",{\"0\":{\"534\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"那么每次数据更新都可能导致索引的页面分裂\",{\"1\":{\"508\":1}}],[\"那么查询可能不需要回表\",{\"1\":{\"504\":1}}],[\"那么索引不会被使用\",{\"1\":{\"501\":1}}],[\"那么成功会检索出上述文档\",{\"1\":{\"451\":1}}],[\"那么首先排除掉32位int类型\",{\"1\":{\"382\":1}}],[\"那么首要的是增大前一个参数的大小\",{\"1\":{\"106\":1}}],[\"那么现有的uuid就完全满足需求\",{\"1\":{\"382\":1}}],[\"那么数组下标为\",{\"1\":{\"359\":2}}],[\"那么假阳性的概率是万分之五\",{\"1\":{\"339\":1}}],[\"那么100亿个就至少需要大约640gb的内存空间\",{\"1\":{\"330\":1}}],[\"那么它就会被加入到等待队列中\",{\"1\":{\"932\":1}}],[\"那么它们有什么不同\",{\"1\":{\"370\":1}}],[\"那么它一定不存在\",{\"1\":{\"330\":1}}],[\"那么它可能存在\",{\"1\":{\"330\":1}}],[\"那么当前线程将进入阻塞状态\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"那么当\",{\"1\":{\"288\":1}}],[\"那么一个页可以存放16行这样的数据\",{\"1\":{\"272\":1}}],[\"那么由于磁盘\",{\"1\":{\"270\":1}}],[\"那么总\",{\"1\":{\"266\":1}}],[\"那么将它附近的位置也会被访问\",{\"1\":{\"266\":1,\"270\":1}}],[\"那么整个集群将暂停对外服务\",{\"1\":{\"166\":1}}],[\"那么就可能会导致这条消息消费失败\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"那么就可能加载一个非授权版本的类\",{\"1\":{\"934\":1}}],[\"那么就和\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"那么就释放以及获得的锁\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"那么就应该考虑改写\",{\"0\":{\"544\":1}}],[\"那么就无需回表\",{\"1\":{\"504\":1}}],[\"那么就新建一个\",{\"1\":{\"342\":1}}],[\"那么就变更为following\",{\"1\":{\"166\":1}}],[\"那么就比较myid\",{\"1\":{\"166\":1}}],[\"那么表明这个客户端连接失败\",{\"1\":{\"157\":1}}],[\"那么直接跳到你需要的知识点\",{\"1\":{\"150\":1}}],[\"那么\",{\"1\":{\"106\":1,\"134\":2,\"451\":1,\"499\":1,\"712\":1,\"766\":1,\"924\":3,\"942\":1,\"946\":2,\"950\":1,\"952\":1,\"954\":2,\"956\":1,\"968\":2,\"970\":1,\"972\":2,\"978\":1,\"986\":2,\"990\":1,\"992\":3,\"994\":5,\"1004\":3,\"1008\":1,\"1022\":11,\"1043\":1,\"1050\":1,\"1164\":1,\"1252\":1,\"1259\":1,\"1352\":1}}],[\"使开发者专注于业务开发而无需过多考虑配置相关操作\",{\"1\":{\"1224\":1,\"1399\":1}}],[\"使开发者只需要关注\",{\"1\":{\"958\":1}}],[\"使\",{\"1\":{\"950\":1}}],[\"使我们可以更加专注于业务开发\",{\"1\":{\"950\":1}}],[\"使我们不用关心框架之间的兼容性\",{\"1\":{\"401\":1}}],[\"使得\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"使得每一个上下文都专注于一个特定的层次\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"使得a\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"使得计算key位置的操作能够充分散列均匀\",{\"1\":{\"1121\":1,\"1316\":1}}],[\"使得高16位的影响能够均匀稀释到低16位中\",{\"1\":{\"1121\":1,\"1316\":1}}],[\"使得在大规模数据集上进行搜索和分析变得更加容易\",{\"1\":{\"1000\":1}}],[\"使得在查询特定值的时候非常高效\",{\"1\":{\"499\":1}}],[\"使得它可以处理大量的消息并保证数据的可靠性\",{\"1\":{\"980\":1}}],[\"使得泛型更加灵活实用\",{\"1\":{\"966\":1}}],[\"使得数据库交互更加灵活\",{\"1\":{\"958\":1}}],[\"使得并发标记成为可能\",{\"1\":{\"938\":1}}],[\"使得cms并发标记清除算法成为可能\",{\"1\":{\"938\":1}}],[\"使得从数据库在任何地方同步树时\",{\"1\":{\"589\":1}}],[\"使得单一数据库\",{\"1\":{\"515\":1}}],[\"使得单一数据库的数据量变小来缓解单一数据库的性能问题\",{\"1\":{\"515\":1}}],[\"使得查询性能更加稳定\",{\"1\":{\"503\":1}}],[\"使得大家能够对倒排索引有一个宏观而直接的感受\",{\"1\":{\"425\":1}}],[\"使得范围查询和排序都很快\",{\"1\":{\"270\":1}}],[\"使其状态与主服务器一致\",{\"1\":{\"964\":1}}],[\"使其继续满足堆定义\",{\"1\":{\"364\":1}}],[\"使其生效\",{\"1\":{\"125\":1}}],[\"使解析更容易\",{\"1\":{\"143\":1}}],[\"使每个url定向到同一个后端服务器\",{\"1\":{\"106\":1}}],[\"使在处理器中加速查找hash表键值成为可能\",{\"1\":{\"106\":1}}],[\"使用主备两层缓存\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"使用范围不同\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"使用链表否则使用红黑树\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"使用标志位停止\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"使用volatile变量能够保证\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"使用反序列化\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"使用clone方法\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"使用class类的newinstance方法\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"使用constructor类的newinstance方法\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"使用cas\",{\"1\":{\"1018\":1}}],[\"使用cas进行检查时会发现它的值没有变化\",{\"1\":{\"1018\":1}}],[\"使用new关键字\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"使用第一个边界类型xclass1作为原始类型\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"使用xclass作为原始类型\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"使用xml中的字符实体\",{\"0\":{\"800\":1}}],[\"使用大量的cpu\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"使用docker\",{\"0\":{\"1060\":1,\"1266\":1},\"1\":{\"1060\":1,\"1266\":1}}],[\"使用互斥锁\",{\"1\":{\"1049\":2,\"1258\":2}}],[\"使用方案二比较多\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"使用方便\",{\"1\":{\"932\":1}}],[\"使用案例\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"使用起来比较复杂\",{\"1\":{\"1022\":1}}],[\"使用起来比较简单\",{\"1\":{\"1022\":1}}],[\"使用通道来进行数据的读写操作\",{\"1\":{\"1020\":1}}],[\"使用缓冲区来处理数据\",{\"1\":{\"1020\":1}}],[\"使用缓存的目的\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"使用缓存\",{\"1\":{\"1002\":1}}],[\"使用缓存技术\",{\"1\":{\"950\":1}}],[\"使用elasticsearch提供的监控工具和api\",{\"1\":{\"1002\":1}}],[\"使用索引别名可以方便地切换索引版本或进行灰度发布\",{\"1\":{\"1002\":1}}],[\"使用分布式锁\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"使用分片和副本\",{\"1\":{\"1002\":1}}],[\"使用分代回收\",{\"1\":{\"936\":1}}],[\"使用kafka\",{\"1\":{\"980\":1}}],[\"使用redis命令\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"使用redis的哈希表来存储多个键值对\",{\"1\":{\"972\":1}}],[\"使用reentrantlock\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"使用resulttype不能完成自动映射\",{\"1\":{\"793\":1}}],[\"使用无边界的\",{\"1\":{\"966\":1}}],[\"使用服务注册与发现\",{\"1\":{\"950\":1}}],[\"使用服务器\",{\"1\":{\"387\":1}}],[\"使用降级策略保证核心服务可用\",{\"1\":{\"950\":1}}],[\"使用限流手段控制流量\",{\"1\":{\"950\":1}}],[\"使用能支撑高并发读写的数据库\",{\"1\":{\"950\":1}}],[\"使用设计模式\",{\"1\":{\"950\":1}}],[\"使用软引用或弱引用存放易变对象\",{\"1\":{\"936\":1}}],[\"使用weakreference例子\",{\"1\":{\"936\":1}}],[\"使用类加载器加载一个类\",{\"1\":{\"934\":1}}],[\"使用上面的命令\",{\"1\":{\"917\":1}}],[\"使用命令\",{\"1\":{\"916\":1}}],[\"使用命令行创建web项目\",{\"0\":{\"704\":1}}],[\"使用工具类生成二维码\",{\"1\":{\"876\":2}}],[\"使用注解的元素\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"使用注解\",{\"1\":{\"944\":1}}],[\"使用注解代替\",{\"1\":{\"830\":1}}],[\"使用注解控制事务方法的优点\",{\"1\":{\"830\":1}}],[\"使用者\",{\"1\":{\"830\":1}}],[\"使用枚举表述常量数据字典\",{\"1\":{\"829\":1}}],[\"使用jdbc的getgeneratedkeys获取数据库自增主键值\",{\"1\":{\"817\":1}}],[\"使用列别名替换列名\",{\"1\":{\"817\":1}}],[\"使用列别名\",{\"1\":{\"817\":1}}],[\"使用自增主键\",{\"1\":{\"817\":1}}],[\"使用到大于号\",{\"1\":{\"800\":1}}],[\"使用到插入排序\",{\"1\":{\"352\":1}}],[\"使用$\",{\"1\":{\"779\":2}}],[\"使用映射器接口实现类的完全限定类名\",{\"1\":{\"772\":1}}],[\"使用相对于类路径的资源引用\",{\"1\":{\"772\":1}}],[\"使用扫描包\",{\"1\":{\"768\":1}}],[\"使用非常方便\",{\"1\":{\"764\":1,\"1117\":1,\"1312\":1}}],[\"使用非常广泛\",{\"1\":{\"594\":1}}],[\"使用动态代理之后和方法的参数类型一致\",{\"1\":{\"763\":4,\"776\":1}}],[\"使用动态代理之后和方法的返回类型一致\",{\"1\":{\"763\":1}}],[\"使用动态代理之后要求和方法名保持一致\",{\"1\":{\"763\":4,\"776\":1}}],[\"使用动态代理改造crud\",{\"0\":{\"762\":1}}],[\"使用占位符替换\",{\"1\":{\"763\":1}}],[\"使用mapper接口不用写接口实现类即可完成数据库操作\",{\"1\":{\"764\":1}}],[\"使用maven方式管理jar依赖的好处\",{\"1\":{\"700\":1}}],[\"使用mybatis的方式非常相似\",{\"1\":{\"761\":1}}],[\"使用别名进行索引管理\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"使用别名\",{\"1\":{\"755\":1,\"815\":1}}],[\"使用idea构建maven工程\",{\"0\":{\"734\":1}}],[\"使用insert\",{\"1\":{\"577\":1}}],[\"使用合适的单元测试框架运行测试\",{\"1\":{\"713\":1}}],[\"使用私服的仓库构件下载\",{\"1\":{\"705\":1}}],[\"使用它\",{\"1\":{\"702\":1}}],[\"使用切点增强的时机注解\",{\"1\":{\"689\":1}}],[\"使用连接池优势\",{\"1\":{\"645\":1}}],[\"使用称手的工具\",{\"1\":{\"643\":1}}],[\"使用list结构来持有链表\",{\"1\":{\"621\":1}}],[\"使用listnode是可以组成链表了\",{\"1\":{\"621\":1}}],[\"使用一个类的名称\",{\"1\":{\"934\":1}}],[\"使用一个\",{\"1\":{\"621\":1}}],[\"使用很方便\",{\"1\":{\"589\":1}}],[\"使用普通的select语句读取数据及版本号\",{\"1\":{\"579\":1}}],[\"使用悲观锁\",{\"1\":{\"573\":1}}],[\"使用乐观锁\",{\"1\":{\"573\":1}}],[\"使用数据库默认的事务隔离级别\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"使用数据库的锁定命令\",{\"1\":{\"570\":1}}],[\"使用数据版本\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"使用数组作为队列的容器\",{\"1\":{\"288\":1}}],[\"使用时间戳来控制事务的顺序\",{\"1\":{\"569\":1}}],[\"使用时并不是完全不走索引\",{\"1\":{\"527\":1}}],[\"使用基于游标的方法或临时表方法之前\",{\"0\":{\"545\":1}}],[\"使用synchronized\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"使用synchronized时\",{\"1\":{\"1018\":1}}],[\"使用system\",{\"1\":{\"285\":1}}],[\"使用select\",{\"1\":{\"564\":1}}],[\"使用show\",{\"1\":{\"511\":1}}],[\"使用覆盖索引可以避免访问数据行本身\",{\"1\":{\"510\":1}}],[\"使用覆盖索引\",{\"1\":{\"510\":1}}],[\"使用物化视图或汇总表\",{\"1\":{\"504\":1}}],[\"使用复合索引\",{\"1\":{\"504\":1}}],[\"使用联合索引时遵循最左前缀集合\",{\"1\":{\"495\":1}}],[\"使用搜索\",{\"1\":{\"411\":1}}],[\"使用频率非常高\",{\"1\":{\"397\":1}}],[\"使用的advice\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"使用的资源不同\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"使用的时候需要实例化对象\",{\"1\":{\"387\":1}}],[\"使用的映射函数能够将输入的\",{\"1\":{\"348\":1}}],[\"使用字符串去拼接sql\",{\"1\":{\"779\":1}}],[\"使用字典\",{\"1\":{\"353\":1}}],[\"使用字段\",{\"1\":{\"106\":3}}],[\"使用了\",{\"1\":{\"337\":1,\"603\":1}}],[\"使用p指针来遍历队列\",{\"1\":{\"289\":1}}],[\"使用这个变量表示链队的数据容量\",{\"1\":{\"289\":1}}],[\"使用以下方法添加的时间复杂度为o\",{\"1\":{\"286\":1}}],[\"使用体验\",{\"1\":{\"181\":1}}],[\"使用\",{\"0\":{\"801\":1},\"1\":{\"166\":1,\"241\":1,\"375\":1,\"387\":1,\"400\":1,\"401\":1,\"437\":1,\"506\":1,\"507\":1,\"511\":1,\"581\":1,\"594\":1,\"603\":1,\"619\":1,\"626\":1,\"658\":1,\"689\":1,\"727\":1,\"781\":1,\"782\":1,\"789\":1,\"801\":1,\"812\":1,\"821\":1,\"830\":1,\"913\":1,\"916\":3,\"922\":1,\"934\":1,\"950\":2,\"952\":1,\"966\":1,\"1018\":1,\"1020\":1,\"1022\":1,\"1033\":2,\"1043\":1,\"1059\":3,\"1101\":1,\"1136\":2,\"1174\":1,\"1177\":1,\"1181\":1,\"1199\":1,\"1252\":1,\"1265\":3,\"1299\":1,\"1329\":2,\"1359\":1,\"1362\":1,\"1366\":1,\"1379\":1}}],[\"使用场景又是什么\",{\"1\":{\"966\":1}}],[\"使用场景\",{\"0\":{\"113\":1},\"1\":{\"561\":2,\"564\":1,\"565\":1,\"566\":1,\"567\":1,\"587\":1}}],[\"使用默认的client\",{\"1\":{\"106\":1}}],[\"使用fs=\",{\"1\":{\"94\":1}}],[\"使用指南\",{\"0\":{\"99\":1},\"1\":{\"44\":2},\"2\":{\"19\":1,\"21\":1,\"40\":1,\"47\":1,\"48\":1}}],[\"参与开发的每一成员只要实现自己的类就可以了\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"参与计算\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"参数等信息\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"参数对象中计算表达式的值\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"参数列表\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"参数列表必须相同\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"参数顺序不同\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"参数类型不同\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"参数类型变更等\",{\"1\":{\"182\":1}}],[\"参数数目不同\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"参数分页\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"参数为\",{\"1\":{\"982\":2,\"1092\":1,\"1293\":1}}],[\"参数的值\",{\"1\":{\"982\":3}}],[\"参数的类型\",{\"1\":{\"763\":4,\"776\":1}}],[\"参数说明\",{\"1\":{\"703\":1,\"704\":1}}],[\"参数值\",{\"1\":{\"689\":1}}],[\"参数名\",{\"1\":{\"689\":1}}],[\"参数\",{\"1\":{\"432\":1,\"433\":1,\"830\":1,\"958\":1,\"982\":1,\"1086\":5,\"1287\":5}}],[\"参数定义\",{\"0\":{\"338\":1}}],[\"参数不合法\",{\"1\":{\"186\":1}}],[\"参数错误\",{\"1\":{\"186\":1}}],[\"参数hash\",{\"1\":{\"106\":1}}],[\"参考一个很形象的例子\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"参考阅读\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"参考图\",{\"1\":{\"1098\":1,\"1296\":1}}],[\"参考底层指令\",{\"0\":{\"1023\":1}}],[\"参考业界大佬的优秀文章与经验\",{\"1\":{\"942\":1}}],[\"参考资料\",{\"0\":{\"904\":1},\"1\":{\"1212\":1,\"1389\":1}}],[\"参考驼峰匹配\",{\"1\":{\"759\":1}}],[\"参考后面的resultmap\",{\"1\":{\"759\":1}}],[\"参考前一篇\",{\"1\":{\"528\":1}}],[\"参考官网阅读\",{\"1\":{\"526\":1}}],[\"参考官网api\",{\"1\":{\"438\":1}}],[\"参考官网\",{\"1\":{\"435\":1}}],[\"参考原文\",{\"1\":{\"388\":1}}],[\"参考来源互联网\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"641\":1,\"698\":1,\"732\":1}}],[\"参考\",{\"1\":{\"98\":1,\"172\":1,\"232\":1,\"238\":1,\"241\":1,\"251\":1,\"275\":1,\"425\":1,\"527\":1,\"548\":1,\"605\":1,\"606\":1,\"633\":1,\"663\":1,\"706\":1,\"714\":1,\"716\":1,\"917\":1,\"919\":1,\"1068\":1,\"1193\":1,\"1272\":1,\"1376\":1}}],[\"保持和\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"保持耐心\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"保留字段偏移量\",{\"1\":{\"1023\":1}}],[\"保留字段\",{\"1\":{\"1023\":1}}],[\"保留插入顺序\",{\"1\":{\"948\":1}}],[\"保证value唯一性\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"保证谁加的锁只能被谁解锁\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"保证优雅的停止服务\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"保证服务的可用性\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"保证有且只有一个线程去查询\",{\"1\":{\"1049\":2,\"1258\":2}}],[\"保证一致性\",{\"1\":{\"1047\":1,\"1049\":1,\"1256\":1,\"1258\":1}}],[\"保证查询的时间复杂度为o\",{\"1\":{\"922\":1}}],[\"保证各个平台的二维码是唯一\",{\"1\":{\"872\":1}}],[\"保证触发事务执行\",{\"1\":{\"830\":1}}],[\"保证事务方法的执行时间尽可能短\",{\"1\":{\"830\":1}}],[\"保证实时性的同时\",{\"1\":{\"664\":1}}],[\"保证每个连接都是有效的\",{\"1\":{\"647\":1}}],[\"保证高可用\",{\"1\":{\"422\":1}}],[\"保证在出现异常时通过日志快速定位到那里就可以啦\",{\"1\":{\"201\":1}}],[\"保证instance未实例化的时候才加锁\",{\"1\":{\"83\":1}}],[\"保姆级教程\",{\"0\":{\"108\":1}}],[\"保存在\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"保存旧表\",{\"1\":{\"948\":1}}],[\"保存元素的数组\",{\"1\":{\"630\":1}}],[\"保存的字符串值\",{\"1\":{\"619\":1}}],[\"保存节点after为add的下一个节点\",{\"1\":{\"286\":1}}],[\"保存历史图片\",{\"1\":{\"226\":1}}],[\"保存到output\",{\"1\":{\"129\":1}}],[\"保存用户头信息的缓冲区大小\",{\"1\":{\"106\":1}}],[\"保存服务器名字的hash表是由指令server\",{\"1\":{\"106\":1}}],[\"默认传播行为\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"默认不打开二级缓存\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"默认不存储向量信息\",{\"1\":{\"440\":1}}],[\"默认也是采用\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"默认一级缓存是开启的\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"默认采用这种策略\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"默认会立即加载\",{\"1\":{\"952\":1}}],[\"默认会当成字符串来处理\",{\"1\":{\"439\":1}}],[\"默认加载因子0\",{\"1\":{\"948\":1}}],[\"默认初始容量16\",{\"1\":{\"948\":1}}],[\"默认初始容量\",{\"1\":{\"946\":1}}],[\"默认有3个classloader\",{\"1\":{\"934\":1}}],[\"默认8\",{\"1\":{\"922\":1}}],[\"默认使用第一个存储\",{\"1\":{\"916\":1}}],[\"默认show第一个存储\",{\"1\":{\"916\":1}}],[\"默认的隔离级别\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"默认的hashcode方法\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"默认的访问地址是\",{\"1\":{\"912\":1}}],[\"默认的用空格分割\",{\"1\":{\"94\":1}}],[\"默认账号\",{\"1\":{\"888\":1}}],[\"默认匹配所有的请求\",{\"1\":{\"820\":1}}],[\"默认编译依赖范围\",{\"1\":{\"706\":1}}],[\"默认编码\",{\"1\":{\"106\":1}}],[\"默认跟ananlyzer是一致的\",{\"1\":{\"440\":1}}],[\"默认都是开启\",{\"1\":{\"440\":1}}],[\"默认为1\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"默认为第一个stash\",{\"1\":{\"916\":1}}],[\"默认为false\",{\"1\":{\"708\":1,\"709\":1}}],[\"默认为jar\",{\"1\":{\"705\":1}}],[\"默认为空字符串\",{\"1\":{\"688\":2}}],[\"默认为\",{\"1\":{\"432\":1,\"434\":1,\"648\":1,\"1071\":1,\"1078\":1,\"1275\":1,\"1282\":1}}],[\"默认为25\",{\"1\":{\"127\":1}}],[\"默认为200kbit\",{\"1\":{\"127\":1}}],[\"默认每个索引的\",{\"1\":{\"422\":1}}],[\"默认分词器\",{\"1\":{\"411\":1}}],[\"默认端口\",{\"1\":{\"597\":1}}],[\"默认端口9300\",{\"1\":{\"406\":1}}],[\"默认端口是\",{\"1\":{\"251\":1}}],[\"默认是原来大小的两倍\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"默认是每隔\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"默认是tf\",{\"1\":{\"440\":1}}],[\"默认是true\",{\"1\":{\"440\":1}}],[\"默认是false\",{\"1\":{\"440\":1}}],[\"默认是有序的\",{\"1\":{\"352\":1}}],[\"默认是没有启用的\",{\"1\":{\"106\":1}}],[\"默认存储容器大小\",{\"1\":{\"285\":1}}],[\"默认启动的端口是\",{\"1\":{\"248\":1}}],[\"默认情况下\",{\"1\":{\"770\":1,\"1160\":1,\"1163\":1,\"1348\":1,\"1351\":1}}],[\"默认情况下这个值的大小为指令proxy\",{\"1\":{\"106\":1}}],[\"默认情况也为分页大小\",{\"1\":{\"106\":1}}],[\"默认访问地址\",{\"1\":{\"106\":1}}],[\"默认\",{\"1\":{\"106\":1,\"411\":1,\"440\":1,\"447\":1,\"817\":1,\"1071\":1,\"1078\":1,\"1275\":1,\"1282\":1}}],[\"默认关闭\",{\"1\":{\"106\":1}}],[\"默认文件类型\",{\"1\":{\"106\":1}}],[\"默认值等\",{\"1\":{\"944\":1}}],[\"默认值为false\",{\"1\":{\"708\":1}}],[\"默认值为\",{\"1\":{\"648\":1,\"715\":1}}],[\"默认值是100\",{\"1\":{\"440\":1}}],[\"默认值0\",{\"1\":{\"140\":1}}],[\"默认值\",{\"1\":{\"106\":3,\"648\":1,\"864\":1}}],[\"但您可以使用setter注入配置循环依赖关系\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"但两者之间的区别是\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"但其实是事务\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"但磁盘的顺序读写性能却很高\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"但加锁和解锁需要手动进行\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"但非常灵活\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"但可以通过带布尔值的构造函数要求使用公平锁\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"但可能导致其他事务长时间等待\",{\"1\":{\"565\":1}}],[\"但还没有调用start\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"但编译器编译完带有泛型的java程序后\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"但即使大多数可用\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"但进程还是可以不受控的访问系统资源\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"但你解释的很通俗易懂\",{\"1\":{\"966\":1}}],[\"但有一定了解\",{\"1\":{\"954\":1}}],[\"但只要把这些要点都串联起来\",{\"1\":{\"952\":1}}],[\"但需要权衡系统复杂性\",{\"1\":{\"950\":1}}],[\"但总体来说\",{\"1\":{\"948\":1,\"978\":1}}],[\"但我相信这会让我的java基础更加扎实\",{\"1\":{\"948\":1}}],[\"但我对其扩容\",{\"1\":{\"948\":1}}],[\"但我还需要继续学习其更深层次的用法与理论知识\",{\"1\":{\"942\":1}}],[\"但迭代顺序不定\",{\"1\":{\"948\":1}}],[\"但和list一样\",{\"1\":{\"948\":1}}],[\"但底层数据结构不同\",{\"1\":{\"946\":1}}],[\"但开销大\",{\"1\":{\"940\":1}}],[\"但开启又会加大索引体积\",{\"1\":{\"440\":1}}],[\"但过于精细\",{\"1\":{\"940\":1}}],[\"但已大大超越\",{\"1\":{\"940\":1}}],[\"但已远非传统意义上的\",{\"1\":{\"940\":1}}],[\"但g1在并发标记的基础上\",{\"1\":{\"940\":1}}],[\"但它展示了broker的基本工作原理\",{\"1\":{\"986\":1}}],[\"但它只能在\",{\"1\":{\"966\":1}}],[\"但它是线程安全的\",{\"1\":{\"946\":1,\"948\":1}}],[\"但它的优点远远超过了缺点\",{\"1\":{\"978\":1}}],[\"但它的算法思想和理念仍十分值得我们学习\",{\"1\":{\"938\":1}}],[\"但它的并发标记清除思想影响了后续的垃圾回收算法\",{\"1\":{\"938\":1}}],[\"但它同样也可以在其它操作系统环境中编译运行\",{\"1\":{\"122\":1}}],[\"但由于算法的限制\",{\"1\":{\"938\":1}}],[\"但由于同一个表被分配在不同的数据库\",{\"1\":{\"518\":1}}],[\"但空间可能不足以分配较大对象\",{\"1\":{\"938\":1}}],[\"但cms算法本身的思想仍然值得我们学习\",{\"1\":{\"938\":1}}],[\"但也远比并发标记阶段的时间短\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"但也是一个方案\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"但也存在一定的缺陷\",{\"1\":{\"938\":1}}],[\"但也有client\",{\"1\":{\"106\":1}}],[\"但没有任何一个对象被外部强引用\",{\"1\":{\"936\":1}}],[\"但没有将表分布到不同的服务器上\",{\"1\":{\"517\":1}}],[\"但会产生碎片\",{\"1\":{\"936\":1}}],[\"但作为最基本和高效的实现\",{\"1\":{\"922\":1}}],[\"但hashmap的内容还是非常之广博\",{\"1\":{\"922\":1}}],[\"但这正是我成长为一名资深java工程师所必须经历的阶段\",{\"1\":{\"946\":1}}],[\"但这些缺点都可以通过选择其他map实现或辅助结构来补充\",{\"1\":{\"922\":1}}],[\"但这种操作出现的几率并不高\",{\"1\":{\"633\":1}}],[\"但相比于前两者性能较低\",{\"1\":{\"922\":1}}],[\"但查找时不方便识别\",{\"1\":{\"916\":1}}],[\"但查询条件只使用了name\",{\"1\":{\"501\":1}}],[\"但如果使用mybatis的dao接口动态代理\",{\"1\":{\"762\":1}}],[\"但对于运行无效\",{\"1\":{\"706\":1}}],[\"但对桶的使用方法上有明显差异\",{\"1\":{\"370\":1}}],[\"但每个节点的成员对象必须是唯一\",{\"1\":{\"629\":1}}],[\"但每个表唯一\",{\"1\":{\"383\":1}}],[\"但分数\",{\"1\":{\"607\":1}}],[\"但后者更易阅读\",{\"1\":{\"602\":1}}],[\"但排他锁\",{\"1\":{\"575\":1}}],[\"但仍然存在一定的冲突可能\",{\"1\":{\"566\":1}}],[\"但innodb会根据需要自动在页级别上应用锁\",{\"1\":{\"561\":1}}],[\"但在\",{\"1\":{\"1018\":1}}],[\"但在算法和实现上都已经有了重大创新\",{\"1\":{\"940\":1}}],[\"但在jdk8之后\",{\"1\":{\"930\":1}}],[\"但在并发量高的场合中\",{\"1\":{\"594\":1}}],[\"但在高并发环境下可能导致其他事务长时间等待\",{\"1\":{\"561\":1}}],[\"但在分配之后并不马上合并回一个数组中\",{\"1\":{\"375\":1}}],[\"但同时也降低了\",{\"0\":{\"537\":1}}],[\"但效果可能不如\",{\"1\":{\"511\":1}}],[\"但不保证可用性\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"但不够灵活\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"但不同的是wait方法从一个对象调用\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"但不拦截\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"但不能传\",{\"1\":{\"966\":1}}],[\"但不在构造器中注入依赖\",{\"1\":{\"954\":1}}],[\"但不会报错\",{\"1\":{\"917\":1}}],[\"但不会把存储从存储列表中删除\",{\"1\":{\"916\":1}}],[\"但不锁定该范围内的任何具体行\",{\"1\":{\"558\":1}}],[\"但不允许其他事务修改或删除这些行\",{\"1\":{\"555\":1}}],[\"但不支持b\",{\"1\":{\"498\":1}}],[\"但不得不占磁盘上4kb的空间\",{\"1\":{\"272\":1}}],[\"但实际上却变动过了\",{\"1\":{\"1018\":1}}],[\"但实际上是存储了\",{\"1\":{\"451\":1}}],[\"但实际测试时发现不同\",{\"1\":{\"145\":1}}],[\"但一定要等到事务提交后\",{\"1\":{\"383\":1}}],[\"但桶排序并不是\",{\"1\":{\"348\":1}}],[\"但当数据非常大的时候它们就无能为力了\",{\"1\":{\"266\":1}}],[\"但是很多同学还没用过这个工具\",{\"1\":{\"1443\":1}}],[\"但是由于使用起来配置较多\",{\"1\":{\"1443\":1}}],[\"但是由于两个\",{\"1\":{\"387\":1}}],[\"但是细节的描述更能体现你的知识底蕴\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"但是经常\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"但是数据更容易丢失\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"但是三者有一些差别\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"但是还未提交\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"但是还没有达到要求\",{\"1\":{\"517\":1}}],[\"但是新的\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"但是新增字段被丢弃\",{\"1\":{\"431\":1}}],[\"但是网络延迟\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"但是因为长生命周期对象持有它的引用而导致不能被回收\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"但是gc又不能回收他们的情况\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"但是本质上还是串行的\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"但是操作3并不依赖于操作2\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"但是也引入一个新问题\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"但是也有很多要点\",{\"1\":{\"917\":1}}],[\"但是性能更好\",{\"1\":{\"1089\":1,\"1290\":1}}],[\"但是一些特殊场景\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"但是一旦leader服务器挂了\",{\"1\":{\"166\":1}}],[\"但是方法的参数不同\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"但是会在结果中被过滤掉\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"但是会在\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"但是会执行字符串拼接操作\",{\"1\":{\"195\":1}}],[\"但是使用足够大的\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"但是读取的频率很高\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"但是又希望它们被写入分区怎么办呢\",{\"1\":{\"996\":1}}],[\"但是又不破坏分辨率\",{\"1\":{\"134\":1}}],[\"但是具体是什么意思呢\",{\"1\":{\"996\":1}}],[\"但是具体怎么实现的呢\",{\"1\":{\"994\":1}}],[\"但是内存是有限的\",{\"1\":{\"972\":1}}],[\"但是redis会尽力保证数据的一致性\",{\"1\":{\"968\":1}}],[\"但是当我们要用到\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"但是当你取出来的时候\",{\"1\":{\"966\":1}}],[\"但是当使用select\",{\"1\":{\"575\":1}}],[\"但是cookie是可以在客户端禁用的\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"但是cms也有一些缺点\",{\"1\":{\"938\":1}}],[\"但是client\",{\"1\":{\"106\":1}}],[\"但是其他线程并不能立即看到这个修改\",{\"1\":{\"924\":1}}],[\"但是其实背后是多台机器构成的集群\",{\"1\":{\"153\":1}}],[\"但是要谈谈优缺点\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"但是要去修复bug\",{\"1\":{\"916\":1}}],[\"但是要注意分区后可能影响写入性能\",{\"1\":{\"509\":1}}],[\"但是这属于确实没查到数据\",{\"1\":{\"1431\":1}}],[\"但是这是\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"但是这个时候大并发的请求可能会瞬间\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"但是这个例子属于单机模式\",{\"1\":{\"153\":1}}],[\"但是这位朋友这为一个外行人\",{\"1\":{\"906\":1}}],[\"但是如果消费者消费出错\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"但是如果\",{\"1\":{\"1162\":1,\"1163\":1,\"1350\":1,\"1351\":1}}],[\"但是如果被除数是2的幂次方\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"但是如果调用线程的join方法其实已经失去了并行的意义\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"但是如果你不等待确认\",{\"1\":{\"994\":1}}],[\"但是如果需要统计有增有减的指标需要用gauge\",{\"1\":{\"883\":1}}],[\"但是如果判断数据存在\",{\"1\":{\"334\":1}}],[\"但是你的二维码依然存在\",{\"1\":{\"871\":1,\"872\":1}}],[\"但是你了解\",{\"1\":{\"844\":1}}],[\"但是你要能注明出处\",{\"1\":{\"97\":1}}],[\"但是实际使用场景下\",{\"1\":{\"771\":1}}],[\"但是实际使用中\",{\"1\":{\"387\":1}}],[\"但是大家要注意一点\",{\"1\":{\"728\":1}}],[\"但是肯定不是最优解\",{\"1\":{\"723\":1}}],[\"但是并没有讲解非常详细的文章\",{\"1\":{\"692\":1}}],[\"但是用了\",{\"1\":{\"659\":1}}],[\"但是商品只剩下一件\",{\"1\":{\"553\":1}}],[\"但是第一个语句将插入一个\",{\"1\":{\"526\":1}}],[\"但是我们还是建议尽量避免使用字段为\",{\"1\":{\"526\":1}}],[\"但是我们生成的id一般都使用整数\",{\"1\":{\"387\":1}}],[\"但是它是不推荐的\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"但是它们的作用不同\",{\"1\":{\"1022\":1}}],[\"但是它们的实现方式和使用场景有所不同\",{\"1\":{\"932\":1}}],[\"但是它的性能开销比较小\",{\"1\":{\"1022\":1}}],[\"但是它的性能开销比较大\",{\"1\":{\"1022\":1}}],[\"但是它需要解决跨库带来的所有复杂问题\",{\"1\":{\"520\":1}}],[\"但是它不适合按字母顺序排序人名\",{\"1\":{\"357\":1}}],[\"但是依然没有解决单表数据量过大的问题\",{\"1\":{\"517\":1}}],[\"但是范围查询和排序操作时\",{\"1\":{\"499\":1}}],[\"但是主键索引一张表只能有一个\",{\"1\":{\"496\":1}}],[\"但是目前多数编辑器会强制让写\",{\"1\":{\"488\":1}}],[\"但是可以说\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"但是可以沿磁盘半径方向运动\",{\"1\":{\"274\":1}}],[\"但是可能还是有一些问题\",{\"1\":{\"438\":1}}],[\"但是非常有助于理解\",{\"1\":{\"375\":1}}],[\"但是有些时候不得不持有多个资源\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"但是有一点\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"但是有一个要求\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"但是有一种特殊的排序算法叫计数排序\",{\"1\":{\"359\":1}}],[\"但是有logo很烦\",{\"1\":{\"140\":1}}],[\"但是在每个分区下的消息是有序的\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"但是在高并发下\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"但是在处理远程用户时\",{\"1\":{\"982\":1}}],[\"但是在使用它之前\",{\"1\":{\"968\":1}}],[\"但是在系统中要以外部jar包的形式提供\",{\"1\":{\"706\":1}}],[\"但是在布隆过滤器中\",{\"1\":{\"333\":1}}],[\"但是在分布式系统中这种方式就不能使用blockingqueue来实现了\",{\"1\":{\"164\":1}}],[\"但是循环队列我们就不能单纯的进行自增\",{\"1\":{\"288\":1}}],[\"但是文件系统及数据库系统普遍采用b\",{\"1\":{\"271\":1}}],[\"但是选择合适的请求方式可以提升开发效率\",{\"1\":{\"178\":1}}],[\"但是zookeeper可以实现\",{\"1\":{\"164\":1}}],[\"但是对于部分维护老代码的工程师来说\",{\"1\":{\"1126\":1}}],[\"但是对于跨进程\",{\"1\":{\"163\":1}}],[\"但是对其中maven不了解\",{\"1\":{\"698\":1}}],[\"但是对数量级较小的整数排序很实用\",{\"1\":{\"356\":1}}],[\"但是对象还没有使用时就被创建\",{\"1\":{\"79\":1}}],[\"但是别把cpu跑到100\",{\"1\":{\"106\":1}}],[\"但是nginx分配请求并不是那么均匀\",{\"1\":{\"106\":1}}],[\"但是真正在生产环境中怎么用确一直不被大多数人掌握\",{\"1\":{\"84\":1}}],[\"但是\",{\"1\":{\"82\":1,\"90\":1,\"225\":1,\"333\":1,\"339\":1,\"357\":1,\"385\":1,\"451\":1,\"502\":1,\"540\":1,\"541\":1,\"924\":3,\"970\":1,\"984\":1,\"1076\":1,\"1131\":1,\"1145\":1,\"1238\":1,\"1280\":1,\"1324\":1,\"1336\":1,\"1411\":1}}],[\"4字节\",{\"1\":{\"1120\":1,\"1315\":1}}],[\"476\",{\"1\":{\"789\":1}}],[\"47\",{\"1\":{\"762\":1}}],[\"4间接依赖log4j1\",{\"1\":{\"709\":1}}],[\"4版本的包\",{\"1\":{\"709\":1}}],[\"4<\",{\"1\":{\"708\":1,\"709\":1,\"715\":1,\"812\":1}}],[\"4行\",{\"1\":{\"692\":1}}],[\"423\",{\"1\":{\"789\":1}}],[\"421\",{\"1\":{\"789\":1}}],[\"42\",{\"1\":{\"689\":1,\"1104\":1,\"1302\":1}}],[\"4294967295\",{\"1\":{\"604\":1,\"607\":1,\"655\":1}}],[\"4个可选参数docs\",{\"1\":{\"440\":1}}],[\"48\",{\"1\":{\"439\":1}}],[\"41\",{\"1\":{\"387\":4,\"388\":1}}],[\"41位的时间截\",{\"1\":{\"388\":1}}],[\"41位时间截不是存储当前时间的时间截\",{\"1\":{\"388\":1}}],[\"41位时间截\",{\"1\":{\"388\":1}}],[\"41位可以表示\",{\"1\":{\"387\":1}}],[\"41位\",{\"1\":{\"387\":1}}],[\"466\",{\"1\":{\"789\":1}}],[\"46\",{\"1\":{\"377\":1}}],[\"4677eb13\",{\"1\":{\"177\":1}}],[\"4340277777778\",{\"1\":{\"865\":1}}],[\"43333333333334\",{\"1\":{\"865\":1}}],[\"4333333333333\",{\"1\":{\"865\":1}}],[\"438\",{\"1\":{\"789\":2}}],[\"437\",{\"1\":{\"789\":1}}],[\"43\",{\"1\":{\"375\":5,\"377\":2,\"824\":1}}],[\"43be\",{\"1\":{\"177\":1}}],[\"4和9交换\",{\"1\":{\"364\":1}}],[\"4秒\",{\"1\":{\"329\":1}}],[\"455\",{\"1\":{\"865\":4}}],[\"45<\",{\"1\":{\"862\":1}}],[\"45\",{\"1\":{\"329\":1}}],[\"4的主存模型\",{\"1\":{\"273\":1}}],[\"4c8g\",{\"1\":{\"244\":1}}],[\"4c8c\",{\"1\":{\"178\":1}}],[\"4a90\",{\"1\":{\"181\":1}}],[\"4a35573e8b04\",{\"1\":{\"178\":1}}],[\"44692737430168\",{\"1\":{\"865\":1}}],[\"440\",{\"1\":{\"789\":1}}],[\"44062339\",{\"1\":{\"520\":1}}],[\"44\",{\"1\":{\"159\":1}}],[\"443\",{\"1\":{\"106\":1}}],[\"4947615\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"492\",{\"1\":{\"789\":1}}],[\"49\",{\"1\":{\"134\":1}}],[\"403\",{\"1\":{\"1431\":1}}],[\"40374604\",{\"1\":{\"275\":1,\"675\":1,\"728\":1}}],[\"400\",{\"1\":{\"1431\":1}}],[\"405\",{\"1\":{\"865\":2}}],[\"401\",{\"1\":{\"789\":1,\"1431\":1}}],[\"408\",{\"1\":{\"789\":1}}],[\"40多亿\",{\"1\":{\"605\":1}}],[\"40\",{\"1\":{\"329\":1,\"789\":11,\"790\":2,\"795\":1,\"830\":1,\"865\":2}}],[\"4094\",{\"1\":{\"387\":1}}],[\"4095\",{\"1\":{\"387\":3}}],[\"40999403\",{\"1\":{\"251\":1}}],[\"4096\",{\"1\":{\"106\":1}}],[\"404747369\",{\"1\":{\"112\":1,\"871\":1,\"889\":1}}],[\"404\",{\"1\":{\"106\":3,\"1027\":1,\"1431\":1,\"1447\":1}}],[\"4\",{\"0\":{\"132\":1,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"179\":1,\"353\":1,\"361\":1,\"497\":1,\"529\":1,\"558\":1,\"563\":1,\"594\":1,\"605\":1,\"617\":1,\"618\":1,\"619\":1,\"620\":1,\"621\":1,\"622\":1,\"623\":1,\"624\":1,\"625\":1,\"626\":1,\"627\":2,\"628\":2,\"629\":2,\"630\":1,\"631\":1,\"632\":1,\"633\":1,\"634\":1,\"635\":1,\"636\":1,\"674\":1,\"689\":1,\"709\":1,\"710\":1,\"714\":1,\"728\":1,\"737\":1,\"739\":1,\"741\":1,\"742\":1,\"743\":1,\"744\":1,\"745\":2,\"746\":1,\"747\":1,\"748\":1,\"756\":1,\"764\":1,\"769\":1,\"778\":1,\"781\":1,\"787\":1,\"795\":1,\"1045\":1,\"1060\":1,\"1071\":1,\"1087\":1,\"1101\":1,\"1115\":1,\"1130\":1,\"1145\":1,\"1161\":1,\"1175\":1,\"1188\":1,\"1201\":1,\"1214\":1,\"1227\":1,\"1240\":1,\"1254\":1,\"1266\":1,\"1276\":1,\"1288\":1,\"1299\":1,\"1310\":1,\"1323\":1,\"1336\":1,\"1349\":1,\"1360\":1,\"1371\":1,\"1381\":1,\"1391\":1,\"1402\":1,\"1413\":1},\"1\":{\"106\":5,\"125\":3,\"141\":1,\"153\":1,\"157\":3,\"158\":1,\"159\":2,\"166\":2,\"266\":1,\"288\":3,\"289\":3,\"352\":2,\"359\":4,\"360\":3,\"364\":4,\"375\":2,\"433\":1,\"451\":1,\"525\":1,\"594\":1,\"605\":1,\"606\":1,\"607\":1,\"635\":2,\"702\":1,\"715\":6,\"726\":4,\"737\":1,\"751\":1,\"757\":1,\"763\":1,\"812\":5,\"815\":1,\"819\":1,\"828\":1,\"837\":1,\"838\":1,\"839\":1,\"844\":4,\"898\":1,\"916\":1,\"924\":2,\"928\":1,\"948\":1,\"1022\":1,\"1044\":4,\"1060\":1,\"1077\":2,\"1100\":1,\"1104\":4,\"1151\":1,\"1162\":1,\"1163\":1,\"1166\":1,\"1167\":1,\"1190\":1,\"1201\":1,\"1211\":1,\"1216\":1,\"1217\":1,\"1253\":4,\"1266\":1,\"1276\":2,\"1281\":2,\"1298\":1,\"1302\":4,\"1342\":1,\"1350\":1,\"1351\":1,\"1354\":1,\"1355\":1,\"1373\":1,\"1381\":1,\"1388\":1,\"1393\":1,\"1394\":1,\"1444\":1}}],[\"4k\",{\"1\":{\"106\":2}}],[\"4万时就有进程可能超过10240了\",{\"1\":{\"106\":1}}],[\"~gohlke\",{\"1\":{\"898\":1}}],[\"~\",{\"1\":{\"106\":9}}],[\"取一个partition对应的isr中最小的leo作为hw\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"取回阶段\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"取消暂停容器\",{\"1\":{\"1063\":1,\"1269\":1}}],[\"取决于你的文档的大小\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"取决于\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"取而代之的是元空间\",{\"1\":{\"930\":2}}],[\"取而代之提供了一套简单一致的\",{\"1\":{\"400\":1}}],[\"取值\",{\"1\":{\"692\":1}}],[\"取值范围为从0到10\",{\"1\":{\"359\":1}}],[\"取出\",{\"1\":{\"597\":1}}],[\"取出文件的并集\",{\"1\":{\"94\":1}}],[\"取余之后的结果是一样的\",{\"1\":{\"333\":1,\"339\":1}}],[\"取得\",{\"1\":{\"106\":1}}],[\"kazjsfecs3y\",{\"1\":{\"1422\":1}}],[\"kafka为流行的流式处理框架提供了可靠的数据来源\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"kafka把消息持久化到磁盘\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"kafka与传统的消息中间件都具备系统解耦\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"kafka与传统消息系统区别\",{\"0\":{\"992\":1}}],[\"kafka中的hw\",{\"0\":{\"1157\":1,\"1345\":1}}],[\"kafka中的isr\",{\"0\":{\"1156\":1,\"1344\":1}}],[\"kafka能够保证消息的可靠性和一致性\",{\"1\":{\"996\":1}}],[\"kafka真是个聪明的家伙\",{\"1\":{\"996\":1}}],[\"kafka仍然会将其写入分区\",{\"1\":{\"996\":1}}],[\"kafka引入了幂等性序列号\",{\"1\":{\"996\":1}}],[\"kafka就会认为这是一条重复的消息\",{\"1\":{\"996\":1}}],[\"kafka就会将该消息标记为已消费\",{\"1\":{\"984\":1}}],[\"kafka会认为这是一条重复的消息\",{\"1\":{\"996\":1}}],[\"kafka会将消息写入分区\",{\"1\":{\"996\":1}}],[\"kafka会检查消息的序列号是否大于分区中最后一条消息的序列号\",{\"1\":{\"996\":1}}],[\"kafka会检查消息的key是否已经存在于特定的主题分区中\",{\"1\":{\"996\":1}}],[\"kafka会为每个分区维护一个递增的序列号\",{\"1\":{\"996\":1}}],[\"kafka会使用这个序列号来判断消息的唯一性\",{\"1\":{\"996\":1}}],[\"kafka会自动进行重试\",{\"1\":{\"994\":1}}],[\"kafka相比传统消息系统有几个明显的优势\",{\"1\":{\"992\":1}}],[\"kafka具有高度可扩展性\",{\"1\":{\"992\":1}}],[\"kafka具有良好的可扩展性和可靠性\",{\"1\":{\"978\":1}}],[\"kafka将消息存储在持久化的日志中\",{\"1\":{\"992\":1}}],[\"kafka和传统消息系统有什么不同呢\",{\"1\":{\"992\":1}}],[\"kafkaproducer<>\",{\"1\":{\"990\":1}}],[\"kafkademo\",{\"1\":{\"990\":1}}],[\"kafka消息采用pull还是push\",{\"0\":{\"990\":1}}],[\"kafka使用了一种叫做\",{\"1\":{\"996\":1}}],[\"kafka使用zookeeper来管理分区和副本的状态\",{\"1\":{\"986\":1}}],[\"kafka使用场景\",{\"0\":{\"976\":1}}],[\"kafka可以并行处理大量的消息\",{\"1\":{\"986\":1}}],[\"kafka通过消息的唯一标识\",{\"1\":{\"996\":1}}],[\"kafka通过分区\",{\"1\":{\"986\":1}}],[\"kafka通过将消息分为多个分区\",{\"1\":{\"974\":1}}],[\"kafka是如何实现这个机制的呢\",{\"1\":{\"994\":1}}],[\"kafka是如何实现高吞吐量和可伸缩性的呢\",{\"1\":{\"986\":1}}],[\"kafka是一个非常强大的工具\",{\"1\":{\"986\":1}}],[\"kafka是一个强大的分布式流处理平台\",{\"1\":{\"986\":1}}],[\"kafka是一个分布式的消息队列\",{\"1\":{\"984\":1}}],[\"kafka是一个分布式流处理平台\",{\"1\":{\"974\":1,\"992\":1}}],[\"kafka是一个高吞吐量的分布式消息系统\",{\"1\":{\"990\":1}}],[\"kafka是一个高吞吐量的分布式消息队列\",{\"1\":{\"976\":1}}],[\"kafka是一个高吞吐量\",{\"1\":{\"980\":1}}],[\"kafkabroker\",{\"1\":{\"986\":1}}],[\"kafka架构设计\",{\"0\":{\"986\":1}}],[\"kafkaconsumer<>\",{\"1\":{\"984\":1,\"990\":1}}],[\"kafkaconsumer<string\",{\"1\":{\"984\":1}}],[\"kafkaconsumerexample\",{\"1\":{\"984\":1}}],[\"kafkaconsumer\",{\"1\":{\"984\":1}}],[\"kafka保证了消息的顺序性和可靠性\",{\"1\":{\"980\":1}}],[\"kafka还提供了大多数消息系统难以实现的消息顺序性保障及回溯性消费的功能\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"kafka还提供了消费者组\",{\"1\":{\"980\":1}}],[\"kafka还支持消息的持久化存储和数据复制\",{\"1\":{\"992\":1}}],[\"kafka还有哪些特点\",{\"1\":{\"992\":1}}],[\"kafka还利用了磁盘顺序写和零拷贝技术\",{\"1\":{\"980\":1}}],[\"kafka还可以用于构建事件驱动的架构\",{\"1\":{\"976\":1}}],[\"kafka采用了分布式的消息存储和复制机制\",{\"1\":{\"980\":1}}],[\"kafka性能好在哪里\",{\"0\":{\"980\":1}}],[\"kafka在处理实时数据和构建可靠的数据管道方面非常强大\",{\"1\":{\"978\":1}}],[\"kafka在一些特定的使用情况下可能会有一些性能瓶颈\",{\"1\":{\"978\":1}}],[\"kafka作为一个高吞吐量\",{\"1\":{\"978\":1}}],[\"kafka并不是适合所有场景的银弹\",{\"1\":{\"978\":1}}],[\"kafka提供了灵活的消息传递模型\",{\"1\":{\"978\":1}}],[\"kafka有四个核心组件\",{\"1\":{\"986\":1}}],[\"kafka有一个活跃的社区和丰富的生态系统\",{\"1\":{\"978\":1}}],[\"kafka有很多优点\",{\"1\":{\"978\":1}}],[\"kafka有哪些常见的使用场景呢\",{\"1\":{\"974\":1}}],[\"kafka优缺点\",{\"0\":{\"978\":1}}],[\"kafka非常适合用于日志收集和分析\",{\"1\":{\"976\":1}}],[\"kafka的leader\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"kafka的设计确实很巧妙\",{\"1\":{\"996\":1}}],[\"kafka的幂等性\",{\"0\":{\"996\":1}}],[\"kafka的ack机制是确保消息可靠性的关键\",{\"1\":{\"994\":1}}],[\"kafka的ack机制是通过生产者和消费者之间的协作来实现的\",{\"1\":{\"994\":1}}],[\"kafka的ack机制\",{\"0\":{\"994\":1}}],[\"kafka的可扩展性使得它能够适应不断增长的数据需求\",{\"1\":{\"992\":1}}],[\"kafka的持久化存储和数据复制功能确保了消息的可靠性和容错性\",{\"1\":{\"992\":1}}],[\"kafka的高吞吐量和低延迟使得它能够处理大规模的数据流\",{\"1\":{\"992\":1}}],[\"kafka的高性能得益于它的设计理念和架构\",{\"1\":{\"980\":1}}],[\"kafka的高性能确实让人印象深刻\",{\"1\":{\"978\":1}}],[\"kafka的这些特点使得它成为处理实时数据流的理想选择\",{\"1\":{\"992\":1}}],[\"kafka的这种设计使得它具有很高的可伸缩性和容错性\",{\"1\":{\"992\":1}}],[\"kafka的架构设计非常注重可靠性和容错性\",{\"1\":{\"986\":1}}],[\"kafka的架构设计非常简洁明了\",{\"1\":{\"986\":1}}],[\"kafka的消费者可以通过设置适当的参数来控制消息的提交和重试机制\",{\"1\":{\"980\":1}}],[\"kafka的消息传递机制基于发布\",{\"1\":{\"980\":1}}],[\"kafka的消息发布和订阅模型就像是一个咖啡馆\",{\"1\":{\"974\":1}}],[\"kafka的优点和缺点都值得我们深入了解和探讨\",{\"1\":{\"978\":1}}],[\"kafka的优点真是让人眼花缭乱\",{\"1\":{\"978\":1}}],[\"kafka的分区机制可能会导致一些延迟\",{\"1\":{\"978\":1}}],[\"kafka的配置确实需要一些技术功底\",{\"1\":{\"978\":1}}],[\"kafka的灵活性和持久性确实让它在数据处理领域脱颖而出\",{\"1\":{\"978\":1}}],[\"kafka的确是一个非常强大的工具\",{\"1\":{\"976\":1}}],[\"kafka的使用场景确实非常丰富多样\",{\"1\":{\"976\":1}}],[\"kafka的使用场景非常广泛\",{\"1\":{\"974\":1}}],[\"kafka的源码是开源的\",{\"1\":{\"974\":1}}],[\"kafka基础\",{\"0\":{\"974\":1}}],[\"kafka\",{\"0\":{\"1155\":1,\"1158\":1,\"1159\":1,\"1160\":1,\"1163\":1,\"1165\":1,\"1167\":1,\"1343\":1,\"1346\":1,\"1347\":1,\"1348\":1,\"1351\":1,\"1353\":1,\"1355\":1},\"1\":{\"524\":1,\"594\":1,\"950\":1,\"982\":5,\"984\":5,\"990\":5,\"1155\":3,\"1158\":1,\"1159\":8,\"1162\":3,\"1164\":3,\"1165\":1,\"1166\":2,\"1167\":4,\"1346\":1,\"1347\":8,\"1350\":3,\"1352\":3,\"1353\":1,\"1354\":2,\"1355\":4},\"2\":{\"1170\":1}}],[\"kryo等\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"kraft\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"kong\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"kotlin\",{\"1\":{\"837\":1}}],[\"koi8\",{\"1\":{\"106\":1}}],[\"kfyrapnrdp8llktjgd658q\",{\"1\":{\"832\":1}}],[\"known\",{\"1\":{\"762\":1}}],[\"knows\",{\"1\":{\"152\":1}}],[\"km\",{\"1\":{\"660\":1}}],[\"kmulx\",{\"1\":{\"147\":1}}],[\"kb\",{\"1\":{\"659\":1}}],[\"kibana\",{\"1\":{\"400\":1}}],[\"kill\",{\"1\":{\"90\":1,\"581\":2}}],[\"k++\",{\"1\":{\"377\":1,\"1085\":1,\"1286\":1}}],[\"k或\",{\"1\":{\"266\":1}}],[\"k\",{\"1\":{\"141\":1,\"266\":2,\"348\":1,\"353\":6,\"357\":1,\"377\":3,\"922\":2,\"928\":11,\"948\":1,\"1044\":2,\"1085\":3,\"1253\":2,\"1286\":3}}],[\"key的hashcode\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"key3\",{\"1\":{\"982\":1}}],[\"key这个命令用来获取指定key的值\",{\"1\":{\"960\":1}}],[\"key这个命令呢\",{\"1\":{\"960\":1}}],[\"keyproperty=\",{\"1\":{\"763\":1,\"1176\":1,\"1361\":1}}],[\"keyproperty\",{\"1\":{\"763\":1,\"776\":1}}],[\"keycolumn=\",{\"1\":{\"763\":1,\"1176\":1,\"1361\":1}}],[\"keycolumn\",{\"1\":{\"763\":1,\"776\":1}}],[\"keycompare\",{\"1\":{\"624\":1}}],[\"keydestructor\",{\"1\":{\"624\":1}}],[\"keydup\",{\"1\":{\"624\":1}}],[\"key2\",{\"1\":{\"604\":2,\"606\":6,\"624\":1,\"982\":1}}],[\"key1\",{\"1\":{\"604\":2,\"606\":6,\"624\":1,\"982\":1}}],[\"key`\",{\"1\":{\"577\":2}}],[\"keyword\",{\"1\":{\"411\":1,\"434\":2,\"439\":1,\"440\":2,\"443\":2,\"1004\":2}}],[\"key数量和bitarray长度确定\",{\"1\":{\"335\":1}}],[\"key为\",{\"1\":{\"270\":1}}],[\"keys自动排序\",{\"1\":{\"922\":1}}],[\"keyset\",{\"1\":{\"353\":1}}],[\"keys\",{\"0\":{\"602\":1},\"1\":{\"267\":1,\"1020\":1}}],[\"key值\",{\"1\":{\"267\":1}}],[\"key\",{\"1\":{\"106\":2,\"112\":1,\"267\":10,\"270\":12,\"353\":3,\"505\":1,\"507\":1,\"560\":1,\"575\":2,\"577\":5,\"589\":2,\"592\":2,\"593\":1,\"597\":2,\"602\":3,\"603\":7,\"604\":14,\"605\":20,\"606\":9,\"607\":24,\"615\":1,\"621\":1,\"624\":4,\"652\":1,\"653\":1,\"654\":1,\"655\":2,\"659\":3,\"664\":2,\"726\":1,\"736\":1,\"792\":1,\"795\":3,\"824\":4,\"831\":1,\"832\":2,\"922\":10,\"928\":8,\"948\":4,\"960\":10,\"970\":6,\"984\":1,\"990\":2,\"1020\":9,\"1044\":4,\"1047\":3,\"1049\":7,\"1052\":1,\"1116\":4,\"1123\":3,\"1162\":7,\"1198\":1,\"1205\":2,\"1206\":1,\"1253\":4,\"1256\":3,\"1258\":7,\"1261\":1,\"1311\":4,\"1318\":3,\"1350\":7,\"1378\":1,\"1385\":2,\"1386\":1,\"1444\":1}}],[\"keepalive\",{\"1\":{\"106\":3}}],[\"keepalive超时时间\",{\"1\":{\"106\":1}}],[\"就够用\",{\"1\":{\"1443\":1}}],[\"就抛出异常\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"就把当前事务挂起\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"就把链表转换为红黑树\",{\"1\":{\"922\":1}}],[\"就以非事务执行\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"就加入该事务\",{\"1\":{\"1220\":3,\"1397\":3}}],[\"就创建一个新事务\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"就将清空\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"就将一个无需序列构造成了一个大顶堆\",{\"1\":{\"364\":1}}],[\"就造成了老节点和新节点之间的负载不均衡\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"就没有这条消息\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"就没有问题\",{\"1\":{\"800\":1}}],[\"就崩溃了\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"就代表成功\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"就代表分区的\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"就成功返回\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"就从数据库获取\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"就绪状态的线程在获得cpu时间片后变为运行中状态\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"就默认下载最新的\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"就挂掉了\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"就产生了aba问题\",{\"1\":{\"1018\":1}}],[\"就重试整个读取\",{\"1\":{\"1018\":1}}],[\"就重新计算每个节点的hash值和索引\",{\"1\":{\"922\":1}}],[\"就可能会影响到整个齿轮组的正常运转\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"就可能会导致内存泄漏\",{\"1\":{\"928\":1}}],[\"就可以使用\",{\"1\":{\"1444\":1}}],[\"就可以使用了\",{\"1\":{\"251\":1}}],[\"就可以直接找到文档1\",{\"1\":{\"1006\":1}}],[\"就可以直接查看全系列文章\",{\"1\":{\"920\":1}}],[\"就可以启动对所有\",{\"1\":{\"958\":1}}],[\"就可以实现方法的切入\",{\"1\":{\"944\":1}}],[\"就可以实现接近\",{\"1\":{\"659\":1}}],[\"就可以继续执行下一阶段了\",{\"1\":{\"932\":1}}],[\"就可以保证看到最新的值\",{\"1\":{\"924\":1}}],[\"就可以更好地选择和使用它\",{\"1\":{\"922\":1}}],[\"就可以看到部署的网站地址\",{\"1\":{\"913\":1}}],[\"就可以把查找工作交给机器\",{\"1\":{\"705\":1}}],[\"就可以获取排名前100的用户\",{\"1\":{\"657\":1}}],[\"就可以找到数据\",{\"1\":{\"270\":1}}],[\"就在新位置形成新的链表\",{\"1\":{\"922\":1}}],[\"就进行resize两倍扩容\",{\"1\":{\"922\":1}}],[\"就替换oldvalue为新值\",{\"1\":{\"922\":1}}],[\"就插入冲突链表中\",{\"1\":{\"922\":1}}],[\"就恢复到了上一次的\",{\"1\":{\"918\":1}}],[\"就已取得间断性胜利\",{\"1\":{\"912\":1}}],[\"就能快速定位到相关文档\",{\"1\":{\"1006\":1}}],[\"就能保证消息不会被重复写入了\",{\"1\":{\"996\":1}}],[\"就能直接更新网站内容\",{\"1\":{\"911\":1}}],[\"就能找到数据\",{\"1\":{\"265\":1}}],[\"就近原则\",{\"1\":{\"709\":1}}],[\"就称之为仓库\",{\"1\":{\"705\":1}}],[\"就很好解释上面的问题了\",{\"1\":{\"692\":1}}],[\"就必须先来了解一下\",{\"1\":{\"692\":1}}],[\"就知道家里没人\",{\"1\":{\"553\":1}}],[\"就不需要读内存\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"就不要用\",{\"1\":{\"529\":1}}],[\"就不会有问题\",{\"1\":{\"387\":1}}],[\"就跟把鸡蛋放在多个篮子里是一样的\",{\"1\":{\"515\":1}}],[\"就算你的程序停止运行\",{\"1\":{\"871\":1,\"872\":1}}],[\"就算有代码的也测试不出效果\",{\"1\":{\"692\":1}}],[\"就算是\",{\"1\":{\"664\":1}}],[\"就算\",{\"1\":{\"501\":1}}],[\"就要进入金银季\",{\"1\":{\"493\":1,\"552\":1}}],[\"就通过\",{\"1\":{\"488\":1,\"1165\":1,\"1353\":1}}],[\"就和java中map一样\",{\"1\":{\"488\":1}}],[\"就像一个工具类\",{\"1\":{\"1113\":1,\"1308\":1}}],[\"就像sleep\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"就像是一本索引书\",{\"1\":{\"1006\":1}}],[\"就像是一个事件的调度员\",{\"1\":{\"976\":1}}],[\"就像是一个数据流的管家\",{\"1\":{\"976\":1}}],[\"就像是你有一个备份咖啡师\",{\"1\":{\"974\":1}}],[\"就像这样\",{\"1\":{\"602\":1}}],[\"就像我们生活中\",{\"1\":{\"553\":1}}],[\"就像\",{\"1\":{\"401\":1}}],[\"就会看到与上面类似的情形\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"就会多个哨兵之间进行确认\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"就会对性能造成影响呢\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"就会进行\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"就会进行扩容resize操作\",{\"1\":{\"922\":1}}],[\"就会自动提交位移\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"就会将其放入\",{\"1\":{\"1160\":2,\"1348\":2}}],[\"就会存在问题\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"就会变成\",{\"1\":{\"1018\":1}}],[\"就会产生aba问题\",{\"1\":{\"1018\":1}}],[\"就会触发一次minor\",{\"1\":{\"930\":1}}],[\"就会先将链表转成红黑树\",{\"1\":{\"922\":1}}],[\"就会在链表中追加新节点\",{\"1\":{\"922\":1}}],[\"就会全部回滚\",{\"1\":{\"728\":1}}],[\"就会涉及到状态同步的场景\",{\"1\":{\"664\":1}}],[\"就会浪费一部分存储空间\",{\"1\":{\"632\":1}}],[\"就会感觉很谨慎\",{\"1\":{\"488\":1}}],[\"就会出现主键不一致\",{\"1\":{\"383\":1}}],[\"就会成为leader\",{\"1\":{\"166\":1}}],[\"就需要namespace中的值\",{\"1\":{\"762\":1}}],[\"就需要创建长度为1亿的数组\",{\"1\":{\"361\":1}}],[\"就需要大量空间消耗\",{\"1\":{\"347\":1}}],[\"就输出几次\",{\"1\":{\"359\":1}}],[\"就如我们平时用字典查单词一样\",{\"1\":{\"266\":1}}],[\"就一定要添加详细说明文档\",{\"1\":{\"179\":1}}],[\"就变更为leading\",{\"1\":{\"166\":1}}],[\"就叫分布式协调系统\",{\"1\":{\"153\":1}}],[\"就说如果外面的人\",{\"1\":{\"153\":1}}],[\"就是错误\",{\"1\":{\"1431\":1}}],[\"就是成功\",{\"1\":{\"1431\":1}}],[\"就是对象之间的依赖关系由容器来创建\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"就是我们要实现整个系统所需要完成的全部内容\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"就是映射文件中的\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"就是文件系统上的\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"就是利用操作系统自身的内存而不是jvm空间内存\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"就是一种不确定的数据类型\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"就是可以用来实现相似商品的推荐\",{\"1\":{\"1079\":1,\"1283\":1}}],[\"就是只能统计基数数量\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"就是只存0\",{\"1\":{\"333\":1,\"339\":1}}],[\"就是描述该层应当如何构建\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"就是提升读写性能\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"就是数据交换的缓冲区\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"就是个大数据的搜索神器\",{\"1\":{\"998\":1}}],[\"就是个不错的注意\",{\"1\":{\"602\":1}}],[\"就是在接口的方法上面加上\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"就是在\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"就是在指定的时间间隔内将内存中的数据集快照写入磁盘\",{\"1\":{\"962\":1}}],[\"就是在规定时间之内后端服务器必须传完所有的数据\",{\"1\":{\"106\":1}}],[\"就是将指定的提交\",{\"1\":{\"917\":1}}],[\"就是如何将网站放在公网上\",{\"1\":{\"913\":1}}],[\"就是用他来搭建的\",{\"1\":{\"906\":1}}],[\"就是装不上\",{\"1\":{\"895\":1}}],[\"就是项目名称\",{\"1\":{\"844\":1}}],[\"就是maven在本机存储构件的地方\",{\"1\":{\"705\":1}}],[\"就是估算在一批数据中\",{\"1\":{\"659\":1}}],[\"就是编程中常用的字符串列表\",{\"1\":{\"655\":1}}],[\"就是普通的\",{\"1\":{\"653\":1}}],[\"就是说\",{\"1\":{\"604\":1}}],[\"就是两个或多个事务陷入了一个循环等待的状态\",{\"1\":{\"562\":1}}],[\"就是两个node节点\",{\"1\":{\"417\":1}}],[\"就是断言的作用\",{\"1\":{\"488\":1}}],[\"就是\",{\"1\":{\"387\":1,\"401\":1,\"658\":1}}],[\"就是前段时间封了懂王账号的\",{\"1\":{\"386\":1}}],[\"就是通过\",{\"1\":{\"177\":1}}],[\"就是她不包含在ffmpeg的源码里\",{\"1\":{\"135\":1}}],[\"就行\",{\"1\":{\"106\":1}}],[\"就有个单例模式的用武之地\",{\"1\":{\"77\":1}}],[\"单命令操作\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"单节点\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"单元测试常用\",{\"1\":{\"864\":1}}],[\"单元测试\",{\"1\":{\"715\":1,\"812\":1}}],[\"单独运行测试类\",{\"1\":{\"705\":1}}],[\"单点抢占式任务执行\",{\"1\":{\"664\":1}}],[\"单位\",{\"1\":{\"648\":1}}],[\"单位毫秒或者秒\",{\"1\":{\"445\":1}}],[\"单排学习\",{\"1\":{\"641\":1,\"647\":1}}],[\"单排学习redis\",{\"2\":{\"610\":1,\"638\":1,\"650\":1}}],[\"单页内存储行数少\",{\"1\":{\"516\":1}}],[\"单页内的数据行越多数据库整体性能越好\",{\"1\":{\"516\":1}}],[\"单一数据表的数据量变小\",{\"1\":{\"515\":1}}],[\"单列是非常快速的\",{\"1\":{\"498\":1}}],[\"单列索引就是在一个列上创建的索引\",{\"1\":{\"498\":1}}],[\"单条插入\",{\"0\":{\"471\":1}}],[\"单词词典内每条索引项记载单词本身的一些信息以及指向\",{\"1\":{\"424\":1}}],[\"单词词典是由文档集合中出现过的所有单词构成的字符串集合\",{\"1\":{\"424\":1}}],[\"单词词典\",{\"1\":{\"424\":2}}],[\"单词\",{\"1\":{\"424\":1}}],[\"单机安装\",{\"0\":{\"596\":1}}],[\"单机存储容量\",{\"1\":{\"515\":1}}],[\"单机存到缓存肯定是适用场景有限\",{\"1\":{\"342\":1}}],[\"单机版本已搭建完成\",{\"1\":{\"407\":1}}],[\"单体架构的服务的日子已经一去不复返了\",{\"1\":{\"381\":1}}],[\"单个cookie保存的数据不能超过4k\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"单个索引切分成多个shard\",{\"1\":{\"421\":1}}],[\"单个元素越小\",{\"1\":{\"270\":1}}],[\"单个进程最大连接数\",{\"1\":{\"106\":1}}],[\"单例\",{\"1\":{\"952\":1,\"1099\":1,\"1297\":1}}],[\"单例最有代表就是我们耳熟能详的\",{\"1\":{\"77\":1}}],[\"单例模式又可以分为预加载和懒加载\",{\"1\":{\"78\":1}}],[\"单例模式是最常见的设计模式之一\",{\"1\":{\"76\":1}}],[\"单例模式\",{\"0\":{\"76\":1},\"1\":{\"79\":1,\"80\":1,\"83\":1,\"84\":1,\"950\":1,\"1215\":1,\"1216\":1,\"1392\":1,\"1393\":1},\"2\":{\"85\":1,\"86\":1}}],[\"6uk3sg\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"6877350\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"665\",{\"1\":{\"790\":1}}],[\"664\",{\"1\":{\"790\":1}}],[\"666\",{\"1\":{\"195\":1,\"586\":1,\"643\":1,\"1431\":1}}],[\"6379>\",{\"1\":{\"654\":1,\"655\":2,\"659\":3}}],[\"6379\",{\"1\":{\"597\":2,\"648\":1}}],[\"6及以上版本中\",{\"1\":{\"507\":1}}],[\"6版本变化较大\",{\"1\":{\"419\":1}}],[\"69<br>\",{\"1\":{\"388\":1}}],[\"69\",{\"1\":{\"387\":1}}],[\"694843237\",{\"1\":{\"251\":1}}],[\"64\",{\"1\":{\"405\":2,\"577\":1,\"597\":1}}],[\"64bit\",{\"1\":{\"387\":2}}],[\"64k\",{\"1\":{\"106\":3}}],[\"624\",{\"1\":{\"865\":1}}],[\"62233031\",{\"1\":{\"394\":1}}],[\"62\",{\"1\":{\"270\":1}}],[\"6773\",{\"1\":{\"159\":1}}],[\"6\",{\"0\":{\"134\":1,\"161\":1,\"181\":1,\"499\":1,\"531\":1,\"560\":1,\"571\":1,\"599\":1,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"604\":1,\"605\":1,\"606\":1,\"607\":2,\"631\":1,\"632\":1,\"633\":1,\"747\":1,\"752\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"757\":1,\"758\":2,\"759\":1,\"771\":1,\"797\":1,\"1047\":1,\"1062\":1,\"1073\":1,\"1089\":1,\"1103\":1,\"1117\":1,\"1132\":1,\"1147\":1,\"1163\":1,\"1177\":1,\"1190\":1,\"1203\":1,\"1216\":1,\"1229\":1,\"1242\":1,\"1256\":1,\"1268\":1,\"1278\":1,\"1290\":1,\"1301\":1,\"1312\":1,\"1325\":1,\"1338\":1,\"1351\":1,\"1362\":1,\"1373\":1,\"1383\":1,\"1393\":1,\"1404\":1,\"1415\":1},\"1\":{\"159\":8,\"166\":1,\"352\":1,\"359\":2,\"364\":2,\"375\":2,\"377\":1,\"408\":4,\"418\":1,\"419\":1,\"457\":1,\"527\":3,\"591\":1,\"594\":1,\"605\":1,\"606\":1,\"607\":1,\"708\":1,\"709\":3,\"715\":1,\"737\":1,\"751\":1,\"812\":1,\"825\":2,\"826\":2,\"828\":3,\"829\":1,\"839\":1,\"844\":1,\"916\":1,\"1022\":2,\"1084\":2,\"1100\":1,\"1167\":1,\"1211\":1,\"1216\":1,\"1217\":1,\"1238\":1,\"1285\":2,\"1298\":1,\"1355\":1,\"1388\":1,\"1393\":1,\"1394\":1,\"1411\":1}}],[\"65001\",{\"1\":{\"824\":1}}],[\"655\",{\"1\":{\"762\":1,\"865\":1}}],[\"65535\",{\"1\":{\"106\":1}}],[\"654321\",{\"1\":{\"757\":1}}],[\"65\",{\"1\":{\"106\":1,\"375\":5,\"377\":2}}],[\"605\",{\"1\":{\"865\":2}}],[\"60042\",{\"1\":{\"864\":1}}],[\"60766742a4e3\",{\"1\":{\"177\":1}}],[\"60s=\",{\"1\":{\"134\":1}}],[\"60s\",{\"1\":{\"134\":1}}],[\"6060\",{\"1\":{\"106\":1}}],[\"60\",{\"1\":{\"106\":2,\"270\":1,\"387\":2,\"388\":2}}],[\"6内核下开启文件打开数为65535\",{\"1\":{\"106\":1}}],[\"总体来说\",{\"1\":{\"1018\":1}}],[\"总体框架图\",{\"1\":{\"881\":1}}],[\"总之\",{\"1\":{\"922\":1,\"998\":1}}],[\"总之理论总是与代码不匹配\",{\"1\":{\"692\":1}}],[\"总报错误\",{\"1\":{\"800\":1}}],[\"总是以相同的顺序来申请锁\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"总是假设会发生并发冲突\",{\"1\":{\"1018\":1}}],[\"总是复习的没考\",{\"1\":{\"920\":1}}],[\"总是等于\",{\"1\":{\"624\":1}}],[\"总是打开一个窗口\",{\"1\":{\"77\":1}}],[\"总的来说\",{\"1\":{\"483\":1,\"503\":1}}],[\"总的来说不要让你的程序在黑盒总运行\",{\"1\":{\"201\":1}}],[\"总的时间长度就是2\",{\"1\":{\"157\":1}}],[\"总的时间长度就是\",{\"1\":{\"157\":1}}],[\"总结如下\",{\"1\":{\"988\":1}}],[\"总结得很全面\",{\"1\":{\"954\":1}}],[\"总结来说使用锁机制时\",{\"1\":{\"1018\":1}}],[\"总结来说\",{\"1\":{\"922\":1}}],[\"总结一下hashmap的优势\",{\"1\":{\"922\":1}}],[\"总结一下\",{\"1\":{\"440\":1,\"988\":1}}],[\"总结\",{\"0\":{\"275\":1,\"520\":1,\"567\":1},\"1\":{\"166\":1,\"561\":1}}],[\"总共会抓10帧\",{\"1\":{\"141\":1}}],[\"总并发量达到3\",{\"1\":{\"106\":1}}],[\"数量发生变化\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"数量为\",{\"1\":{\"604\":2}}],[\"数量占表中总页数的很大一部分\",{\"1\":{\"574\":1}}],[\"数量限制\",{\"1\":{\"496\":1}}],[\"数量在创建索引时指定\",{\"1\":{\"422\":1}}],[\"数字和日期的format\",{\"1\":{\"819\":1}}],[\"数字类型的字段在满足需求的前提下应当尽量选择范围较小的数据类型\",{\"1\":{\"444\":1}}],[\"数字类型分为\",{\"1\":{\"444\":1}}],[\"数字类型\",{\"0\":{\"444\":1},\"1\":{\"442\":1}}],[\"数字\",{\"1\":{\"429\":1}}],[\"数字中排序\",{\"1\":{\"347\":1}}],[\"数列就变成一个有序序列\",{\"1\":{\"374\":1}}],[\"数列遍历完毕时\",{\"1\":{\"359\":1}}],[\"数位较短的数前面补零\",{\"1\":{\"374\":1}}],[\"数组同一个位置上的元素数量是成泊松分布的\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"数组增删元素的效率比较低\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"数组拥有o\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"数组是final的\",{\"1\":{\"988\":1}}],[\"数组是主干\",{\"1\":{\"948\":1}}],[\"数组table\",{\"1\":{\"948\":1}}],[\"数组实现通过散列算法\",{\"1\":{\"922\":1}}],[\"数组和链表各自的优点可以满足这个要求\",{\"1\":{\"922\":1}}],[\"数组要求每个元素大大小相同\",{\"1\":{\"632\":1}}],[\"数组可以包含多个元素\",{\"1\":{\"628\":1}}],[\"数组中键值对的数量\",{\"1\":{\"928\":1}}],[\"数组中\",{\"1\":{\"658\":1}}],[\"数组中的每个项都是一个\",{\"1\":{\"624\":1}}],[\"数组中的每一个值\",{\"1\":{\"359\":1}}],[\"数组中未使用字节的数量\",{\"1\":{\"619\":1}}],[\"数组中已使用字节的数量\",{\"1\":{\"619\":1}}],[\"数组\",{\"1\":{\"451\":1,\"630\":1,\"922\":2}}],[\"数组order\",{\"1\":{\"377\":1}}],[\"数组的长度是2的幂次方\",{\"0\":{\"1123\":1,\"1318\":1}}],[\"数组的下标在\",{\"1\":{\"658\":1}}],[\"数组的每个单元只能存储\",{\"1\":{\"658\":1}}],[\"数组的优势占用一片\",{\"1\":{\"632\":1}}],[\"数组的第一维表示可能的余数0\",{\"1\":{\"377\":1}}],[\"数组的状态如下\",{\"1\":{\"359\":1}}],[\"数组下标从0到10\",{\"1\":{\"359\":1}}],[\"数组下标\",{\"1\":{\"359\":1}}],[\"数组里有20个随机数\",{\"1\":{\"359\":1}}],[\"数学之美\",{\"1\":{\"339\":1}}],[\"数学公式\",{\"1\":{\"335\":1}}],[\"数学推导\",{\"0\":{\"335\":1}}],[\"数和森林的遍历\",{\"0\":{\"314\":1}}],[\"数目\",{\"1\":{\"106\":1}}],[\"数据发布\",{\"1\":{\"1244\":2,\"1417\":2}}],[\"数据每更新一次\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"数据读写也是批量的而不是单条的\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"数据的复制\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"数据的同步\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"数据的物理存储位置可能分散\",{\"1\":{\"503\":1}}],[\"数据不丢失\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"数据不共享\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"数据不一致\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"数据还是老的\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"数据之前\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"数据在某个时间点过期时\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"数据在插入后\",{\"1\":{\"383\":1}}],[\"数据相对固定\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"数据命中不高\",{\"1\":{\"1047\":2,\"1256\":2}}],[\"数据更新的频率不高\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"数据转换等\",{\"1\":{\"1034\":1}}],[\"数据接收\",{\"1\":{\"1034\":1}}],[\"数据分析等领域都有广泛应用\",{\"1\":{\"1006\":1}}],[\"数据分布不均\",{\"1\":{\"501\":1}}],[\"数据分布和性能要求\",{\"1\":{\"498\":1}}],[\"数据可视化等各种场景\",{\"1\":{\"1002\":1}}],[\"数据可以从主服务器向任意数量的从服务器上同步\",{\"1\":{\"589\":1}}],[\"数据丢失等问题\",{\"1\":{\"988\":1}}],[\"数据也不会丢失\",{\"1\":{\"978\":1}}],[\"数据迁移和高可用性等方面的问题\",{\"1\":{\"968\":1}}],[\"数据被分成多个分片\",{\"1\":{\"968\":1}}],[\"数据同步完成\",{\"1\":{\"964\":1}}],[\"数据冗余\",{\"1\":{\"964\":1}}],[\"数据存放在内存中\",{\"1\":{\"962\":1}}],[\"数据存储结构\",{\"0\":{\"279\":1}}],[\"数据并渲染视图\",{\"1\":{\"956\":1}}],[\"数据访问等功能\",{\"1\":{\"950\":1}}],[\"数据全部使用相同hashcode\",{\"1\":{\"922\":1}}],[\"数据绑定\",{\"1\":{\"819\":1}}],[\"数据源\",{\"1\":{\"743\":2,\"745\":1,\"751\":1,\"1133\":1,\"1326\":1}}],[\"数据为多对多\",{\"1\":{\"723\":1}}],[\"数据都是缓存在内存中\",{\"1\":{\"589\":1}}],[\"数据一致性要求高\",{\"1\":{\"570\":1}}],[\"数据是按页存储的\",{\"1\":{\"561\":1}}],[\"数据路由问题后边介绍\",{\"1\":{\"520\":1}}],[\"数据量不大就用不上\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"数据量不大时\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"数据量大时候\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"数据量大的表\",{\"1\":{\"502\":1}}],[\"数据量小的表不需要建立索引\",{\"1\":{\"500\":1}}],[\"数据重复且分布平均的字短没必要建立索引\",{\"1\":{\"500\":1}}],[\"数据变更后索引也需要更新\",{\"1\":{\"500\":1}}],[\"数据维度\",{\"1\":{\"499\":1}}],[\"数据操作\",{\"0\":{\"469\":1}}],[\"数据写入直接出错\",{\"1\":{\"431\":1}}],[\"数据中心id\",{\"1\":{\"388\":2}}],[\"数据标识id向左移17位\",{\"1\":{\"388\":1}}],[\"数据标识id所占的位数\",{\"1\":{\"388\":1}}],[\"数据才能够继续向下走\",{\"1\":{\"334\":1}}],[\"数据先经过布隆过滤器\",{\"1\":{\"334\":1}}],[\"数据域\",{\"1\":{\"289\":1}}],[\"数据类型操作\",{\"1\":{\"593\":1}}],[\"数据类型\",{\"0\":{\"279\":1},\"1\":{\"342\":1}}],[\"数据逻辑结构\",{\"0\":{\"279\":1}}],[\"数据元素\",{\"0\":{\"279\":1}}],[\"数据\",{\"0\":{\"279\":1},\"1\":{\"1050\":2,\"1259\":2}}],[\"数据表中的数据都是存储在页中的\",{\"1\":{\"272\":1}}],[\"数据大小是固定的\",{\"1\":{\"270\":1}}],[\"数据遍布整个树结构\",{\"1\":{\"263\":1}}],[\"数据结构包括字符串\",{\"1\":{\"1198\":1,\"1378\":1}}],[\"数据结构并不会保存真实的元数据\",{\"1\":{\"659\":1}}],[\"数据结构来保存位数组\",{\"1\":{\"658\":1}}],[\"数据结构来理解\",{\"1\":{\"505\":1}}],[\"数据结构维度\",{\"1\":{\"495\":1}}],[\"数据结构和算法的基本概念\",{\"0\":{\"278\":1}}],[\"数据结构\",{\"0\":{\"258\":1},\"1\":{\"98\":1,\"100\":1,\"630\":1,\"659\":1,\"824\":1,\"940\":1,\"1047\":1,\"1256\":1},\"2\":{\"259\":1,\"260\":1,\"326\":1,\"327\":1,\"344\":1,\"354\":1,\"355\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"378\":1,\"379\":1,\"389\":1,\"390\":1}}],[\"数据库事务的提交和回滚是通过\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"数据库你用过吧\",{\"1\":{\"960\":1}}],[\"数据库更新策略\",{\"1\":{\"864\":1}}],[\"数据库配置\",{\"1\":{\"816\":1}}],[\"数据库连接池\",{\"1\":{\"815\":1}}],[\"数据库连接数\",{\"1\":{\"517\":1}}],[\"数据库脚本\",{\"1\":{\"795\":1}}],[\"数据库有两个一模一样的表\",{\"1\":{\"779\":1}}],[\"数据库结构\",{\"0\":{\"726\":1}}],[\"数据库的乐观锁和悲观锁是什么\",{\"0\":{\"1191\":1,\"1374\":1}}],[\"数据库的字段名是user\",{\"1\":{\"759\":1}}],[\"数据库的读写会有磁盘操作\",{\"1\":{\"616\":1}}],[\"数据库的完整性不被破坏\",{\"1\":{\"560\":1}}],[\"数据库锁\",{\"2\":{\"583\":1}}],[\"数据库管理系统通常有机制来检测和解决死锁\",{\"1\":{\"581\":1}}],[\"数据库中的每个键值对的键和值都是一个对象\",{\"1\":{\"636\":1}}],[\"数据库中的数据量猛增\",{\"1\":{\"515\":1}}],[\"数据库中数据的存储单位\",{\"1\":{\"574\":1}}],[\"数据库系统可能会认为整个表都被锁定了\",{\"1\":{\"574\":1}}],[\"数据库系统可能会将这些行锁升级为表锁\",{\"1\":{\"574\":1}}],[\"数据库系统会自动处理这些锁定\",{\"1\":{\"560\":1}}],[\"数据库系统不仅需要更新数据本身\",{\"1\":{\"508\":1}}],[\"数据库13问\",{\"0\":{\"551\":1},\"1\":{\"551\":1}}],[\"数据库以行为单位将数据加载到内存中\",{\"1\":{\"516\":1}}],[\"数据库操作经常涉及磁盘i\",{\"1\":{\"503\":1}}],[\"数据库自增id的缺点是数据在插入前\",{\"1\":{\"383\":1}}],[\"数据库自增\",{\"0\":{\"383\":1},\"1\":{\"383\":1}}],[\"数据库请求出错\",{\"1\":{\"186\":1}}],[\"数据库错误\",{\"1\":{\"186\":1}}],[\"数据库都是非常重要的\",{\"1\":{\"100\":1}}],[\"数据库\",{\"0\":{\"12\":1,\"74\":1},\"1\":{\"98\":1,\"100\":1,\"506\":1,\"812\":1,\"960\":1},\"2\":{\"13\":1}}],[\"简洁\",{\"1\":{\"1444\":1}}],[\"简而言之\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"简少了\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"简直是必备利器\",{\"1\":{\"998\":1}}],[\"简称rr\",{\"1\":{\"575\":1}}],[\"简称\",{\"1\":{\"557\":2,\"559\":1,\"1187\":1,\"1370\":1}}],[\"简化web应用的开发\",{\"1\":{\"1229\":1,\"1404\":1}}],[\"简化了lucene的使用和管理\",{\"1\":{\"1000\":1}}],[\"简化构建过程\",{\"1\":{\"950\":1}}],[\"简化代码\",{\"1\":{\"825\":2}}],[\"简化配置\",{\"1\":{\"819\":1,\"1225\":1,\"1400\":1}}],[\"简化的编程模式\",{\"1\":{\"645\":1}}],[\"简化\",{\"1\":{\"269\":1}}],[\"简历作为找工作的第一块敲门砖\",{\"1\":{\"211\":1}}],[\"简历优化\",{\"1\":{\"211\":1}}],[\"简历修改\",{\"1\":{\"49\":1}}],[\"简单工厂模式的本质就是一个工厂类根据传入的参数\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"简单工厂模式\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"简单实现登录拦截逻辑\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"简单理解\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"简单而强大的线程模型\",{\"1\":{\"1032\":1}}],[\"简单易用\",{\"1\":{\"960\":1}}],[\"简单介绍下\",{\"1\":{\"1018\":1}}],[\"简单介绍下map这个接口及常用实现类\",{\"1\":{\"948\":1}}],[\"简单介绍下list这个接口及常用实现类吧\",{\"1\":{\"946\":1}}],[\"简单介绍一下常用指令\",{\"1\":{\"127\":1}}],[\"简单说一下吧\",{\"1\":{\"1033\":1}}],[\"简单说一下\",{\"1\":{\"922\":1}}],[\"简单说明\",{\"0\":{\"127\":1}}],[\"简单倒排索引实例\",{\"0\":{\"425\":1}}],[\"简单可以理解为\",{\"1\":{\"383\":1}}],[\"简单用公式描述一下就是\",{\"1\":{\"364\":1}}],[\"简单明了\",{\"1\":{\"176\":1}}],[\"简单的说\",{\"1\":{\"135\":1}}],[\"简单来说就是当该节点下面没有子节点的话\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"简单来说就是把复杂系统分解成相互合作的对象\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"简单来说就是快照保存\",{\"1\":{\"962\":1}}],[\"简单来说就是创建一个集合\",{\"1\":{\"647\":1}}],[\"简单来说\",{\"1\":{\"134\":1,\"330\":1,\"401\":1,\"483\":1,\"562\":1,\"919\":1,\"994\":1,\"998\":1,\"1077\":2,\"1088\":1,\"1101\":1,\"1104\":1,\"1281\":2,\"1289\":1,\"1299\":1,\"1302\":1}}],[\"简介\",{\"0\":{\"122\":1,\"882\":1}}],[\"简述\",{\"1\":{\"104\":1}}],[\"也允许开发者根据实际情况自定义相关配置\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"也允许满足某些使用场景的需要\",{\"1\":{\"966\":1}}],[\"也称作被通知\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"也称为内部锁或互斥锁\",{\"1\":{\"1022\":1}}],[\"也称为\",{\"1\":{\"143\":1}}],[\"也记录一些警告信息或者正确的信息\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"也没有注册\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"也没有具体的类型边界\",{\"1\":{\"966\":1}}],[\"也就丢失了\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"也就是工友们一块审核代码规范\",{\"1\":{\"1439\":1}}],[\"也就是项目的公共模块\",{\"1\":{\"1439\":1}}],[\"也就是案例中的\",{\"1\":{\"1431\":1}}],[\"也就是注入这个bean依赖的其它bean对象\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"也就是ioc容器\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"也就是单机部署\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"也就是布隆过滤器的原理\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"也就是不存在的数据\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"也就是不能被覆盖重写\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"也就是可能最终不会存到数据库中\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"也就是直接将数据从内核空间的读缓冲区直接拷贝到内核空间的\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"也就是字节码\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"也就是通过等待\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"也就是一个请求一个线程\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"也就是一些正能量的综合性文章\",{\"1\":{\"225\":1}}],[\"也就是cgroup\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"也就是下次缓存读取时\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"也就是下面的6结点\",{\"1\":{\"364\":1}}],[\"也就是边改边实时预览\",{\"1\":{\"912\":1}}],[\"也就是网站的首页\",{\"1\":{\"911\":1}}],[\"也就是我们常说的\",{\"1\":{\"1027\":1}}],[\"也就是我们的网站在进入后首先加载的文件\",{\"1\":{\"911\":1}}],[\"也就是我们网站的内核\",{\"1\":{\"910\":1}}],[\"也就是我们要在网页上展示的内容\",{\"1\":{\"910\":1}}],[\"也就是我们在使用联合索引时\",{\"1\":{\"501\":1}}],[\"也就是\",{\"1\":{\"831\":1,\"958\":2,\"1049\":1,\"1072\":1,\"1258\":1,\"1276\":1}}],[\"也就是上面说到的例子\",{\"1\":{\"556\":1}}],[\"也就是在目标方法开始之前启动一个事务\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"也就是在\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"也就是在主键字段建立聚簇索引\",{\"1\":{\"495\":1}}],[\"也就是在这个时间诞生了\",{\"1\":{\"225\":1}}],[\"也就是合约初始化时调用的函数\",{\"1\":{\"488\":1}}],[\"也就是这个字段可以被搜索\",{\"1\":{\"431\":1}}],[\"也就是说vector在并发环境下是线程安全的\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"也就是说一个类如果是final的\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"也就是说这个类不能被继承\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"也就是说如果你的from是10\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"也就是说它是线程安全的\",{\"1\":{\"1018\":1}}],[\"也就是说\",{\"1\":{\"712\":1,\"1099\":1,\"1145\":1,\"1297\":1,\"1336\":1}}],[\"也就是说我们在主线程设置的\",{\"1\":{\"692\":1}}],[\"也就是说41位可以表示\",{\"1\":{\"387\":1}}],[\"也就是说每个ticktime时间就会发送一个心跳\",{\"1\":{\"157\":1}}],[\"也就是元素到桶的映射规则\",{\"1\":{\"350\":1}}],[\"也就是根据元素值特性将集合拆分为多个区域\",{\"1\":{\"348\":1}}],[\"也就是接口的\",{\"1\":{\"177\":1}}],[\"也就是ticktime\",{\"1\":{\"157\":1}}],[\"也就是操作系统页面大小的两倍\",{\"1\":{\"106\":1}}],[\"也就是你看到这篇文章的网站\",{\"1\":{\"97\":1}}],[\"也应该返回true\",{\"1\":{\"1087\":2,\"1288\":2}}],[\"也许最来的层会依赖它\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"也挂掉的情况\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"也打挂了\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"也减小\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"也让我对你的能力有了更高的评价\",{\"1\":{\"1018\":1}}],[\"也能帮助到你的读者\",{\"1\":{\"1012\":1}}],[\"也能拿出去吹\",{\"1\":{\"226\":1}}],[\"也不想去查接口文档\",{\"1\":{\"1431\":1}}],[\"也不是线程安全的\",{\"1\":{\"988\":1}}],[\"也不会将\",{\"1\":{\"924\":1}}],[\"也不会影响性能\",{\"1\":{\"922\":1}}],[\"也对泛型有了更深刻的理解\",{\"1\":{\"966\":1}}],[\"也为后续的命令传播阶段奠定基础\",{\"1\":{\"964\":1}}],[\"也兼顾了效率\",{\"1\":{\"962\":1}}],[\"也很期待加入贵团队一起成长\",{\"1\":{\"958\":1}}],[\"也难以维护\",{\"1\":{\"954\":1}}],[\"也直接或间接依赖\",{\"1\":{\"954\":1}}],[\"也支持通过\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"也支持延迟加载\",{\"1\":{\"952\":1}}],[\"也支持push方式\",{\"1\":{\"883\":1}}],[\"也祝面试官心想事成\",{\"1\":{\"934\":1}}],[\"也清楚自己的不足和需要努力的方向\",{\"1\":{\"922\":1}}],[\"也叫做mapper\",{\"1\":{\"772\":1}}],[\"也有很大用途\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"也有利于安全性\",{\"1\":{\"934\":1}}],[\"也有clean阶段\",{\"1\":{\"712\":1}}],[\"也有可能正好hash值对应的\",{\"1\":{\"333\":1,\"339\":1}}],[\"也即本地下载的jar存放路径\",{\"1\":{\"702\":1}}],[\"也提供了灵活的键淘汰策略\",{\"1\":{\"594\":1}}],[\"也可能存在因为网络等原因导致写入副本失败\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"也可能是t的子类型\",{\"1\":{\"966\":1}}],[\"也可能触发锁升级\",{\"1\":{\"574\":1}}],[\"也可以丰富我们的简历\",{\"1\":{\"1429\":1}}],[\"也可以是基本数据类型和\",{\"1\":{\"1179\":2,\"1364\":2}}],[\"也可以是点\",{\"1\":{\"454\":1}}],[\"也可以通过设置搜索请求参数\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"也可以克隆基于docker的俩万\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"也可以将kafka作为长期的存储系统来使用\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"也可以将\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"也可以对性能进行优化\",{\"1\":{\"980\":1}}],[\"也可以手动触发system\",{\"1\":{\"936\":1}}],[\"也可以解决冲突\",{\"1\":{\"922\":1}}],[\"也可以应对散列算法产生碰撞的情况\",{\"1\":{\"922\":1}}],[\"也可以写成\",{\"1\":{\"918\":1}}],[\"也可以在这里配置过滤器\",{\"1\":{\"820\":1}}],[\"也可以使用分页插件来完成物理分页\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"也可以使用插件机制\",{\"1\":{\"770\":1}}],[\"也可以使用第三方分词器插件\",{\"1\":{\"411\":1}}],[\"也可以用于\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"也可以用于精确查询\",{\"1\":{\"443\":1}}],[\"也可以用包名的方式达到相同的效果\",{\"1\":{\"689\":1}}],[\"也可以切某个\",{\"1\":{\"689\":1}}],[\"也可以再次调用这个命令来改变超时时间\",{\"1\":{\"603\":1}}],[\"也可以说是java提供的原子性内置锁机制\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"也可以说是后端服务器处理请求的时间\",{\"1\":{\"106\":1}}],[\"也可以说一个\",{\"1\":{\"429\":1}}],[\"也可以选择不包含这个信息\",{\"1\":{\"425\":1}}],[\"也可以催更\",{\"1\":{\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"368\":1,\"377\":1,\"587\":1,\"613\":1,\"648\":1,\"698\":1,\"732\":1}}],[\"也可以防止后续扯皮\",{\"1\":{\"175\":1}}],[\"也可以实现集群的负载均衡\",{\"1\":{\"165\":1}}],[\"也可以转为其他格式\",{\"1\":{\"132\":1}}],[\"也可以放在\",{\"1\":{\"106\":1}}],[\"也要可以的\",{\"1\":{\"916\":1}}],[\"也要创建一个同样保存了整数值\",{\"1\":{\"635\":1}}],[\"也要慎用\",{\"0\":{\"529\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"也要多刷提到的\",{\"1\":{\"101\":1}}],[\"也需要扎实的基础才能玩转\",{\"1\":{\"522\":1}}],[\"也需要考虑以下因素\",{\"1\":{\"502\":1}}],[\"也需要这样的协调者\",{\"1\":{\"153\":1}}],[\"也会出现在软件系统的各模块之间\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"也会导致全表扫描\",{\"1\":{\"1192\":1,\"1375\":1}}],[\"也会触发一次full\",{\"1\":{\"930\":1}}],[\"也会全表扫描\",{\"1\":{\"501\":1}}],[\"也会有直播回看的哦\",{\"1\":{\"211\":1}}],[\"也同时被更新\",{\"1\":{\"431\":1}}],[\"也被称为0拷贝技术\",{\"1\":{\"403\":1}}],[\"也基本满足需求\",{\"1\":{\"383\":1}}],[\"也是接口对外提供的业务数据\",{\"1\":{\"1431\":1}}],[\"也是必要的\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"也是经过多个哨兵确认后\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"也是垃圾回收的主要区域\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"也是可以避免死锁的\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"也是很重要的内容\",{\"1\":{\"1018\":1}}],[\"也是日常开发中最常用的\",{\"1\":{\"946\":1}}],[\"也是官方推荐的使用方式\",{\"1\":{\"764\":1}}],[\"也是并发场景下必问的问题\",{\"1\":{\"552\":1}}],[\"也是最常用的\",{\"1\":{\"506\":1}}],[\"也是无法走索引的\",{\"1\":{\"501\":1}}],[\"也是一种多路搜索树\",{\"1\":{\"269\":1}}],[\"也是我们团队间协作沟通\",{\"1\":{\"190\":1}}],[\"也是1\",{\"1\":{\"134\":1}}],[\"全部对象的控制权全部上缴给\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"全部查找\",{\"1\":{\"94\":1}}],[\"全称\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"全称叫\",{\"1\":{\"422\":1}}],[\"全表扫描是否比索引更快\",{\"1\":{\"527\":1}}],[\"全表扫描效率更优\",{\"1\":{\"501\":1}}],[\"全文索引\",{\"1\":{\"1189\":1,\"1372\":1}}],[\"全文索引也有一些限制\",{\"1\":{\"507\":1}}],[\"全文索引一般用于内容管理平台\",{\"1\":{\"507\":1}}],[\"全文索引是一种建立倒排索引\",{\"1\":{\"495\":1}}],[\"全功能的搜索引擎库\",{\"1\":{\"400\":1}}],[\"全局总开关\",{\"1\":{\"790\":1}}],[\"全局的配置文件\",{\"1\":{\"751\":1}}],[\"全局配置文件mybatis\",{\"1\":{\"763\":1}}],[\"全局配置文件\",{\"0\":{\"743\":1}}],[\"全局唯一且不重复的id\",{\"1\":{\"382\":1}}],[\"全局唯一\",{\"1\":{\"381\":2}}],[\"全局日志定义类型\",{\"1\":{\"106\":1}}],[\"全栈工程师\",{\"1\":{\"223\":1}}],[\"全干开发工程师\",{\"1\":{\"217\":1}}],[\"全站工程师在哪儿都是稀缺的\",{\"1\":{\"101\":1}}],[\"地完成的\",{\"1\":{\"625\":1}}],[\"地理位置搜索等高级功能\",{\"1\":{\"998\":1}}],[\"地理空间\",{\"1\":{\"601\":1}}],[\"地理区域类型\",{\"0\":{\"454\":1}}],[\"地理类型字段分为两种\",{\"1\":{\"452\":1}}],[\"地理类型\",{\"0\":{\"452\":1}}],[\"地理类型以及特殊类型\",{\"1\":{\"441\":1}}],[\"地动山摇\",{\"1\":{\"100\":1}}],[\"地址生成\",{\"1\":{\"385\":1}}],[\"地址\",{\"1\":{\"4\":1,\"97\":1,\"456\":1,\"648\":1,\"1030\":1,\"1062\":1,\"1268\":1}}],[\"等注解\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"等集合类型\",{\"1\":{\"1179\":2,\"1364\":2}}],[\"等集合时\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"等方法时\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"等属性\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"等到另一个线程结束\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"等繁杂的过程\",{\"1\":{\"958\":1}}],[\"等事务管理\",{\"1\":{\"950\":1}}],[\"等标签不会被解析\",{\"1\":{\"801\":1}}],[\"等同于\",{\"1\":{\"712\":1}}],[\"等待业务正常处理完成后\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"等待cpu的使用权\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"等待了很长时间以后\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"等待可中断\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"等待可用连接最大的等待时间\",{\"1\":{\"648\":1}}],[\"等待家庭成员到齐才能开饭\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"等待其他一组线程完成操作\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"等待通知机制是基于wait和notify方法来实现的\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"等待名单\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"等待该条件的线程将被唤醒\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"等待一定的时间之后\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"等待划分时间片\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"等待被线程调度选中\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"等待队列\",{\"1\":{\"1023\":1}}],[\"等待队列的条件变量\",{\"1\":{\"1023\":1}}],[\"等待队列尾指针偏移量\",{\"1\":{\"1023\":1}}],[\"等待队列尾指针\",{\"1\":{\"1023\":1}}],[\"等待队列头指针偏移量\",{\"1\":{\"1023\":1}}],[\"等待队列头指针\",{\"1\":{\"1023\":1}}],[\"等待队列长度偏移量\",{\"1\":{\"1023\":1}}],[\"等待队列长度\",{\"1\":{\"1023\":1}}],[\"等待选主结果\",{\"1\":{\"1008\":1}}],[\"等待确认和不等待确认有什么区别呢\",{\"1\":{\"994\":1}}],[\"等待\",{\"1\":{\"988\":2,\"1008\":1,\"1100\":1,\"1102\":1,\"1298\":1,\"1300\":1}}],[\"等待线程就会被唤醒\",{\"1\":{\"932\":4}}],[\"等待下一个任务的分配\",{\"1\":{\"926\":1}}],[\"等待下载好\",{\"1\":{\"898\":1}}],[\"等待安装好\",{\"1\":{\"898\":1}}],[\"等待信息同步完成\",{\"1\":{\"153\":1}}],[\"等等外部工具\",{\"1\":{\"844\":1}}],[\"等等\",{\"1\":{\"622\":1,\"628\":1,\"944\":1,\"960\":1,\"1032\":1}}],[\"等流行的消息队列中间件\",{\"1\":{\"594\":1}}],[\"等内存数据库为中心的\",{\"1\":{\"594\":1}}],[\"等数据结构的存储\",{\"1\":{\"592\":1}}],[\"等于\",{\"1\":{\"571\":2,\"619\":1}}],[\"等你\",{\"1\":{\"328\":1}}],[\"等你哦\",{\"1\":{\"150\":1,\"698\":1,\"732\":1}}],[\"等候后端服务器响应时间\",{\"1\":{\"106\":1}}],[\"等\",{\"1\":{\"98\":1,\"100\":1,\"183\":1,\"192\":1,\"411\":1,\"429\":1,\"950\":4,\"954\":1,\"1022\":1,\"1092\":1,\"1113\":1,\"1225\":1,\"1241\":1,\"1293\":1,\"1308\":1,\"1400\":1,\"1414\":1}}],[\"要对哪些join\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"要指定xml映射文件里面的\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"要让类对象进行比较有意义\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"要优先使用拦截器\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"要理解这两种机制的表象\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"要了解sleep和wait\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"要么通过构造方法赋值\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"要么使用直接赋值\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"要么就是长度比较短的字符串\",{\"1\":{\"633\":2}}],[\"要记住需要传递信息给协调节点的每个分片必须先创建一个\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"要是有人利用不存在的\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"要考虑清楚版本号的更新策略\",{\"1\":{\"1018\":1}}],[\"要考虑到\",{\"1\":{\"527\":1}}],[\"要根据实际需求选择合适的确认级别\",{\"1\":{\"994\":1}}],[\"要根据薄弱点来学习\",{\"1\":{\"100\":1}}],[\"要时刻考虑对象或方法的状态是否在多线程下也能保持一致和正确\",{\"1\":{\"988\":1}}],[\"要确保从kafka中获取的信息是准确的\",{\"1\":{\"984\":1}}],[\"要消费kafka中的消息\",{\"1\":{\"984\":1}}],[\"要从kafka中获取准确的信息\",{\"1\":{\"984\":1}}],[\"要全面理解\",{\"1\":{\"952\":1}}],[\"要保证高效的增删改查操作\",{\"1\":{\"922\":1}}],[\"要保证防火墙对应端口开放\",{\"1\":{\"675\":1}}],[\"要加入的\",{\"1\":{\"837\":1}}],[\"要处理异常\",{\"1\":{\"831\":1}}],[\"要先于catch\",{\"1\":{\"830\":1}}],[\"要视情况而定\",{\"1\":{\"537\":1}}],[\"要正确使用最左匹配\",{\"1\":{\"501\":1}}],[\"要求下班前完成\",{\"1\":{\"916\":1}}],[\"要求id和mapper接口中的方法的名字一致\",{\"1\":{\"775\":1}}],[\"要求mapper\",{\"1\":{\"772\":1}}],[\"要求必须有聚簇索引\",{\"1\":{\"495\":1}}],[\"要求用最快的速度把这20个整数从小到大进行排序\",{\"1\":{\"359\":1}}],[\"要尽量减少磁盘i\",{\"1\":{\"274\":1}}],[\"要使用clone方法\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"要使用\",{\"0\":{\"194\":1}}],[\"要使用此布局\",{\"1\":{\"6\":1}}],[\"要打印函数的入参\",{\"0\":{\"192\":1}}],[\"要选择合适的等级打印\",{\"1\":{\"191\":1}}],[\"要设置\",{\"1\":{\"183\":1}}],[\"要写清楚请求头信息\",{\"1\":{\"183\":1}}],[\"要明确记录\",{\"1\":{\"182\":1}}],[\"要怎么开始学\",{\"0\":{\"98\":1}}],[\"答\",{\"1\":{\"97\":1,\"98\":1}}],[\"问我们提到了分区再分配\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"问答社区等检索场景\",{\"1\":{\"507\":1}}],[\"问就是\",{\"1\":{\"121\":1}}],[\"问题\",{\"1\":{\"772\":1,\"938\":1,\"1018\":1,\"1165\":2,\"1353\":2}}],[\"问题出现了\",{\"1\":{\"692\":1}}],[\"问题二\",{\"1\":{\"364\":1}}],[\"问题就出现了\",{\"1\":{\"106\":1}}],[\"问题2\",{\"0\":{\"98\":1},\"1\":{\"1164\":1,\"1352\":1}}],[\"问题1\",{\"0\":{\"97\":1},\"1\":{\"1164\":1,\"1352\":1}}],[\"问最多的问题\",{\"1\":{\"96\":1}}],[\"必然会出现牵一发而动全身的情形\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"必要时采用悲观锁避免问题进一步扩大\",{\"1\":{\"1018\":1}}],[\"必须为接口的全路径名\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"必须为引用类型\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"必须等到sqlsession关闭了以后\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"必须等待一个线程的run\",{\"1\":{\"1098\":1,\"1296\":1}}],[\"必须按照申请的时间顺序来依次获得锁\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"必须保证类当中所有重载的构造方法都最终会对\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"必须二者选其一\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"必须是\",{\"1\":{\"966\":2}}],[\"必须是2的n次方\",{\"1\":{\"948\":1}}],[\"必须是mapper接口的全路径\",{\"1\":{\"763\":1}}],[\"必须早于提交\",{\"1\":{\"917\":1}}],[\"必须手动关闭引擎\",{\"1\":{\"864\":1}}],[\"必须序列化\",{\"1\":{\"790\":1}}],[\"必须属性\",{\"1\":{\"777\":1,\"778\":1}}],[\"必须\",{\"1\":{\"775\":2}}],[\"必须使用注解方式\",{\"1\":{\"772\":1}}],[\"必须使用$\",{\"1\":{\"763\":1}}],[\"必须使用64位long型\",{\"1\":{\"382\":1}}],[\"必须进行日志级别开关\",{\"1\":{\"195\":1}}],[\"必须进行日志级别开关判断\",{\"0\":{\"195\":1}}],[\"必须设为on\",{\"1\":{\"106\":1}}],[\"必看\",{\"0\":{\"95\":1}}],[\"必应收录\",{\"1\":{\"4\":1}}],[\"znode\",{\"1\":{\"1244\":3,\"1417\":3}}],[\"zndxall\",{\"1\":{\"919\":1}}],[\"zab是在paxos的基础上改进和演变过来的\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"zab\",{\"0\":{\"1243\":1,\"1416\":1},\"1\":{\"1243\":3,\"1416\":3}}],[\"zab协议包括两种基本的模式\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"zab协议是为分布式协调服务zookeeper专门设计的一种支持崩溃恢复的原子广播协议\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"zadd\",{\"1\":{\"607\":1,\"657\":1}}],[\"zgc等高性能收集器\",{\"1\":{\"942\":1}}],[\"zgc\",{\"1\":{\"938\":1}}],[\"zpc\",{\"1\":{\"736\":1,\"744\":1,\"747\":1,\"753\":1,\"754\":2,\"755\":5,\"757\":3,\"759\":1,\"762\":4,\"763\":9,\"768\":3,\"772\":1,\"779\":7,\"780\":2,\"782\":1,\"784\":1,\"785\":1,\"786\":2,\"787\":1,\"789\":18,\"790\":6,\"793\":4,\"794\":3,\"795\":4}}],[\"zunionstore\",{\"1\":{\"607\":1}}],[\"zrevrank\",{\"1\":{\"607\":1}}],[\"zrevrangebyscore\",{\"1\":{\"607\":1}}],[\"zrevrange\",{\"1\":{\"607\":1,\"657\":1}}],[\"zremrangebyscore\",{\"1\":{\"607\":1}}],[\"zremrangebyrank\",{\"1\":{\"607\":1}}],[\"zremrangebylex\",{\"1\":{\"607\":1}}],[\"zrem\",{\"1\":{\"607\":1}}],[\"zrank\",{\"1\":{\"607\":1,\"657\":1}}],[\"zrangebyscore\",{\"1\":{\"607\":1}}],[\"zrangebylex\",{\"1\":{\"607\":1}}],[\"zrange\",{\"1\":{\"607\":1}}],[\"zlexcount\",{\"1\":{\"607\":1}}],[\"zinterstore\",{\"1\":{\"607\":1}}],[\"zincrby\",{\"1\":{\"607\":1}}],[\"zip1ist\",{\"1\":{\"633\":1}}],[\"zip压缩包到\",{\"1\":{\"597\":1}}],[\"zip\",{\"1\":{\"90\":1,\"94\":4,\"412\":1,\"413\":1,\"701\":1}}],[\"zcount\",{\"1\":{\"607\":1}}],[\"zcard\",{\"1\":{\"607\":1}}],[\"zcvf\",{\"1\":{\"94\":1}}],[\"zskiplistlevel\",{\"1\":{\"628\":1}}],[\"zskiplist\",{\"1\":{\"628\":2,\"629\":2}}],[\"zskiplistnode\",{\"1\":{\"628\":7,\"629\":2}}],[\"zscan\",{\"1\":{\"607\":1}}],[\"zscore\",{\"1\":{\"607\":1}}],[\"zset内部元素也可以使用整数对象池\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"zset\",{\"1\":{\"589\":1,\"592\":1,\"1198\":1,\"1378\":1}}],[\"zsxq\",{\"1\":{\"212\":1}}],[\"zendiscovery\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"zen\",{\"1\":{\"406\":1,\"1070\":1,\"1074\":1,\"1274\":1,\"1278\":1}}],[\"zerofill\",{\"1\":{\"795\":1}}],[\"zero\",{\"1\":{\"106\":1}}],[\"z\",{\"1\":{\"333\":1,\"339\":1,\"1087\":2,\"1288\":2}}],[\"zk遵循的是cp原则\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"zk\",{\"0\":{\"1238\":1,\"1411\":1},\"1\":{\"1165\":1,\"1353\":1}}],[\"zkenv\",{\"1\":{\"159\":2}}],[\"zkcli\",{\"1\":{\"159\":3}}],[\"zkcleanup\",{\"1\":{\"159\":1}}],[\"zkserver\",{\"1\":{\"158\":4,\"159\":2}}],[\"zxing<\",{\"1\":{\"874\":2}}],[\"zxid比较大的服务器优先作为leader\",{\"1\":{\"166\":1}}],[\"zxid\",{\"1\":{\"166\":3}}],[\"zxf\",{\"1\":{\"157\":1}}],[\"zxvf\",{\"1\":{\"94\":1,\"405\":1,\"408\":1,\"672\":1}}],[\"zoodefs\",{\"1\":{\"1008\":1}}],[\"zoo\",{\"1\":{\"157\":2,\"158\":1}}],[\"zookeeper以fast\",{\"1\":{\"1246\":1,\"1419\":1}}],[\"zookeeper=文件系统+通知机制\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"zookeeper就将负责通知已经在zookeeper上注册的那些观察者做出反应\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"zookeeper就是其中的佼佼者\",{\"1\":{\"153\":1}}],[\"zookeeper负载过重\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"zookeeper会根据接收到的节点信息来选择主节点\",{\"1\":{\"1008\":1}}],[\"zookeeper会自动选举一个新的leader副本\",{\"1\":{\"986\":1}}],[\"zookeeper会监听这个端口接受客户端的访问请求\",{\"1\":{\"157\":1}}],[\"zookeeper客户端连接指令\",{\"1\":{\"159\":1}}],[\"zookeeper的角色\",{\"1\":{\"1008\":1}}],[\"zookeeper的状态存储位置\",{\"1\":{\"157\":1}}],[\"zookeeper的目标就是封装好复杂易出错的关键服务\",{\"1\":{\"154\":1}}],[\"zookeeper整体架构\",{\"0\":{\"155\":1},\"1\":{\"155\":1}}],[\"zookeeper代码版本中\",{\"1\":{\"154\":1}}],[\"zookeeper包含一个简单的原语集\",{\"1\":{\"154\":1}}],[\"zookeeper是cp还是ap\",{\"0\":{\"1240\":1,\"1413\":1}}],[\"zookeeper是一个分布式协调服务\",{\"1\":{\"1008\":1}}],[\"zookeeper是一个分布式的\",{\"1\":{\"154\":1}}],[\"zookeeper是一个功能非常强大的应用\",{\"1\":{\"165\":1}}],[\"zookeeper是解压包\",{\"1\":{\"157\":1}}],[\"zookeeper是分布式应用程序的分布式协调服务\",{\"1\":{\"152\":1}}],[\"zookeeper介绍\",{\"0\":{\"154\":1}}],[\"zookeeper能完美解决分布式协调服务这个问题\",{\"1\":{\"153\":1}}],[\"zookeeperover\",{\"1\":{\"152\":1}}],[\"zookeeper\",{\"0\":{\"1236\":1,\"1237\":1,\"1239\":1,\"1241\":1,\"1244\":1,\"1409\":1,\"1410\":1,\"1412\":1,\"1414\":1,\"1417\":1},\"1\":{\"152\":4,\"157\":7,\"158\":2,\"159\":2,\"524\":1,\"1008\":5,\"1159\":2,\"1166\":2,\"1236\":3,\"1237\":3,\"1238\":2,\"1242\":1,\"1243\":4,\"1244\":4,\"1245\":3,\"1347\":2,\"1354\":2,\"1410\":3,\"1411\":2,\"1415\":1,\"1416\":4,\"1417\":4,\"1418\":3},\"2\":{\"1248\":1}}],[\"zookeeper简介\",{\"0\":{\"152\":1}}],[\"zone\",{\"1\":{\"106\":1}}],[\"zhang\",{\"1\":{\"434\":2}}],[\"zhihu\",{\"1\":{\"110\":1,\"251\":1,\"1105\":1,\"1303\":1}}],[\"zhuanlan\",{\"1\":{\"110\":1,\"251\":1,\"1105\":1,\"1303\":1}}],[\"删除和更新也都是写操作\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"删除和更新操作的维护成本\",{\"1\":{\"502\":1}}],[\"删除镜像\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"删除工作空间改动代码\",{\"1\":{\"918\":1}}],[\"删除所有缓存的stash\",{\"1\":{\"916\":1}}],[\"删除一个或多个哈希表字段\",{\"1\":{\"605\":1}}],[\"删除记录以释放锁\",{\"1\":{\"577\":1}}],[\"删除索引\",{\"0\":{\"467\":1}}],[\"删除临时索引\",{\"1\":{\"438\":1}}],[\"删除的statement\",{\"1\":{\"763\":1}}],[\"删除的元素\",{\"1\":{\"285\":1}}],[\"删除的位置\",{\"1\":{\"284\":1,\"285\":1}}],[\"删除元素的过程称为出队\",{\"1\":{\"287\":1}}],[\"删除元素的位置\",{\"1\":{\"284\":1}}],[\"删除元素\",{\"1\":{\"285\":1}}],[\"删除位置的元素\",{\"1\":{\"284\":1}}],[\"删除指定键\",{\"1\":{\"603\":1}}],[\"删除指定位置的元素\",{\"1\":{\"284\":1}}],[\"删除指定行\",{\"1\":{\"94\":1}}],[\"删除时变更参数\",{\"1\":{\"181\":1}}],[\"删除操作\",{\"1\":{\"178\":1,\"286\":1}}],[\"删除\",{\"0\":{\"473\":1},\"1\":{\"115\":1,\"503\":1,\"606\":1,\"607\":1,\"625\":1,\"1050\":1,\"1122\":1,\"1178\":1,\"1259\":1,\"1317\":1,\"1363\":1}}],[\"删除包含特定字符的行\",{\"1\":{\"94\":1}}],[\"用完删除\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"用完删除掉自己创建的\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"用一个异步的线程更新缓存\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"用一条等价的命令代替多条之前的命令\",{\"1\":{\"962\":1}}],[\"用xml绑定\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"用注解绑定\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"用法\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"用法和上边一样\",{\"1\":{\"342\":1}}],[\"用java虚拟机执行编译文件\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"用得多也就熟了\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"用clone方法创建对象并不会调用任何构造函数\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"用object作为原始类型\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"用元数据和\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"用了缓存之后\",{\"0\":{\"1046\":1,\"1255\":1}}],[\"用官方的总结就是\",{\"1\":{\"1031\":1}}],[\"用起来特顺手\",{\"1\":{\"960\":1}}],[\"用过用过\",{\"1\":{\"960\":1}}],[\"用新值替换旧值\",{\"1\":{\"922\":1}}],[\"用邮箱注册一个就可以了\",{\"1\":{\"913\":1}}],[\"用户登录\",{\"1\":{\"1439\":1}}],[\"用户登录成功\",{\"1\":{\"1431\":1}}],[\"用户管理\",{\"1\":{\"1439\":1}}],[\"用户管理系统\",{\"2\":{\"1433\":1,\"1437\":1,\"1441\":1,\"1446\":1}}],[\"用户查询等\",{\"1\":{\"1439\":1}}],[\"用户删除\",{\"1\":{\"1439\":2}}],[\"用户添加\",{\"1\":{\"1439\":1}}],[\"用户中心\",{\"0\":{\"1429\":1,\"1431\":1,\"1434\":1,\"1435\":1,\"1438\":1,\"1439\":1,\"1443\":1},\"1\":{\"1429\":1,\"1439\":1},\"2\":{\"1432\":1,\"1436\":1,\"1440\":1,\"1445\":1}}],[\"用户得到了没有完成初始化的\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"用户请求时\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"用户无需等待\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"用户发送请求到\",{\"1\":{\"956\":1}}],[\"用户发送请求至前端控制器\",{\"1\":{\"956\":1}}],[\"用户访问数等统计\",{\"1\":{\"883\":1}}],[\"用户每月签到情况\",{\"1\":{\"658\":1}}],[\"用户需要用到此方法释放资源\",{\"1\":{\"648\":1}}],[\"用以生成和发布maven站点\",{\"1\":{\"714\":1}}],[\"用以下两个属性替换\",{\"1\":{\"648\":1}}],[\"用以记录原有客户端的ip地址和原来客户端的请求的服务器地址\",{\"1\":{\"106\":1}}],[\"用作\",{\"1\":{\"619\":1}}],[\"用在缓存的场合非常多\",{\"1\":{\"594\":1}}],[\"用具体的字段列表代替\",{\"0\":{\"540\":1}}],[\"用下面的语句替换\",{\"1\":{\"535\":1}}],[\"用\",{\"1\":{\"501\":1,\"643\":1,\"692\":1,\"1060\":1,\"1123\":1,\"1266\":1,\"1318\":1}}],[\"用我的话来理解\",{\"1\":{\"401\":1}}],[\"用ffmpeg的delogo过滤器\",{\"1\":{\"140\":1}}],[\"用于消息存储\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"用于\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"用于根据请求找到匹配的处理器\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"用于节约内存\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"用于会话管理\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"用于限定集合的输入类型\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"用于限制输入\",{\"1\":{\"145\":1}}],[\"用于在映像层中添加功能层\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"用于快速开发可维护\",{\"1\":{\"1031\":1}}],[\"用于访问保留字段中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问条件变量等待时间中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问条件变量中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问成功次数中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问竞争次数中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问自旋提前量中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问自旋持续时间中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问自旋时钟中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问自旋频率中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问责任线程指针中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问空闲链表指针中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问等待队列尾指针中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问等待队列头指针中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问等待队列长度中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问持有者指针中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问对象指针中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问对象头中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问递归深度中的信息\",{\"1\":{\"1023\":1}}],[\"用于访问计数器中的信息\",{\"1\":{\"1023\":1}}],[\"用于未来扩展\",{\"1\":{\"1023\":1}}],[\"用于控制自旋等待的时间\",{\"1\":{\"1023\":3}}],[\"用于控制倒排索引记录的内容\",{\"1\":{\"433\":1}}],[\"用于回收\",{\"1\":{\"1023\":1}}],[\"用于支持条件变量的等待和唤醒操作\",{\"1\":{\"1023\":1}}],[\"用于记录条件变量等待的时间\",{\"1\":{\"1023\":1}}],[\"用于记录获取锁的成功次数\",{\"1\":{\"1023\":1}}],[\"用于记录获取锁的竞争次数\",{\"1\":{\"1023\":1}}],[\"用于记录自旋等待的时间\",{\"1\":{\"1023\":1}}],[\"用于记录最后一个释放锁的线程\",{\"1\":{\"1023\":1}}],[\"用于记录当前线程已经获取锁的次数\",{\"1\":{\"1023\":1}}],[\"用于记录等待锁的线程数\",{\"1\":{\"1023\":1}}],[\"用于记录重入次数\",{\"1\":{\"1023\":1}}],[\"用于实现\",{\"1\":{\"1023\":1}}],[\"用于实现同步机制\",{\"1\":{\"1022\":1}}],[\"用于实现一个简单的聊天室应用\",{\"1\":{\"1020\":1}}],[\"用于比较内存某个位置的值是否为预期值\",{\"1\":{\"1018\":1}}],[\"用于管理集群中的节点\",{\"1\":{\"1008\":1}}],[\"用于提高数据的可用性和容错性\",{\"1\":{\"1002\":1,\"1012\":1}}],[\"用于对文档进行分类\",{\"1\":{\"1002\":1}}],[\"用于存储要映射的\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"用于存储锁状态和其他信息\",{\"1\":{\"1023\":1}}],[\"用于存储和组织数据\",{\"1\":{\"1002\":1}}],[\"用于存储局部变量表\",{\"1\":{\"930\":1,\"1142\":1,\"1333\":1}}],[\"用于处理大规模数据的搜索和分析\",{\"1\":{\"1002\":1}}],[\"用于高吞吐量\",{\"1\":{\"974\":1}}],[\"用于这次实例化\",{\"1\":{\"966\":1}}],[\"用于执行一些增强操作\",{\"1\":{\"958\":1}}],[\"用于执行映射语句并commit\",{\"1\":{\"958\":1}}],[\"用于定义映射语句\",{\"1\":{\"958\":1}}],[\"用于创建\",{\"1\":{\"958\":2}}],[\"用于组件扫描\",{\"1\":{\"944\":1}}],[\"用于观察运行时的线程活动\",{\"1\":{\"942\":1}}],[\"用于后续分析\",{\"1\":{\"942\":1}}],[\"用于后端服务器性能不均的情况\",{\"1\":{\"106\":1}}],[\"用于分析垃圾收集情况\",{\"1\":{\"942\":1}}],[\"用于保证用户线程的一致性快照\",{\"1\":{\"940\":1}}],[\"用于保存整数值的集合抽象数据结构\",{\"1\":{\"630\":1}}],[\"用于保存\",{\"1\":{\"629\":1}}],[\"用于保存字符串\",{\"1\":{\"619\":1}}],[\"用于判定垃圾\",{\"1\":{\"940\":1}}],[\"用于业务层非成功情况下的返回\",{\"1\":{\"829\":1,\"830\":1}}],[\"用于计算索引值\",{\"1\":{\"624\":1}}],[\"用于锁定一个区间内的所有行以及区间的边界值\",{\"1\":{\"575\":1}}],[\"用于行级锁定和范围查询\",{\"1\":{\"556\":1}}],[\"用于操作对数据的读取和写入\",{\"1\":{\"555\":1}}],[\"用于连接的列\",{\"1\":{\"502\":1}}],[\"用于加速地理空间数据的查询和检索操作\",{\"1\":{\"495\":1}}],[\"用于复制指定的数组内容以达到扩容的目的\",{\"1\":{\"352\":1}}],[\"用于编码hevc\",{\"1\":{\"135\":1}}],[\"用于设置码率控制缓冲器的大小\",{\"1\":{\"134\":1}}],[\"用来做测试\",{\"1\":{\"1444\":1}}],[\"用来构建高可用的分布式数据主备系统\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"用来给slave\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"用来给不同的server来使用\",{\"1\":{\"106\":1}}],[\"用来指示执行引擎下一条执行指令的地址\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"用来修饰局部变量\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"用来创建按顺序执行多个命令行指令的自动构建\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"用来实现对象之间的\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"用来实现文档的一对一\",{\"1\":{\"457\":1}}],[\"用来实时监控内存\",{\"1\":{\"942\":1}}],[\"用来存储我们执行预约操作的返回结果\",{\"1\":{\"829\":1}}],[\"用来定义预约业务的数据字典\",{\"1\":{\"829\":1}}],[\"用来控制内存的使用\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"用来控制依赖和编译\",{\"1\":{\"706\":1}}],[\"用来控制当前字段是否被索引\",{\"1\":{\"432\":1}}],[\"用来进行原子性操作\",{\"1\":{\"692\":1}}],[\"用来处理当织入的代码抛出异常后的逻辑处理\",{\"1\":{\"689\":1}}],[\"用来抢占锁\",{\"1\":{\"664\":1}}],[\"用来回收\",{\"1\":{\"648\":1}}],[\"用来帮助提升查询和检索数据速度\",{\"1\":{\"494\":1}}],[\"用来表示该位是i的数的个数\",{\"1\":{\"377\":1}}],[\"用来记录同毫秒内产生的不同id\",{\"1\":{\"387\":1}}],[\"用来记录工作机器id\",{\"1\":{\"387\":1}}],[\"用来记录时间戳\",{\"1\":{\"387\":1}}],[\"用来记录从那个页面链接访问过来的\",{\"1\":{\"106\":1}}],[\"用来记录请求状态\",{\"1\":{\"106\":1}}],[\"用来记录请求的url与http协议\",{\"1\":{\"106\":1}}],[\"用来记录访问时间与时区\",{\"1\":{\"106\":1}}],[\"用来记录客户端用户名称\",{\"1\":{\"106\":1}}],[\"用冒号分割已经来不及了\",{\"1\":{\"94\":1}}],[\"用到的\",{\"1\":{\"90\":1}}],[\"指带有存活时间\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"指要在连接点\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"指程序运行过程中所执行的方法\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"指令重排技术大大提高了程序执行效率\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"指令运行\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"指令\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"指令为执行的容器提供默认值\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"指令可在映像当前层执行任何命令并创建一个新层\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"指令用于组织项目映像\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"指令的实现是通过释放对象的锁来实现的\",{\"1\":{\"1023\":1}}],[\"指令的实现是通过获取对象的锁来实现的\",{\"1\":{\"1023\":1}}],[\"指令的实现\",{\"1\":{\"1023\":2}}],[\"指令来实现\",{\"1\":{\"1022\":2}}],[\"指令来实现的\",{\"1\":{\"1022\":1}}],[\"指向等待队列的尾节点\",{\"1\":{\"1023\":1}}],[\"指向等待队列的头节点\",{\"1\":{\"1023\":1}}],[\"指向当前持有锁的线程\",{\"1\":{\"1023\":1}}],[\"指向被锁定的对象\",{\"1\":{\"1023\":1}}],[\"指向\",{\"1\":{\"952\":2}}],[\"指向底层实现数据结构的指针\",{\"1\":{\"635\":1}}],[\"指向下个哈希表节点\",{\"1\":{\"624\":1}}],[\"指向下一个元素\",{\"1\":{\"286\":1}}],[\"指针构成一个单向链表\",{\"1\":{\"624\":1}}],[\"指针\",{\"1\":{\"624\":1}}],[\"指针域\",{\"1\":{\"289\":1}}],[\"指非关系型数据库\",{\"1\":{\"588\":1}}],[\"指事务之间形成了一个闭环\",{\"1\":{\"562\":1}}],[\"指已经分配给一个事务的资源\",{\"1\":{\"562\":1}}],[\"指一个事务至少持有一个资源\",{\"1\":{\"562\":1}}],[\"指某些资源\",{\"1\":{\"562\":1}}],[\"指比较严重的问题\",{\"1\":{\"191\":1}}],[\"指定时间后就会被自动删除\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"指定扫描哪些\",{\"1\":{\"1227\":1,\"1402\":1}}],[\"指定\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"指定t的实际类型\",{\"1\":{\"966\":1}}],[\"指定监控指标\",{\"1\":{\"889\":1}}],[\"指定数据源\",{\"1\":{\"889\":1}}],[\"指定数据库的主键\",{\"1\":{\"763\":1,\"776\":1}}],[\"指定配置文件\",{\"1\":{\"763\":1}}],[\"指定传入sql的参数\",{\"1\":{\"747\":2}}],[\"指定statement\",{\"1\":{\"747\":2}}],[\"指定systempath\",{\"1\":{\"706\":1}}],[\"指定全局配置文件\",{\"1\":{\"746\":1,\"747\":1}}],[\"指定采用哪个环境\",{\"1\":{\"743\":1,\"745\":1}}],[\"指定的位置进行运行\",{\"1\":{\"950\":1}}],[\"指定的内容\",{\"1\":{\"724\":1}}],[\"指定的字段是否存在\",{\"1\":{\"605\":1}}],[\"指定关系\",{\"1\":{\"457\":1}}],[\"指定一个字段评分策略\",{\"1\":{\"440\":1}}],[\"指定分区\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"指定分词器\",{\"1\":{\"440\":1}}],[\"指定分割符\",{\"1\":{\"94\":1}}],[\"指定位置插入元素\",{\"1\":{\"284\":1}}],[\"指定客户端允许的数据压缩格式\",{\"1\":{\"183\":1}}],[\"指定客户端信息\",{\"1\":{\"183\":1}}],[\"指定客户端能够接收的内容类型\",{\"1\":{\"183\":1}}],[\"指定视频设备的索引号\",{\"1\":{\"145\":1}}],[\"指定音频码率\",{\"1\":{\"145\":1}}],[\"指定帧率\",{\"1\":{\"145\":1}}],[\"指定从哪儿采集数据\",{\"1\":{\"145\":1}}],[\"指定使用\",{\"1\":{\"145\":2,\"1151\":3,\"1342\":3}}],[\"指定轮询几率\",{\"1\":{\"106\":1}}],[\"指定进程可以打开的最大描述符\",{\"1\":{\"106\":1}}],[\"指南\",{\"0\":{\"14\":1},\"2\":{\"24\":1}}],[\"5倍\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"5倍扩容\",{\"1\":{\"285\":1}}],[\"5之前的vm上运行泛型代码\",{\"1\":{\"966\":1}}],[\"5之前并没有泛型的概念\",{\"1\":{\"966\":1}}],[\"56597222222223\",{\"1\":{\"865\":1}}],[\"56d7cbc6\",{\"1\":{\"181\":1}}],[\"585\",{\"1\":{\"865\":2}}],[\"58\",{\"1\":{\"825\":2}}],[\"538\",{\"1\":{\"789\":1}}],[\"533\",{\"1\":{\"789\":1}}],[\"532\",{\"1\":{\"789\":2}}],[\"529\",{\"1\":{\"789\":1}}],[\"527\",{\"1\":{\"789\":1}}],[\"5个\",{\"1\":{\"422\":1}}],[\"5+5+12\",{\"1\":{\"388\":1}}],[\"5level\",{\"1\":{\"821\":1}}],[\"5l\",{\"1\":{\"388\":2}}],[\"5位\",{\"1\":{\"387\":5}}],[\"5530726256983\",{\"1\":{\"865\":1}}],[\"555\",{\"1\":{\"865\":2}}],[\"55\",{\"1\":{\"270\":1,\"375\":5,\"377\":2}}],[\"59\",{\"1\":{\"212\":1}}],[\"592560633\",{\"1\":{\"110\":1}}],[\"5ctwvn0qli1iywng\",{\"1\":{\"147\":1}}],[\"540\",{\"1\":{\"138\":1}}],[\"512m\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"512\",{\"1\":{\"266\":1}}],[\"51~\",{\"1\":{\"263\":1}}],[\"51\",{\"1\":{\"134\":1,\"266\":1,\"789\":8}}],[\"5m\",{\"1\":{\"106\":1}}],[\"505\",{\"1\":{\"865\":1}}],[\"50716\",{\"1\":{\"824\":2}}],[\"509\",{\"1\":{\"789\":1}}],[\"50冷却时间\",{\"1\":{\"329\":1}}],[\"50的节点必须从根节点索引到叶节点\",{\"1\":{\"270\":1}}],[\"50和51\",{\"1\":{\"266\":1}}],[\"50\",{\"1\":{\"263\":2,\"266\":2,\"267\":1,\"270\":4,\"500\":1,\"505\":2,\"591\":1,\"603\":1,\"789\":5,\"824\":1,\"1072\":1,\"1104\":1,\"1276\":1,\"1302\":1,\"1444\":1}}],[\"504\",{\"1\":{\"106\":1}}],[\"503\",{\"1\":{\"106\":1}}],[\"502669\",{\"1\":{\"660\":1}}],[\"502\",{\"1\":{\"106\":1}}],[\"5000\",{\"1\":{\"1008\":1}}],[\"50000\",{\"1\":{\"388\":1}}],[\"500\",{\"1\":{\"106\":1,\"865\":2,\"1431\":1}}],[\"50x\",{\"1\":{\"106\":3}}],[\"5\",{\"0\":{\"133\":1,\"160\":1,\"180\":1,\"498\":1,\"530\":1,\"559\":1,\"568\":1,\"595\":1,\"596\":1,\"597\":1,\"598\":1,\"606\":1,\"630\":1,\"675\":1,\"703\":1,\"704\":1,\"705\":1,\"738\":1,\"746\":1,\"749\":1,\"750\":1,\"751\":1,\"757\":1,\"770\":1,\"782\":1,\"796\":1,\"1046\":1,\"1061\":1,\"1072\":1,\"1088\":1,\"1102\":1,\"1116\":1,\"1131\":1,\"1146\":1,\"1162\":1,\"1176\":1,\"1189\":1,\"1202\":1,\"1215\":1,\"1228\":1,\"1241\":1,\"1255\":1,\"1267\":1,\"1275\":1,\"1277\":1,\"1289\":1,\"1300\":1,\"1311\":1,\"1324\":1,\"1337\":1,\"1350\":1,\"1361\":1,\"1372\":1,\"1382\":1,\"1392\":1,\"1403\":1,\"1414\":1},\"1\":{\"94\":1,\"106\":1,\"134\":2,\"157\":2,\"166\":2,\"266\":1,\"329\":1,\"337\":3,\"352\":3,\"359\":4,\"360\":2,\"364\":4,\"375\":2,\"387\":1,\"408\":4,\"419\":1,\"443\":1,\"507\":1,\"526\":1,\"527\":3,\"548\":1,\"591\":1,\"594\":1,\"603\":1,\"605\":1,\"606\":1,\"607\":1,\"672\":2,\"701\":1,\"702\":1,\"737\":1,\"751\":1,\"790\":1,\"812\":1,\"839\":1,\"916\":1,\"932\":4,\"952\":2,\"1047\":1,\"1062\":1,\"1072\":3,\"1084\":1,\"1100\":1,\"1104\":1,\"1105\":1,\"1167\":1,\"1177\":2,\"1198\":1,\"1211\":1,\"1216\":1,\"1217\":1,\"1256\":1,\"1268\":1,\"1276\":1,\"1285\":1,\"1298\":1,\"1302\":1,\"1303\":1,\"1355\":1,\"1362\":2,\"1378\":1,\"1388\":1,\"1393\":1,\"1394\":1,\"1444\":2}}],[\"0之后新增的方式\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"0版本中移\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"0版本type废弃后\",{\"1\":{\"418\":1}}],[\"0的区别\",{\"0\":{\"1138\":1,\"1331\":1}}],[\"0和http1\",{\"0\":{\"1138\":1,\"1331\":1}}],[\"04\",{\"1\":{\"917\":1,\"919\":2}}],[\"0411\",{\"1\":{\"525\":1}}],[\"0成功非0失败\",{\"1\":{\"795\":1}}],[\"02\",{\"1\":{\"736\":1,\"757\":1}}],[\"09\",{\"1\":{\"736\":2,\"757\":1,\"759\":1,\"919\":1}}],[\"08\",{\"1\":{\"789\":5,\"828\":1,\"1087\":2,\"1288\":2}}],[\"087269\",{\"1\":{\"660\":1}}],[\"0829\",{\"1\":{\"136\":1}}],[\"0～10\",{\"1\":{\"655\":1}}],[\"0<\",{\"1\":{\"648\":1,\"715\":2,\"812\":3,\"844\":1,\"862\":1,\"874\":2}}],[\"0到\",{\"1\":{\"635\":1}}],[\"07\",{\"1\":{\"439\":1,\"789\":42,\"790\":14,\"795\":2,\"824\":1,\"828\":1,\"998\":1}}],[\"0l\",{\"1\":{\"388\":2}}],[\"0~2\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"0~3\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"0~31\",{\"1\":{\"388\":4}}],[\"0~4095\",{\"1\":{\"388\":1}}],[\"0b111111111111=0xfff=4095\",{\"1\":{\"388\":1}}],[\"0b2c\",{\"1\":{\"181\":1}}],[\"0d\",{\"1\":{\"340\":3}}],[\"0用户中心接口更新\",{\"1\":{\"182\":1}}],[\"05\",{\"1\":{\"182\":1,\"736\":1,\"759\":1,\"831\":1}}],[\"05d\",{\"1\":{\"141\":1}}],[\"01`\",{\"1\":{\"725\":1,\"726\":2}}],[\"01\",{\"1\":{\"182\":1,\"388\":2,\"445\":2,\"789\":42,\"790\":14,\"795\":2,\"826\":2}}],[\"03\",{\"1\":{\"182\":1,\"445\":2}}],[\"03d\",{\"1\":{\"141\":2}}],[\"0644\",{\"1\":{\"962\":1}}],[\"065\",{\"1\":{\"789\":1}}],[\"06\",{\"1\":{\"129\":1,\"759\":2}}],[\"000\",{\"1\":{\"1072\":4,\"1276\":4}}],[\"00000\",{\"1\":{\"388\":2}}],[\"0000000001\",{\"1\":{\"795\":1}}],[\"000000000000\",{\"1\":{\"388\":1}}],[\"0000000000\",{\"1\":{\"388\":4,\"795\":1}}],[\"00000001这样子\",{\"1\":{\"361\":1}}],[\"006r3pqbjw1fb5h84baewj306404lmx9\",{\"1\":{\"179\":1}}],[\"00\",{\"1\":{\"129\":4,\"141\":2,\"445\":5,\"830\":1}}],[\"0还是ie8\",{\"1\":{\"106\":1}}],[\"0\",{\"0\":{\"600\":1,\"645\":1},\"1\":{\"94\":1,\"106\":27,\"140\":1,\"141\":1,\"143\":2,\"145\":7,\"159\":2,\"166\":6,\"212\":1,\"248\":2,\"251\":2,\"266\":1,\"285\":14,\"286\":12,\"288\":5,\"289\":2,\"337\":4,\"347\":1,\"352\":8,\"353\":1,\"359\":2,\"360\":5,\"364\":4,\"375\":3,\"377\":6,\"387\":3,\"388\":11,\"405\":3,\"406\":4,\"408\":3,\"412\":4,\"413\":3,\"418\":1,\"419\":2,\"429\":1,\"436\":1,\"440\":1,\"487\":1,\"488\":3,\"511\":1,\"526\":1,\"591\":2,\"597\":2,\"603\":1,\"604\":6,\"619\":1,\"624\":2,\"625\":4,\"635\":1,\"636\":1,\"648\":2,\"654\":2,\"655\":5,\"657\":1,\"658\":2,\"659\":7,\"672\":2,\"673\":4,\"688\":1,\"689\":1,\"690\":4,\"692\":2,\"703\":2,\"704\":2,\"708\":1,\"709\":2,\"710\":1,\"715\":18,\"723\":2,\"726\":7,\"737\":2,\"743\":6,\"744\":2,\"745\":4,\"755\":2,\"759\":2,\"763\":3,\"779\":3,\"782\":2,\"786\":1,\"789\":12,\"790\":5,\"795\":1,\"807\":1,\"812\":11,\"815\":1,\"817\":2,\"818\":1,\"819\":2,\"821\":1,\"827\":5,\"828\":1,\"829\":1,\"830\":3,\"832\":3,\"844\":11,\"849\":1,\"854\":2,\"855\":1,\"865\":54,\"888\":2,\"916\":2,\"922\":1,\"928\":4,\"932\":9,\"946\":1,\"948\":1,\"988\":1,\"994\":1,\"1008\":2,\"1020\":2,\"1022\":1,\"1044\":1,\"1071\":2,\"1077\":1,\"1084\":1,\"1085\":1,\"1104\":7,\"1105\":2,\"1107\":1,\"1138\":2,\"1161\":1,\"1163\":1,\"1176\":1,\"1181\":1,\"1192\":1,\"1204\":2,\"1219\":2,\"1245\":1,\"1253\":1,\"1275\":2,\"1281\":1,\"1285\":1,\"1286\":1,\"1302\":7,\"1303\":2,\"1305\":1,\"1331\":2,\"1349\":1,\"1351\":1,\"1361\":1,\"1366\":1,\"1375\":1,\"1384\":2,\"1396\":2,\"1418\":1,\"1429\":2,\"1431\":3}}],[\"去中心化\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"去执行\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"去查询\",{\"1\":{\"1047\":1,\"1049\":1,\"1256\":1,\"1258\":1}}],[\"去除停用词\",{\"1\":{\"1012\":1}}],[\"去除文件中字符\",{\"1\":{\"94\":1}}],[\"去调用同一个\",{\"1\":{\"958\":1}}],[\"去修正并发标记期间的\",{\"1\":{\"938\":1}}],[\"去掉不必要的属性\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"去掉\",{\"1\":{\"800\":1}}],[\"去掉视频的logo\",{\"0\":{\"140\":1}}],[\"去取出参数值信息\",{\"1\":{\"779\":1}}],[\"去重比\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"去重但是可以排序\",{\"1\":{\"657\":1}}],[\"去重\",{\"1\":{\"94\":1,\"656\":1}}],[\">delete\",{\"1\":{\"1190\":1,\"1373\":1}}],[\">displaced\",{\"1\":{\"1023\":4}}],[\">销毁\",{\"1\":{\"1128\":1,\"1321\":1}}],[\">请求响应\",{\"1\":{\"1128\":1,\"1321\":1}}],[\">初始化\",{\"1\":{\"1128\":1,\"1321\":1}}],[\">实例化\",{\"1\":{\"1128\":1,\"1321\":1}}],[\">clear\",{\"1\":{\"1023\":1}}],[\">set\",{\"1\":{\"1023\":1}}],[\">sex\",{\"1\":{\"755\":1,\"763\":1,\"786\":1}}],[\">lock\",{\"1\":{\"1023\":2}}],[\">mark\",{\"1\":{\"1023\":2}}],[\">可以匹配任何类型\",{\"1\":{\"966\":1}}],[\">代表一个未知类型的通配符\",{\"1\":{\"966\":1}}],[\">和<\",{\"1\":{\"966\":1}}],[\">javapub知识清单<\",{\"1\":{\"832\":1}}],[\">相当于if\",{\"1\":{\"787\":1}}],[\"><\",{\"1\":{\"782\":5,\"865\":45}}],[\">birthday\",{\"1\":{\"755\":1,\"763\":1,\"786\":1}}],[\">buf\",{\"1\":{\"619\":1}}],[\">age\",{\"1\":{\"755\":1,\"763\":1,\"786\":1}}],[\">name\",{\"1\":{\"755\":1,\"763\":1,\"786\":1}}],[\">next\",{\"1\":{\"267\":1}}],[\">password\",{\"1\":{\"755\":1,\"763\":1,\"786\":1}}],[\">user\",{\"1\":{\"755\":1,\"763\":1,\"786\":1}}],[\">o\",{\"1\":{\"357\":1}}],[\">=\",{\"1\":{\"285\":1,\"286\":1,\"353\":1,\"364\":3,\"800\":3,\"801\":1,\"928\":2,\"948\":1,\"1085\":1,\"1286\":1}}],[\">key\",{\"1\":{\"267\":1}}],[\">>\",{\"1\":{\"94\":1,\"285\":1,\"924\":1,\"928\":1}}],[\">result\",{\"1\":{\"94\":1}}],[\">\",{\"1\":{\"94\":3,\"266\":1,\"285\":2,\"286\":1,\"348\":1,\"352\":2,\"360\":1,\"364\":3,\"377\":4,\"388\":2,\"501\":1,\"511\":1,\"603\":22,\"604\":5,\"708\":2,\"709\":1,\"710\":1,\"715\":11,\"724\":7,\"727\":9,\"743\":35,\"744\":6,\"745\":16,\"755\":19,\"759\":1,\"761\":2,\"762\":1,\"763\":20,\"766\":8,\"767\":1,\"768\":5,\"770\":3,\"772\":12,\"779\":7,\"780\":2,\"782\":13,\"784\":2,\"785\":4,\"786\":6,\"787\":2,\"790\":6,\"793\":11,\"794\":12,\"795\":9,\"797\":5,\"800\":2,\"801\":7,\"812\":19,\"815\":37,\"817\":11,\"818\":10,\"819\":17,\"820\":7,\"821\":6,\"827\":17,\"828\":1,\"831\":1,\"832\":7,\"844\":2,\"862\":2,\"865\":30,\"874\":1,\"922\":2,\"928\":8,\"932\":3,\"934\":1,\"946\":1,\"952\":2,\"958\":5,\"966\":12,\"1010\":5,\"1020\":1,\"1090\":2,\"1175\":1,\"1176\":2,\"1177\":3,\"1216\":1,\"1219\":8,\"1291\":2,\"1360\":1,\"1361\":2,\"1362\":3,\"1393\":1,\"1396\":8,\"1439\":7}}],[\"$num\",{\"1\":{\"916\":6}}],[\"$nf\",{\"1\":{\"94\":1}}],[\"$号\",{\"1\":{\"780\":1}}],[\"$区别\",{\"0\":{\"780\":1}}],[\"$可以是sql中的任一部分传入到statement中\",{\"1\":{\"779\":1}}],[\"$path\",{\"1\":{\"125\":1}}],[\"$proxy\",{\"1\":{\"106\":2}}],[\"$host\",{\"1\":{\"106\":2}}],[\"$http\",{\"1\":{\"106\":5}}],[\"$\",{\"1\":{\"106\":5,\"109\":1,\"598\":4,\"701\":1,\"702\":1,\"743\":4,\"763\":2,\"766\":4,\"779\":3,\"780\":1,\"784\":1,\"785\":1,\"786\":1,\"815\":5,\"832\":1,\"865\":7,\"917\":7,\"1174\":3,\"1359\":3}}],[\"$binary\",{\"1\":{\"106\":1}}],[\"$body\",{\"1\":{\"106\":2}}],[\"$status\",{\"1\":{\"106\":2}}],[\"$scp\",{\"1\":{\"94\":4}}],[\"$request\",{\"1\":{\"106\":3}}],[\"$remote\",{\"1\":{\"106\":6}}],[\"$time\",{\"1\":{\"106\":2}}],[\"$min\",{\"1\":{\"94\":1}}],[\"$3\",{\"1\":{\"94\":2}}],[\"$1\",{\"1\":{\"94\":1}}],[\"$2\",{\"1\":{\"94\":1}}],[\"$$\",{\"1\":{\"35\":2}}],[\"9586088\",{\"1\":{\"919\":1}}],[\"9527\",{\"1\":{\"658\":4}}],[\"94\",{\"1\":{\"919\":1}}],[\"99\",{\"1\":{\"657\":1,\"795\":2}}],[\"9999\",{\"1\":{\"635\":2,\"636\":1,\"1204\":2,\"1384\":2}}],[\"9200\",{\"1\":{\"406\":1,\"412\":1,\"413\":1,\"436\":3,\"462\":2}}],[\"9300\",{\"1\":{\"406\":1}}],[\"93\",{\"1\":{\"375\":5,\"377\":2}}],[\"9197\",{\"1\":{\"178\":1}}],[\"97\",{\"1\":{\"145\":1}}],[\"9092\",{\"1\":{\"984\":1,\"990\":1}}],[\"9093\",{\"1\":{\"887\":1}}],[\"9090\",{\"1\":{\"106\":1,\"109\":2,\"887\":1}}],[\"9001\",{\"1\":{\"690\":2}}],[\"9000\",{\"1\":{\"106\":2}}],[\"90\",{\"1\":{\"106\":3,\"140\":1,\"795\":1,\"1072\":1,\"1276\":1}}],[\"9\",{\"0\":{\"137\":1,\"138\":1,\"139\":1,\"140\":1,\"184\":1,\"502\":1,\"534\":1,\"574\":1,\"711\":1,\"712\":1,\"713\":1,\"714\":1,\"773\":1,\"774\":1,\"775\":1,\"776\":1,\"777\":1,\"778\":1,\"779\":1,\"780\":1,\"781\":1,\"782\":1,\"1050\":1,\"1076\":1,\"1092\":1,\"1106\":1,\"1120\":1,\"1121\":1,\"1135\":1,\"1150\":1,\"1166\":1,\"1180\":1,\"1193\":1,\"1206\":1,\"1219\":1,\"1232\":1,\"1245\":1,\"1259\":1,\"1281\":1,\"1293\":1,\"1304\":1,\"1315\":1,\"1316\":1,\"1328\":1,\"1341\":1,\"1354\":1,\"1365\":1,\"1376\":1,\"1386\":1,\"1396\":1,\"1407\":1,\"1418\":1},\"1\":{\"94\":1,\"106\":1,\"337\":1,\"359\":10,\"364\":1,\"375\":3,\"377\":1,\"603\":1,\"605\":1,\"606\":1,\"607\":1,\"692\":1,\"812\":1,\"897\":1}}],[\"udp\",{\"1\":{\"1135\":3,\"1328\":3}}],[\"udp的区别\",{\"1\":{\"104\":1}}],[\"uci\",{\"1\":{\"898\":1}}],[\"uv\",{\"1\":{\"659\":5}}],[\"u64\",{\"1\":{\"624\":1}}],[\"ui\",{\"1\":{\"831\":1}}],[\"uint32\",{\"1\":{\"630\":2}}],[\"uint64\",{\"1\":{\"624\":2}}],[\"uint\",{\"1\":{\"487\":4,\"488\":4}}],[\"uid\",{\"1\":{\"192\":1,\"439\":1,\"602\":1,\"658\":3}}],[\"uuid\",{\"0\":{\"385\":1},\"1\":{\"385\":4,\"1008\":1}}],[\"utc\",{\"1\":{\"445\":1}}],[\"utils\",{\"1\":{\"352\":1,\"388\":1,\"852\":1,\"876\":1}}],[\"util\",{\"1\":{\"337\":2,\"352\":1,\"364\":1,\"377\":1,\"385\":1,\"689\":1,\"747\":1,\"753\":1,\"754\":1,\"757\":2,\"763\":2,\"825\":1,\"826\":1,\"828\":1,\"830\":2,\"831\":1,\"932\":4,\"984\":2,\"990\":1,\"1020\":1,\"1022\":1,\"1104\":2,\"1105\":4,\"1107\":1,\"1175\":1,\"1302\":2,\"1303\":4,\"1305\":1,\"1360\":1}}],[\"utf\",{\"1\":{\"106\":1,\"743\":1,\"744\":1,\"745\":1,\"755\":1,\"763\":1,\"782\":1,\"812\":1,\"815\":1,\"817\":1,\"818\":1,\"819\":1,\"821\":1,\"827\":2,\"832\":2,\"844\":1,\"865\":1,\"1020\":1}}],[\"up\",{\"1\":{\"1060\":1,\"1101\":1,\"1266\":1,\"1299\":1}}],[\"upgrade\",{\"1\":{\"896\":1}}],[\"update=\",{\"1\":{\"828\":1}}],[\"updateuser\",{\"1\":{\"753\":1,\"754\":2,\"755\":1,\"757\":2,\"763\":3,\"786\":3,\"789\":4}}],[\"updated=\",{\"1\":{\"759\":1,\"789\":6,\"790\":2}}],[\"updated\",{\"1\":{\"736\":3,\"747\":5,\"755\":4,\"759\":2,\"763\":2,\"782\":2,\"786\":1,\"789\":1,\"792\":2,\"793\":2,\"794\":1,\"795\":1}}],[\"updates\",{\"1\":{\"725\":1,\"789\":1}}],[\"update>\",{\"1\":{\"724\":1,\"727\":1,\"755\":1,\"763\":1,\"786\":1,\"827\":1}}],[\"updatebatch1\",{\"1\":{\"727\":1}}],[\"updatebatch\",{\"1\":{\"724\":1}}],[\"update来获取排他锁\",{\"1\":{\"578\":1}}],[\"update或select\",{\"1\":{\"575\":1}}],[\"update可以显式地对行加排他锁\",{\"1\":{\"564\":1}}],[\"update\",{\"0\":{\"537\":1,\"571\":1,\"777\":1},\"1\":{\"178\":2,\"537\":1,\"555\":3,\"556\":3,\"558\":1,\"570\":1,\"571\":1,\"573\":3,\"578\":1,\"579\":1,\"724\":1,\"725\":1,\"727\":2,\"754\":1,\"755\":1,\"763\":1,\"770\":4,\"786\":1,\"789\":2,\"824\":1,\"827\":2,\"828\":2,\"830\":2,\"852\":1,\"864\":2,\"1180\":1,\"1188\":2,\"1191\":5,\"1365\":1,\"1371\":2,\"1374\":5}}],[\"upon\",{\"1\":{\"152\":1}}],[\"upstream模块定义的错误\",{\"1\":{\"106\":1}}],[\"upstream的负载均衡\",{\"1\":{\"106\":1}}],[\"upstream\",{\"1\":{\"106\":6}}],[\"uri\",{\"1\":{\"106\":1}}],[\"urlclassloader\",{\"1\":{\"934\":1}}],[\"url填的prometheus访问地址\",{\"1\":{\"889\":1}}],[\"url=jdbc\",{\"1\":{\"816\":1}}],[\"url>\",{\"1\":{\"812\":1}}],[\"url去重\",{\"1\":{\"330\":1}}],[\"url\",{\"1\":{\"106\":1,\"109\":2,\"177\":2,\"737\":2,\"743\":4,\"745\":1,\"766\":5,\"772\":1,\"815\":2,\"820\":1,\"831\":1,\"864\":1,\"876\":8,\"1176\":1,\"1361\":1,\"1444\":1}}],[\"ulimit\",{\"1\":{\"106\":1}}],[\"ustc\",{\"1\":{\"852\":1,\"896\":2}}],[\"usage\",{\"1\":{\"158\":1}}],[\"using\",{\"1\":{\"106\":1,\"158\":1,\"526\":1}}],[\"use\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"usecolumnlabel\",{\"1\":{\"817\":1}}],[\"usegeneratedkeys=\",{\"1\":{\"763\":1,\"1176\":2,\"1361\":2}}],[\"usegeneratedkeys\",{\"1\":{\"763\":1,\"776\":1,\"817\":1,\"1176\":1,\"1361\":1}}],[\"useunicode=true\",{\"1\":{\"743\":1,\"816\":1}}],[\"used\",{\"1\":{\"614\":1,\"624\":1,\"887\":1,\"889\":1,\"1044\":2,\"1101\":1,\"1253\":2,\"1299\":1}}],[\"usessl=false\",{\"1\":{\"1444\":1}}],[\"uses\",{\"1\":{\"106\":3,\"152\":1,\"1101\":1,\"1299\":1}}],[\"user3\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"user4\",{\"1\":{\"1087\":2,\"1288\":2}}],[\"user2\",{\"1\":{\"1087\":2,\"1288\":2}}],[\"user1\",{\"1\":{\"1087\":2,\"1288\":2}}],[\"usertask>\",{\"1\":{\"865\":3}}],[\"user=new\",{\"1\":{\"789\":1}}],[\"userresultmap\",{\"1\":{\"782\":2}}],[\"usermappertest\",{\"1\":{\"763\":1}}],[\"usermapper\",{\"1\":{\"762\":1,\"763\":15,\"772\":1,\"784\":1,\"785\":1,\"786\":2,\"787\":1,\"789\":25,\"790\":9,\"958\":2}}],[\"userlist\",{\"1\":{\"757\":2,\"763\":4}}],[\"user即为数据库中的表\",{\"1\":{\"755\":1}}],[\"user即为数据库中的表名\",{\"1\":{\"744\":1}}],[\"userdaotest\",{\"1\":{\"757\":1,\"762\":2}}],[\"userdaomapper\",{\"0\":{\"755\":1},\"1\":{\"755\":1,\"763\":1,\"772\":1}}],[\"userdaoimpl\",{\"1\":{\"754\":2,\"757\":2}}],[\"userdao\",{\"1\":{\"753\":1,\"754\":7,\"755\":1,\"756\":1,\"757\":9,\"762\":3}}],[\"userstatus\",{\"1\":{\"724\":1}}],[\"users\",{\"1\":{\"431\":1,\"434\":5,\"436\":6,\"451\":2,\"505\":4,\"784\":2,\"785\":2,\"786\":2,\"787\":2,\"1431\":1}}],[\"userservice\",{\"1\":{\"159\":2,\"1431\":1}}],[\"userid=123\",{\"1\":{\"866\":2}}],[\"userid\",{\"1\":{\"192\":1,\"724\":3,\"792\":1,\"793\":1,\"794\":1}}],[\"user\",{\"1\":{\"106\":6,\"177\":2,\"181\":2,\"183\":1,\"195\":4,\"200\":3,\"201\":3,\"249\":1,\"432\":1,\"501\":3,\"555\":1,\"602\":2,\"701\":1,\"702\":1,\"724\":5,\"725\":4,\"736\":5,\"737\":3,\"744\":2,\"747\":9,\"753\":8,\"754\":8,\"755\":13,\"757\":24,\"759\":4,\"763\":51,\"766\":1,\"768\":4,\"772\":1,\"779\":18,\"780\":8,\"782\":10,\"784\":5,\"785\":5,\"786\":20,\"787\":5,\"789\":17,\"790\":4,\"792\":1,\"793\":9,\"794\":7,\"795\":6,\"797\":2,\"815\":1,\"832\":1,\"838\":1,\"839\":1,\"958\":5,\"1087\":8,\"1093\":3,\"1174\":4,\"1288\":8,\"1294\":3,\"1359\":4,\"1431\":5,\"1439\":1,\"1444\":8}}],[\"username2\",{\"1\":{\"780\":4}}],[\"username1\",{\"1\":{\"780\":4}}],[\"username=root\",{\"1\":{\"816\":1}}],[\"username=\",{\"1\":{\"759\":1,\"789\":6,\"790\":2}}],[\"username\",{\"1\":{\"94\":2,\"451\":5,\"501\":3,\"657\":2,\"736\":2,\"737\":1,\"743\":4,\"745\":1,\"747\":5,\"755\":4,\"759\":1,\"763\":7,\"766\":4,\"779\":9,\"782\":2,\"786\":2,\"793\":1,\"815\":1,\"864\":1,\"1174\":3,\"1175\":1,\"1359\":3,\"1360\":1,\"1444\":1}}],[\"usr\",{\"1\":{\"94\":1,\"106\":1,\"109\":1,\"125\":3}}],[\"unauthorized\",{\"1\":{\"1431\":1}}],[\"under\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"undo\",{\"1\":{\"1185\":1,\"1220\":1,\"1368\":1,\"1397\":1}}],[\"uncommitted\",{\"1\":{\"1187\":1,\"1220\":1,\"1370\":1,\"1397\":1}}],[\"unchecked\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"unheld\",{\"1\":{\"1023\":2}}],[\"unsafe\",{\"1\":{\"1008\":1,\"1101\":1,\"1299\":1}}],[\"unsigned\",{\"1\":{\"621\":1,\"624\":4,\"628\":1,\"635\":3,\"795\":1}}],[\"untyped等等\",{\"1\":{\"883\":1}}],[\"unlock\",{\"1\":{\"561\":1,\"932\":2,\"1101\":1,\"1105\":4,\"1299\":1,\"1303\":4}}],[\"unknownhostexception\",{\"1\":{\"388\":2}}],[\"unimplemented\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"union\",{\"1\":{\"528\":1,\"624\":1}}],[\"uninstall\",{\"1\":{\"114\":1}}],[\"unique\",{\"1\":{\"506\":1,\"1206\":1,\"1386\":1}}],[\"uniq\",{\"1\":{\"94\":1}}],[\"unzip\",{\"1\":{\"94\":1}}],[\"u\",{\"1\":{\"94\":1,\"602\":1,\"793\":2,\"794\":1,\"795\":1,\"913\":1}}],[\"8<\",{\"1\":{\"742\":1,\"812\":3,\"844\":6}}],[\"8个哈希函数\",{\"1\":{\"339\":1}}],[\"8k或者16k\",{\"1\":{\"106\":1}}],[\"8888\",{\"1\":{\"1020\":1}}],[\"88929992\",{\"1\":{\"919\":1}}],[\"88\",{\"1\":{\"106\":2,\"1177\":3,\"1362\":3}}],[\"8m\",{\"1\":{\"106\":1,\"134\":2}}],[\"87601992\",{\"1\":{\"394\":1}}],[\"87\",{\"1\":{\"104\":1}}],[\"8634753\",{\"1\":{\"394\":1}}],[\"86\",{\"1\":{\"104\":1}}],[\"85\",{\"1\":{\"104\":1}}],[\"84\",{\"1\":{\"104\":1,\"141\":1}}],[\"83\",{\"1\":{\"104\":1}}],[\"82\",{\"1\":{\"104\":1}}],[\"81039050\",{\"1\":{\"917\":1,\"919\":1}}],[\"81000次\",{\"1\":{\"591\":1,\"960\":1}}],[\"810241024\",{\"1\":{\"134\":1}}],[\"81\",{\"1\":{\"104\":1,\"375\":5,\"377\":2,\"1077\":1,\"1281\":1}}],[\"8081\",{\"1\":{\"864\":1,\"866\":4}}],[\"8080\",{\"1\":{\"106\":3,\"177\":2,\"181\":2,\"251\":1,\"831\":1,\"850\":1,\"855\":2,\"885\":2,\"887\":1,\"1444\":1}}],[\"8000\",{\"1\":{\"106\":1}}],[\"80s\",{\"1\":{\"106\":1}}],[\"80\",{\"1\":{\"104\":1,\"106\":9,\"865\":3}}],[\"8\",{\"0\":{\"136\":1,\"167\":1,\"183\":1,\"501\":1,\"533\":1,\"573\":1,\"706\":1,\"707\":1,\"708\":1,\"709\":1,\"710\":1,\"765\":1,\"766\":1,\"767\":1,\"768\":1,\"769\":1,\"770\":1,\"771\":1,\"772\":1,\"1049\":1,\"1064\":1,\"1075\":1,\"1091\":1,\"1105\":1,\"1119\":1,\"1120\":1,\"1134\":1,\"1149\":1,\"1165\":1,\"1179\":1,\"1192\":1,\"1205\":1,\"1218\":1,\"1231\":1,\"1244\":1,\"1258\":1,\"1270\":1,\"1280\":1,\"1292\":1,\"1303\":1,\"1314\":1,\"1315\":1,\"1327\":1,\"1340\":1,\"1353\":1,\"1364\":1,\"1375\":1,\"1385\":1,\"1395\":1,\"1406\":1,\"1417\":1},\"1\":{\"94\":1,\"106\":1,\"134\":1,\"158\":1,\"159\":1,\"266\":1,\"359\":2,\"364\":1,\"375\":2,\"402\":1,\"403\":1,\"460\":1,\"487\":1,\"488\":2,\"594\":1,\"598\":3,\"605\":1,\"606\":1,\"607\":1,\"648\":2,\"658\":2,\"672\":2,\"692\":1,\"743\":2,\"744\":1,\"745\":1,\"755\":1,\"763\":1,\"782\":1,\"812\":1,\"815\":1,\"817\":1,\"818\":1,\"819\":1,\"821\":1,\"827\":2,\"831\":2,\"832\":3,\"844\":2,\"850\":1,\"864\":1,\"865\":1,\"916\":1,\"922\":1,\"1020\":1,\"1084\":1,\"1092\":1,\"1101\":1,\"1151\":1,\"1159\":1,\"1216\":1,\"1285\":1,\"1293\":1,\"1299\":1,\"1342\":1,\"1347\":1,\"1393\":1}}],[\"7<\",{\"1\":{\"1444\":1}}],[\"7``\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"7及以下\",{\"1\":{\"897\":1}}],[\"785\",{\"1\":{\"865\":4}}],[\"7850\",{\"1\":{\"159\":1}}],[\"771\",{\"1\":{\"865\":2}}],[\"7cbd213e\",{\"1\":{\"790\":1}}],[\"74\",{\"1\":{\"800\":1}}],[\"746\",{\"1\":{\"790\":1}}],[\"744\",{\"1\":{\"790\":1}}],[\"743\",{\"1\":{\"790\":1}}],[\"74076262d8f14d5390e1ba557e0296a0\",{\"1\":{\"175\":1}}],[\"712\",{\"1\":{\"790\":1}}],[\"7178327462869205051\",{\"1\":{\"663\":1}}],[\"7步操作数据库\",{\"1\":{\"737\":1}}],[\"7以下的吧\",{\"1\":{\"701\":1}}],[\"735\",{\"1\":{\"865\":2}}],[\"734\",{\"1\":{\"790\":1}}],[\"73\",{\"1\":{\"375\":5,\"377\":2}}],[\"731444260\",{\"1\":{\"211\":1}}],[\"70\",{\"1\":{\"270\":1}}],[\"7070\",{\"1\":{\"106\":1}}],[\"76\",{\"1\":{\"266\":1}}],[\"76~\",{\"1\":{\"263\":1}}],[\"75f\",{\"1\":{\"928\":1,\"948\":1,\"1044\":1,\"1253\":1}}],[\"75\",{\"1\":{\"263\":1,\"266\":1,\"329\":1,\"948\":1}}],[\"7969757\",{\"1\":{\"425\":1}}],[\"79\",{\"1\":{\"104\":1}}],[\"72123709\",{\"1\":{\"388\":1}}],[\"72\",{\"1\":{\"94\":1}}],[\"7\",{\"0\":{\"135\":1,\"166\":1,\"182\":1,\"500\":1,\"532\":1,\"561\":1,\"572\":1,\"608\":1,\"634\":1,\"635\":1,\"636\":1,\"748\":1,\"759\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"772\":1,\"1048\":1,\"1063\":1,\"1074\":1,\"1090\":1,\"1104\":1,\"1118\":1,\"1133\":1,\"1148\":1,\"1164\":1,\"1178\":1,\"1191\":1,\"1204\":1,\"1217\":1,\"1230\":1,\"1243\":1,\"1257\":1,\"1269\":1,\"1279\":1,\"1291\":1,\"1302\":1,\"1313\":1,\"1326\":1,\"1339\":1,\"1352\":1,\"1363\":1,\"1374\":1,\"1384\":1,\"1394\":1,\"1405\":1,\"1416\":1},\"1\":{\"94\":1,\"337\":1,\"359\":4,\"375\":2,\"402\":2,\"405\":6,\"412\":7,\"413\":5,\"429\":1,\"431\":1,\"443\":1,\"526\":1,\"548\":1,\"594\":1,\"605\":1,\"606\":1,\"607\":1,\"692\":1,\"737\":1,\"812\":1,\"824\":1,\"825\":2,\"826\":2,\"828\":3,\"829\":9,\"830\":8,\"831\":2,\"898\":1,\"916\":1,\"922\":1,\"988\":1,\"1022\":1,\"1166\":1,\"1211\":1,\"1216\":1,\"1217\":1,\"1354\":1,\"1388\":1,\"1393\":1,\"1394\":1}}],[\"查不到数据则不写入缓存\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"查询逻辑比较简单\",{\"1\":{\"1443\":1}}],[\"查询时通过该bitmap过滤\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"查询时可指定slop间隔\",{\"1\":{\"440\":1}}],[\"查询日志\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"查询禁用排序使这个取回行为更有效率\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"查询阶段包含以下三个步骤\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"查询阶段\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"查询调优\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"查询到的结果缓存到本地\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"查询解析\",{\"1\":{\"1002\":1}}],[\"查询表等\",{\"1\":{\"948\":1}}],[\"查询表中的信息\",{\"1\":{\"779\":1}}],[\"查询慢\",{\"1\":{\"946\":1}}],[\"查询快\",{\"1\":{\"946\":2}}],[\"查询和修改的时间复杂度都是o\",{\"1\":{\"922\":1}}],[\"查询一本图书\",{\"1\":{\"830\":1}}],[\"查询条数\",{\"1\":{\"826\":1}}],[\"查询起始位置\",{\"1\":{\"826\":1}}],[\"查询所有图书\",{\"1\":{\"826\":1,\"830\":1}}],[\"查询所有用户\",{\"1\":{\"786\":2}}],[\"查询所有用户信息\",{\"1\":{\"753\":1,\"763\":1}}],[\"查询出下单人信息并且查询出订单详情中的商品数据\",{\"1\":{\"795\":1}}],[\"查询出下单人信息并且查询出订单详情\",{\"1\":{\"794\":1}}],[\"查询订单\",{\"1\":{\"794\":1,\"795\":1}}],[\"查询男性用户\",{\"1\":{\"783\":1,\"784\":2,\"785\":2}}],[\"查询数据为空\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"查询数据的时候\",{\"1\":{\"759\":1}}],[\"查询数据是否已经存在\",{\"1\":{\"334\":1}}],[\"查询第\",{\"1\":{\"655\":1}}],[\"查询可能不会去利用索引\",{\"0\":{\"536\":1}}],[\"查询性能变差\",{\"1\":{\"922\":1}}],[\"查询性能就能得到较大提高\",{\"1\":{\"922\":1}}],[\"查询性能将大大提高\",{\"1\":{\"505\":1}}],[\"查询性能稳定\",{\"1\":{\"503\":1}}],[\"查询类型\",{\"1\":{\"502\":1}}],[\"查询以\",{\"1\":{\"501\":1}}],[\"查询维度\",{\"1\":{\"499\":1}}],[\"查询效率\",{\"1\":{\"499\":2}}],[\"查询速度会非常快\",{\"1\":{\"498\":1}}],[\"查询索引\",{\"0\":{\"468\":1}}],[\"查询全部索引\",{\"0\":{\"464\":1}}],[\"查询临时文件的动态mapping\",{\"1\":{\"438\":1}}],[\"查询模型安装是否成功\",{\"1\":{\"247\":1}}],[\"查询用户信息\",{\"1\":{\"176\":1}}],[\"查询\",{\"0\":{\"159\":1},\"1\":{\"506\":1,\"511\":1}}],[\"查询有哪些设备\",{\"1\":{\"145\":1}}],[\"查询ffmpeg软件信息\",{\"0\":{\"144\":1}}],[\"查询视频总帧数\",{\"0\":{\"143\":1}}],[\"查询操作\",{\"0\":{\"142\":1}}],[\"查看autoconfigurationimportselector\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"查看更多面试题及答案\",{\"1\":{\"1093\":1}}],[\"查看本地主机的所用镜像\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"查看stash了哪些存储\",{\"1\":{\"916\":1}}],[\"查看slf4j日志\",{\"1\":{\"856\":1}}],[\"查看可以发现\",{\"1\":{\"916\":1}}],[\"查看控制台日志\",{\"1\":{\"856\":1}}],[\"查看日志\",{\"0\":{\"856\":1}}],[\"查看镜像是否打包成功\",{\"1\":{\"854\":1}}],[\"查看哈希表\",{\"1\":{\"605\":1}}],[\"查看\",{\"1\":{\"439\":2,\"692\":1,\"1228\":2,\"1403\":2}}],[\"查看结果\",{\"1\":{\"434\":1}}],[\"查看是否安装成功\",{\"1\":{\"412\":1,\"413\":1}}],[\"查看已注册服务\",{\"1\":{\"159\":1}}],[\"查看集群状态\",{\"1\":{\"116\":1}}],[\"查看文件92行前后20行\",{\"1\":{\"94\":1}}],[\"查看详情\",{\"1\":{\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1}}],[\"查找元素等操作的时间复杂度均为o\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"查找元素的所有位置\",{\"1\":{\"284\":1}}],[\"查找或者更新操作时\",{\"1\":{\"625\":1}}],[\"查找的复杂度都是o\",{\"1\":{\"607\":1}}],[\"查找的复杂度都是\",{\"1\":{\"606\":1}}],[\"查找指定元素的位置\",{\"1\":{\"284\":1}}],[\"查找位置\",{\"1\":{\"284\":1}}],[\"查找文件\",{\"1\":{\"94\":1}}],[\"查找运行的进程\",{\"1\":{\"94\":1}}],[\"常量\",{\"1\":{\"930\":2,\"1142\":1,\"1333\":1}}],[\"常数复杂度获取字符串长度\",{\"1\":{\"620\":1}}],[\"常见的方案就是\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"常见的策略有两种\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"常见的问题\",{\"1\":{\"1046\":1,\"1255\":1}}],[\"常见的缓存工具和框架列举如下\",{\"1\":{\"1045\":1,\"1254\":1}}],[\"常见的常见的缓存工具和框架有哪些\",{\"0\":{\"1045\":1,\"1254\":1}}],[\"常见的解决aba问题的方法是使用版本号或者时间戳\",{\"1\":{\"1018\":1}}],[\"常见的使用场景有\",{\"1\":{\"1018\":1}}],[\"常见的nosql产品有\",{\"1\":{\"588\":1}}],[\"常见问题解答\",{\"0\":{\"96\":1}}],[\"常见问题\",{\"1\":{\"1\":1}}],[\"常索引单位是单词\",{\"1\":{\"424\":1}}],[\"常用命令\",{\"1\":{\"1241\":1,\"1414\":1}}],[\"常用命令大全\",{\"0\":{\"94\":1}}],[\"常用选主机制的缺点\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"常用的命令\",{\"0\":{\"1241\":1,\"1414\":1}}],[\"常用的解决方案有\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"常用的\",{\"0\":{\"1151\":1,\"1342\":1}}],[\"常用实现类有\",{\"1\":{\"948\":1}}],[\"常用git\",{\"1\":{\"916\":1}}],[\"常用作缓存的一种技术\",{\"1\":{\"615\":1}}],[\"常用指令\",{\"0\":{\"160\":1},\"1\":{\"604\":1}}],[\"常用参数说明\",{\"1\":{\"127\":1}}],[\"放进\",{\"1\":{\"1186\":1,\"1369\":1}}],[\"放进master上的binlog中\",{\"1\":{\"1186\":1,\"1369\":1}}],[\"放进去\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"放入fruit\",{\"1\":{\"966\":1}}],[\"放入apple\",{\"1\":{\"966\":1}}],[\"放在\",{\"1\":{\"865\":1}}],[\"放图片\",{\"1\":{\"91\":1}}],[\"放文档\",{\"1\":{\"91\":1}}],[\"email\",{\"1\":{\"1444\":6}}],[\"emp5\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"emp4\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"emp3\",{\"1\":{\"1093\":2,\"1294\":2}}],[\"emp2\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"emp\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"employee\",{\"1\":{\"1093\":11,\"1294\":11}}],[\"emptydb\",{\"1\":{\"962\":1}}],[\"empty\",{\"1\":{\"353\":1}}],[\"effect\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"e系统设计的一种避免死锁产生的算法\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"ehcache\",{\"1\":{\"1045\":2,\"1048\":1,\"1254\":2,\"1257\":1}}],[\"eden\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"edt\",{\"1\":{\"1018\":1}}],[\"edu\",{\"1\":{\"157\":1,\"852\":1,\"896\":2,\"898\":1}}],[\"epoch\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"ephemeral\",{\"1\":{\"1008\":1}}],[\"epsilon等算法与案例\",{\"1\":{\"938\":1}}],[\"e2\",{\"1\":{\"831\":1}}],[\"e1\",{\"1\":{\"830\":2,\"831\":1}}],[\"evaluate\",{\"1\":{\"887\":2}}],[\"evaluation\",{\"1\":{\"887\":2}}],[\"evanjin\",{\"1\":{\"757\":1}}],[\"evan\",{\"1\":{\"737\":1,\"757\":1}}],[\"eviction\",{\"1\":{\"601\":1}}],[\"every\",{\"1\":{\"887\":4}}],[\"everyone\",{\"1\":{\"152\":1}}],[\"everything\",{\"1\":{\"90\":1}}],[\"eventloopgroup\",{\"1\":{\"1034\":1}}],[\"eventloop\",{\"1\":{\"1034\":1}}],[\"event=\",{\"1\":{\"865\":2}}],[\"events\",{\"1\":{\"106\":1}}],[\"even\",{\"1\":{\"112\":1}}],[\"ether\",{\"1\":{\"487\":1,\"488\":1}}],[\"etcdctl\",{\"1\":{\"115\":4,\"116\":1}}],[\"etcd\",{\"0\":{\"114\":1,\"115\":1},\"1\":{\"112\":2,\"114\":5,\"116\":2},\"2\":{\"117\":1,\"118\":1}}],[\"etc\",{\"1\":{\"94\":1,\"109\":1,\"125\":3,\"403\":1,\"852\":1}}],[\"erlang等客户端\",{\"1\":{\"589\":1}}],[\"erc721\",{\"1\":{\"484\":1}}],[\"erc20\",{\"1\":{\"484\":1}}],[\"errorlog\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"error错误\",{\"1\":{\"106\":1}}],[\"errors\",{\"1\":{\"106\":4,\"152\":1}}],[\"error\",{\"1\":{\"106\":10,\"143\":2,\"191\":2,\"196\":1,\"197\":1,\"285\":1,\"779\":1,\"829\":1,\"830\":7,\"831\":1,\"1431\":3}}],[\"earlysingletonobjects\",{\"1\":{\"1216\":2,\"1393\":2}}],[\"early\",{\"1\":{\"1216\":2,\"1393\":2}}],[\"eager\",{\"1\":{\"440\":1}}],[\"easy\",{\"1\":{\"152\":1}}],[\"es里面分布式search的查询流程\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"es里面分布式search的查询流程如下\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"es作为一个分布式的存储和检索系统\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"es的索引名不能改变\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"es字段数据类型\",{\"1\":{\"441\":1}}],[\"es映射的文件会很多\",{\"1\":{\"403\":1}}],[\"es\",{\"0\":{\"1068\":1,\"1272\":1},\"1\":{\"394\":1,\"404\":1,\"411\":1,\"428\":2,\"429\":1,\"431\":1,\"434\":1,\"439\":4,\"441\":2,\"443\":2,\"445\":2,\"446\":1,\"450\":2,\"451\":1,\"457\":1,\"460\":1,\"1071\":1,\"1275\":1}}],[\"es集群\",{\"0\":{\"406\":1},\"1\":{\"394\":1}}],[\"especially\",{\"1\":{\"152\":1}}],[\"e技能\",{\"1\":{\"329\":1}}],[\"equals与==区别\",{\"0\":{\"1087\":1,\"1288\":1}}],[\"equals\",{\"1\":{\"285\":3,\"286\":4,\"831\":1,\"922\":1,\"948\":1,\"952\":1,\"1008\":1,\"1020\":1,\"1087\":12,\"1288\":12}}],[\"e>\",{\"1\":{\"284\":1,\"285\":2,\"286\":2}}],[\"exnteds\",{\"1\":{\"1090\":2,\"1291\":2}}],[\"exactly\",{\"1\":{\"887\":1}}],[\"example<\",{\"1\":{\"844\":1}}],[\"exampleplugin\",{\"1\":{\"770\":3}}],[\"example\",{\"1\":{\"766\":1,\"770\":1,\"844\":1,\"904\":1,\"936\":7,\"958\":1,\"1101\":1,\"1299\":1}}],[\"ex\",{\"1\":{\"603\":1,\"952\":1,\"1092\":1,\"1206\":1,\"1293\":1,\"1386\":1}}],[\"exec\",{\"1\":{\"856\":1}}],[\"executeupdate\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"executequery\",{\"1\":{\"737\":1}}],[\"executor\",{\"1\":{\"770\":4,\"864\":1,\"1179\":3,\"1364\":3}}],[\"execution方式可以用路径表达式指定对哪些方法拦截\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"executions>\",{\"1\":{\"844\":1}}],[\"execution>\",{\"1\":{\"844\":1}}],[\"execution\",{\"1\":{\"689\":1,\"830\":2,\"831\":7,\"1143\":1,\"1334\":1}}],[\"exe\",{\"1\":{\"597\":2,\"887\":1}}],[\"exchange\",{\"1\":{\"924\":9}}],[\"exclusivegateway>\",{\"1\":{\"865\":1}}],[\"exclusive\",{\"1\":{\"575\":1}}],[\"exclusion\",{\"1\":{\"562\":1,\"1106\":1,\"1304\":1}}],[\"exception异常前先catch住再抛出\",{\"1\":{\"830\":1}}],[\"exceptions\",{\"1\":{\"779\":1}}],[\"exception\",{\"1\":{\"196\":2,\"197\":1,\"352\":4,\"364\":2,\"648\":3,\"692\":2,\"737\":1,\"747\":1,\"757\":6,\"763\":1,\"785\":1,\"786\":1,\"787\":1,\"793\":2,\"794\":1,\"795\":1,\"828\":5,\"829\":4,\"830\":5,\"831\":3,\"876\":4,\"934\":1,\"956\":5,\"1044\":1,\"1092\":5,\"1101\":1,\"1104\":1,\"1127\":1,\"1253\":1,\"1293\":5,\"1299\":1,\"1302\":1,\"1320\":1,\"1431\":1}}],[\"exists\",{\"0\":{\"535\":1},\"1\":{\"535\":1,\"603\":3,\"736\":1,\"824\":2,\"960\":1,\"1192\":1,\"1375\":1}}],[\"extension\",{\"1\":{\"934\":3}}],[\"extensionelements>\",{\"1\":{\"865\":3}}],[\"extendedtypesenabled\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"extendedlength\",{\"1\":{\"285\":5}}],[\"extendedcapacity\",{\"1\":{\"285\":2}}],[\"extends\",{\"1\":{\"284\":1,\"285\":2,\"286\":2,\"692\":2,\"793\":1,\"828\":2,\"829\":3,\"830\":1,\"928\":1,\"932\":1,\"934\":3,\"946\":1,\"956\":1,\"966\":9,\"1104\":3,\"1107\":3,\"1302\":3,\"1305\":3}}],[\"extern\",{\"1\":{\"689\":1}}],[\"ext4\",{\"1\":{\"272\":1}}],[\"expectmodcount\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"expectedmodcount\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"expense\",{\"1\":{\"865\":4,\"866\":4}}],[\"expenseprocess\",{\"1\":{\"865\":2}}],[\"expungestaleentry\",{\"1\":{\"928\":2}}],[\"expungestaleentries\",{\"1\":{\"928\":3}}],[\"expressionlanguage=\",{\"1\":{\"865\":1}}],[\"expiration\",{\"1\":{\"664\":1}}],[\"expire\",{\"1\":{\"603\":2,\"664\":3,\"970\":1}}],[\"expires\",{\"1\":{\"106\":4}}],[\"explain\",{\"1\":{\"501\":2,\"525\":1}}],[\"exposure\",{\"1\":{\"885\":1}}],[\"expose\",{\"1\":{\"850\":1}}],[\"exposes\",{\"1\":{\"152\":1}}],[\"exporter\",{\"1\":{\"883\":2}}],[\"export\",{\"1\":{\"125\":2,\"885\":1}}],[\"eb21c081\",{\"1\":{\"178\":1}}],[\"eldest\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"elastic\",{\"1\":{\"400\":1,\"419\":1,\"431\":1,\"435\":1,\"457\":1,\"1067\":1,\"1072\":1,\"1073\":1,\"1276\":1,\"1277\":1}}],[\"elasticsearch搜索文档过程\",{\"0\":{\"1014\":1}}],[\"elasticsearch能够高效地处理大量的文档和复杂的搜索需求\",{\"1\":{\"1012\":1}}],[\"elasticsearch可以从磁盘中读取文档内容并返回给我们\",{\"1\":{\"1012\":1}}],[\"elasticsearch索引文档底层过程\",{\"0\":{\"1012\":1}}],[\"elasticsearch会将原始文档和相关的元数据存储在磁盘上\",{\"1\":{\"1012\":1}}],[\"elasticsearch会将文档的副本分配给其他节点上的分片\",{\"1\":{\"1012\":1}}],[\"elasticsearch会将文档内容进行分析\",{\"1\":{\"1012\":1}}],[\"elasticsearch会使用分布式写入协调器来确保数据的一致性\",{\"1\":{\"1012\":1}}],[\"elasticsearch会为每个词条创建倒排索引\",{\"1\":{\"1012\":1}}],[\"elasticsearch会根据文档的路由值确定将文档索引到哪个分片\",{\"1\":{\"1012\":1}}],[\"elasticsearch会根据一定的规则将数据均匀地分配到不同的分片上\",{\"1\":{\"1004\":1}}],[\"elasticsearch会执行以下几个步骤\",{\"1\":{\"1012\":1}}],[\"elasticsearch会自动处理选主过程\",{\"1\":{\"1008\":1}}],[\"elasticsearch会如何重新选举新的主节点\",{\"1\":{\"1008\":1}}],[\"elasticsearch选主\",{\"0\":{\"1008\":1}}],[\"elasticsearch倒排索引\",{\"0\":{\"1006\":1},\"1\":{\"1006\":1}}],[\"elasticsearch集群就像是一个大家庭\",{\"1\":{\"1004\":1}}],[\"elasticsearch集群是如何工作的呢\",{\"1\":{\"1004\":1}}],[\"elasticsearch集群索引分片\",{\"0\":{\"1004\":1}}],[\"elasticsearch就像是一群小伙伴组成的团队\",{\"1\":{\"1004\":1}}],[\"elasticsearch不仅仅是一个搜索引擎\",{\"1\":{\"1002\":1}}],[\"elasticsearch提供了缓存机制\",{\"1\":{\"1002\":1}}],[\"elasticsearch将搜索请求发送到所有相关的分片上\",{\"1\":{\"1002\":1}}],[\"elasticsearch使用tf\",{\"1\":{\"1002\":1}}],[\"elasticsearch使用倒排索引来加速搜索\",{\"1\":{\"1002\":1}}],[\"elasticsearch使用分片和复制机制来实现数据的分布式存储和高可用性\",{\"1\":{\"1000\":1}}],[\"elasticsearch的应用非常广泛\",{\"1\":{\"1002\":1}}],[\"elasticsearch的性能优化\",{\"1\":{\"1002\":1}}],[\"elasticsearch的搜索原理可以简单概括为以下几个步骤\",{\"1\":{\"1002\":1}}],[\"elasticsearch的搜索原理\",{\"1\":{\"1002\":1}}],[\"elasticsearch的核心组件包括\",{\"1\":{\"1002\":1}}],[\"elasticsearch的核心组件\",{\"1\":{\"1002\":1}}],[\"elasticsearch的核心概念包括索引\",{\"1\":{\"998\":1}}],[\"elasticsearch架构设计\",{\"0\":{\"1002\":1}}],[\"elasticsearch通过提供restful\",{\"1\":{\"1000\":1}}],[\"elasticsearch通过文件映射\",{\"1\":{\"403\":1}}],[\"elasticsearch实际上是在lucene的基础上构建的\",{\"1\":{\"1000\":1}}],[\"elasticsearch和lucene\",{\"0\":{\"1000\":1}}],[\"elasticsearch是一个基于lucene构建的分布式搜索和分析引擎\",{\"1\":{\"1000\":1}}],[\"elasticsearch是一个开源的分布式搜索和分析引擎\",{\"1\":{\"998\":1,\"1002\":1}}],[\"elasticsearch是个非常强大且灵活的工具\",{\"1\":{\"998\":1}}],[\"elasticsearch还支持聚合\",{\"1\":{\"998\":1}}],[\"elasticsearch真是太棒了\",{\"1\":{\"998\":1}}],[\"elasticsearch基础\",{\"0\":{\"998\":1}}],[\"elasticsearch中的最小的数据存储单元\",{\"1\":{\"420\":1}}],[\"elasticsearch核心概念\",{\"0\":{\"415\":1},\"1\":{\"394\":1}}],[\"elasticsearch\",{\"0\":{\"391\":1,\"399\":1,\"400\":1,\"1069\":1,\"1070\":1,\"1071\":1,\"1072\":1,\"1073\":1,\"1074\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1271\":1,\"1273\":1,\"1274\":1,\"1275\":1,\"1276\":1,\"1277\":1,\"1278\":1,\"1280\":1,\"1281\":1,\"1282\":1},\"1\":{\"159\":16,\"394\":1,\"397\":2,\"400\":4,\"402\":1,\"405\":4,\"406\":1,\"407\":1,\"411\":2,\"412\":3,\"413\":2,\"414\":1,\"416\":1,\"417\":1,\"419\":2,\"422\":1,\"428\":1,\"431\":1,\"435\":1,\"440\":2,\"457\":1,\"460\":1,\"507\":1,\"524\":1,\"884\":1,\"998\":1,\"1067\":1,\"1070\":1,\"1071\":1,\"1072\":1,\"1073\":1,\"1075\":1,\"1076\":2,\"1077\":1,\"1079\":1,\"1274\":1,\"1275\":1,\"1276\":1,\"1277\":1,\"1279\":1,\"1280\":2,\"1281\":1,\"1283\":1},\"2\":{\"392\":1,\"393\":1,\"395\":1,\"396\":1,\"409\":1,\"410\":1,\"426\":1,\"427\":1,\"458\":1,\"459\":1,\"476\":1,\"477\":1,\"1082\":1,\"1424\":1,\"1428\":1}}],[\"elementdata\",{\"1\":{\"946\":5,\"988\":2}}],[\"elementtype\",{\"1\":{\"688\":1,\"944\":9,\"1092\":2,\"1293\":2}}],[\"element\",{\"1\":{\"659\":2}}],[\"elements\",{\"1\":{\"353\":2}}],[\"elemdata\",{\"1\":{\"285\":26}}],[\"elem\",{\"1\":{\"284\":10,\"285\":12,\"286\":34}}],[\"election方案解决了上述问题\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"election\",{\"1\":{\"157\":1,\"1008\":2}}],[\"elections\",{\"1\":{\"112\":1}}],[\"else\",{\"1\":{\"200\":2,\"267\":1,\"285\":3,\"286\":4,\"288\":4,\"289\":4,\"337\":1,\"352\":1,\"353\":1,\"388\":1,\"648\":1,\"787\":2,\"830\":2,\"922\":4,\"924\":1,\"928\":3,\"940\":1,\"946\":1,\"958\":1,\"1008\":1,\"1020\":2,\"1044\":1,\"1085\":1,\"1253\":1,\"1286\":1,\"1431\":1}}],[\"else的八种方案\",{\"0\":{\"172\":1}}],[\"elk\",{\"1\":{\"196\":1,\"400\":1}}],[\"env\",{\"1\":{\"885\":1}}],[\"environments\",{\"0\":{\"771\":1}}],[\"environments>\",{\"1\":{\"743\":1,\"745\":1}}],[\"environment\",{\"1\":{\"766\":1,\"950\":1,\"1230\":1,\"1405\":1}}],[\"environment>\",{\"1\":{\"743\":2,\"745\":1}}],[\"enum中的注解呢\",{\"1\":{\"944\":1}}],[\"enummap\",{\"1\":{\"922\":1}}],[\"enum\",{\"1\":{\"829\":1,\"944\":2,\"1431\":1}}],[\"enums\",{\"1\":{\"829\":3,\"830\":1,\"831\":1}}],[\"entryset\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"entrylist\",{\"1\":{\"1023\":2}}],[\"entry<string\",{\"1\":{\"1044\":2,\"1253\":2}}],[\"entry<>\",{\"1\":{\"948\":1}}],[\"entry<k\",{\"1\":{\"948\":2,\"1044\":2,\"1253\":2}}],[\"entry\",{\"1\":{\"922\":1,\"928\":13,\"1044\":1,\"1253\":1}}],[\"entrypoint\",{\"1\":{\"850\":1}}],[\"entries\",{\"1\":{\"143\":2}}],[\"enter\",{\"1\":{\"837\":1}}],[\"entity\",{\"1\":{\"815\":1,\"817\":1,\"825\":3,\"826\":2,\"828\":2,\"829\":1,\"830\":3,\"831\":1,\"1444\":2}}],[\"engine\",{\"1\":{\"526\":1,\"581\":1,\"852\":2,\"1143\":1,\"1334\":1}}],[\"engine=innodb\",{\"1\":{\"511\":1,\"577\":1,\"726\":1,\"736\":1,\"792\":1,\"795\":3,\"824\":2}}],[\"engine=myisam\",{\"1\":{\"507\":1}}],[\"english\",{\"1\":{\"437\":4}}],[\"enough\",{\"1\":{\"487\":1,\"488\":1}}],[\"en\",{\"1\":{\"343\":1,\"419\":1,\"431\":1,\"457\":1,\"526\":1,\"527\":3,\"548\":1,\"743\":1,\"744\":1,\"745\":1,\"755\":1,\"763\":1,\"782\":1,\"817\":1,\"827\":2}}],[\"enqueue|push\",{\"1\":{\"287\":1}}],[\"ensurecapacityinternal\",{\"1\":{\"946\":1}}],[\"ensurecapacity\",{\"1\":{\"285\":4}}],[\"endpoint\",{\"1\":{\"887\":1}}],[\"endpoints\",{\"1\":{\"885\":1}}],[\"endevent>\",{\"1\":{\"865\":1}}],[\"enddatetime\",{\"1\":{\"800\":2,\"801\":1}}],[\"end\",{\"1\":{\"192\":1,\"724\":1,\"725\":1,\"727\":4,\"800\":3,\"865\":5,\"952\":2}}],[\"encode\",{\"1\":{\"876\":2}}],[\"encoder>\",{\"1\":{\"821\":1}}],[\"encoder\",{\"1\":{\"821\":1}}],[\"encoders\",{\"1\":{\"144\":1,\"821\":1}}],[\"encoding>\",{\"1\":{\"844\":1}}],[\"encoding=\",{\"1\":{\"743\":1,\"744\":1,\"745\":1,\"755\":1,\"763\":1,\"782\":1,\"812\":1,\"815\":1,\"817\":1,\"818\":1,\"819\":1,\"821\":1,\"827\":2,\"844\":1,\"865\":1}}],[\"encoding\",{\"1\":{\"106\":1,\"183\":1,\"630\":1,\"635\":2,\"824\":1}}],[\"enableautoconfiguration=\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"enableautoconfiguration\",{\"1\":{\"944\":1,\"1227\":1,\"1228\":3,\"1402\":1,\"1403\":3}}],[\"enabletransactionmanagement\",{\"1\":{\"944\":1}}],[\"enabled\",{\"1\":{\"158\":1,\"406\":3,\"440\":1,\"885\":1}}],[\"enable\",{\"1\":{\"125\":1,\"440\":2,\"944\":1}}],[\"enhance\",{\"1\":{\"31\":1}}],[\"e\",{\"1\":{\"94\":1,\"196\":6,\"197\":2,\"284\":9,\"285\":12,\"286\":13,\"329\":1,\"388\":1,\"648\":6,\"702\":1,\"830\":4,\"831\":1,\"876\":4,\"883\":1,\"917\":2,\"922\":15,\"928\":22,\"932\":2,\"946\":3,\"988\":4,\"1044\":6,\"1068\":1,\"1104\":4,\"1105\":4,\"1107\":4,\"1214\":1,\"1253\":6,\"1272\":1,\"1302\":4,\"1303\":4,\"1305\":4,\"1391\":1,\"1431\":1}}],[\"一项重要功能\",{\"1\":{\"1231\":1,\"1406\":1}}],[\"一项或多项\",{\"1\":{\"178\":1}}],[\"一种可能的解决方案是编辑由setter而不是构造函数配置的某些类的源代码\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"一种是类名中含有wrapper\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"一种方法是使用\",{\"1\":{\"1022\":1}}],[\"一锁二查三更新\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"一张经典的图\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"一方面是因为\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"一是可见性\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"一是插入操作\",{\"1\":{\"282\":1}}],[\"一辆从\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"一图胜千文\",{\"1\":{\"1071\":1,\"1142\":1,\"1179\":1,\"1275\":1,\"1333\":1,\"1364\":1}}],[\"一图顶千文\",{\"1\":{\"919\":1}}],[\"一起合作来处理海量数据\",{\"1\":{\"1004\":1}}],[\"一直追加\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"一直在循环注入过程中\",{\"1\":{\"954\":1}}],[\"一直下一步\",{\"1\":{\"899\":1}}],[\"一名\",{\"1\":{\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1022\":1}}],[\"一通狂写git\",{\"1\":{\"917\":1}}],[\"一小时后上线\",{\"1\":{\"916\":1}}],[\"一大早领导甲某分配给p哥一个需求\",{\"1\":{\"916\":1}}],[\"一条条试\",{\"1\":{\"896\":1}}],[\"一条记录update一次\",{\"1\":{\"722\":1}}],[\"一对多查询\",{\"0\":{\"794\":1},\"1\":{\"794\":1}}],[\"一对多的关系\",{\"1\":{\"457\":1}}],[\"一对一查询\",{\"0\":{\"793\":1}}],[\"一级缓存也会被清空\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"一级缓存是\",{\"1\":{\"958\":2}}],[\"一级缓存满足条件\",{\"1\":{\"789\":1}}],[\"一级缓存默认是开启的\",{\"1\":{\"789\":1}}],[\"一级缓存\",{\"0\":{\"789\":1},\"1\":{\"1178\":1,\"1363\":1}}],[\"一号图片\",{\"1\":{\"738\":1}}],[\"一一对应的情况\",{\"1\":{\"723\":1}}],[\"一家独有\",{\"1\":{\"659\":1}}],[\"一年的签到只需要\",{\"1\":{\"658\":1}}],[\"一致性级别支持\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"一致性\",{\"1\":{\"553\":1,\"1087\":1,\"1187\":1,\"1240\":1,\"1288\":1,\"1370\":1,\"1413\":1}}],[\"一定有一种适合你的\",{\"1\":{\"895\":1}}],[\"一定想上手试试\",{\"1\":{\"807\":1}}],[\"一定不要以为它们不重要\",{\"1\":{\"602\":1}}],[\"一定耐心看完\",{\"1\":{\"600\":1}}],[\"一定会带来开销\",{\"1\":{\"500\":1}}],[\"一定用得上\",{\"1\":{\"493\":1,\"552\":1}}],[\"一定要有状态码\",{\"1\":{\"1431\":1}}],[\"一定要掌握\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"一定要了解为什么要用kafka\",{\"1\":{\"1155\":1,\"1343\":1}}],[\"一定要看\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"一定要加\",{\"1\":{\"826\":1}}],[\"一定要阅读这篇官方英文文档\",{\"1\":{\"419\":1}}],[\"一定要错误码\",{\"1\":{\"186\":1}}],[\"一定要写清楚\",{\"1\":{\"178\":1}}],[\"一些最常用的指令如下\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"一些高性能查询的场景\",{\"1\":{\"655\":1}}],[\"一些要点\",{\"1\":{\"436\":1}}],[\"一些信息\",{\"1\":{\"94\":1}}],[\"一旦这些数据的状态发生变化\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"一旦标记完成之后就会恢复之前被暂停的所有应用线程\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"一旦使用\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"一旦协调节点接收到所有的结果文档\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"一旦所有的文档都被取回了\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"一旦所有的副本分片都报告成功\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"一旦zookeeper选出了主节点\",{\"1\":{\"1008\":1}}],[\"一旦强转错了类型\",{\"1\":{\"966\":1}}],[\"一旦有条件成立的when\",{\"1\":{\"785\":1}}],[\"一旦指定就不能再修改了\",{\"1\":{\"421\":1}}],[\"一旦确定了leader\",{\"1\":{\"166\":1}}],[\"一篇新闻的文档数据\",{\"1\":{\"420\":1}}],[\"一篇简单的布隆过滤器\",{\"1\":{\"337\":1}}],[\"一\",{\"0\":{\"397\":1},\"1\":{\"411\":1}}],[\"一棵深度为k的有n个结点的二叉树\",{\"1\":{\"364\":1}}],[\"一书中展示了不同情况下的误判率\",{\"1\":{\"339\":1}}],[\"一端做push\",{\"1\":{\"288\":1}}],[\"一次性创建了所有的bean\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"一次性传输10mb的消息比传输1kb的消息10000万次显然要快得多\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"一次限定在64kb之内\",{\"1\":{\"1135\":1,\"1328\":1}}],[\"一次请求\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"一次赋值\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"一次学会终身受益\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"一次只能被一个事务占用\",{\"1\":{\"562\":1}}],[\"一次磁盘\",{\"1\":{\"270\":1}}],[\"一次读取若干个\",{\"1\":{\"266\":1}}],[\"一键安装\",{\"1\":{\"247\":1,\"643\":1}}],[\"一样也是\",{\"1\":{\"607\":1}}],[\"一样\",{\"1\":{\"145\":2,\"589\":1,\"656\":1,\"988\":1,\"1100\":1,\"1244\":1,\"1298\":1,\"1417\":1}}],[\"一般很少用到\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"一般命名为\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"一般不会作为消费队列\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"一般问这个问题你最少要答出以下几点\",{\"1\":{\"1198\":1,\"1378\":1}}],[\"一般的做法是在需要锁的数据上增加一个版本号\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"一般查询日志\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"一般情况都是用中间件作为缓存层\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"一般情况下\",{\"1\":{\"624\":1}}],[\"一般堆大小远远大于栈\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"一般现在\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"一般比较常用的有\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"一般都会把aio和nio\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"一般都会搭建以\",{\"1\":{\"594\":1}}],[\"一般建议不要超过\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"一般可以bitmap和hyperloglog配合使用\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"一般可以存放在时序数据库中\",{\"1\":{\"883\":1}}],[\"一般可不指定\",{\"1\":{\"715\":1}}],[\"一般\",{\"1\":{\"844\":1}}],[\"一般第一段为域\",{\"1\":{\"838\":1,\"839\":1}}],[\"一般分为多个段\",{\"1\":{\"838\":1,\"839\":1}}],[\"一般和前端通过接口数据交互\",{\"1\":{\"831\":1}}],[\"一般保证命名空间唯一\",{\"1\":{\"744\":1,\"755\":1,\"763\":1}}],[\"一般eclipse找不到parent项目时可以先update\",{\"1\":{\"715\":1}}],[\"一般性能问题第一道就是数据库扛不住了\",{\"1\":{\"616\":1}}],[\"一般用xml绑定的比较多\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"一般用于对返回值做些加工处理的场景\",{\"1\":{\"689\":1}}],[\"一般用\",{\"1\":{\"536\":1}}],[\"一般会将写请求转发到master\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"一般会有以下几种常见的情况\",{\"1\":{\"501\":1}}],[\"一般会对b+树做一些优化\",{\"1\":{\"269\":1}}],[\"一般存储合约的所有者地址\",{\"1\":{\"488\":1}}],[\"一般存放令牌信息\",{\"1\":{\"183\":1}}],[\"一般也不会超过\",{\"1\":{\"387\":1}}],[\"一般而言\",{\"1\":{\"267\":1}}],[\"一般而言内存访问的时间约为\",{\"1\":{\"266\":1}}],[\"一般为\",{\"1\":{\"266\":2}}],[\"一般一棵b\",{\"1\":{\"266\":1}}],[\"一般一棵\",{\"1\":{\"263\":1}}],[\"一般一个请求的头部大小不会超过1k\",{\"1\":{\"106\":1}}],[\"一般一个请求头的大小不会超过1k\",{\"1\":{\"106\":1}}],[\"一般由开发人员关注\",{\"1\":{\"191\":1}}],[\"一般是项目开发中的最后一步\",{\"1\":{\"1439\":1}}],[\"一般是项目名\",{\"1\":{\"838\":1,\"839\":1}}],[\"一般是通过为数据库表增加一个数字类型的\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"一般是新生代和老年代\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"一般是我们的id生成器开始使用的时间\",{\"1\":{\"388\":1}}],[\"一般是\",{\"1\":{\"180\":1}}],[\"一般来说需求都是由业务人员收集业务痛点\",{\"1\":{\"1439\":1}}],[\"一般来说我们在\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"一般来说\",{\"1\":{\"177\":1,\"271\":1,\"516\":1,\"520\":1,\"628\":1,\"1010\":1,\"1051\":1,\"1190\":1,\"1260\":1,\"1373\":1}}],[\"一般2是高质量\",{\"1\":{\"141\":1}}],[\"一般音频的码率只有固定几种\",{\"1\":{\"134\":1}}],[\"一切皆文件\",{\"1\":{\"90\":1}}],[\"一个需求从产生到完成生命周期是什么样的\",{\"1\":{\"1439\":1}}],[\"一个是保持独占\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"一个是数组与链表底层实现的不同\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"一个完整的项目被拆分成多个不相同的独立的服务\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"一个完整的docker由哪些部分组成\",{\"0\":{\"1061\":1,\"1267\":1}}],[\"一个切面可以由多个切点和通知组成\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"一个连接点总代表一个方法的执行\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"一个控制反转和面向切面的容器框架\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"一个\",{\"0\":{\"1175\":1,\"1360\":1},\"1\":{\"1159\":3,\"1347\":3}}],[\"一个非常大的\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"一个逻辑上的概念\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"一个典型的\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"一个线程引用锁的时候\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"一个线程对象调用了sleep方法之后\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"一个使用docker容器的应用\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"一个eventloop可以为多个channel服务\",{\"1\":{\"1034\":1}}],[\"一个最基本的\",{\"1\":{\"1033\":1}}],[\"一个简单的方法是通过调整\",{\"1\":{\"982\":1}}],[\"一个常见的优化方式是使用lua脚本来减少网络开销\",{\"1\":{\"970\":1}}],[\"一个子进程来进行持久化\",{\"1\":{\"962\":1}}],[\"一个参数的时候\",{\"1\":{\"763\":2}}],[\"一个月最多只有\",{\"1\":{\"658\":1}}],[\"一个群友给我发消息\",{\"1\":{\"652\":1}}],[\"一个用作值\",{\"1\":{\"635\":1}}],[\"一个用作键\",{\"1\":{\"635\":1}}],[\"一个用于平时使用\",{\"1\":{\"626\":1}}],[\"一个哈希表里面可以有多个哈希表节点\",{\"1\":{\"624\":1}}],[\"一个列表最多可以包含\",{\"1\":{\"604\":1}}],[\"一个有趣的操作\",{\"1\":{\"603\":1}}],[\"一个表的索引数最好不要超过6个\",{\"1\":{\"537\":1}}],[\"一个文档可以嵌套多个\",{\"1\":{\"450\":1}}],[\"一个不分词\",{\"1\":{\"440\":1}}],[\"一个分区只能由一个组内消费者消费\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"一个分词\",{\"1\":{\"440\":1}}],[\"一个分布式近实时分析搜索引擎\",{\"1\":{\"400\":1}}],[\"一个分布式的实时文档存储\",{\"1\":{\"400\":1}}],[\"一个索引文件和一个数据文件\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"一个索引只有一个\",{\"1\":{\"429\":1}}],[\"一个索引下是可以有多个\",{\"1\":{\"429\":1}}],[\"一个shard可以有一个或者多个replica\",{\"1\":{\"422\":1}}],[\"一个集群中可以有多个索引\",{\"1\":{\"418\":1}}],[\"一个磁盘由大小相同且同轴的圆形盘片组成\",{\"1\":{\"274\":1}}],[\"一个页的大小是16k\",{\"1\":{\"272\":1}}],[\"一个块的大小是4k\",{\"1\":{\"272\":1}}],[\"一个扇区的大小是512字节\",{\"1\":{\"272\":1}}],[\"一个节点就一个值\",{\"1\":{\"266\":1}}],[\"一个团队里面\",{\"1\":{\"153\":1}}],[\"一个对象是无法保证顺序性的\",{\"1\":{\"84\":1}}],[\"一个创业程序员的35岁人生人生总结\",{\"1\":{\"10\":1}}],[\"一个虚幻而真实的金融世界\",{\"1\":{\"10\":1}}],[\"有客户说\",{\"1\":{\"1439\":1}}],[\"有个学妹自学了半年编程\",{\"1\":{\"1439\":1}}],[\"有个老六在定义了一个状态码\",{\"1\":{\"1431\":1}}],[\"有同学会问\",{\"1\":{\"1431\":1}}],[\"有相关的读写操作时\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"有相似之处\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"有继承关系\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"有共享锁和排他锁\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"有共识就有价值\",{\"1\":{\"483\":1}}],[\"有配置\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"有配置时\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"有大小限制\",{\"1\":{\"1135\":1,\"1328\":1}}],[\"有大量的并发请求过来\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"有loginrequired注解说明需要登录\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"有使用过注解吗\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"有局限性\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"有限制的\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"有两种方案可以解决\",{\"1\":{\"1047\":1,\"1049\":1,\"1256\":1,\"1258\":1}}],[\"有两种字符串类型\",{\"1\":{\"443\":1}}],[\"有完整的\",{\"1\":{\"1032\":1}}],[\"有更高的吞吐量\",{\"1\":{\"1032\":1}}],[\"有消息会通知你\",{\"1\":{\"1023\":1}}],[\"有三个线程\",{\"0\":{\"1107\":1,\"1305\":1}}],[\"有三个级别可供选择\",{\"1\":{\"994\":1}}],[\"有三种情况会触发类的初始化\",{\"1\":{\"934\":1}}],[\"有几种常见的解决hashmap线程不安全的方法\",{\"1\":{\"988\":1}}],[\"有的是数据节点\",{\"1\":{\"1004\":1}}],[\"有的是主节点\",{\"1\":{\"1004\":1}}],[\"有的话直接返回\",{\"1\":{\"958\":1}}],[\"有的同学可能在测试上面代码的时候程序可以正常退出\",{\"1\":{\"692\":1}}],[\"有的同学说\",{\"1\":{\"90\":1}}],[\"有很深入的理解\",{\"1\":{\"956\":1}}],[\"有很好的性能\",{\"1\":{\"385\":1}}],[\"有以下几点建议\",{\"1\":{\"950\":1}}],[\"有哪些优点\",{\"0\":{\"1225\":1,\"1400\":1}}],[\"有哪些实现方式\",{\"0\":{\"1180\":1,\"1365\":1}}],[\"有哪些动态\",{\"0\":{\"1177\":1,\"1362\":1}}],[\"有哪些垃圾回收器\",{\"0\":{\"1147\":1,\"1338\":1}}],[\"有哪些垃圾回收算法\",{\"0\":{\"1146\":1,\"1337\":1}}],[\"有哪些内置对象\",{\"0\":{\"1127\":1,\"1320\":1}}],[\"有哪些用法\",{\"0\":{\"1091\":1,\"1292\":1}}],[\"有哪些常见问题\",{\"0\":{\"1046\":1,\"1255\":1}}],[\"有哪些项目信息\",{\"1\":{\"699\":1}}],[\"有哪几个阶段会触发类初始化\",{\"1\":{\"934\":1}}],[\"有多个可替代的map实现供选择\",{\"1\":{\"922\":1}}],[\"有多个模块时\",{\"1\":{\"844\":1}}],[\"有什么作用\",{\"0\":{\"1158\":1,\"1346\":1}}],[\"有什么不同\",{\"0\":{\"1104\":1,\"1106\":1,\"1302\":1,\"1304\":1}}],[\"有什么特点\",{\"0\":{\"1090\":1,\"1291\":1}}],[\"有什么优势呢\",{\"1\":{\"992\":1}}],[\"有什么用\",{\"0\":{\"1177\":1,\"1362\":1},\"1\":{\"920\":1}}],[\"有什么区别\",{\"0\":{\"1113\":1,\"1115\":1,\"1308\":1,\"1310\":1},\"1\":{\"104\":1,\"966\":1,\"1018\":1,\"1027\":1}}],[\"有趣\",{\"1\":{\"920\":1}}],[\"有需要帮助请留言\",{\"1\":{\"832\":1}}],[\"有了\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"有了这两项技术\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"有了这个统计结果\",{\"1\":{\"359\":1}}],[\"有了cgroup就可以控制容器中进程对系统资源的消耗了\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"有了解吗\",{\"1\":{\"928\":1}}],[\"有了一定了解\",{\"1\":{\"807\":1}}],[\"有问题\",{\"1\":{\"779\":1}}],[\"有clean生命周期\",{\"1\":{\"712\":1}}],[\"有没有其他关于选主的问题想要问我的呢\",{\"1\":{\"1008\":1}}],[\"有没有其他的建议或技巧可以分享给我们呢\",{\"1\":{\"984\":1}}],[\"有没有其他的建议\",{\"1\":{\"982\":1}}],[\"有没有什么源码方面的知识可以分享一下\",{\"1\":{\"1004\":1}}],[\"有没有什么想补充的\",{\"1\":{\"1002\":1}}],[\"有没有什么问题想问我的\",{\"1\":{\"992\":1}}],[\"有没有什么其他的问题你想问我的\",{\"1\":{\"980\":1}}],[\"有没有什么其他问题或者想法\",{\"1\":{\"970\":1}}],[\"有没有什么需要注意的地方呢\",{\"1\":{\"970\":1,\"990\":1}}],[\"有没有注意到\",{\"1\":{\"624\":1}}],[\"有没有发现上面的命令大多都是对文件的操作\",{\"1\":{\"90\":1}}],[\"有一点我们要注意\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"有一定了解\",{\"1\":{\"1041\":1}}],[\"有一定的了解\",{\"1\":{\"956\":1}}],[\"有一定工作经验的技术人\",{\"1\":{\"523\":1}}],[\"有一些共同的方法\",{\"1\":{\"946\":1}}],[\"有一个学生对象\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"有一个关键字\",{\"1\":{\"692\":1}}],[\"有一个\",{\"1\":{\"429\":1}}],[\"有一个整体认识和实践实战\",{\"1\":{\"411\":1,\"428\":1,\"460\":1}}],[\"有索引\",{\"1\":{\"501\":1}}],[\"有利于磁盘的顺序访问\",{\"1\":{\"499\":1}}],[\"有利于快速定位问题原因\",{\"1\":{\"201\":1}}],[\"有时为了监控sql执行效率\",{\"1\":{\"770\":1}}],[\"有时也叫它二级索引\",{\"1\":{\"497\":1}}],[\"有时候需要去新的表去查询数据\",{\"1\":{\"779\":1}}],[\"有时候需要获取一些公共的配置\",{\"1\":{\"162\":1}}],[\"有时候从历史表中去查询数据\",{\"1\":{\"779\":1}}],[\"有时候\",{\"1\":{\"140\":1,\"504\":1}}],[\"有人气了就有共识\",{\"1\":{\"483\":1}}],[\"有人问rodert哥这篇文章干货有多干\",{\"1\":{\"121\":1}}],[\"有且仅有\",{\"1\":{\"434\":1}}],[\"有如下几种方式来实现\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"有如下操作方法\",{\"1\":{\"660\":1}}],[\"有如下\",{\"1\":{\"433\":1}}],[\"有色趋势很不错\",{\"1\":{\"408\":1}}],[\"有些面试官喜欢问\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"有些应用需要根据事件来触发相应的操作\",{\"1\":{\"976\":1}}],[\"有些应用需要实时地处理大量的数据流\",{\"1\":{\"976\":1}}],[\"有些业务场景\",{\"1\":{\"432\":1}}],[\"有些情况会使用我们自己的分词服务\",{\"1\":{\"414\":1}}],[\"有些地方从github下载网络不好\",{\"1\":{\"412\":1,\"413\":1}}],[\"有些双向引用的数据\",{\"1\":{\"383\":1}}],[\"有些接口参数涉及到隐私和敏感数据\",{\"1\":{\"184\":1}}],[\"有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序\",{\"1\":{\"348\":1}}],[\"有可能在同一台主机也有可能在不同的主机上\",{\"1\":{\"165\":1}}],[\"有兴趣的同学可以参考维基英文页面\",{\"1\":{\"339\":1}}],[\"有最小存储单元\",{\"1\":{\"272\":1}}],[\"有序集成员按分数值递减\",{\"1\":{\"607\":1}}],[\"有序集合数据类型\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"有序集合中对指定成员的分数加上增量\",{\"1\":{\"607\":1}}],[\"有序集合的成员是唯一的\",{\"1\":{\"607\":1}}],[\"有序集合\",{\"0\":{\"607\":1},\"1\":{\"589\":1,\"601\":1,\"607\":1,\"636\":1,\"1198\":1,\"1378\":1}}],[\"有序\",{\"1\":{\"267\":1}}],[\"有1\",{\"1\":{\"266\":1}}],[\"有10mbps\",{\"1\":{\"134\":1}}],[\"有效期长\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"有效期按照经验值设置\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"有效的降低了消息丢失的风险\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"有效的降低了b\",{\"1\":{\"266\":1}}],[\"有效防止数据丢失\",{\"1\":{\"962\":1}}],[\"有效日志才是\",{\"1\":{\"192\":1}}],[\"有权限校验的接口请求\",{\"1\":{\"183\":1}}],[\"有默认启动配置文件\",{\"1\":{\"157\":1}}],[\"有任何问题都可以继续问我\",{\"1\":{\"936\":1}}],[\"有任何问题都可以来谈谈\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"648\":1,\"698\":1,\"732\":1}}],[\"有任何争议可以留言\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"641\":1,\"698\":1,\"732\":1}}],[\"有办法\",{\"1\":{\"140\":1}}],[\"有句话叫做\",{\"1\":{\"90\":1}}],[\"d这4个对象之间已经没有了耦合关系\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"d这4个对象没有了耦合关系\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"db\",{\"0\":{\"1050\":1,\"1259\":1},\"1\":{\"962\":2,\"1046\":1,\"1047\":4,\"1048\":9,\"1049\":5,\"1050\":9,\"1051\":1,\"1060\":2,\"1255\":1,\"1256\":4,\"1257\":9,\"1258\":5,\"1259\":9,\"1260\":1,\"1266\":2}}],[\"dc\",{\"1\":{\"865\":1}}],[\"dyuproject\",{\"1\":{\"812\":2}}],[\"dynamic参数设置\",{\"1\":{\"431\":1}}],[\"dynamic\",{\"0\":{\"431\":1},\"1\":{\"414\":1,\"431\":4,\"439\":2,\"440\":1,\"619\":1}}],[\"dd\",{\"1\":{\"800\":2,\"801\":2,\"865\":2}}],[\"dto\",{\"1\":{\"829\":2,\"830\":4,\"831\":2}}],[\"dtd\",{\"1\":{\"743\":3,\"744\":3,\"745\":3,\"755\":3,\"763\":3,\"782\":3,\"817\":3,\"827\":6}}],[\"dtest=类名\",{\"1\":{\"705\":1}}],[\"driven\",{\"1\":{\"818\":1,\"819\":1}}],[\"driver=com\",{\"1\":{\"816\":1}}],[\"driverclass\",{\"1\":{\"815\":1}}],[\"driver\",{\"1\":{\"737\":1,\"743\":6,\"745\":2,\"766\":3,\"815\":1,\"816\":1,\"864\":2,\"1444\":2}}],[\"drivermanager\",{\"1\":{\"737\":2,\"1176\":1,\"1361\":1}}],[\"drop是ddl\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"drop>\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"drop\",{\"0\":{\"543\":1,\"1190\":1,\"1373\":1},\"1\":{\"541\":1,\"736\":1,\"824\":2,\"864\":2,\"916\":1}}],[\"dskiptests\",{\"1\":{\"705\":1,\"850\":1}}],[\"dmanven\",{\"1\":{\"705\":1}}],[\"dversion=0\",{\"1\":{\"703\":2,\"704\":2}}],[\"dgroupid=com\",{\"1\":{\"703\":2,\"704\":2}}],[\"damaged\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"daemon\",{\"1\":{\"852\":2,\"1061\":1,\"1267\":1}}],[\"daocloud\",{\"1\":{\"852\":1}}],[\"dao接口的工作原理是jdk动态代理\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"dao接口测试\",{\"0\":{\"828\":1}}],[\"dao接口xml\",{\"0\":{\"827\":1}}],[\"dao接口\",{\"0\":{\"826\":1},\"1\":{\"827\":1}}],[\"dao层\",{\"1\":{\"812\":1}}],[\"dao\",{\"0\":{\"815\":1,\"1175\":2,\"1360\":2},\"1\":{\"754\":1,\"757\":2,\"762\":4,\"763\":2,\"772\":1,\"789\":18,\"790\":6,\"793\":1,\"812\":1,\"815\":4,\"820\":1,\"826\":2,\"827\":3,\"828\":5,\"829\":1,\"830\":2,\"1175\":1,\"1211\":1,\"1360\":1,\"1388\":1}}],[\"dartifactid=helloweb\",{\"1\":{\"704\":2}}],[\"dartifactid=hellojava\",{\"1\":{\"703\":2}}],[\"darchetypeartifactid=maven\",{\"1\":{\"703\":2,\"704\":2}}],[\"darchetypecatalog=internal\",{\"1\":{\"703\":2,\"704\":2}}],[\"data节点\",{\"1\":{\"1074\":1,\"1278\":1}}],[\"databind<\",{\"1\":{\"812\":1}}],[\"database\",{\"1\":{\"94\":1,\"506\":1,\"511\":1,\"614\":1,\"664\":1,\"736\":1,\"779\":1,\"824\":1,\"863\":1,\"864\":2,\"962\":1,\"1201\":1,\"1381\":1}}],[\"datacenteridshift\",{\"1\":{\"388\":2}}],[\"datacenteridbits\",{\"1\":{\"388\":3}}],[\"datacenterid\",{\"1\":{\"387\":2,\"388\":9}}],[\"data2\",{\"1\":{\"337\":3}}],[\"datasourcetransactionmanager\",{\"1\":{\"818\":1}}],[\"datasource\",{\"1\":{\"789\":3,\"790\":2,\"815\":3,\"818\":3,\"864\":1,\"1444\":2}}],[\"datasource>\",{\"1\":{\"743\":2,\"745\":1,\"766\":1}}],[\"datas\",{\"1\":{\"288\":6}}],[\"datalogdir=\",{\"1\":{\"157\":1}}],[\"datadir\",{\"1\":{\"157\":2}}],[\"data\",{\"1\":{\"106\":1,\"109\":2,\"112\":1,\"152\":1,\"157\":1,\"251\":1,\"267\":10,\"269\":2,\"270\":7,\"288\":4,\"289\":9,\"337\":11,\"377\":3,\"406\":1,\"511\":4,\"573\":3,\"614\":1,\"824\":1,\"825\":4,\"829\":2,\"830\":6,\"852\":1,\"1073\":1,\"1092\":1,\"1093\":1,\"1143\":1,\"1277\":1,\"1293\":1,\"1294\":1,\"1334\":1,\"1431\":11}}],[\"datetimeformat\",{\"1\":{\"819\":1}}],[\"datetime\",{\"1\":{\"736\":2,\"792\":2,\"795\":2}}],[\"datecenterid\",{\"1\":{\"387\":1}}],[\"date\",{\"1\":{\"90\":1,\"288\":1,\"289\":1,\"337\":1,\"352\":1,\"377\":1,\"439\":2,\"448\":1,\"688\":1,\"689\":1,\"736\":1,\"747\":4,\"757\":3,\"763\":3,\"786\":1,\"792\":2,\"793\":5,\"794\":2,\"800\":14,\"801\":2,\"824\":1,\"825\":4,\"826\":2,\"828\":3,\"829\":5,\"830\":4,\"831\":1,\"849\":1,\"998\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1302\":2,\"1303\":1,\"1305\":1}}],[\"d表示最大的数有多少位\",{\"1\":{\"377\":1}}],[\"d是在leader挂掉时专门用来进行选举leader所用的端口\",{\"1\":{\"157\":1}}],[\"d中的a是一个数字\",{\"1\":{\"157\":1}}],[\"dialect\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"diff\",{\"1\":{\"916\":2}}],[\"diff看到此时的修改信息\",{\"1\":{\"916\":1}}],[\"di\",{\"0\":{\"1213\":1,\"1390\":1},\"1\":{\"865\":2,\"950\":1,\"1213\":1,\"1390\":1}}],[\"dicttype\",{\"1\":{\"624\":3}}],[\"dictentry\",{\"1\":{\"624\":6}}],[\"dictht\",{\"1\":{\"624\":5}}],[\"dict\",{\"1\":{\"624\":5}}],[\"dictionary\",{\"1\":{\"589\":1}}],[\"directorpassflow\",{\"1\":{\"865\":3}}],[\"directornotpassflow\",{\"1\":{\"865\":3}}],[\"directortak\",{\"1\":{\"865\":6}}],[\"directory\",{\"1\":{\"152\":1}}],[\"dir\",{\"1\":{\"506\":1}}],[\"displaced\",{\"1\":{\"1023\":2}}],[\"disposablebean\",{\"1\":{\"952\":4}}],[\"dispatcherservlet\",{\"1\":{\"950\":3,\"956\":15}}],[\"dispatcherservlet<\",{\"1\":{\"820\":1}}],[\"discardpolicy\",{\"1\":{\"926\":2}}],[\"discardoldestpolicy\",{\"1\":{\"926\":2}}],[\"disc\",{\"1\":{\"506\":1}}],[\"discovery\",{\"1\":{\"406\":2,\"1070\":1,\"1074\":1,\"1274\":1,\"1278\":1}}],[\"distribution\",{\"1\":{\"371\":1}}],[\"distributed\",{\"1\":{\"112\":2,\"152\":6,\"1002\":1}}],[\"digital\",{\"1\":{\"374\":2}}],[\"dopost\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"doget\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"dog\",{\"1\":{\"726\":1}}],[\"doafterreturning\",{\"1\":{\"689\":1}}],[\"dobeforeadvice\",{\"1\":{\"689\":1}}],[\"double\",{\"1\":{\"340\":4,\"444\":1,\"448\":1,\"607\":1,\"628\":1,\"794\":1,\"795\":1,\"1085\":1,\"1286\":1}}],[\"dosubsomething\",{\"1\":{\"198\":2}}],[\"dosth\",{\"1\":{\"195\":1,\"197\":1}}],[\"dosomething\",{\"1\":{\"195\":1,\"196\":2,\"198\":1,\"200\":3,\"201\":4,\"924\":4,\"944\":2,\"1022\":3,\"1107\":3,\"1305\":3}}],[\"dosome\",{\"1\":{\"193\":1}}],[\"do\",{\"1\":{\"193\":3,\"198\":2,\"201\":2,\"922\":1,\"924\":2,\"1018\":1}}],[\"download\",{\"1\":{\"246\":1,\"408\":1,\"598\":1,\"701\":1,\"728\":2,\"852\":1,\"887\":1}}],[\"down表示单前的server暂时不参与负载\",{\"1\":{\"106\":1}}],[\"down\",{\"1\":{\"106\":1,\"1104\":14,\"1302\":14}}],[\"docreatebean\",{\"1\":{\"954\":1}}],[\"doctype\",{\"1\":{\"743\":1,\"744\":1,\"745\":1,\"755\":1,\"763\":1,\"782\":1,\"817\":1,\"827\":2,\"832\":1}}],[\"docker采用control\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"docker容器之间怎么隔离\",{\"0\":{\"1064\":1,\"1270\":1}}],[\"docker常用命令\",{\"0\":{\"1062\":1,\"1268\":1}}],[\"dockercontainer\",{\"1\":{\"1061\":1,\"1267\":1}}],[\"dockerclient\",{\"1\":{\"1061\":1,\"1267\":1}}],[\"dockerhub\",{\"1\":{\"852\":1}}],[\"dockerfile\",{\"0\":{\"1059\":1,\"1265\":1},\"1\":{\"851\":1,\"854\":1,\"1059\":4,\"1265\":4}}],[\"dockerfile讲解\",{\"1\":{\"850\":1}}],[\"docker\",{\"0\":{\"1056\":1,\"1057\":1,\"1058\":1,\"1063\":1,\"1262\":1,\"1263\":1,\"1264\":1,\"1269\":1},\"1\":{\"250\":1,\"251\":2,\"852\":22,\"854\":5,\"855\":3,\"856\":3,\"1056\":3,\"1057\":2,\"1058\":1,\"1059\":4,\"1060\":5,\"1061\":2,\"1062\":1,\"1063\":1,\"1263\":2,\"1264\":1,\"1265\":4,\"1266\":5,\"1267\":2,\"1268\":1,\"1269\":1},\"2\":{\"1066\":1}}],[\"docker在线linux操作视频\",{\"1\":{\"90\":1}}],[\"doc\",{\"1\":{\"152\":1,\"431\":1,\"433\":6,\"434\":2,\"436\":3,\"439\":2,\"440\":2,\"457\":1,\"526\":1,\"527\":3,\"548\":1,\"904\":1,\"998\":1}}],[\"documents\",{\"1\":{\"1004\":4}}],[\"documentation>\",{\"1\":{\"865\":1}}],[\"documented\",{\"1\":{\"688\":1,\"1092\":1,\"1293\":1}}],[\"document\",{\"0\":{\"420\":1},\"1\":{\"106\":1,\"420\":1,\"800\":1,\"998\":1,\"1002\":1,\"1004\":7,\"1071\":1,\"1275\":1}}],[\"docsify\",{\"1\":{\"909\":2,\"910\":1,\"912\":2,\"913\":4}}],[\"docs\",{\"1\":{\"91\":1,\"232\":1,\"440\":1,\"910\":1,\"911\":2,\"913\":1,\"1084\":1,\"1101\":2,\"1285\":1,\"1299\":2}}],[\"deathlock\",{\"1\":{\"1105\":2,\"1303\":2}}],[\"deadlock\",{\"1\":{\"152\":1,\"1105\":2,\"1303\":2}}],[\"deep\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"detected\",{\"1\":{\"1023\":1}}],[\"detail<\",{\"1\":{\"832\":1}}],[\"detail\",{\"1\":{\"795\":2,\"831\":3}}],[\"detaillist\",{\"1\":{\"794\":2,\"795\":1}}],[\"details\",{\"1\":{\"232\":1,\"251\":2,\"275\":1,\"388\":1,\"394\":2,\"425\":1,\"520\":1,\"675\":1,\"797\":1,\"917\":1,\"919\":2,\"1030\":1}}],[\"depends\",{\"1\":{\"952\":1,\"1060\":2,\"1266\":2}}],[\"dependencies<\",{\"1\":{\"844\":1}}],[\"dependencies\",{\"1\":{\"837\":1,\"844\":1,\"954\":1}}],[\"dependencies>\",{\"1\":{\"715\":2,\"812\":1,\"844\":2}}],[\"dependency\",{\"1\":{\"950\":1,\"952\":1}}],[\"dependencymanagement\",{\"1\":{\"844\":1}}],[\"dependencymanagement>\",{\"1\":{\"715\":1,\"844\":1}}],[\"dependency>\",{\"1\":{\"648\":1,\"687\":1,\"708\":2,\"709\":4,\"710\":2,\"715\":6,\"735\":1,\"742\":1,\"756\":1,\"812\":23,\"844\":3,\"862\":3,\"874\":2,\"885\":3,\"1092\":1,\"1293\":1,\"1444\":2}}],[\"dependence\",{\"1\":{\"706\":1}}],[\"deprecated表示这个方法以后可能会删掉\",{\"1\":{\"944\":1}}],[\"deprecated\",{\"1\":{\"876\":1,\"1092\":1,\"1293\":1}}],[\"deploy阶段\",{\"1\":{\"714\":1}}],[\"deploy\",{\"1\":{\"705\":1,\"713\":1,\"714\":1}}],[\"develop\",{\"1\":{\"915\":1}}],[\"development\",{\"1\":{\"743\":1}}],[\"device\",{\"1\":{\"852\":1}}],[\"devices\",{\"1\":{\"144\":1,\"145\":1}}],[\"dev\",{\"1\":{\"526\":1,\"527\":3,\"548\":1,\"766\":1}}],[\"decode\",{\"1\":{\"1085\":2,\"1286\":2}}],[\"decoders\",{\"1\":{\"144\":1}}],[\"decimal\",{\"1\":{\"795\":2}}],[\"decrement\",{\"1\":{\"1022\":2}}],[\"decrby\",{\"1\":{\"603\":1}}],[\"decr\",{\"1\":{\"603\":1}}],[\"declare\",{\"1\":{\"526\":1}}],[\"dequeue|pop\",{\"1\":{\"287\":1}}],[\"def\",{\"1\":{\"970\":2}}],[\"definitions\",{\"1\":{\"950\":1}}],[\"definitions>\",{\"1\":{\"865\":1}}],[\"definition\",{\"1\":{\"950\":1,\"954\":1}}],[\"deflate\",{\"1\":{\"183\":1}}],[\"defaultlistablebeanfactory\",{\"1\":{\"950\":3}}],[\"defaultvalue\",{\"1\":{\"849\":1}}],[\"defaultsqlsession\",{\"1\":{\"762\":2}}],[\"defaults\",{\"1\":{\"762\":1,\"887\":2}}],[\"default=\",{\"1\":{\"743\":1,\"745\":1}}],[\"default=nokey=1\",{\"1\":{\"143\":1}}],[\"default生命周期default生命周期是maven生命周期中最重要的一个\",{\"1\":{\"713\":1}}],[\"default生命周期\",{\"0\":{\"713\":1}}],[\"defaultcapacity\",{\"1\":{\"285\":3}}],[\"default\",{\"1\":{\"106\":1,\"143\":1,\"158\":1,\"507\":1,\"577\":1,\"688\":1,\"711\":1,\"726\":5,\"736\":9,\"743\":1,\"745\":1,\"792\":5,\"795\":14,\"819\":1,\"821\":1,\"824\":3,\"887\":3,\"944\":1,\"946\":3,\"948\":2,\"1220\":1,\"1397\":1,\"1431\":1}}],[\"design\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"designed\",{\"1\":{\"152\":1}}],[\"deserializer\",{\"1\":{\"984\":2,\"990\":2}}],[\"destroymethod\",{\"1\":{\"952\":4}}],[\"destroymethodname\",{\"1\":{\"952\":3}}],[\"destroybean\",{\"1\":{\"952\":2}}],[\"destroy\",{\"1\":{\"952\":10,\"1128\":1,\"1321\":1}}],[\"destruction\",{\"1\":{\"952\":1}}],[\"dest\",{\"1\":{\"924\":6}}],[\"destkey\",{\"1\":{\"659\":1}}],[\"destination\",{\"1\":{\"604\":2,\"606\":8,\"607\":2,\"655\":1}}],[\"desktop\",{\"0\":{\"643\":1},\"1\":{\"643\":1}}],[\"descriptions\",{\"1\":{\"885\":1}}],[\"description>\",{\"1\":{\"844\":1}}],[\"description\",{\"1\":{\"337\":1,\"352\":1,\"377\":1,\"688\":1,\"689\":2,\"825\":2,\"826\":2,\"828\":3,\"829\":5,\"830\":4,\"831\":1,\"849\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1302\":2,\"1303\":1,\"1305\":1}}],[\"descriptors\",{\"1\":{\"106\":1}}],[\"demuxers\",{\"1\":{\"144\":1}}],[\"demo效果\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"demos\",{\"1\":{\"876\":2}}],[\"demoapplication<\",{\"1\":{\"844\":1}}],[\"demo\",{\"1\":{\"112\":1,\"116\":1,\"439\":1,\"686\":1,\"688\":1,\"689\":3,\"824\":1,\"844\":1,\"849\":1,\"1030\":1}}],[\"delnode\",{\"1\":{\"286\":4}}],[\"delete语句是dml\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"delete和truncate只删除表的数据不删除表的结构\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"delete与truncate的区\",{\"0\":{\"1190\":1,\"1373\":1}}],[\"delete>\",{\"1\":{\"755\":1,\"763\":1}}],[\"deleteuserbyid\",{\"1\":{\"763\":3}}],[\"deleteuser\",{\"1\":{\"753\":1,\"754\":2,\"755\":1,\"757\":2}}],[\"delete\",{\"0\":{\"778\":1},\"1\":{\"178\":2,\"434\":1,\"436\":1,\"541\":1,\"577\":1,\"754\":1,\"755\":1,\"763\":1,\"778\":1,\"789\":1,\"970\":1,\"1190\":1,\"1241\":1,\"1373\":1,\"1414\":1}}],[\"delogo=0\",{\"1\":{\"140\":1}}],[\"delogo=x\",{\"1\":{\"140\":1}}],[\"del\",{\"1\":{\"115\":1,\"603\":3,\"1076\":4,\"1280\":4}}],[\"deny\",{\"1\":{\"106\":2}}],[\"debug=\",{\"1\":{\"821\":1}}],[\"debug\",{\"1\":{\"106\":1,\"191\":2,\"192\":2,\"195\":6,\"198\":1,\"789\":24,\"790\":8,\"821\":1}}],[\"d\",{\"1\":{\"94\":2,\"249\":2,\"251\":1,\"289\":1,\"364\":1,\"377\":2,\"388\":3,\"436\":3,\"821\":1,\"831\":1,\"855\":1,\"917\":2,\"1068\":1,\"1214\":1,\"1272\":1,\"1391\":1,\"1439\":1}}],[\"dup\",{\"1\":{\"621\":1}}],[\"dubbo\",{\"1\":{\"159\":3,\"1032\":1}}],[\"dump\",{\"1\":{\"146\":1}}],[\"durability\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"duration\",{\"1\":{\"134\":1,\"990\":1}}],[\"during\",{\"1\":{\"112\":1}}],[\"du\",{\"1\":{\"90\":1}}],[\"df\",{\"1\":{\"90\":1}}],[\"进群的场景下\",{\"1\":{\"1245\":1,\"1418\":1}}],[\"进100+原创文章\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"进一步提高了性能和效率\",{\"1\":{\"980\":1}}],[\"进一步降低树的高度\",{\"1\":{\"503\":1}}],[\"进来\",{\"1\":{\"966\":1}}],[\"进度\",{\"1\":{\"896\":1}}],[\"进而需要更多的存储空间来维护索引结构\",{\"1\":{\"508\":1}}],[\"进阶\",{\"1\":{\"394\":1,\"641\":1,\"647\":1}}],[\"进阶二\",{\"0\":{\"341\":1}}],[\"进阶一\",{\"0\":{\"338\":1}}],[\"进队\",{\"1\":{\"288\":2,\"289\":1}}],[\"进栈\",{\"1\":{\"282\":1}}],[\"进入崩溃恢复模式\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"进入该状态的线程需要等待其他线程做出一些特定动作\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"进入拦截器了\",{\"1\":{\"1092\":2,\"1293\":2}}],[\"进入并发清理阶段做连续空间整理\",{\"1\":{\"938\":1}}],[\"进入仓库\",{\"1\":{\"913\":1}}],[\"进入容器\",{\"1\":{\"856\":1}}],[\"进入项目后再操作\",{\"1\":{\"705\":1}}],[\"进入方法前执行\",{\"1\":{\"689\":1}}],[\"进入\",{\"1\":{\"209\":1,\"913\":1,\"1092\":1,\"1293\":1}}],[\"进入新一轮leader选举\",{\"1\":{\"166\":1}}],[\"进入zookeeper下bin目录\",{\"1\":{\"159\":1}}],[\"进入到bin目录下\",{\"1\":{\"158\":1}}],[\"进行封装\",{\"1\":{\"1431\":1}}],[\"进行初始化bean操作\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"进行加锁\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"进行下线处理\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"进行直接读取\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"进行自己的集群管理\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"进行业务逻辑处理\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"进行讨论\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"进行数据可视化和监控\",{\"1\":{\"998\":1}}],[\"进行数据展示\",{\"1\":{\"883\":1}}],[\"进行外包装\",{\"1\":{\"988\":1}}],[\"进行视图渲染\",{\"1\":{\"956\":1}}],[\"进行\",{\"1\":{\"956\":1,\"1162\":1,\"1205\":1,\"1350\":1,\"1385\":1}}],[\"进行压力测试\",{\"1\":{\"950\":1}}],[\"进行压缩的文件类型\",{\"1\":{\"106\":1}}],[\"进行并行计算等\",{\"1\":{\"950\":1}}],[\"进行管理\",{\"1\":{\"950\":1}}],[\"进行属性注入\",{\"1\":{\"950\":1}}],[\"进行指定\",{\"1\":{\"797\":1}}],[\"进行判断的\",{\"1\":{\"692\":1}}],[\"进行i++\",{\"1\":{\"692\":1}}],[\"进行期间\",{\"1\":{\"625\":1}}],[\"进行更新操作\",{\"1\":{\"573\":1}}],[\"进行设置\",{\"1\":{\"431\":1}}],[\"进行拷贝\",{\"1\":{\"352\":2,\"364\":1}}],[\"进行引用\",{\"1\":{\"45\":1}}],[\"进程都会等待超过半数的\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"进程的运行\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"进程的角色\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"进程\",{\"1\":{\"417\":1}}],[\"进程数\",{\"1\":{\"106\":1}}],[\"进程pid\",{\"1\":{\"106\":1}}],[\"进程操作\",{\"1\":{\"90\":1}}],[\"比zookeeper\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"比例为\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"比\",{\"1\":{\"1043\":1,\"1226\":1,\"1252\":1,\"1401\":1}}],[\"比直接使用\",{\"1\":{\"1032\":1}}],[\"比且每个键值对的键和值要么就是小整数值\",{\"1\":{\"633\":1}}],[\"比较等等\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"比较简单的方式\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"比较重要的就是解决两个问题\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"比较重要和常用的阶段如下\",{\"1\":{\"713\":1}}],[\"比较常见的是三种\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"比较多\",{\"1\":{\"1033\":1}}],[\"比较棘手\",{\"1\":{\"1018\":1}}],[\"比较v和a之后\",{\"1\":{\"1018\":1}}],[\"比较熟悉吗\",{\"1\":{\"958\":1}}],[\"比较麻烦\",{\"1\":{\"383\":1}}],[\"比较排序\",{\"1\":{\"348\":1}}],[\"比较自己的选票和接收到的投票\",{\"1\":{\"166\":1}}],[\"比二叉树深层次的搜索肯定快很多\",{\"1\":{\"266\":1}}],[\"比如你的代码模块拆分\",{\"1\":{\"1439\":1}}],[\"比如你可以限制某个容器使用内存的上限\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"比如对接口返回值的统一校验封装\",{\"1\":{\"1439\":1}}],[\"比如应用的web层\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"比如应用并删除第二个\",{\"1\":{\"916\":1}}],[\"比如权限校验和\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"比如指定拦截add\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"比如其他事务改了这批数据并提交了\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"比如redis\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"比如复制限流\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"比如窗口\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"比如二者都是aop编程思想的体现\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"比如购物车\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"比如遍历\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"比如copyonwritearraylist\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"比如cpu\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"比如提供的排序方法\",{\"1\":{\"1113\":1,\"1308\":1}}],[\"比如总是先申请\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"比如银行转账\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"比如main线程\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"比如类\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"比如所有类都是继承与object类的\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"比如共\",{\"0\":{\"1074\":1,\"1278\":1}}],[\"比如可以是连接\",{\"1\":{\"1034\":1}}],[\"比如书名\",{\"1\":{\"1004\":1}}],[\"比如这样\",{\"1\":{\"998\":1,\"1431\":1}}],[\"比如这个蛇和青蛙互不放手\",{\"1\":{\"562\":1}}],[\"比如金融交易或者实时监控系统\",{\"1\":{\"994\":1}}],[\"比如记录日志或者通知管理员\",{\"1\":{\"994\":1}}],[\"比如activemq或rabbitmq\",{\"1\":{\"992\":1}}],[\"比如两个线程同时\",{\"1\":{\"988\":1}}],[\"比如开个程序\",{\"1\":{\"988\":1}}],[\"比如增加\",{\"1\":{\"982\":1}}],[\"比如增加存储容量\",{\"1\":{\"515\":1}}],[\"比如订单支付成功后触发发货操作\",{\"1\":{\"976\":1}}],[\"比如实时监控\",{\"1\":{\"976\":1}}],[\"比如lzf和snappy\",{\"1\":{\"972\":1}}],[\"比如往集合中添加元素\",{\"1\":{\"966\":1}}],[\"比如从集合中取出元素\",{\"1\":{\"966\":1}}],[\"比如拆分过于庞大的\",{\"1\":{\"954\":1}}],[\"比如新生代使用copying算法\",{\"1\":{\"936\":1}}],[\"比如说key的hashcode\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"比如说我们常常用arraylist代替数组\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"比如说\",{\"1\":{\"932\":1,\"966\":1}}],[\"比如说你要是想根据时间对数据排序\",{\"1\":{\"657\":1}}],[\"比如大量hash冲突会导致拉链过长\",{\"1\":{\"922\":1}}],[\"比如第二个\",{\"1\":{\"916\":3}}],[\"比如第一个整数是\",{\"1\":{\"359\":1}}],[\"比如在物流等容易损坏的环境中\",{\"1\":{\"872\":1}}],[\"比如在物流等环境中扫码编程别人的二维码\",{\"1\":{\"871\":1}}],[\"比如在商品编号的生成\",{\"1\":{\"653\":1}}],[\"比如导入\",{\"1\":{\"844\":1}}],[\"比如我们经常接触的\",{\"1\":{\"1032\":1}}],[\"比如我的如下\",{\"1\":{\"839\":1}}],[\"比如我最近开发中需要一个邮件验证码发送服务\",{\"1\":{\"664\":1}}],[\"比如判断用户是否登录状态\",{\"1\":{\"658\":1}}],[\"比如需要进行交集计算\",{\"1\":{\"656\":1}}],[\"比如微博新闻的列表页面\",{\"1\":{\"655\":1}}],[\"比如文章列表\",{\"1\":{\"655\":1}}],[\"比如表头节点\",{\"1\":{\"629\":1}}],[\"比如节点的数量\",{\"1\":{\"628\":1}}],[\"比如列表键\",{\"1\":{\"622\":1}}],[\"比如读多写少场景下\",{\"1\":{\"573\":1}}],[\"比如行粒度锁\",{\"1\":{\"557\":1}}],[\"比如它只能用于myisam或innodb存储引擎\",{\"1\":{\"507\":1}}],[\"比如一本书有\",{\"1\":{\"500\":1}}],[\"比如一个新的文档\",{\"1\":{\"431\":1}}],[\"比如一个队列尾长度为\",{\"1\":{\"288\":1}}],[\"比如一个视频的编码是mpeg4\",{\"1\":{\"135\":1}}],[\"比如一个视频源的码率太高了\",{\"1\":{\"134\":1}}],[\"比如一个文件20\",{\"1\":{\"134\":1}}],[\"比如完成任务后的用户地址里有某个\",{\"1\":{\"486\":1}}],[\"比如用户持有一定数量的某种代币\",{\"1\":{\"486\":1}}],[\"比如邀请\",{\"1\":{\"483\":1}}],[\"比如index时用standard+ngram\",{\"1\":{\"440\":1}}],[\"比如设置某个字段为不被索引\",{\"1\":{\"429\":1}}],[\"比如字符串\",{\"1\":{\"429\":1}}],[\"比如3\",{\"1\":{\"361\":1}}],[\"比如给定20个随机整数\",{\"1\":{\"361\":1}}],[\"比如查询\",{\"1\":{\"270\":1}}],[\"比如上图中\",{\"1\":{\"267\":1}}],[\"比如普通的二叉树对于\",{\"1\":{\"263\":1}}],[\"比如函数的入口处\",{\"1\":{\"192\":1}}],[\"比如函数的入参\",{\"1\":{\"191\":1}}],[\"比如错误码更新\",{\"1\":{\"182\":1}}],[\"比如前面这个接口\",{\"1\":{\"177\":1}}],[\"比如数据库连接信息等\",{\"1\":{\"162\":1}}],[\"比如产品经理小饼过来要人\",{\"1\":{\"153\":1}}],[\"比如1\",{\"1\":{\"134\":1}}],[\"比如是128kbps\",{\"1\":{\"134\":1}}],[\"比如如何保证数据库和缓存的数据一致性\",{\"1\":{\"98\":1}}],[\"比如试着解决某个业务场景\",{\"1\":{\"98\":1}}],[\"比如某管理系统等\",{\"1\":{\"98\":1}}],[\"比如把我们上传到服务器的代码复制到需要运行的目录下\",{\"1\":{\"91\":1}}],[\"比如\",{\"1\":{\"90\":1,\"91\":1,\"98\":1,\"100\":1,\"176\":1,\"177\":1,\"183\":1,\"186\":1,\"266\":1,\"500\":1,\"501\":1,\"553\":1,\"664\":1,\"709\":1,\"712\":1,\"766\":1,\"838\":2,\"839\":2,\"844\":1,\"917\":1,\"924\":3,\"944\":3,\"952\":2,\"958\":1,\"966\":5,\"972\":1,\"974\":1,\"982\":1,\"1000\":1,\"1004\":1,\"1006\":1,\"1033\":1,\"1086\":1,\"1113\":1,\"1144\":1,\"1177\":1,\"1287\":1,\"1308\":1,\"1335\":1,\"1362\":1,\"1431\":4,\"1439\":1}}],[\"比特币\",{\"1\":{\"10\":1}}],[\"其可以帮助我们查看应用的运行状态\",{\"1\":{\"1231\":1,\"1406\":1}}],[\"其作用是利用autoconfigurationimportselector给容器中导入一些组件\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"其本质是通过aop功能\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"其本质意义也是线性表的一种\",{\"1\":{\"282\":1}}],[\"其存储作用域为\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"其执行原理为\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"其区别不过是虚拟机栈为虚拟机执行java方法\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"其下又有很多子类\",{\"1\":{\"1112\":1,\"1307\":1}}],[\"其下的实现类功能非常丰富\",{\"1\":{\"946\":1}}],[\"其特点是\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"其释放键值对的条件与实现原理\",{\"1\":{\"948\":1}}],[\"其典型应用场景\",{\"1\":{\"948\":1}}],[\"其性能和效率甚至与\",{\"1\":{\"940\":1}}],[\"其提供的展示配置以及可扩展性能满足绝大部分时间序列数据展示需求\",{\"1\":{\"884\":1}}],[\"其采用pull方式采集时间序列的度量数据\",{\"1\":{\"883\":1}}],[\"其取值有四个\",{\"1\":{\"864\":1}}],[\"其里面的内容包括\",{\"1\":{\"710\":1}}],[\"其官网地址为\",{\"1\":{\"698\":1}}],[\"其优势就是可以做到只需要\",{\"1\":{\"659\":1}}],[\"其它和follower功能一样\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"其它程序可以通过context访问spring的bean资源\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"其它公共库\",{\"1\":{\"705\":1}}],[\"其它参数\",{\"1\":{\"440\":1}}],[\"其它所有的非backup机器down或者忙的时候\",{\"1\":{\"106\":1}}],[\"其原因与单词频率信息一样\",{\"1\":{\"425\":1}}],[\"其设计目的是用来简化新\",{\"1\":{\"401\":1}}],[\"其时间复杂度为\",{\"1\":{\"371\":1}}],[\"其插入和删除的操作分别在表的两端进行\",{\"1\":{\"287\":1}}],[\"其附近的数据也通常会马上被使用\",{\"1\":{\"274\":1}}],[\"其成为leader可能性越大\",{\"1\":{\"166\":1}}],[\"其过程和启动时期的leader选举过程基本一致\",{\"1\":{\"166\":1}}],[\"其无须更新自己的投票\",{\"1\":{\"166\":1}}],[\"其单独无法进行和完成leader选举\",{\"1\":{\"166\":1}}],[\"其中肯定要有用户的登录\",{\"1\":{\"1439\":1}}],[\"其中public\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"其中三级缓存是主要功臣\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"其中可见性就是可以让线程之间进行通信\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"其中有三个分区\",{\"1\":{\"992\":1}}],[\"其中有一个内存区域是\",{\"1\":{\"692\":1}}],[\"其中一个线程正在扩容数组\",{\"1\":{\"988\":1}}],[\"其中一个常见的问题是可见性问题\",{\"1\":{\"924\":1}}],[\"其中会调用\",{\"1\":{\"950\":1}}],[\"其中的\",{\"0\":{\"1074\":1,\"1278\":1}}],[\"其中的方法直接对应映射文件中的\",{\"1\":{\"958\":1}}],[\"其中的并发标记清除算法也为之后g1等收集器奠定了基础\",{\"1\":{\"938\":1}}],[\"其中的一个replica可以升级成shard\",{\"1\":{\"422\":1}}],[\"其中键是当前\",{\"1\":{\"928\":1}}],[\"其中包含来自get或post请求的参数\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"其中包含我们需要运行以构建\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"其中包含一个\",{\"1\":{\"924\":1}}],[\"其中包括数据库和哈希键\",{\"1\":{\"626\":1}}],[\"其中包括\",{\"1\":{\"511\":1}}],[\"其中最常用作查询条件的列应该放在索引的最前面\",{\"1\":{\"502\":1}}],[\"其中构建初始堆经推导复杂度为o\",{\"1\":{\"364\":1}}],[\"其中k是整数的范围\",{\"1\":{\"357\":1}}],[\"其中0<=i<=k\",{\"1\":{\"339\":1}}],[\"其中分布锁和队列有java和c两个版本\",{\"1\":{\"154\":1}}],[\"其中\",{\"1\":{\"141\":1,\"371\":1,\"372\":1,\"443\":1,\"457\":1,\"628\":1,\"629\":1,\"844\":1,\"922\":1,\"926\":1,\"1022\":2,\"1177\":1,\"1362\":1}}],[\"其中都是精华中的精华\",{\"1\":{\"100\":1}}],[\"其次会判断bean是否实现了disposablebean接口\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"其次是序列化的工具选择上\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"其次是锁的释放\",{\"1\":{\"970\":1}}],[\"其次对于查询来说\",{\"0\":{\"539\":1}}],[\"其次平衡二叉树的高度相对较大为\",{\"1\":{\"266\":1}}],[\"其次\",{\"1\":{\"100\":1,\"992\":1}}],[\"其实也就是\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"其实也就那么几个\",{\"1\":{\"90\":1}}],[\"其实就返回了\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"其实就是maven项目的目录结构\",{\"1\":{\"702\":1}}],[\"其实简单而言\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"其实现机制是接收到请求后\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"其实现类与使用场景\",{\"1\":{\"946\":1}}],[\"其实这条说的过于绝对\",{\"1\":{\"526\":1}}],[\"其实不是什么新的框架\",{\"1\":{\"401\":1}}],[\"其实在这之前\",{\"1\":{\"225\":1}}],[\"其实限制了也没用\",{\"1\":{\"145\":1}}],[\"其实已经进入后端的排队之中等候处理\",{\"1\":{\"106\":1}}],[\"其实\",{\"1\":{\"90\":1}}],[\"其他用例\",{\"1\":{\"1444\":1}}],[\"其他两种方式在遇到循环依赖问题时都会产生异常\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"其他类型如list\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"其他类型默认为\",{\"1\":{\"433\":1}}],[\"其他信息如果需要保留\",{\"1\":{\"1131\":2,\"1324\":2}}],[\"其他作为\",{\"1\":{\"1074\":1,\"1278\":1}}],[\"其他线程阻塞排队\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"其他线程\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"其他线程就无法访问该对象的被\",{\"1\":{\"1022\":1}}],[\"其他线程就可以立即看到这个变量的最新值\",{\"1\":{\"924\":1}}],[\"其他线程可以立即看到这个修改\",{\"1\":{\"1022\":1}}],[\"其他节点会接收到这个信息\",{\"1\":{\"1008\":1}}],[\"其他方面与hashmap相同\",{\"1\":{\"948\":1}}],[\"其他行仍然可以被其他事务访问\",{\"1\":{\"571\":1}}],[\"其他事务无法再获取到相同的排他锁\",{\"1\":{\"578\":1}}],[\"其他事务可能需要等待表锁释放\",{\"1\":{\"574\":1}}],[\"其他事务不能对表进行任何读写操作\",{\"1\":{\"565\":1}}],[\"其他事务不能访问table\",{\"1\":{\"561\":1}}],[\"其他事务不能修改或读取这行\",{\"1\":{\"556\":1}}],[\"其他事务既不能读取也不能修改这些数据\",{\"1\":{\"555\":1}}],[\"其他特殊类型可以查看官方文档\",{\"1\":{\"455\":1}}],[\"其他的\",{\"1\":{\"964\":1}}],[\"其他的默认是docs\",{\"1\":{\"440\":1}}],[\"其他的类无法实例化单例类的对象\",{\"1\":{\"79\":1}}],[\"其他博主反馈\",{\"1\":{\"385\":1}}],[\"其他编程语言\",{\"0\":{\"168\":1}}],[\"其他\",{\"0\":{\"111\":1}}],[\"其他平台也会同步\",{\"1\":{\"3\":1}}],[\"网上有张非常形象的图\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"网上看到一个比较形象一个例子\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"网上看到一个例子\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"网上关于volatile的文章非常多\",{\"1\":{\"692\":1}}],[\"网关等手段管理各服务\",{\"1\":{\"950\":1}}],[\"网购\",{\"1\":{\"871\":1}}],[\"网站上可以搜索具体的组织或项目关键字\",{\"1\":{\"705\":1}}],[\"网站的日活跃用户\",{\"1\":{\"659\":1}}],[\"网站查询\",{\"1\":{\"499\":1}}],[\"网站\",{\"1\":{\"614\":1,\"837\":1,\"913\":1},\"2\":{\"227\":1,\"228\":1}}],[\"网站更新时间线\",{\"0\":{\"225\":1}}],[\"网站更新记录\",{\"0\":{\"224\":1}}],[\"网站信息\",{\"0\":{\"1\":1},\"2\":{\"51\":1}}],[\"网页平均在32k以下的设置\",{\"1\":{\"106\":1}}],[\"网络等\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"网络等资源是全局的\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"网络通信\",{\"1\":{\"1033\":1}}],[\"网络io\",{\"1\":{\"517\":1}}],[\"网络面试题\",{\"0\":{\"104\":1}}],[\"网络\",{\"0\":{\"103\":1},\"1\":{\"524\":1}}],[\"网络操作\",{\"1\":{\"90\":1}}],[\"网络讲解设计模式的文章有很多\",{\"1\":{\"84\":1}}],[\"如使用contextloader\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"如url和文件\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"如init\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"如innodb\",{\"1\":{\"574\":1}}],[\"如实现beannameaware接口可以获取到beanname\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"如实例一\",{\"1\":{\"166\":1}}],[\"如上图\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"如上图是一个分区日志文件\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"如上分析\",{\"1\":{\"83\":1}}],[\"如名称\",{\"1\":{\"1000\":1}}],[\"如加锁或者使用同步包装类\",{\"1\":{\"988\":1}}],[\"如调整副本\",{\"1\":{\"980\":1}}],[\"如同总指挥\",{\"1\":{\"956\":1}}],[\"如对大量短连接使用线程池\",{\"1\":{\"950\":1}}],[\"如工厂模式\",{\"1\":{\"950\":1}}],[\"如sleep\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"如synchronized关键词加在方法或者代码块上\",{\"1\":{\"1018\":1}}],[\"如string\",{\"1\":{\"988\":1}}],[\"如spring使用\",{\"1\":{\"944\":1}}],[\"如serial\",{\"1\":{\"936\":1}}],[\"如select\",{\"1\":{\"570\":1}}],[\"如吞吐量\",{\"1\":{\"942\":1}}],[\"如被引用变量置null\",{\"1\":{\"936\":1}}],[\"如在变量声明中使用该类的名称\",{\"1\":{\"934\":1}}],[\"如rt\",{\"1\":{\"934\":1}}],[\"如大对象和长时间存活的对象\",{\"1\":{\"930\":1}}],[\"如c\",{\"1\":{\"930\":1}}],[\"如安装包下载不成功\",{\"1\":{\"886\":1}}],[\"如源码路径\",{\"1\":{\"844\":1}}],[\"如只有一条修改操作\",{\"1\":{\"830\":1}}],[\"如js\",{\"1\":{\"819\":1}}],[\"如此重复\",{\"1\":{\"692\":1}}],[\"如此反复下去就会有无穷无尽的bean产生了\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"如此反复进行\",{\"1\":{\"364\":1}}],[\"如此反复执行\",{\"1\":{\"364\":1}}],[\"如activemq\",{\"1\":{\"594\":1}}],[\"如全局id\",{\"1\":{\"594\":1}}],[\"如全表备份或全表删除\",{\"1\":{\"561\":1,\"565\":1}}],[\"如全表扫描或全表更新\",{\"1\":{\"561\":1}}],[\"如电商网站商品的浏览量\",{\"1\":{\"594\":1}}],[\"如京东的月度销量榜单\",{\"1\":{\"594\":1}}],[\"如意向共享锁\",{\"1\":{\"575\":1}}],[\"如意犹未尽\",{\"1\":{\"525\":1}}],[\"如行锁升级为表锁\",{\"1\":{\"574\":1}}],[\"如行锁或表锁\",{\"1\":{\"570\":1}}],[\"如时间戳\",{\"1\":{\"569\":1}}],[\"如数据库中的记录\",{\"1\":{\"562\":1}}],[\"如脏读\",{\"1\":{\"553\":1}}],[\"如一表中有字段\",{\"1\":{\"536\":1}}],[\"如主键或具有唯一约束的列\",{\"1\":{\"502\":1}}],[\"如点\",{\"1\":{\"495\":1}}],[\"如存储结构\",{\"1\":{\"440\":1}}],[\"如从\",{\"1\":{\"347\":1}}],[\"如图3所示\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"如图1所示\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"如图\",{\"1\":{\"333\":1,\"339\":1}}],[\"如图所示\",{\"1\":{\"289\":1}}],[\"如下对应spring\",{\"1\":{\"709\":1}}],[\"如下例子中\",{\"1\":{\"501\":1}}],[\"如下下面程序idworker类的starttime属性\",{\"1\":{\"388\":1}}],[\"如下所示\",{\"1\":{\"359\":1,\"1112\":1,\"1307\":1}}],[\"如下所示b\",{\"1\":{\"270\":1}}],[\"如下\",{\"1\":{\"287\":1,\"457\":1,\"829\":1,\"1092\":1,\"1293\":1}}],[\"如下图带顺序访问的b+树\",{\"1\":{\"269\":1}}],[\"如下图\",{\"1\":{\"269\":1,\"288\":1,\"515\":1,\"916\":1,\"1047\":1,\"1161\":1,\"1212\":1,\"1256\":1,\"1349\":1,\"1389\":1}}],[\"如磁盘\",{\"1\":{\"266\":1}}],[\"如llama2\",{\"1\":{\"245\":1}}],[\"如\",{\"0\":{\"526\":1,\"528\":1,\"529\":1,\"531\":1,\"532\":1},\"1\":{\"183\":3,\"266\":1,\"342\":1,\"357\":1,\"411\":1,\"558\":1,\"601\":1,\"705\":1,\"713\":1,\"715\":1,\"772\":1,\"831\":1,\"950\":3,\"958\":1,\"988\":1,\"1092\":2,\"1142\":1,\"1174\":2,\"1204\":1,\"1293\":2,\"1333\":1,\"1359\":2,\"1384\":1}}],[\"如检查是否是本轮投票\",{\"1\":{\"166\":1}}],[\"如何自定义starter\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"如何降低系统之间\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"如何获取自动生成的\",{\"0\":{\"1176\":1,\"1361\":1}}],[\"如何获取maven坐标\",{\"1\":{\"705\":1}}],[\"如何防御csrf\",{\"0\":{\"1137\":1,\"1330\":1}}],[\"如何快速排查死锁\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"如何快速索引呢\",{\"1\":{\"266\":1}}],[\"如何在两个线程间共享数据\",{\"0\":{\"1102\":1,\"1300\":1}}],[\"如何在mysql中创建全文索引\",{\"0\":{\"507\":1}}],[\"如何停止一个正在运行的线程\",{\"0\":{\"1101\":1,\"1299\":1}}],[\"如何处理更好\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"如何处理缓存击穿的问题\",{\"0\":{\"1049\":1,\"1258\":1}}],[\"如何处理缓存雪崩的问题\",{\"0\":{\"1048\":1,\"1257\":1}}],[\"如何处理缓存穿透的问题\",{\"0\":{\"1047\":1,\"1256\":1}}],[\"如何实现\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"如何实现缓存预热\",{\"0\":{\"1051\":1,\"1260\":1}}],[\"如何实现跨域\",{\"1\":{\"104\":1}}],[\"如何解决跨域问题\",{\"0\":{\"1136\":1,\"1329\":1}}],[\"如何解决\",{\"1\":{\"1047\":1,\"1048\":1,\"1049\":1,\"1105\":1,\"1256\":1,\"1257\":1,\"1258\":1,\"1303\":1}}],[\"如何解决这些问题\",{\"1\":{\"509\":1}}],[\"如何确保我们从kafka中获取的信息是准确的呢\",{\"1\":{\"984\":1}}],[\"如何确定当前能读到哪一条消息\",{\"0\":{\"1161\":1,\"1349\":1}}],[\"如何确定适当的过期时间呢\",{\"1\":{\"972\":1}}],[\"如何确定一个键值对应该存储在哪个分片上呢\",{\"1\":{\"968\":1}}],[\"如何从kafka中消费消息呢\",{\"1\":{\"984\":1}}],[\"如何提高远程用户吞吐量\",{\"0\":{\"982\":1}}],[\"如何避免死锁\",{\"0\":{\"1105\":1,\"1303\":1},\"1\":{\"1105\":1,\"1303\":1}}],[\"如何避免缓存击穿的问题\",{\"1\":{\"1046\":1,\"1255\":1}}],[\"如何避免缓存穿透的问题\",{\"1\":{\"1046\":1,\"1255\":1}}],[\"如何避免\",{\"1\":{\"954\":1}}],[\"如何控制\",{\"1\":{\"952\":1}}],[\"如何优化\",{\"1\":{\"936\":1,\"946\":1}}],[\"如何优化索引\",{\"0\":{\"510\":1}}],[\"如何保证二维码的准确性\",{\"1\":{\"872\":1}}],[\"如何保证各个平台的二维码是唯一的\",{\"1\":{\"871\":1}}],[\"如何保证不重复\",{\"1\":{\"871\":1,\"872\":1}}],[\"如何告诉mybatis把结果映射到appointment同时映射book属性\",{\"1\":{\"827\":1}}],[\"如何检测死锁\",{\"0\":{\"580\":1}}],[\"如何检测索引碎片化\",{\"1\":{\"511\":1}}],[\"如何修改同一条数据\",{\"0\":{\"573\":1}}],[\"如何修复索引碎片化\",{\"1\":{\"511\":1}}],[\"如何通过\",{\"0\":{\"572\":1}}],[\"如何分析和优化索引的使用\",{\"1\":{\"510\":1}}],[\"如何有效地维护和管理索引\",{\"0\":{\"508\":1}}],[\"如何查看mysql表中已有的索引\",{\"0\":{\"506\":1}}],[\"如何减少回表\",{\"0\":{\"504\":1}}],[\"如何选择特定的节点执行请求的\",{\"0\":{\"1075\":1,\"1279\":1}}],[\"如何选择红黑树还是二叉查找树\",{\"1\":{\"948\":1}}],[\"如何选择恰当的并发list类\",{\"1\":{\"946\":1}}],[\"如何选择\",{\"0\":{\"499\":1},\"1\":{\"1047\":1,\"1256\":1}}],[\"如何生成自增\",{\"1\":{\"382\":1}}],[\"如何生成全局唯一id\",{\"1\":{\"382\":1}}],[\"如何使用呢\",{\"1\":{\"1431\":1}}],[\"如何使用分布式锁\",{\"0\":{\"576\":1}}],[\"如何使用\",{\"1\":{\"209\":2}}],[\"如何打印日志呢\",{\"1\":{\"201\":1}}],[\"如何是转行的人\",{\"1\":{\"98\":1}}],[\"如果调用的方法是在新线程调用的\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"如果调用时用string类型替换t\",{\"1\":{\"966\":1}}],[\"如果bean的某一个属性没有注入\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"如果实现了将会调用其实现的destroy\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"如果实现了\",{\"1\":{\"1214\":2,\"1391\":2}}],[\"如果真能实现ioc容器\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"如果理解有难度\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"如果超过一半确认服务异常\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"如果master服务异常\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"如果值是一个大的业务对象\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"如果试图选中同一行则会发生排斥\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"如果已经配置自动加载选项\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"如果已过期\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"如果线程a遍历的不是一个\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"如果系统现存的资源可以满足它的最大需求量则按当前的申请资源分配资源\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"如果条件不满足则等待\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"如果方法上加了\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"如果频繁的进行这样的操作对性能有所影响\",{\"1\":{\"1089\":1,\"1290\":1}}],[\"如果操作系统帮你完成了再通知你\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"如果x和y引用的对象没有发生变化\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"如果x\",{\"1\":{\"1087\":2,\"1288\":2}}],[\"如果父类加载器可以完成类加载任务\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"如果父类加载器还存在其父类加载器\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"如果父类的一个方法被声明为public\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"如果父类可以完成类加载工作则子类不会再去加载\",{\"1\":{\"934\":1}}],[\"如果保证读写一致\",{\"0\":{\"1078\":1,\"1282\":1}}],[\"如果成功了\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"如果成功获取到锁\",{\"1\":{\"970\":1}}],[\"如果依靠用户请求的方式重建缓存数据\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"如果缓存中没有任何数据\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"如果未过期\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"如果避免缓存雪崩的问题\",{\"1\":{\"1046\":1,\"1255\":1}}],[\"如果读多\",{\"1\":{\"1018\":1}}],[\"如果删除节点时版本号没有同步更新\",{\"1\":{\"1018\":1}}],[\"如果校验失败\",{\"1\":{\"1018\":1}}],[\"如果当\",{\"1\":{\"1018\":1}}],[\"如果当前不存在事务\",{\"1\":{\"1220\":2,\"1397\":2}}],[\"如果当前存在事务\",{\"1\":{\"1220\":6,\"1397\":6}}],[\"如果当前没有事务\",{\"1\":{\"1220\":2,\"1397\":2}}],[\"如果当前数组长度已经达到最大值\",{\"1\":{\"928\":1}}],[\"如果当前时间小于上一次id生成的时间戳\",{\"1\":{\"388\":1}}],[\"如果主节点宕机了\",{\"1\":{\"1008\":1}}],[\"如果存在\",{\"1\":{\"996\":1,\"1047\":1,\"1256\":1}}],[\"如果存在了就返回true\",{\"1\":{\"337\":1}}],[\"如果仍然没有成功\",{\"1\":{\"994\":1}}],[\"如果消息没有被确认\",{\"1\":{\"994\":1}}],[\"如果消息没有被确认怎么办\",{\"1\":{\"994\":1}}],[\"如果消费者在处理消息时发生错误\",{\"1\":{\"980\":1}}],[\"如果必须使用非线程安全的类\",{\"1\":{\"988\":1}}],[\"如果多个线程同时访问一个\",{\"1\":{\"988\":1}}],[\"如果多出一个and\",{\"1\":{\"786\":1}}],[\"如果leader副本出现故障怎么办\",{\"1\":{\"986\":1}}],[\"如果您还有其他问题\",{\"1\":{\"1002\":1}}],[\"如果您还有其他关于kafka或其他技术的问题\",{\"1\":{\"984\":1}}],[\"如果您确定不需要对字段进行排序或聚合\",{\"1\":{\"440\":1}}],[\"如果从\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"如果从kafka得到准确消息\",{\"0\":{\"984\":1}}],[\"如果从服务器因网络故障与主服务器断开\",{\"1\":{\"964\":1}}],[\"如果相等\",{\"1\":{\"970\":1}}],[\"如果相同则进行更新\",{\"1\":{\"579\":1}}],[\"如果相同\",{\"1\":{\"573\":1}}],[\"如果获取成功则执行业务逻辑\",{\"1\":{\"1105\":2,\"1303\":2}}],[\"如果获取锁失败\",{\"1\":{\"970\":1}}],[\"如果获取失败了再判断是否需要阻塞\",{\"1\":{\"1018\":1}}],[\"如果获取失败\",{\"1\":{\"388\":1,\"1105\":2,\"1303\":2}}],[\"如果我的链表长度不停地在7和8之间切换\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"如果我想修饰一个代码块\",{\"1\":{\"1022\":1}}],[\"如果我要添加或删除一个节点\",{\"1\":{\"968\":1}}],[\"如果我们打开机械式手表的后盖\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"如果我们仍然使用使用链表把多个冲突的元素串起来\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"如果我们的查询指定了\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"如果我们的服务器有n多台的话\",{\"1\":{\"162\":1}}],[\"如果我们使用\",{\"1\":{\"1048\":2,\"1257\":2}}],[\"如果我们使用hashset来实现过滤的话\",{\"1\":{\"330\":1}}],[\"如果我们要搜索关键词\",{\"1\":{\"1006\":1}}],[\"如果我们没有及时清理这些变量副本\",{\"1\":{\"928\":1}}],[\"如果我们运行\",{\"1\":{\"712\":1}}],[\"如果我们想要保留这种优势\",{\"1\":{\"632\":1}}],[\"如果我们有一个指向图\",{\"1\":{\"619\":1}}],[\"如果aof加载失败\",{\"1\":{\"962\":1}}],[\"如果键\",{\"1\":{\"960\":1}}],[\"如果键所在的链表过长或超过加载因子\",{\"1\":{\"948\":1}}],[\"如果key已经存在\",{\"1\":{\"960\":1}}],[\"如果上述方式都不可行\",{\"1\":{\"954\":1}}],[\"如果再给你一个机会\",{\"1\":{\"952\":1}}],[\"如果再次执行的话\",{\"1\":{\"830\":1}}],[\"如果配置了\",{\"1\":{\"952\":1}}],[\"如果在创建消息的时候\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"如果在高速缓存中找到所需数据\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"如果在\",{\"1\":{\"952\":1}}],[\"如果旧表不为空且旧表的键与新键hash值相同\",{\"1\":{\"948\":1}}],[\"如果注解有默认值\",{\"1\":{\"944\":1}}],[\"如果注释该指令\",{\"1\":{\"106\":1}}],[\"如果永久代填满\",{\"1\":{\"936\":1}}],[\"如果两个对象彼此引用\",{\"1\":{\"936\":1}}],[\"如果两者都输入\",{\"1\":{\"786\":2}}],[\"如果锁被当前线程持有\",{\"1\":{\"1023\":1}}],[\"如果锁没有被其他线程持有\",{\"1\":{\"1023\":1}}],[\"如果锁已经被其他线程占用了\",{\"1\":{\"932\":1}}],[\"如果锁定的行数过多\",{\"1\":{\"575\":1}}],[\"如果锁定的行数占表中行数的很大一部分\",{\"1\":{\"574\":1}}],[\"如果锁定的页\",{\"1\":{\"574\":1}}],[\"如果eden区没有足够的空间\",{\"1\":{\"930\":1}}],[\"如果找到了一个空的位置\",{\"1\":{\"928\":1}}],[\"如果找到了相同的\",{\"1\":{\"928\":1}}],[\"如果该节点的分区是单副本的\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"如果该锁被其他线程持有\",{\"1\":{\"1023\":1}}],[\"如果该锁被当前线程持有\",{\"1\":{\"1023\":1}}],[\"如果该锁没有被其他线程持有\",{\"1\":{\"1022\":3,\"1023\":1}}],[\"如果该锁已经被其他线程持有\",{\"1\":{\"1022\":5,\"1023\":1}}],[\"如果该位置没有键值对\",{\"1\":{\"928\":1}}],[\"如果该位置已经有键值对了\",{\"1\":{\"928\":1}}],[\"如果该索引是复合索引\",{\"0\":{\"534\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"如果能清楚\",{\"1\":{\"922\":1}}],[\"如果能够定位到具体的索引记录\",{\"1\":{\"575\":1}}],[\"如果集合很大\",{\"1\":{\"922\":1}}],[\"如果链表长度过长\",{\"1\":{\"922\":1}}],[\"如果链表长度超过treeify\",{\"1\":{\"922\":1}}],[\"如果节点的新的索引位置相同\",{\"1\":{\"922\":1}}],[\"如果节点已经存在\",{\"1\":{\"922\":1}}],[\"如果桶位非空\",{\"1\":{\"922\":1}}],[\"如果采用两倍扩容\",{\"1\":{\"922\":1}}],[\"如果采用整型作为id\",{\"1\":{\"382\":1}}],[\"如果扩容过小\",{\"1\":{\"922\":1}}],[\"如果slave节点服务异常\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"如果size已经超过阈值threshold\",{\"1\":{\"922\":1}}],[\"如果sql语句中出现\",{\"0\":{\"799\":1}}],[\"如果容量达到阈值\",{\"1\":{\"922\":1}}],[\"如果产生冲突\",{\"1\":{\"922\":1}}],[\"如果对某个节点的投票数达到一定的值\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"如果对象为空\",{\"1\":{\"1023\":2}}],[\"如果对象已经实例化了\",{\"1\":{\"82\":1}}],[\"如果对性能有较高要求\",{\"1\":{\"922\":1}}],[\"如果用户编写了一个java\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"如果用自己的话描述技术难题\",{\"1\":{\"920\":1}}],[\"如果用来进行下载等应用磁盘io重负载应用\",{\"1\":{\"106\":2}}],[\"如果表不存在\",{\"1\":{\"864\":1}}],[\"如果中途出现什么旧版本没卸载干净\",{\"1\":{\"853\":1}}],[\"如果没有这个\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"如果没有双亲委派模型而是由各个类加载器自行加载的话\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"如果没有最终标记阶段\",{\"1\":{\"938\":1}}],[\"如果没有其他引用指向example对象\",{\"1\":{\"936\":1}}],[\"如果没有冲突就直接插入\",{\"1\":{\"922\":1}}],[\"如果没有\",{\"1\":{\"913\":1,\"926\":1,\"1199\":1,\"1379\":1}}],[\"如果没有表或者版本不匹配\",{\"1\":{\"864\":1}}],[\"如果没安装\",{\"1\":{\"852\":1}}],[\"如果没看可以先回去看完再继续本篇~\",{\"1\":{\"613\":1}}],[\"如果影响行数等于>1\",{\"1\":{\"826\":1}}],[\"如果看过前几篇文章\",{\"1\":{\"807\":1}}],[\"如果看上一篇\",{\"1\":{\"347\":1}}],[\"如果属性是集合使用collection\",{\"1\":{\"797\":1}}],[\"如果属性在不只一个地方进行了配置\",{\"1\":{\"766\":1}}],[\"如果参数user中的某个属性为null\",{\"1\":{\"786\":1}}],[\"如果缺少and或者多出多个and则会报错\",{\"1\":{\"786\":1}}],[\"如果输入年龄\",{\"1\":{\"786\":2}}],[\"如果输入了姓名按照姓名进行模糊查询\",{\"1\":{\"786\":2}}],[\"如果输入了姓名则按照姓名模糊查找\",{\"1\":{\"785\":2}}],[\"如果输入了姓名\",{\"1\":{\"783\":1,\"784\":2}}],[\"如果输入的是\",{\"1\":{\"439\":2}}],[\"如果包的路径有很多\",{\"1\":{\"772\":1}}],[\"如果希望使用mybatis通过的动态代理的接口\",{\"1\":{\"762\":1}}],[\"如果id为1\",{\"1\":{\"727\":1}}],[\"如果只是调用\",{\"1\":{\"1098\":1,\"1296\":1}}],[\"如果只有一个参数\",{\"1\":{\"779\":1}}],[\"如果只有\",{\"1\":{\"724\":1}}],[\"如果只用来表示正整数\",{\"1\":{\"387\":1}}],[\"如果同时有\",{\"1\":{\"724\":1}}],[\"如果想要转移一系列的连续提交\",{\"1\":{\"917\":1}}],[\"如果想显示其他存存储\",{\"1\":{\"916\":1}}],[\"如果想一次构建多个项目模块\",{\"1\":{\"716\":1}}],[\"如果想尝试\",{\"1\":{\"614\":1}}],[\"如果引入的依赖包含了很多其它的传递依赖\",{\"1\":{\"710\":1}}],[\"如果间接依赖中包含有同一个坐标不同版本的资源依赖\",{\"1\":{\"709\":1}}],[\"如果直接依赖中包含有同一个坐标不同版本的资源依赖\",{\"1\":{\"709\":1}}],[\"如果直接与间接依赖中包含有同一个坐标不同版本的资源依赖\",{\"1\":{\"709\":1}}],[\"如果项目a中直接配置了log4j\",{\"1\":{\"709\":1}}],[\"如果显示java\",{\"1\":{\"692\":2}}],[\"如果大家发现有错误的地方欢迎大家指正\",{\"1\":{\"692\":1}}],[\"如果大于自己\",{\"1\":{\"166\":1}}],[\"如果外网访问\",{\"1\":{\"675\":1}}],[\"如果重复创建\",{\"1\":{\"645\":1}}],[\"如果这些\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"如果这时键\",{\"1\":{\"635\":1}}],[\"如果这个值相对较高\",{\"1\":{\"511\":1}}],[\"如果要包含提交\",{\"1\":{\"917\":1}}],[\"如果要应用并删除其他stash\",{\"1\":{\"916\":1}}],[\"如果要使用其他个\",{\"1\":{\"916\":1}}],[\"如果要显示其他存贮\",{\"1\":{\"916\":1}}],[\"如果要深入了解\",{\"1\":{\"692\":1}}],[\"如果要存储长度不同的字符串\",{\"1\":{\"632\":1}}],[\"如果要经常的调用\",{\"1\":{\"82\":1}}],[\"如果还有其他关于kafka或者任何其他技术的问题\",{\"1\":{\"990\":1}}],[\"如果还有其他问题\",{\"1\":{\"974\":1}}],[\"如果还有疑惑\",{\"1\":{\"628\":1}}],[\"如果还有什么疑问\",{\"1\":{\"364\":1}}],[\"如果修改sds时\",{\"1\":{\"620\":1}}],[\"如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\",{\"1\":{\"604\":3}}],[\"如果设置\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"如果设置返回1说明获取锁成功\",{\"1\":{\"594\":1}}],[\"如果设为\",{\"1\":{\"432\":1}}],[\"如果返回值大于0\",{\"1\":{\"577\":1}}],[\"如果插入失败\",{\"1\":{\"577\":1}}],[\"如果插入成功\",{\"1\":{\"577\":1}}],[\"如果检测到时间戳冲突\",{\"1\":{\"569\":1}}],[\"如果检测到冲突\",{\"1\":{\"569\":1}}],[\"如果变化了\",{\"1\":{\"569\":1}}],[\"如果开发时间允许\",{\"1\":{\"546\":1}}],[\"如果游标操作的数据超过1万行\",{\"0\":{\"544\":1}}],[\"如果数值在\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"如果数据库表当前版本号与第一次取出来的\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"如果数据表没有添加索引或主键\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"如果数据变化较少\",{\"1\":{\"972\":1}}],[\"如果数据量太大会造成长时间阻塞\",{\"1\":{\"962\":1}}],[\"如果数据量不大\",{\"0\":{\"542\":1}}],[\"如果数列中的元素都是小数\",{\"1\":{\"361\":1}}],[\"如果一致则\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"如果一台服务器上只部署了一个\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"如果一次性插入数据量很大\",{\"0\":{\"542\":1}}],[\"如果一个客户端设置了\",{\"1\":{\"1245\":1,\"1418\":1}}],[\"如果一个咖啡师不在\",{\"1\":{\"974\":1}}],[\"如果一个节点宕机了\",{\"1\":{\"968\":2}}],[\"如果一个\",{\"1\":{\"954\":1}}],[\"如果一个分段里至少有一个对象被老年代引用\",{\"1\":{\"940\":1}}],[\"如果一个对象仅被软引用\",{\"1\":{\"936\":1}}],[\"如果一个对象仅被强引用变量引用\",{\"1\":{\"936\":1}}],[\"如果一个对象被强引用的变量引用\",{\"1\":{\"936\":1}}],[\"如果一个变量的修改涉及到多个步骤\",{\"1\":{\"924\":1}}],[\"如果一个事务执行了\",{\"1\":{\"558\":1}}],[\"如果一个事务要对一张表加排他锁\",{\"1\":{\"557\":1}}],[\"如果一个字段的查询频率远低于更新频率\",{\"1\":{\"508\":1}}],[\"如果一个元素不存在\",{\"1\":{\"330\":1}}],[\"如果一个存储器的某个位置被访问\",{\"1\":{\"266\":1,\"270\":1}}],[\"如果创建了索引\",{\"1\":{\"508\":1}}],[\"如果索引是整形\",{\"1\":{\"1192\":1,\"1375\":1}}],[\"如果索引配置了副本\",{\"1\":{\"1012\":1}}],[\"如果索引包含了所有需要的列\",{\"1\":{\"504\":1}}],[\"如果索引列包含\",{\"1\":{\"501\":1}}],[\"如果索引列的数据分布非常不均匀\",{\"1\":{\"501\":1}}],[\"如果索引列具有大量重复值\",{\"1\":{\"499\":1}}],[\"如果磁盘\",{\"1\":{\"499\":1}}],[\"如果查询条件的结果为空\",{\"1\":{\"575\":1}}],[\"如果查询条件没有从索引的第一部分匹配\",{\"1\":{\"501\":1}}],[\"如果查询只访问索引中包含的列\",{\"1\":{\"510\":1}}],[\"如果查询只需要索引中包含的字段\",{\"1\":{\"504\":1}}],[\"如果查询中的某些条件不太可能同时满足\",{\"1\":{\"504\":1}}],[\"如果查询经常根据多个列进行过滤\",{\"1\":{\"504\":1}}],[\"如果查询涉及到范围查询\",{\"1\":{\"499\":1}}],[\"如果查询主要是等值查询\",{\"1\":{\"499\":1}}],[\"如果前面的判断为\",{\"1\":{\"488\":1}}],[\"如果需要下载csdn资料又没有积分可以javapub留言\",{\"1\":{\"1093\":1,\"1107\":1}}],[\"如果需要排序可以使用treemap或者对hashmap进行排序\",{\"1\":{\"922\":1}}],[\"如果需要顺序\",{\"1\":{\"922\":1}}],[\"如果需要存储\",{\"1\":{\"456\":1}}],[\"如果需要使用该类型的字段只需要在定义映射时指定\",{\"1\":{\"443\":1}}],[\"如果尝试搜索\",{\"1\":{\"451\":1}}],[\"如果将a类和b类的bean配置为相互注入\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"如果将\",{\"1\":{\"451\":1}}],[\"如果机器上时钟回拨\",{\"1\":{\"387\":1}}],[\"如果位数多的话\",{\"1\":{\"375\":1}}],[\"如果排序的对象有三位数以上\",{\"1\":{\"375\":1}}],[\"如果编号为i\",{\"1\":{\"364\":1}}],[\"如果有动手能力的朋友可以通过这些文章\",{\"1\":{\"1429\":1}}],[\"如果有的话\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"如果有一个齿轮出了问题\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"如果有一个服务挂掉\",{\"1\":{\"166\":1}}],[\"如果有恶意攻击者不断请求系统中不存在的数据\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"如果有相应的trigger\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"如果有则会使用\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"如果有需要的话\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"如果有索引\",{\"1\":{\"1006\":1}}],[\"如果有多个线程等待\",{\"1\":{\"988\":1}}],[\"如果有机会能参与\",{\"1\":{\"940\":1}}],[\"如果有\",{\"1\":{\"701\":1,\"926\":1}}],[\"如果有几百万用户\",{\"1\":{\"659\":1}}],[\"如果有疑问\",{\"1\":{\"358\":1}}],[\"如果布隆过滤器判断用户名不存在\",{\"1\":{\"334\":1}}],[\"如果布隆过滤器判断数据不存在则数据绝对不存在\",{\"1\":{\"334\":1}}],[\"如果计算出有一个元素已存在\",{\"1\":{\"330\":1}}],[\"如果信息太长太多\",{\"1\":{\"196\":1}}],[\"如果使用本地缓存时\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"如果使用不当\",{\"1\":{\"1022\":1}}],[\"如果使用事务\",{\"1\":{\"728\":1}}],[\"如果使用到了临时表\",{\"0\":{\"543\":1}}],[\"如果使用的是\",{\"1\":{\"526\":1}}],[\"如果使用数据库自增\",{\"1\":{\"383\":1}}],[\"如果使用\",{\"1\":{\"196\":1,\"1087\":1,\"1091\":1,\"1288\":1,\"1292\":1}}],[\"如果使用更大的值\",{\"1\":{\"106\":1}}],[\"如果打印值是对象的话\",{\"1\":{\"195\":1}}],[\"如果打开多个重复的窗口\",{\"1\":{\"77\":1}}],[\"如果接口发生了变更\",{\"1\":{\"182\":1}}],[\"如果是多副本的\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"如果是第一次访问某个jsp页面\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"如果是第一次同步\",{\"1\":{\"964\":1}}],[\"如果是7的话\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"如果是则更改为新的值\",{\"1\":{\"1018\":1}}],[\"如果是\",{\"1\":{\"996\":1}}],[\"如果是所有代码\",{\"1\":{\"917\":1}}],[\"如果是以上错误\",{\"1\":{\"899\":1}}],[\"如果是用mvn命令生成的xml\",{\"1\":{\"820\":1}}],[\"如果是亿级大表\",{\"1\":{\"509\":1}}],[\"如果是小数据量的\",{\"1\":{\"499\":1}}],[\"如果是同一时间生成的\",{\"1\":{\"388\":1}}],[\"如果是字符串\",{\"1\":{\"382\":1}}],[\"如果是一些非常复杂的接口\",{\"1\":{\"179\":1}}],[\"如果是非常简单的接口\",{\"1\":{\"179\":1}}],[\"如果是leader\",{\"1\":{\"166\":1}}],[\"如果是follower\",{\"1\":{\"166\":1}}],[\"如果是单个进程中对共享资源的访问\",{\"1\":{\"163\":1}}],[\"如果zxid相同\",{\"1\":{\"166\":1}}],[\"如果不明白来javapub\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"如果不能确定类型\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"如果不能转换则直接报错\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"如果不是第一次访问某个jsp页面\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"如果不是\",{\"1\":{\"996\":1}}],[\"如果不需要高并发\",{\"1\":{\"922\":1}}],[\"如果不使用这个命令\",{\"1\":{\"917\":1}}],[\"如果不太明白\",{\"1\":{\"829\":1}}],[\"如果不了解\",{\"1\":{\"652\":1}}],[\"如果不同\",{\"1\":{\"573\":1,\"922\":1}}],[\"如果不理解\",{\"1\":{\"352\":1}}],[\"如果不存在就进行记录并返回false\",{\"1\":{\"337\":1}}],[\"如果不存在手动创建\",{\"1\":{\"157\":1}}],[\"如果不知道没关系\",{\"1\":{\"329\":1}}],[\"如果不确定是否要加入\",{\"1\":{\"212\":1}}],[\"如果不设置就会报错\",{\"1\":{\"145\":1}}],[\"如果老吕这时候忘了小耀已经被安排走了\",{\"1\":{\"153\":1}}],[\"如果540不写\",{\"1\":{\"138\":1}}],[\"如果ffmpeg当时编译时\",{\"1\":{\"135\":1}}],[\"如果把它设置为比较大的数值\",{\"1\":{\"106\":1}}],[\"如果后端服务器down掉\",{\"1\":{\"106\":1}}],[\"如果图片显示不正常把这个改成off\",{\"1\":{\"106\":1}}],[\"如果header过大\",{\"1\":{\"106\":1}}],[\"如果hash算法设计不当\",{\"1\":{\"922\":1}}],[\"如果hash\",{\"1\":{\"106\":1}}],[\"如果nginx给出需要增大hash\",{\"1\":{\"106\":1}}],[\"如果平时时间充裕\",{\"1\":{\"101\":1}}],[\"如果\",{\"1\":{\"49\":1,\"604\":1,\"918\":1,\"924\":3,\"952\":2,\"1105\":1,\"1163\":1,\"1303\":1,\"1351\":1}}],[\"如果你没有数据库\",{\"1\":{\"1444\":1}}],[\"如果你没有很多实战经验\",{\"1\":{\"1079\":1,\"1283\":1}}],[\"如果你想要声明让所有的portlet公用全局的存储变量的话\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"如果你想深入了解kafka的工作原理\",{\"1\":{\"974\":1}}],[\"如果你\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"如果你对网络有点了解\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"如果你对\",{\"1\":{\"1030\":1}}],[\"如果你对zookeeper有一定了解\",{\"1\":{\"150\":1}}],[\"如果你等待服务员确认你的点菜后再点下一道菜\",{\"1\":{\"994\":1}}],[\"如果你还有其他关于kafka或者其他技术的问题\",{\"1\":{\"996\":1}}],[\"如果你还有其他关于redis内存优化的问题\",{\"1\":{\"972\":1}}],[\"如果你还有其他问题\",{\"1\":{\"982\":1,\"986\":1,\"1006\":1,\"1008\":1,\"1012\":1}}],[\"如果你还不懂\",{\"1\":{\"587\":1}}],[\"如果你的数据变化频繁\",{\"1\":{\"972\":1}}],[\"如果你进行了2次\",{\"1\":{\"918\":1}}],[\"如果你是第一次操作\",{\"1\":{\"910\":1}}],[\"如果你是一个新手\",{\"1\":{\"27\":1}}],[\"如果你在写一个demo\",{\"1\":{\"706\":1}}],[\"如果你读到在这里\",{\"1\":{\"608\":1}}],[\"如果你要用\",{\"1\":{\"602\":1}}],[\"如果你经常执行涉及多个列的查询\",{\"1\":{\"502\":1}}],[\"如果你有实战项目经验\",{\"1\":{\"829\":1}}],[\"如果你有一个\",{\"1\":{\"501\":1}}],[\"如果你有开发需要欢迎在\",{\"1\":{\"498\":1}}],[\"如果你有兴趣了解更多\",{\"1\":{\"339\":1}}],[\"如果你有兴趣欢迎参与进来\",{\"1\":{\"1\":1}}],[\"如果你了解其他的编程语言\",{\"1\":{\"488\":1}}],[\"如果你需要维护低版本\",{\"1\":{\"419\":1}}],[\"如果你会一些\",{\"1\":{\"101\":1}}],[\"如果你担心费用太高\",{\"1\":{\"98\":1}}],[\"如果觉得有用\",{\"1\":{\"1\":1}}],[\"加互斥锁\",{\"1\":{\"1203\":2,\"1383\":2}}],[\"加上我们的自定义注解\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"加油\",{\"1\":{\"934\":1,\"952\":1,\"954\":1,\"958\":1}}],[\"加快初始化\",{\"1\":{\"838\":1}}],[\"加如相关依赖即可\",{\"1\":{\"812\":1}}],[\"加完以后将结果写回至\",{\"1\":{\"692\":1}}],[\"加读锁\",{\"1\":{\"572\":1}}],[\"加写锁\",{\"1\":{\"572\":1}}],[\"加了行锁还是表锁\",{\"0\":{\"571\":1}}],[\"加排他锁\",{\"1\":{\"555\":2}}],[\"加共享锁\",{\"1\":{\"555\":2}}],[\"加起来刚好64位\",{\"1\":{\"388\":1}}],[\"加1\",{\"1\":{\"359\":1}}],[\"加群\",{\"1\":{\"209\":1}}],[\"加入对静态资源的处理\",{\"1\":{\"819\":1}}],[\"加入mymapper\",{\"1\":{\"745\":1}}],[\"加入\",{\"1\":{\"212\":1}}],[\"加入我们\",{\"1\":{\"211\":1}}],[\"加入群消息自行获取\",{\"1\":{\"209\":1}}],[\"加入环境变量\",{\"1\":{\"125\":1}}],[\"加锁过程要保证原子性\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"加锁和解锁的过程需要手动进行\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"加锁和解锁的过程自动进行\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"加锁\",{\"1\":{\"82\":1}}],[\"加载的\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"加载映射文件\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"加载servlet后\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"加载类\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"加载数据并回设到缓存\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"加载数据库配置\",{\"1\":{\"815\":1}}],[\"加载因子loadfactor等\",{\"1\":{\"948\":1}}],[\"加载驱动\",{\"1\":{\"737\":1}}],[\"加载内存\",{\"1\":{\"440\":1}}],[\"加载\",{\"1\":{\"82\":1,\"247\":1,\"440\":1,\"934\":1,\"1128\":1,\"1148\":1,\"1218\":1,\"1321\":1,\"1339\":1,\"1395\":1}}],[\"不到万不得已不去拿锁\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"不带spring事务的方法内\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"不为空\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"不建议用\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"不必担心最后是否释放锁\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"不易操作\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"不易存储\",{\"1\":{\"385\":1}}],[\"不安全\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"不允许还有人不会\",{\"1\":{\"1442\":1}}],[\"不允许其他线程同时执行\",{\"1\":{\"1018\":1}}],[\"不允许值重复或者值为空\",{\"1\":{\"495\":1}}],[\"不推荐使用\",{\"1\":{\"988\":1}}],[\"不客气\",{\"1\":{\"972\":1,\"980\":1,\"982\":1,\"986\":1,\"988\":1,\"994\":1,\"996\":1,\"1002\":1,\"1006\":1,\"1008\":1}}],[\"不敢说很熟悉\",{\"1\":{\"954\":1}}],[\"不生效\",{\"1\":{\"950\":1}}],[\"不错\",{\"1\":{\"942\":1,\"946\":1,\"948\":1,\"952\":1,\"954\":1,\"984\":1,\"1018\":1}}],[\"不停顿太久\",{\"1\":{\"940\":1}}],[\"不像以上三种方式是多个线程之间的通信\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"不像cms要全部stw\",{\"1\":{\"940\":1}}],[\"不像二叉树那样\",{\"1\":{\"266\":1}}],[\"不适合缓存\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"不适合大数据量用\",{\"1\":{\"440\":1}}],[\"不适用于需要极低停顿的场景\",{\"1\":{\"938\":1}}],[\"不适用服务器环境\",{\"1\":{\"936\":1}}],[\"不重复加载\",{\"1\":{\"934\":1}}],[\"不重复元素的个数有多少\",{\"1\":{\"659\":1}}],[\"不断探索新的知识和技术\",{\"1\":{\"996\":1}}],[\"不断提高自己\",{\"1\":{\"958\":1}}],[\"不断提高自己对这方面的认知\",{\"1\":{\"922\":1}}],[\"不断深耕累积\",{\"1\":{\"942\":1}}],[\"不断总结与提高\",{\"1\":{\"942\":1}}],[\"不断总结和实践\",{\"1\":{\"922\":1}}],[\"不断通过实践来提高各工具与理论的运用能力\",{\"1\":{\"942\":1}}],[\"不撤销\",{\"1\":{\"918\":1}}],[\"不删除工作空间改动代码\",{\"1\":{\"918\":2}}],[\"不想提交\",{\"1\":{\"916\":1}}],[\"不了解可以先不用在意\",{\"1\":{\"911\":1}}],[\"不了解整个项目的开发流程\",{\"1\":{\"211\":1}}],[\"不论如何定义\",{\"1\":{\"1431\":1}}],[\"不论这些请求是否得到了正确的执行\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"不论最终结果如何\",{\"1\":{\"922\":1}}],[\"不论是我们在买菜\",{\"1\":{\"871\":1}}],[\"不论你学什么语言\",{\"1\":{\"100\":1}}],[\"不然自定义的异常也会被转换为appointexception\",{\"1\":{\"830\":1}}],[\"不然\",{\"1\":{\"826\":1}}],[\"不熟悉查看前面文章\",{\"1\":{\"809\":1}}],[\"不一一测试了\",{\"1\":{\"828\":1}}],[\"不一一介绍\",{\"1\":{\"809\":1}}],[\"不一定是提交的哈希值\",{\"1\":{\"917\":1}}],[\"不一定\",{\"1\":{\"763\":1}}],[\"不一定完全精确\",{\"1\":{\"339\":1}}],[\"不开启\",{\"1\":{\"790\":1}}],[\"不区分大小写\",{\"1\":{\"768\":1}}],[\"不写实现类\",{\"1\":{\"761\":1}}],[\"不写也行\",{\"1\":{\"488\":1}}],[\"不但创建目录结构和pom\",{\"1\":{\"704\":1}}],[\"不但严重浪费了空间\",{\"1\":{\"361\":1}}],[\"不知道🤷‍♀️该看点什么来\",{\"1\":{\"920\":1}}],[\"不知道如何部署\",{\"1\":{\"698\":1}}],[\"不知道什么是x265\",{\"1\":{\"135\":1}}],[\"不做任何操作\",{\"1\":{\"960\":1}}],[\"不做过多解释\",{\"1\":{\"692\":1}}],[\"不做深入讲解\",{\"1\":{\"435\":1}}],[\"不讲虚的\",{\"1\":{\"652\":1}}],[\"不支持排序等\",{\"1\":{\"922\":1}}],[\"不支持\",{\"1\":{\"897\":1}}],[\"不支持降级操作\",{\"1\":{\"630\":1}}],[\"不支持sql语句\",{\"1\":{\"588\":1}}],[\"不理解什么是跳跃表\",{\"1\":{\"628\":1}}],[\"不在多个线程间共享\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"不在一个事务中\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"不在进行时\",{\"1\":{\"624\":1}}],[\"不在指定区间之内的元素都将被删除\",{\"1\":{\"604\":1}}],[\"不存在就创建\",{\"1\":{\"664\":1}}],[\"不存在时\",{\"1\":{\"605\":1,\"960\":1}}],[\"不存储实际数据\",{\"1\":{\"503\":1}}],[\"不执行任何操作\",{\"1\":{\"604\":2}}],[\"不仅提升了数据读取的效率\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"不仅因为消耗内存\",{\"1\":{\"602\":1}}],[\"不仅仅支持简单的\",{\"1\":{\"592\":1}}],[\"不仅仅是\",{\"1\":{\"400\":1,\"960\":1}}],[\"不再赘述\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"不再被使用的对象\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"不再需要强制类型转换\",{\"1\":{\"966\":1}}],[\"不再由容器管理\",{\"1\":{\"594\":1}}],[\"不再成为你的知识盲点\",{\"1\":{\"262\":1}}],[\"不加锁\",{\"1\":{\"575\":1}}],[\"不能回滚\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"不能被实例化\",{\"1\":{\"1113\":1,\"1308\":1}}],[\"不能被中断\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"不能被强行剥夺\",{\"1\":{\"562\":1}}],[\"不能是基本类型\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"不能是对象\",{\"1\":{\"944\":1}}],[\"不能在\",{\"1\":{\"966\":1}}],[\"不能保证原子性\",{\"1\":{\"924\":1}}],[\"不能统一返回\",{\"1\":{\"831\":1}}],[\"不能防止sql注入\",{\"1\":{\"779\":1}}],[\"不能获取值\",{\"1\":{\"440\":1}}],[\"不可重复读指的是在同一事务内\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"不可重复读\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"不可重复读和幻读等\",{\"1\":{\"553\":1}}],[\"不可靠\",{\"1\":{\"1135\":1,\"1328\":1}}],[\"不可变说的是变量当中的地址值不可改变\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"不可变说的是变量当中的数据不可改变\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"不可变的\",{\"1\":{\"988\":1}}],[\"不可以防止sql注入\",{\"1\":{\"763\":1}}],[\"不可剥夺条件\",{\"1\":{\"562\":1}}],[\"不可能全部存储在内存中\",{\"1\":{\"271\":1}}],[\"不影响表结构\",{\"1\":{\"518\":1}}],[\"不是同个请求\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"不是主节点\",{\"1\":{\"1008\":1}}],[\"不是线程安全的\",{\"1\":{\"988\":1}}],[\"不是性能瓶颈\",{\"1\":{\"960\":1}}],[\"不是列表类型\",{\"1\":{\"604\":1}}],[\"不是所有的方法都需要事务\",{\"1\":{\"830\":1}}],[\"不是所有字段都要走索引\",{\"1\":{\"510\":1}}],[\"不是所有情况都不允许回表\",{\"1\":{\"504\":1}}],[\"不是\",{\"1\":{\"500\":1,\"658\":1,\"1115\":1,\"1310\":1}}],[\"不同点\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"不同\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"不同在于其存储作用域为\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"不同线程的run\",{\"1\":{\"1098\":1,\"1296\":1}}],[\"不同服务节点之间的通信是如何做的呢\",{\"1\":{\"1033\":1}}],[\"不同服务节点之间经常需要相互调用\",{\"1\":{\"1033\":1}}],[\"不同map中null键与null值的处理方式\",{\"1\":{\"948\":1}}],[\"不同map实现类的序列化方式与注意事项\",{\"1\":{\"948\":1}}],[\"不同list的扩容策略及性能影响\",{\"1\":{\"946\":1}}],[\"不同层高节点\",{\"1\":{\"628\":1}}],[\"不同的时刻读到的同一批数据可能是不一样的\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"不同的sqlsession之间的缓存数据也不是想互访就能互访的\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"不同的哈希函数对hashmap性能的影响\",{\"1\":{\"948\":1}}],[\"不同的是\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"不同的是它为本地方法服务\",{\"1\":{\"930\":1}}],[\"不同的是每个元素都会关联一个\",{\"1\":{\"607\":1}}],[\"不同的编码可以在不同的使用场景上优化对象的使用效率\",{\"1\":{\"636\":1}}],[\"不同的业务库可根据自身情况定制优化方案\",{\"1\":{\"520\":1}}],[\"不同的一点是b\",{\"1\":{\"266\":1}}],[\"不同值的数量较少\",{\"1\":{\"510\":1}}],[\"不同版本中支持程度不同\",{\"1\":{\"495\":1}}],[\"不被索引\",{\"1\":{\"440\":1}}],[\"不容易出错\",{\"1\":{\"438\":1}}],[\"不分词字段\",{\"1\":{\"440\":1}}],[\"不分词\",{\"1\":{\"411\":1}}],[\"不转小写\",{\"1\":{\"411\":1}}],[\"不懂的同学建议不要交太多学费\",{\"1\":{\"408\":1}}],[\"不用我再解释了\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"不用等待所有的连接\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"不用编程\",{\"1\":{\"906\":1}}],[\"不用\",{\"1\":{\"387\":1,\"954\":1}}],[\"不得不插入后再做一次更新\",{\"1\":{\"383\":1}}],[\"不改变参数内容\",{\"1\":{\"352\":2,\"364\":1}}],[\"不放过一个\",{\"1\":{\"330\":1}}],[\"不需要添加\",{\"1\":{\"1444\":1}}],[\"不需要添加版本\",{\"1\":{\"710\":1}}],[\"不需要打成\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"不需要数据库提供特殊的支持\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"不需要花费精力去处理加载驱动\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"不需要等待响应\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"不需要强转\",{\"1\":{\"966\":1}}],[\"不需要在程序中进行大量的字符串拼接\",{\"1\":{\"958\":1}}],[\"不需要频繁使用\",{\"1\":{\"954\":1}}],[\"不需要一次全堆回收\",{\"1\":{\"940\":1}}],[\"不需要stw\",{\"1\":{\"938\":2}}],[\"不需要stop\",{\"1\":{\"938\":1}}],[\"不需要手动关闭引擎\",{\"1\":{\"864\":1}}],[\"不需要用户干预\",{\"1\":{\"574\":1}}],[\"不需要用户显式操作\",{\"1\":{\"561\":1,\"566\":1}}],[\"不需要额外的工作\",{\"1\":{\"382\":1}}],[\"不需要寻道时间\",{\"1\":{\"274\":1}}],[\"不需要什么奖励\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"648\":1,\"698\":1,\"732\":1}}],[\"不携带任何业务信息的日志\",{\"1\":{\"201\":1}}],[\"不携带上下文\",{\"0\":{\"201\":1}}],[\"不要将其设置为\",{\"1\":{\"954\":1}}],[\"不要穿插其他网络操作\",{\"1\":{\"830\":1}}],[\"不要关闭原\",{\"1\":{\"597\":1}}],[\"不要返回用不到的任何字段\",{\"0\":{\"540\":1}}],[\"不要在\",{\"0\":{\"533\":1}}],[\"不要放过任何一个你模凌两可的点\",{\"1\":{\"488\":1}}],[\"不要打印无意义的日志\",{\"0\":{\"201\":1}}],[\"不要打印重复日志\",{\"0\":{\"198\":1}}],[\"不要用e\",{\"0\":{\"196\":1}}],[\"不要使用日志系统的\",{\"0\":{\"194\":1}}],[\"不要上来直接\",{\"1\":{\"191\":1}}],[\"不要超过一个阈值\",{\"1\":{\"134\":1}}],[\"不管是抛出异常或者正常退出都会执行\",{\"1\":{\"689\":1}}],[\"不管用哪种\",{\"1\":{\"178\":1}}],[\"不管有没有初始化实例\",{\"1\":{\"82\":1}}],[\"不会马上进入运行状态\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"不会再给默认值了\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"不会阻塞客户端请求\",{\"1\":{\"962\":1}}],[\"不会影响应用的访问\",{\"1\":{\"962\":1}}],[\"不会触发初始化\",{\"1\":{\"934\":2}}],[\"不会误导小菜鸟我\",{\"1\":{\"934\":1}}],[\"不会因为紧张的忘记\",{\"1\":{\"920\":1}}],[\"不会让一个模块资源占用过高\",{\"1\":{\"645\":1}}],[\"不会命中索引\",{\"1\":{\"535\":1}}],[\"不会有不同的配置\",{\"1\":{\"387\":1}}],[\"不会有spof\",{\"1\":{\"153\":1}}],[\"不会对时间有任何影响\",{\"1\":{\"273\":1}}],[\"不会对系统运行造成大的影响\",{\"1\":{\"191\":1}}],[\"不会对整个系统造成大的影响\",{\"1\":{\"166\":1}}],[\"不对外提供服务\",{\"1\":{\"153\":1}}],[\"不打印节头和页脚\",{\"1\":{\"143\":1}}],[\"不打印每个字段的键\",{\"1\":{\"143\":1}}],[\"不处理音频\",{\"1\":{\"127\":1}}],[\"不处理视频\",{\"1\":{\"127\":1}}],[\"不过这点性能损失在大部分情况下可以忽略\",{\"1\":{\"966\":1}}],[\"不过list相关知识还有更广阔的空间\",{\"1\":{\"946\":1}}],[\"不过日常工作中也对jvm参数与监控工具稍有使用\",{\"1\":{\"942\":1}}],[\"不过也可以直接运行\",{\"1\":{\"711\":1}}],[\"不过由于\",{\"1\":{\"450\":1}}],[\"不过由于一般系统分页都要大于1k\",{\"1\":{\"106\":2}}],[\"不过\",{\"1\":{\"446\":1,\"632\":1,\"1006\":1}}],[\"不过是一种特殊的线性表\",{\"1\":{\"282\":1}}],[\"不过目前已经有多磁头独立技术\",{\"1\":{\"274\":1}}],[\"不过可以将其设置为更小\",{\"1\":{\"106\":1}}],[\"不只可以下载\",{\"1\":{\"97\":1}}],[\"不如加上三五好友加入\",{\"1\":{\"49\":1}}],[\"关系建立开始\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"关系型数据库本身比较容易成为系统瓶颈\",{\"1\":{\"515\":1}}],[\"关闭缓存swap\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"关闭定时任务job\",{\"1\":{\"864\":1}}],[\"关闭二级缓存\",{\"1\":{\"790\":1}}],[\"关闭会话\",{\"1\":{\"751\":1}}],[\"关闭连接后不自动commit\",{\"1\":{\"815\":1}}],[\"关闭连接\",{\"1\":{\"737\":1}}],[\"关闭redis的服务保护模式\",{\"1\":{\"673\":1}}],[\"关闭资源\",{\"1\":{\"645\":1}}],[\"关注javapub会做详细讲解\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"关注openjdk等开源项目了解jvm的最新进展与发展方向\",{\"1\":{\"942\":1}}],[\"关注\",{\"1\":{\"521\":1,\"594\":1}}],[\"关键源码和视频自学\",{\"1\":{\"1429\":1}}],[\"关键的不同在于vector的对外提供操作的方法都是用synchronized修饰的\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"关键是\",{\"1\":{\"950\":1}}],[\"关键还是它发明的这套\",{\"1\":{\"940\":1}}],[\"关键字不能同时使用\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"关键字用来修饰一个方法的时候\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"关键字用来修饰一个类的时候\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"关键字可以确保变量的可见性\",{\"1\":{\"1022\":1}}],[\"关键字可以确保在同一时间只有一个线程可以访问被修饰的代码\",{\"1\":{\"1022\":1}}],[\"关键字可能会导致线程安全问题\",{\"1\":{\"924\":1}}],[\"关键字都可以用来实现多线程之间的同步\",{\"1\":{\"1022\":1}}],[\"关键字之间的区别吗\",{\"1\":{\"1022\":1}}],[\"关键字和\",{\"1\":{\"1022\":3,\"1091\":1,\"1292\":1}}],[\"关键字带来的性能开销\",{\"1\":{\"1022\":1}}],[\"关键字带来的性能开销吗\",{\"1\":{\"1022\":1}}],[\"关键字会带来一些性能上的开销\",{\"1\":{\"1022\":1}}],[\"关键字修饰的代码块时\",{\"1\":{\"1022\":3}}],[\"关键字修饰的方法或代码块后\",{\"1\":{\"1022\":1}}],[\"关键字修饰的方法或代码块\",{\"1\":{\"1022\":1}}],[\"关键字修饰的方法或代码块时\",{\"1\":{\"1022\":3}}],[\"关键字修饰\",{\"1\":{\"1022\":1,\"1091\":1,\"1292\":1}}],[\"关键字修饰了一个代码块\",{\"1\":{\"1022\":1}}],[\"关键字修饰了\",{\"1\":{\"1022\":1}}],[\"关键字对\",{\"1\":{\"988\":1}}],[\"关键字或者\",{\"1\":{\"924\":1}}],[\"关键字只能保证可见性\",{\"1\":{\"924\":1}}],[\"关键字有什么缺点吗\",{\"1\":{\"924\":1}}],[\"关键字的同步机制\",{\"1\":{\"1023\":1}}],[\"关键字的底层实现是通过\",{\"1\":{\"1022\":1}}],[\"关键字的底层\",{\"1\":{\"1022\":1}}],[\"关键字的性能\",{\"1\":{\"1022\":1}}],[\"关键字的性能开销比较大\",{\"1\":{\"1022\":1}}],[\"关键字的性能开销\",{\"1\":{\"1022\":1}}],[\"关键字的优化策略吗\",{\"1\":{\"1022\":1}}],[\"关键字的缺点吗\",{\"1\":{\"1022\":1}}],[\"关键字的理解很清晰\",{\"1\":{\"1022\":1}}],[\"关键字的理解非常清晰\",{\"1\":{\"924\":1}}],[\"关键字的示例\",{\"1\":{\"1022\":1}}],[\"关键字的实现是基于对象头中的标记字\",{\"1\":{\"1022\":1}}],[\"关键字的实现原理吗\",{\"1\":{\"1022\":1}}],[\"关键字的实现涉及到以下几个方面\",{\"1\":{\"924\":1}}],[\"关键字的使用方法吗\",{\"1\":{\"1022\":1}}],[\"关键字的作用呢\",{\"1\":{\"924\":1}}],[\"关键字的作用吗\",{\"1\":{\"924\":1}}],[\"关键字的作用\",{\"0\":{\"1084\":1,\"1285\":1},\"1\":{\"692\":2,\"924\":1}}],[\"关键字是\",{\"1\":{\"1022\":1}}],[\"关键字是如何保证可见性的吗\",{\"1\":{\"924\":1}}],[\"关键字是我们处理线程安全的一个利器\",{\"1\":{\"82\":1}}],[\"关键字来修饰变量\",{\"1\":{\"1022\":1}}],[\"关键字来修饰一个代码块\",{\"1\":{\"1022\":1}}],[\"关键字来修饰方法或代码块\",{\"1\":{\"1022\":1}}],[\"关键字来解决这个问题\",{\"1\":{\"924\":1}}],[\"关键字来实现\",{\"1\":{\"692\":1}}],[\"关键字\",{\"1\":{\"692\":1,\"1022\":1}}],[\"关键字机制\",{\"1\":{\"692\":1}}],[\"关键\",{\"0\":{\"350\":1}}],[\"关键路径\",{\"0\":{\"325\":1}}],[\"关键日志\",{\"1\":{\"191\":1}}],[\"关于持久和顺序这两个关键字\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"关于es的面试\",{\"1\":{\"1067\":1}}],[\"关于hashmap\",{\"1\":{\"948\":1}}],[\"关于list\",{\"1\":{\"946\":1}}],[\"关于key的几条规则\",{\"1\":{\"602\":2}}],[\"关于\",{\"1\":{\"419\":1,\"481\":1}}],[\"关于布隆过滤器\",{\"0\":{\"330\":1}}],[\"关于队列的操作\",{\"1\":{\"287\":1}}],[\"关于我\",{\"2\":{\"215\":1,\"220\":1}}],[\"关于作者\",{\"2\":{\"102\":1}}],[\"关于网站\",{\"0\":{\"50\":1}}],[\"关于这些扩展\",{\"1\":{\"30\":1}}],[\"关于站长\",{\"0\":{\"2\":1}}],[\"设username=javapub\",{\"1\":{\"1174\":2,\"1359\":2}}],[\"设计调优\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"设计稳定的容错方案\",{\"1\":{\"950\":1}}],[\"设计一个高并发系统\",{\"1\":{\"950\":1}}],[\"设计不好会导致性能下降\",{\"1\":{\"922\":1}}],[\"设计上要保证唯一性\",{\"1\":{\"871\":1,\"872\":1}}],[\"设计成泛型\",{\"1\":{\"830\":1}}],[\"设计良好的覆盖索引可以显著减少回表操作\",{\"1\":{\"504\":1}}],[\"设计\",{\"1\":{\"225\":1,\"1429\":1,\"1439\":3}}],[\"设计模式构建的\",{\"1\":{\"950\":1}}],[\"设计模式\",{\"0\":{\"75\":1},\"1\":{\"524\":1,\"824\":1,\"1237\":1,\"1410\":1}}],[\"设定null\",{\"1\":{\"434\":1}}],[\"设定声音编解码器\",{\"1\":{\"127\":1}}],[\"设定声音的channel数\",{\"1\":{\"127\":1}}],[\"设定采样率\",{\"1\":{\"127\":1}}],[\"设定视频编解码器\",{\"1\":{\"127\":1}}],[\"设定视频流量\",{\"1\":{\"127\":1}}],[\"设定画面的比例\",{\"1\":{\"127\":1}}],[\"设定画面的宽与高\",{\"1\":{\"127\":1}}],[\"设定帧速率\",{\"1\":{\"127\":1}}],[\"设定输出格式\",{\"1\":{\"127\":1}}],[\"设定输入流\",{\"1\":{\"127\":1}}],[\"设定查看nginx状态的地址\",{\"1\":{\"106\":1}}],[\"设定缓存文件夹大小\",{\"1\":{\"106\":1}}],[\"设定通过nginx上传文件的大小\",{\"1\":{\"106\":1}}],[\"设定http服务器\",{\"1\":{\"106\":1}}],[\"设置锁超时时间\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"设置不同的过期时间\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"设置一个阈值\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"设置一些缺失字段的初始化值\",{\"1\":{\"440\":1}}],[\"设置新生代\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"设置新值\",{\"1\":{\"603\":1}}],[\"设置年轻的和老年代的内存比例为\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"设置instance指向刚分配的内存地址\",{\"1\":{\"1099\":2,\"1297\":2}}],[\"设置instance实例指向刚分配的内存空间\",{\"1\":{\"80\":1}}],[\"设置最大文件句柄数\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"设置最多多少空闲的\",{\"1\":{\"648\":1}}],[\"设置合理的路由机制\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"设置较短的过期时间\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"设置age值为30\",{\"1\":{\"960\":1}}],[\"设置name的值为\",{\"1\":{\"960\":1}}],[\"设置字符串值\",{\"1\":{\"960\":1}}],[\"设置堆最大值和初始值\",{\"1\":{\"942\":1}}],[\"设置堆内存\",{\"1\":{\"406\":1}}],[\"设置g1垃圾收集器\",{\"1\":{\"942\":2}}],[\"设置gzip压缩针对的http协议版本\",{\"1\":{\"106\":1}}],[\"设置jvm参数\",{\"1\":{\"942\":1}}],[\"设置键值对的值\",{\"1\":{\"928\":1}}],[\"设置参数\",{\"1\":{\"737\":1}}],[\"设置系统环境变量path\",{\"1\":{\"702\":1}}],[\"设置方法问google\",{\"1\":{\"692\":1}}],[\"设置方式\",{\"1\":{\"403\":1}}],[\"设置过期时间\",{\"1\":{\"664\":1}}],[\"设置是否提前进行测试借用\",{\"1\":{\"648\":1}}],[\"设置是否此字段包含在\",{\"1\":{\"440\":1}}],[\"设置等待可用连接的最大时间\",{\"1\":{\"648\":1}}],[\"设置连接实例最大数目\",{\"1\":{\"648\":1}}],[\"设置哈希表字段的值\",{\"1\":{\"605\":1}}],[\"设置\",{\"1\":{\"597\":1,\"603\":1,\"982\":2}}],[\"设置和获取的值是一个\",{\"1\":{\"591\":1}}],[\"设置条件\",{\"1\":{\"486\":1}}],[\"设置搜索时的分词器\",{\"1\":{\"440\":1}}],[\"设置成false\",{\"1\":{\"440\":1}}],[\"设置为主读取的缓存\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"设置为对象类型\",{\"1\":{\"451\":1}}],[\"设置为\",{\"1\":{\"431\":1}}],[\"设置为默认值\",{\"1\":{\"143\":1}}],[\"设置的好处是\",{\"1\":{\"134\":1}}],[\"设置b\",{\"1\":{\"134\":1}}],[\"设置在写入proxy\",{\"1\":{\"106\":1}}],[\"设置用于读取应答\",{\"1\":{\"106\":1}}],[\"设置从被代理服务器读取的第一部分应答的缓冲区大小\",{\"1\":{\"106\":1}}],[\"设置代理服务器\",{\"1\":{\"106\":1}}],[\"设置压缩所需要的缓冲区大小\",{\"1\":{\"106\":1}}],[\"设置值和cpu核心数一致\",{\"1\":{\"106\":1}}],[\"设置启动用户和用户组\",{\"1\":{\"106\":1}}],[\"jconsole\",{\"1\":{\"942\":1}}],[\"jcp\",{\"1\":{\"820\":3}}],[\"jvisualvm\",{\"1\":{\"942\":2}}],[\"jvm创建对象并不会调用任何构造函数\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"jvm就会创建一个新的对象\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"jvm并不知道泛型的存在\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"jvms\",{\"1\":{\"1084\":3,\"1285\":3}}],[\"jvm调优主要通过以下手段\",{\"1\":{\"942\":1}}],[\"jvm调优\",{\"0\":{\"942\":1}}],[\"jvm栈\",{\"1\":{\"936\":2}}],[\"jvm要真正帮我干活了\",{\"1\":{\"934\":1}}],[\"jvm还需要干什么\",{\"1\":{\"934\":1}}],[\"jvm该准备干啥\",{\"1\":{\"934\":1}}],[\"jvm会给我们创建一个单独的对象\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"jvm会首先搜索类的加载路径\",{\"1\":{\"934\":1}}],[\"jvm会使用tlab\",{\"1\":{\"930\":1}}],[\"jvm会使用各种内存分配算法和内存分配器\",{\"1\":{\"930\":1}}],[\"jvm会使用各种垃圾回收算法和垃圾回收器\",{\"1\":{\"930\":1}}],[\"jvm会使用分代垃圾回收算法来对不同年龄段的对象进行不同的回收策略\",{\"1\":{\"930\":1}}],[\"jvm会使用对象池技术来重复利用对象\",{\"1\":{\"930\":1}}],[\"jvm会对对象的创建和销毁进行优化\",{\"1\":{\"930\":1}}],[\"jvm内存结构图示\",{\"1\":{\"936\":1}}],[\"jvm内存结构分为\",{\"1\":{\"936\":1}}],[\"jvm内存结构与垃圾回收有密切关系\",{\"1\":{\"936\":1}}],[\"jvm内存模型的优化策略主要有以下几个方面\",{\"1\":{\"930\":1}}],[\"jvm内存模型主要由以下几个部分组成\",{\"1\":{\"930\":1}}],[\"jvm内存模型是java程序运行时内存使用的规范\",{\"1\":{\"930\":1}}],[\"jvm内存模型\",{\"0\":{\"930\":1}}],[\"jvm内存太大容易挂掉\",{\"1\":{\"615\":1}}],[\"jvm在运行时候的内存分配过程\",{\"1\":{\"692\":2}}],[\"jvm\",{\"0\":{\"1143\":1,\"1146\":1,\"1147\":1,\"1151\":1,\"1332\":1,\"1334\":1,\"1337\":1,\"1338\":1,\"1342\":1},\"1\":{\"406\":1,\"524\":1,\"656\":1,\"692\":4,\"887\":1,\"889\":1,\"924\":8,\"930\":1,\"1023\":2,\"1048\":1,\"1141\":2,\"1143\":1,\"1151\":1,\"1257\":1,\"1334\":1},\"2\":{\"1154\":1}}],[\"jvm为了提高程序执行性能\",{\"1\":{\"80\":1}}],[\"jianmang\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"jia部分stw\",{\"1\":{\"936\":1}}],[\"jint\",{\"1\":{\"924\":10}}],[\"jinjin\",{\"1\":{\"763\":1,\"786\":1}}],[\"jfloat\",{\"1\":{\"924\":4}}],[\"jlong\",{\"1\":{\"924\":8}}],[\"jetty\",{\"1\":{\"726\":1}}],[\"jeck\",{\"1\":{\"723\":1}}],[\"jerry\",{\"1\":{\"723\":1}}],[\"jedispoolconfig\",{\"1\":{\"648\":3}}],[\"jedispool\",{\"1\":{\"648\":7}}],[\"jedisconnectionexception\",{\"1\":{\"648\":1}}],[\"jedis\",{\"1\":{\"342\":1,\"648\":26,\"664\":2,\"812\":1}}],[\"just\",{\"1\":{\"942\":1}}],[\"junmajinlong\",{\"1\":{\"904\":1}}],[\"junit的\",{\"1\":{\"944\":1}}],[\"junit启动时加载springioc容器\",{\"1\":{\"828\":1}}],[\"junit4\",{\"1\":{\"828\":1}}],[\"junit\",{\"1\":{\"715\":3,\"757\":2,\"763\":2,\"828\":4,\"830\":1}}],[\"judgeless\",{\"1\":{\"865\":3}}],[\"judgemore\",{\"1\":{\"865\":3}}],[\"judgetask\",{\"1\":{\"865\":6}}],[\"juejin\",{\"1\":{\"663\":1}}],[\"jdouble\",{\"1\":{\"924\":4}}],[\"jdbc3keygenerator\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"jdbcurl\",{\"1\":{\"815\":1}}],[\"jdbc<\",{\"1\":{\"812\":1}}],[\"jdbc4connection\",{\"1\":{\"790\":1}}],[\"jdbctemplate的query方法总体结构是一个模板方法+回调函数\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"jdbctest\",{\"1\":{\"737\":2}}],[\"jdbctransaction\",{\"1\":{\"789\":3,\"790\":2}}],[\"jdbc类型的事务管理器\",{\"1\":{\"743\":2,\"745\":1}}],[\"jdbc缺点分析\",{\"0\":{\"738\":1}}],[\"jdbc代码回顾\",{\"0\":{\"737\":1}}],[\"jdbc驱动\",{\"1\":{\"706\":1}}],[\"jdbc\",{\"0\":{\"816\":1},\"1\":{\"645\":2,\"737\":2,\"743\":6,\"745\":3,\"789\":6,\"790\":5,\"815\":5,\"816\":6,\"818\":1,\"864\":2,\"950\":1,\"958\":1,\"1179\":2,\"1364\":2,\"1444\":2}}],[\"jdk动态代理\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"jdk5引入\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"jdk9默认\",{\"1\":{\"936\":1}}],[\"jdk源码中classloader的继承关系\",{\"1\":{\"934\":1}}],[\"jdk8\",{\"1\":{\"404\":1,\"808\":1}}],[\"jdk\",{\"1\":{\"404\":1,\"1032\":1}}],[\"jdk17\",{\"1\":{\"1444\":1}}],[\"jdk1\",{\"0\":{\"1120\":1,\"1315\":1},\"1\":{\"402\":1,\"403\":1}}],[\"job\",{\"1\":{\"887\":2}}],[\"join其实合理理解成是线程合并\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"join方式\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"joinpoint\",{\"1\":{\"689\":14,\"1092\":4,\"1293\":4}}],[\"join参考\",{\"1\":{\"457\":1}}],[\"join类型\",{\"0\":{\"457\":1}}],[\"join\",{\"1\":{\"455\":2,\"457\":11,\"793\":2,\"794\":2,\"795\":3,\"827\":1,\"1107\":3,\"1217\":2,\"1305\":3,\"1394\":2}}],[\"john\",{\"1\":{\"436\":2,\"960\":4}}],[\"j++\",{\"1\":{\"360\":1,\"377\":1,\"1085\":1,\"1286\":1}}],[\"j\",{\"1\":{\"352\":8,\"360\":2,\"364\":3,\"377\":3,\"922\":5,\"1085\":1,\"1286\":1}}],[\"jmx\",{\"1\":{\"158\":1}}],[\"jp\",{\"1\":{\"689\":2}}],[\"jpg等\",{\"1\":{\"819\":1}}],[\"jpg\",{\"1\":{\"141\":1,\"339\":1,\"738\":1,\"876\":2,\"913\":1}}],[\"jpeg\",{\"1\":{\"141\":2,\"602\":1}}],[\"jxvf\",{\"1\":{\"125\":1}}],[\"jsr\",{\"1\":{\"952\":1}}],[\"jstlview\",{\"1\":{\"819\":1}}],[\"js\",{\"1\":{\"819\":1}}],[\"jsp变为\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"jsp的执行过程\",{\"0\":{\"1130\":1,\"1323\":1}}],[\"jsp的9内置对象及其含义\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"jsp页面由系统翻译成servlet\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"jsp页面本身\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"jsp是servlet的一种特殊形式\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"jsp是在html代码里面写java代码\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"jsp允许使用特殊标签直接嵌入到html页面\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"jsp使人们将显示和逻辑分隔称为可能\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"jsp有9个内置对象\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"jsp<\",{\"1\":{\"820\":1}}],[\"jsp\",{\"0\":{\"1127\":1,\"1320\":1},\"1\":{\"819\":3,\"831\":3,\"832\":1}}],[\"jsp|jspx|do\",{\"1\":{\"106\":1}}],[\"json默认读写支持\",{\"1\":{\"819\":1}}],[\"json数据格式\",{\"1\":{\"420\":1}}],[\"json\",{\"1\":{\"183\":2,\"436\":3,\"439\":2,\"443\":1,\"446\":2,\"450\":2,\"451\":6,\"831\":4,\"852\":1,\"1092\":1,\"1293\":1}}],[\"jsonp\",{\"1\":{\"104\":1,\"1136\":1,\"1329\":1}}],[\"js|css\",{\"1\":{\"106\":2}}],[\"js和css缓存时间设置\",{\"1\":{\"106\":1}}],[\"jack\",{\"1\":{\"960\":4,\"1176\":1,\"1361\":1}}],[\"jackson\",{\"1\":{\"812\":1}}],[\"jackie\",{\"1\":{\"439\":1}}],[\"jar等\",{\"1\":{\"934\":1}}],[\"jar包\",{\"1\":{\"854\":1}}],[\"jar是自己生成的\",{\"1\":{\"850\":1}}],[\"jar中\",{\"1\":{\"850\":1}}],[\"jar文件不用在每个项目保存\",{\"1\":{\"700\":1}}],[\"jar在不同阶段无法个性化配置\",{\"1\":{\"700\":1}}],[\"jar体积过大\",{\"1\":{\"700\":1}}],[\"jar依赖\",{\"1\":{\"700\":1}}],[\"jar冲突\",{\"1\":{\"700\":1}}],[\"jar\",{\"1\":{\"94\":2,\"401\":1,\"648\":1,\"705\":1,\"713\":1,\"812\":1,\"844\":1,\"850\":6,\"851\":1}}],[\"java基础\",{\"0\":{\"1284\":1}}],[\"java导致内存泄露的原因很明确\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"java也还是存在着内存泄漏的情况\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"java是有gc垃圾回收机制的\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"java内存泄漏\",{\"0\":{\"1145\":1,\"1336\":1}}],[\"java变为\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"java提供\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"java如何实现多线程之间的通讯和协作\",{\"0\":{\"1102\":1,\"1300\":1}}],[\"java线程中将就绪\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"java并发\",{\"0\":{\"1295\":1},\"1\":{\"1097\":1}}],[\"java创建对象有几种方式\",{\"0\":{\"1093\":1,\"1294\":1}}],[\"java原生除了提供基本注解\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"java原生注解\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"java自动装箱和拆箱\",{\"0\":{\"1085\":1,\"1286\":1}}],[\"java容器常见面试题\",{\"1\":{\"1111\":1}}],[\"java容器篇\",{\"1\":{\"1041\":1}}],[\"java容器\",{\"1\":{\"1041\":1}}],[\"java范型\",{\"0\":{\"966\":1}}],[\"java的类加载过程由加载\",{\"1\":{\"934\":1}}],[\"java堆的内存结构主要由三个部分组成\",{\"1\":{\"930\":1}}],[\"java堆的作用是存放对象实例\",{\"1\":{\"930\":1}}],[\"java堆是被所有线程共享的一块内存区域\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"java堆是垃圾收集器管理的主要区域\",{\"1\":{\"930\":1}}],[\"java堆是java虚拟机所管理的内存中最大的一块\",{\"1\":{\"930\":1,\"1142\":1,\"1333\":1}}],[\"java堆\",{\"1\":{\"930\":1}}],[\"java虚拟机栈也是线程私有的\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"java虚拟机栈是线程私有的\",{\"1\":{\"930\":1}}],[\"java虚拟机栈\",{\"1\":{\"930\":1}}],[\"java中有5种创建对象的方式\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"java中8种基本数据类型\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"java中常用的map还有\",{\"1\":{\"922\":1}}],[\"java中引用\",{\"1\":{\"284\":1}}],[\"javanio\",{\"0\":{\"1020\":1},\"1\":{\"920\":1}}],[\"java反射\",{\"0\":{\"1010\":1},\"1\":{\"920\":1}}],[\"java多线程\",{\"0\":{\"988\":1},\"1\":{\"920\":1}}],[\"java泛型\",{\"1\":{\"920\":1}}],[\"java注解\",{\"0\":{\"944\":1},\"1\":{\"920\":1}}],[\"javax\",{\"1\":{\"876\":3}}],[\"javaub\",{\"1\":{\"838\":1,\"839\":1}}],[\"java文件\",{\"1\":{\"831\":1}}],[\"java图书业务接口\",{\"1\":{\"830\":1}}],[\"javaappointexception\",{\"1\":{\"829\":1}}],[\"javarepeatappointexception\",{\"1\":{\"829\":1}}],[\"java程序设计\",{\"1\":{\"824\":1}}],[\"javaee\",{\"0\":{\"1126\":1,\"1319\":1},\"1\":{\"820\":3,\"950\":2,\"1126\":3},\"2\":{\"1140\":1}}],[\"javatype=\",{\"1\":{\"793\":1,\"794\":2,\"795\":3,\"797\":2}}],[\"javatype\",{\"1\":{\"793\":1,\"794\":1,\"797\":2}}],[\"java接口\",{\"0\":{\"753\":1}}],[\"java<\",{\"1\":{\"735\":1,\"812\":1,\"862\":1,\"1444\":1}}],[\"javadoc\",{\"1\":{\"688\":2}}],[\"javase\",{\"0\":{\"678\":1},\"1\":{\"1084\":2,\"1101\":1,\"1285\":2,\"1299\":1}}],[\"javascript\",{\"1\":{\"589\":1,\"1136\":1,\"1329\":1}}],[\"javaweb\",{\"1\":{\"524\":1}}],[\"java语言\",{\"1\":{\"364\":1}}],[\"java代码优化\",{\"1\":{\"942\":1}}],[\"java代码\",{\"0\":{\"343\":1}}],[\"java实现\",{\"0\":{\"340\":1}}],[\"java版的一些demo\",{\"1\":{\"1079\":1,\"1283\":1}}],[\"java版\",{\"0\":{\"337\":1}}],[\"java里一个很重要的数据结构\",{\"1\":{\"282\":1}}],[\"java\",{\"0\":{\"7\":1,\"81\":1,\"87\":1,\"377\":1,\"746\":1,\"754\":1,\"1104\":1,\"1106\":1,\"1119\":1,\"1302\":1,\"1304\":1,\"1306\":1,\"1314\":1},\"1\":{\"84\":1,\"94\":5,\"101\":1,\"152\":2,\"337\":2,\"352\":2,\"364\":1,\"377\":2,\"385\":1,\"387\":2,\"388\":3,\"394\":1,\"397\":2,\"400\":1,\"523\":1,\"524\":1,\"615\":2,\"621\":2,\"648\":2,\"654\":1,\"656\":1,\"688\":1,\"689\":2,\"692\":4,\"737\":4,\"747\":5,\"753\":1,\"754\":1,\"756\":1,\"757\":3,\"762\":4,\"763\":4,\"766\":1,\"768\":2,\"769\":1,\"770\":1,\"772\":2,\"825\":3,\"826\":5,\"828\":7,\"829\":8,\"830\":8,\"831\":2,\"832\":2,\"836\":1,\"837\":1,\"839\":1,\"844\":3,\"850\":2,\"876\":1,\"922\":3,\"928\":1,\"932\":5,\"936\":7,\"938\":1,\"940\":2,\"946\":1,\"950\":3,\"956\":1,\"958\":2,\"984\":2,\"988\":1,\"990\":1,\"1010\":5,\"1016\":1,\"1018\":1,\"1020\":29,\"1022\":14,\"1023\":3,\"1032\":1,\"1033\":1,\"1045\":1,\"1048\":1,\"1083\":1,\"1084\":1,\"1093\":1,\"1104\":2,\"1105\":4,\"1107\":1,\"1111\":1,\"1112\":1,\"1119\":1,\"1130\":1,\"1142\":1,\"1143\":1,\"1175\":1,\"1254\":1,\"1257\":1,\"1285\":1,\"1294\":1,\"1302\":2,\"1303\":4,\"1305\":1,\"1307\":1,\"1314\":1,\"1323\":1,\"1333\":1,\"1334\":1,\"1360\":1,\"1443\":1},\"2\":{\"8\":1,\"679\":1,\"680\":1,\"691\":1,\"693\":1,\"695\":1,\"696\":1,\"717\":1,\"718\":1,\"720\":1,\"721\":1,\"729\":1,\"802\":1,\"803\":1,\"805\":1,\"806\":1,\"833\":1,\"841\":1,\"842\":1,\"845\":1,\"846\":1,\"857\":1,\"858\":1,\"868\":1,\"869\":1,\"879\":1,\"880\":1,\"1096\":1,\"1110\":1,\"1125\":1}}],[\"javapub666\",{\"1\":{\"1444\":1}}],[\"javapub博主\",{\"1\":{\"1431\":1}}],[\"javapub帮你下载\",{\"1\":{\"1093\":1,\"1107\":1}}],[\"javapub会单独写一篇深入图解nio和bio\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"javapubtest\",{\"1\":{\"1086\":9,\"1287\":9}}],[\"javapub在这里整理这些容易忘记的重点知识及解答\",{\"1\":{\"1041\":1,\"1056\":1,\"1067\":1,\"1083\":1,\"1097\":1,\"1111\":1,\"1126\":1,\"1141\":1,\"1155\":1,\"1171\":1,\"1184\":1,\"1197\":1,\"1210\":1,\"1223\":1,\"1236\":1}}],[\"javapub<\",{\"1\":{\"708\":1}}],[\"javapub版\",{\"1\":{\"528\":1}}],[\"javapub参考教程\",{\"1\":{\"520\":1}}],[\"javapub说\",{\"0\":{\"329\":1},\"1\":{\"917\":1}}],[\"javapub学习路线\",{\"1\":{\"219\":1}}],[\"javapub官网\",{\"1\":{\"219\":1}}],[\"javapub官方公众号\",{\"1\":{\"3\":1}}],[\"javapub讲坛\",{\"1\":{\"132\":2}}],[\"javapub为金九银十助力\",{\"1\":{\"78\":1}}],[\"javapub知识星球\",{\"1\":{\"49\":1}}],[\"javapub\",{\"1\":{\"1\":1,\"49\":2,\"79\":2,\"80\":2,\"83\":2,\"84\":2,\"90\":1,\"91\":2,\"106\":4,\"109\":1,\"150\":1,\"177\":2,\"180\":1,\"181\":2,\"182\":1,\"190\":1,\"192\":1,\"194\":1,\"195\":2,\"200\":1,\"209\":2,\"212\":1,\"214\":1,\"225\":2,\"249\":2,\"252\":1,\"288\":1,\"289\":1,\"328\":1,\"337\":3,\"347\":1,\"356\":1,\"364\":2,\"368\":1,\"377\":2,\"394\":1,\"425\":1,\"498\":1,\"501\":1,\"524\":1,\"525\":1,\"528\":1,\"587\":1,\"613\":1,\"648\":1,\"659\":5,\"664\":1,\"668\":1,\"673\":1,\"681\":1,\"686\":1,\"688\":3,\"689\":5,\"690\":1,\"698\":1,\"732\":1,\"812\":2,\"815\":2,\"818\":1,\"819\":1,\"825\":2,\"826\":4,\"827\":2,\"828\":7,\"829\":8,\"830\":19,\"831\":9,\"832\":2,\"838\":1,\"839\":1,\"844\":1,\"849\":4,\"856\":1,\"863\":1,\"864\":1,\"876\":3,\"885\":1,\"906\":1,\"920\":3,\"922\":4,\"924\":4,\"926\":4,\"928\":4,\"930\":4,\"932\":4,\"934\":3,\"936\":4,\"938\":4,\"940\":4,\"942\":4,\"944\":4,\"946\":4,\"948\":4,\"950\":4,\"952\":4,\"954\":4,\"956\":4,\"958\":4,\"960\":4,\"962\":4,\"964\":4,\"966\":4,\"968\":4,\"970\":4,\"972\":4,\"974\":4,\"976\":4,\"978\":4,\"980\":4,\"982\":4,\"984\":1,\"988\":4,\"990\":4,\"992\":4,\"994\":4,\"996\":4,\"998\":4,\"1000\":4,\"1002\":4,\"1004\":4,\"1006\":4,\"1008\":4,\"1010\":4,\"1012\":4,\"1016\":4,\"1018\":4,\"1020\":4,\"1022\":1,\"1023\":3,\"1026\":2,\"1030\":3,\"1068\":2,\"1070\":1,\"1087\":2,\"1092\":1,\"1093\":1,\"1104\":5,\"1105\":2,\"1107\":3,\"1126\":1,\"1174\":2,\"1219\":1,\"1249\":1,\"1272\":2,\"1274\":1,\"1288\":2,\"1293\":1,\"1294\":1,\"1302\":5,\"1303\":2,\"1305\":3,\"1359\":2,\"1396\":1,\"1431\":2,\"1439\":1,\"1443\":1,\"1444\":16}}],[\"nx\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"n数据的列表\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"npm\",{\"1\":{\"909\":1}}],[\"n<\",{\"1\":{\"821\":1}}],[\"nic\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"nio和bio是非常重要的计算机知识\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"nio和bio是一个相对有点抽象的概念\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"nio\",{\"1\":{\"1020\":25,\"1032\":1,\"1033\":1,\"1088\":1,\"1289\":1}}],[\"nil\",{\"1\":{\"603\":1,\"660\":1,\"960\":1}}],[\"niedermayer主要负责维护\",{\"1\":{\"122\":1}}],[\"nft\",{\"1\":{\"484\":1,\"486\":1}}],[\"nacos\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"navigation\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"navicat\",{\"1\":{\"824\":1}}],[\"native\",{\"1\":{\"1142\":2,\"1143\":1,\"1333\":2,\"1334\":1}}],[\"natural\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"nanoseconds\",{\"1\":{\"1105\":2,\"1303\":2}}],[\"nanotime\",{\"1\":{\"388\":2}}],[\"napoay\",{\"1\":{\"394\":1}}],[\"naming\",{\"1\":{\"152\":1}}],[\"name的值保持为\",{\"1\":{\"960\":1}}],[\"name填一个\",{\"1\":{\"889\":1}}],[\"name>`\",{\"1\":{\"887\":1}}],[\"name>contextconfiglocation<\",{\"1\":{\"820\":1}}],[\"name>\",{\"1\":{\"820\":3,\"844\":1}}],[\"name>dispatcherservlet<\",{\"1\":{\"820\":2}}],[\"name=出差报销\",{\"1\":{\"866\":1}}],[\"name=\",{\"1\":{\"743\":12,\"745\":4,\"759\":1,\"766\":6,\"767\":1,\"768\":1,\"770\":1,\"780\":2,\"782\":1,\"785\":1,\"789\":6,\"790\":4,\"815\":15,\"817\":3,\"818\":1,\"819\":4,\"821\":1,\"832\":1,\"865\":12,\"958\":1}}],[\"name=case\",{\"1\":{\"727\":1}}],[\"name3\",{\"1\":{\"727\":1}}],[\"name2\",{\"1\":{\"727\":1}}],[\"name1\",{\"1\":{\"727\":1}}],[\"name以abc开头的id\",{\"1\":{\"532\":1}}],[\"namespace实际上修改了应用进程看待整个计算机\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"namespace=\",{\"1\":{\"744\":1,\"755\":1,\"762\":1,\"763\":1,\"782\":1,\"790\":1,\"793\":1,\"827\":2}}],[\"namespace\",{\"1\":{\"744\":1,\"755\":1,\"762\":1,\"763\":2,\"827\":1,\"1175\":1,\"1178\":1,\"1180\":1,\"1360\":1,\"1363\":1,\"1365\":1}}],[\"names\",{\"1\":{\"106\":3}}],[\"name\",{\"1\":{\"94\":5,\"106\":5,\"192\":3,\"195\":4,\"251\":1,\"406\":2,\"436\":16,\"450\":4,\"457\":1,\"501\":1,\"505\":1,\"506\":7,\"511\":5,\"530\":2,\"532\":2,\"542\":4,\"555\":2,\"556\":2,\"558\":2,\"559\":1,\"561\":2,\"571\":4,\"572\":2,\"573\":4,\"654\":1,\"655\":2,\"727\":3,\"736\":4,\"737\":1,\"747\":5,\"755\":9,\"759\":4,\"763\":7,\"779\":4,\"782\":6,\"784\":7,\"785\":7,\"786\":10,\"789\":1,\"793\":1,\"825\":1,\"827\":3,\"844\":1,\"849\":2,\"855\":1,\"864\":1,\"887\":2,\"934\":1,\"944\":5,\"960\":7,\"1092\":2,\"1174\":4,\"1176\":3,\"1177\":3,\"1216\":2,\"1293\":2,\"1359\":4,\"1361\":3,\"1362\":3,\"1393\":2,\"1431\":2,\"1444\":7}}],[\"nlog\",{\"1\":{\"371\":1,\"372\":1}}],[\"nlogn\",{\"1\":{\"359\":1,\"364\":2}}],[\"n+k\",{\"1\":{\"357\":1}}],[\"n+1\",{\"1\":{\"266\":1,\"267\":1}}],[\"n是准备存入数据数量\",{\"1\":{\"340\":2}}],[\"n²\",{\"1\":{\"286\":1}}],[\"ns\",{\"1\":{\"266\":1,\"820\":3}}],[\"nb\",{\"1\":{\"143\":1,\"201\":1}}],[\"nofity\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"nofile\",{\"1\":{\"106\":1}}],[\"nofile就相应应该填写65535\",{\"1\":{\"106\":1}}],[\"nosuchmethodexception\",{\"1\":{\"952\":1}}],[\"nosql中存储的数据是kv形式\",{\"1\":{\"588\":1}}],[\"nosql\",{\"0\":{\"588\":1},\"1\":{\"960\":2}}],[\"nojekyll\",{\"1\":{\"911\":1}}],[\"now\",{\"1\":{\"755\":3,\"763\":3,\"786\":1,\"789\":1}}],[\"normalizer\",{\"1\":{\"440\":1}}],[\"norms\",{\"1\":{\"440\":1}}],[\"no\",{\"1\":{\"436\":1,\"440\":1,\"501\":2,\"562\":1,\"673\":1,\"829\":1,\"830\":2,\"831\":1}}],[\"nonumberexception\",{\"1\":{\"829\":5,\"830\":3,\"831\":2}}],[\"none\",{\"1\":{\"603\":1,\"1216\":1,\"1393\":1}}],[\"non\",{\"1\":{\"353\":1,\"506\":1}}],[\"nokeygenerator\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"nokey\",{\"1\":{\"143\":2}}],[\"noprint\",{\"1\":{\"143\":3}}],[\"nopush\",{\"1\":{\"106\":2}}],[\"notify或wait\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"notifyall\",{\"1\":{\"988\":6,\"1100\":1,\"1298\":1}}],[\"notify\",{\"1\":{\"988\":4,\"1100\":1,\"1298\":1}}],[\"notice\",{\"1\":{\"106\":2,\"964\":1}}],[\"note\",{\"1\":{\"527\":1,\"1193\":1,\"1376\":1}}],[\"notoriously\",{\"1\":{\"152\":1}}],[\"not\",{\"0\":{\"529\":1,\"588\":1},\"1\":{\"141\":2,\"487\":1,\"488\":1,\"507\":3,\"526\":2,\"527\":2,\"535\":1,\"577\":1,\"624\":1,\"726\":6,\"736\":1,\"762\":1,\"779\":2,\"792\":1,\"795\":3,\"824\":6,\"960\":1,\"1192\":1,\"1216\":1,\"1220\":1,\"1375\":1,\"1393\":1,\"1397\":1,\"1431\":3,\"1444\":1,\"1447\":1}}],[\"nodeid\",{\"1\":{\"1008\":3,\"1070\":1,\"1274\":1}}],[\"nodes\",{\"1\":{\"406\":2,\"1008\":3,\"1070\":1,\"1074\":1,\"1274\":1,\"1278\":1}}],[\"node01\",{\"1\":{\"406\":1}}],[\"node<k\",{\"1\":{\"922\":7,\"988\":1}}],[\"node<>\",{\"1\":{\"286\":5}}],[\"node<e>\",{\"1\":{\"286\":21}}],[\"node\",{\"0\":{\"417\":1},\"1\":{\"112\":1,\"267\":4,\"286\":4,\"289\":9,\"406\":3,\"416\":1,\"907\":1,\"922\":1,\"1008\":5,\"1070\":1,\"1071\":7,\"1072\":4,\"1274\":1,\"1275\":7,\"1276\":4}}],[\"nodelay\",{\"1\":{\"106\":1}}],[\"nobody\",{\"1\":{\"106\":2}}],[\"nohup\",{\"1\":{\"94\":2,\"674\":1}}],[\"nginxstatus\",{\"1\":{\"106\":2}}],[\"nginx跟后端服务器连接超时时间\",{\"1\":{\"106\":1}}],[\"nginx支持同时设置多组的负载均衡\",{\"1\":{\"106\":1}}],[\"nginx的upstream目前支持4种方式的分配\",{\"1\":{\"106\":1}}],[\"nginx默认会用client\",{\"1\":{\"106\":1}}],[\"nginx\",{\"0\":{\"106\":1},\"1\":{\"94\":1,\"106\":5,\"1136\":2,\"1329\":2}}],[\"numpy\",{\"1\":{\"898\":1}}],[\"numkeys\",{\"1\":{\"607\":2}}],[\"num=a\",{\"1\":{\"535\":1}}],[\"num=20\",{\"1\":{\"528\":2}}],[\"num=100\",{\"1\":{\"531\":1}}],[\"num=10\",{\"1\":{\"528\":2}}],[\"num=0\",{\"1\":{\"526\":1}}],[\"num\",{\"1\":{\"353\":5,\"526\":3,\"529\":2,\"531\":1,\"535\":5,\"1071\":1,\"1275\":1}}],[\"nums\",{\"1\":{\"353\":3}}],[\"number>\",{\"1\":{\"966\":1}}],[\"numberformat\",{\"1\":{\"819\":1}}],[\"number\",{\"1\":{\"106\":1,\"377\":4,\"792\":1,\"793\":9,\"794\":5,\"795\":6,\"825\":1,\"827\":7,\"829\":1,\"830\":2,\"831\":1,\"966\":2,\"996\":1,\"1072\":1,\"1276\":1}}],[\"nu\",{\"1\":{\"94\":1}}],[\"nullpointerexception\",{\"1\":{\"1023\":4}}],[\"nullbean\",{\"1\":{\"952\":1}}],[\"null键值处理\",{\"1\":{\"948\":1}}],[\"null值在各list实现类中的处理方式\",{\"1\":{\"946\":1}}],[\"null值\",{\"1\":{\"526\":1}}],[\"null与空字符串是同一回事\",{\"1\":{\"526\":1}}],[\"null对于sql的新手来说\",{\"1\":{\"526\":1}}],[\"nullable\",{\"1\":{\"506\":1,\"952\":2}}],[\"null\",{\"0\":{\"434\":1,\"526\":1},\"1\":{\"80\":2,\"83\":4,\"84\":3,\"193\":1,\"267\":2,\"285\":8,\"286\":29,\"288\":1,\"289\":8,\"353\":2,\"434\":8,\"440\":3,\"501\":3,\"507\":3,\"526\":11,\"527\":2,\"548\":1,\"559\":1,\"577\":1,\"622\":1,\"648\":5,\"726\":6,\"736\":9,\"737\":6,\"759\":1,\"763\":1,\"784\":1,\"785\":1,\"792\":5,\"795\":14,\"824\":6,\"829\":1,\"831\":4,\"876\":4,\"922\":10,\"928\":18,\"932\":1,\"936\":2,\"948\":1,\"952\":6,\"954\":1,\"958\":1,\"964\":4,\"1008\":1,\"1023\":5,\"1085\":1,\"1087\":1,\"1092\":1,\"1115\":1,\"1162\":1,\"1192\":2,\"1216\":6,\"1286\":1,\"1288\":1,\"1293\":1,\"1310\":1,\"1350\":1,\"1375\":2,\"1393\":6,\"1431\":1,\"1444\":4}}],[\"n\",{\"1\":{\"94\":6,\"106\":2,\"141\":4,\"190\":1,\"264\":1,\"266\":4,\"267\":1,\"270\":2,\"286\":4,\"340\":4,\"348\":4,\"357\":4,\"364\":3,\"377\":3,\"503\":2,\"689\":4,\"922\":2,\"932\":6,\"1086\":3,\"1122\":1,\"1287\":3,\"1317\":1}}],[\"never\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"nested\",{\"1\":{\"449\":1,\"1220\":1,\"1397\":1}}],[\"netty\",{\"0\":{\"1030\":1,\"1032\":1,\"1033\":1,\"1034\":1},\"1\":{\"1030\":4,\"1031\":3,\"1032\":2,\"1033\":6,\"1034\":2},\"2\":{\"1038\":1}}],[\"net\",{\"1\":{\"177\":1,\"180\":1,\"181\":2,\"232\":1,\"251\":2,\"252\":1,\"275\":1,\"388\":3,\"394\":3,\"425\":1,\"520\":1,\"659\":1,\"664\":1,\"668\":1,\"675\":1,\"688\":1,\"689\":1,\"728\":1,\"838\":1,\"839\":1,\"849\":1,\"876\":2,\"906\":1,\"917\":1,\"919\":2,\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":2,\"1023\":1,\"1030\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1193\":1,\"1219\":1,\"1302\":2,\"1303\":1,\"1305\":1,\"1376\":1,\"1396\":1,\"1431\":1,\"1439\":1,\"1444\":7}}],[\"network\",{\"1\":{\"112\":1,\"406\":1}}],[\"netstat\",{\"1\":{\"90\":1}}],[\"needs\",{\"1\":{\"112\":1}}],[\"next指向旧表\",{\"1\":{\"948\":1}}],[\"nextint\",{\"1\":{\"1105\":2,\"1303\":2}}],[\"nextindex\",{\"1\":{\"928\":6}}],[\"nextid\",{\"1\":{\"388\":2}}],[\"nextlong\",{\"1\":{\"388\":1}}],[\"next\",{\"1\":{\"106\":1,\"286\":43,\"289\":17,\"575\":1,\"621\":1,\"624\":3,\"737\":1,\"922\":8,\"1018\":5,\"1020\":1,\"1176\":1,\"1361\":1}}],[\"newratio=4\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"newproxyinstance\",{\"1\":{\"1016\":2}}],[\"newinstance\",{\"1\":{\"1010\":4,\"1093\":3,\"1294\":3}}],[\"newtopic\",{\"1\":{\"982\":4}}],[\"newtab\",{\"1\":{\"922\":2}}],[\"newtable\",{\"1\":{\"922\":2,\"928\":4}}],[\"newtable的长度是oldtable的两倍\",{\"1\":{\"922\":1}}],[\"newentry\",{\"1\":{\"948\":3}}],[\"newcap\",{\"1\":{\"922\":1}}],[\"newcapacity\",{\"1\":{\"922\":2,\"928\":5}}],[\"newnode\",{\"1\":{\"922\":1}}],[\"news\",{\"1\":{\"94\":1,\"420\":1,\"655\":2}}],[\"new\",{\"1\":{\"79\":1,\"80\":1,\"83\":1,\"84\":2,\"195\":1,\"285\":7,\"286\":9,\"288\":2,\"289\":7,\"337\":5,\"352\":3,\"353\":4,\"360\":2,\"364\":1,\"377\":2,\"388\":4,\"542\":2,\"573\":2,\"648\":2,\"692\":3,\"727\":3,\"746\":1,\"747\":1,\"757\":6,\"763\":5,\"766\":2,\"786\":2,\"787\":1,\"830\":7,\"831\":6,\"832\":1,\"915\":2,\"922\":1,\"928\":5,\"932\":5,\"934\":3,\"936\":6,\"946\":7,\"948\":5,\"950\":3,\"952\":2,\"966\":7,\"982\":5,\"984\":2,\"990\":5,\"992\":2,\"1004\":2,\"1008\":1,\"1016\":2,\"1020\":2,\"1044\":3,\"1085\":3,\"1086\":1,\"1087\":4,\"1092\":2,\"1093\":3,\"1099\":1,\"1100\":1,\"1104\":6,\"1105\":6,\"1107\":3,\"1220\":1,\"1253\":3,\"1286\":3,\"1287\":1,\"1288\":4,\"1293\":2,\"1294\":3,\"1297\":1,\"1298\":1,\"1302\":6,\"1303\":6,\"1305\":3,\"1397\":1,\"1431\":3}}],[\"懒加载+线程安全\",{\"0\":{\"82\":1}}],[\"懒加载显然是不能保证线程安全的\",{\"1\":{\"80\":1}}],[\"懒加载\",{\"0\":{\"80\":1},\"1\":{\"80\":1}}],[\"淦\",{\"1\":{\"78\":1,\"1010\":1}}],[\"下创建\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"下降为o\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"下次带笔记本过来\",{\"1\":{\"1020\":1}}],[\"下限的使用场景是当需要添加t的父类型对象时\",{\"1\":{\"966\":1}}],[\"下限的影响\",{\"1\":{\"348\":1}}],[\"下限是\",{\"1\":{\"966\":1}}],[\"下的\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"下的文件\",{\"1\":{\"934\":1}}],[\"下的方法\",{\"1\":{\"689\":1}}],[\"下一个要清理的键值对的索引\",{\"1\":{\"928\":1}}],[\"下一篇docker进阶面试题\",{\"1\":{\"1056\":1}}],[\"下一篇\",{\"1\":{\"20\":1}}],[\"下篇单独写一篇图解\",{\"1\":{\"917\":1}}],[\"下篇一起上\",{\"1\":{\"608\":1}}],[\"下午1\",{\"1\":{\"916\":1}}],[\"下标从0开始\",{\"1\":{\"604\":1}}],[\"下类似\",{\"1\":{\"598\":1}}],[\"下例中\",{\"1\":{\"501\":1}}],[\"下留言讨论\",{\"1\":{\"498\":1}}],[\"下文做详细讲解\",{\"1\":{\"525\":1}}],[\"下文提到了很多\",{\"1\":{\"460\":1}}],[\"下文会提及单例的演变过程\",{\"1\":{\"78\":1}}],[\"下图作为参考\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"下图回复\",{\"1\":{\"586\":1}}],[\"下图是一个相对复杂些的倒排索引\",{\"1\":{\"425\":1}}],[\"下图\",{\"1\":{\"364\":1}}],[\"下期见\",{\"1\":{\"275\":1}}],[\"下期继续\",{\"1\":{\"91\":1}}],[\"下面举了一个简单的sql注入案例\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"下面给出它们的例子\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"下面简称为hll\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"下面的每一条都可以当做调优的一部分\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"下面的查询也将导致全表扫描\",{\"0\":{\"530\":1}}],[\"下面问一点深入的东西\",{\"1\":{\"1022\":1}}],[\"下面会详细解释\",{\"1\":{\"958\":1}}],[\"下面开始业务层编写\",{\"1\":{\"829\":1}}],[\"下面通过maven命令\",{\"1\":{\"703\":1}}],[\"下面这个结构\",{\"1\":{\"1431\":1}}],[\"下面这段代码是integer的valueof方法的具体实现\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"下面这段代码的输出结果是什么\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"下面这几种调优手段一定要了解懂\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"下面这几个痛点\",{\"1\":{\"700\":1}}],[\"下面这些操作不会触发类的初始化\",{\"1\":{\"934\":1}}],[\"下面这三个你可能不太熟悉\",{\"1\":{\"657\":1}}],[\"下面让我用伪代码来描述一下我们的程序\",{\"1\":{\"692\":1}}],[\"下面一幅图\",{\"1\":{\"692\":1}}],[\"下面分析一种比较常见的方式\",{\"1\":{\"485\":1}}],[\"下面我们聊点有深度的\",{\"1\":{\"1018\":1}}],[\"下面我们通过具体实例来进行说明\",{\"1\":{\"425\":1}}],[\"下面我的写文章就是要把b树\",{\"1\":{\"262\":1}}],[\"下面步骤介绍布局虽然不好看\",{\"1\":{\"375\":1}}],[\"下面直接给出公式\",{\"1\":{\"339\":1}}],[\"下面继续\",{\"1\":{\"329\":1}}],[\"下面几张图可以帮你理解最小存储单元\",{\"1\":{\"272\":1}}],[\"下面先介绍内存和磁盘存取原理\",{\"1\":{\"271\":1}}],[\"下面结合数据库深入了解\",{\"1\":{\"264\":1}}],[\"下面是java线程的6种状态\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"下面是\",{\"1\":{\"924\":3,\"928\":1}}],[\"下面是一段示例代码\",{\"1\":{\"982\":4}}],[\"下面是一个使用\",{\"1\":{\"1022\":1}}],[\"下面是一个简单的示例代码\",{\"1\":{\"924\":1,\"928\":1}}],[\"下面是一个\",{\"1\":{\"824\":1}}],[\"下面是一篇简单版本的布隆过滤器\",{\"1\":{\"337\":1}}],[\"下面是为了解决冲突依赖内容\",{\"1\":{\"706\":1}}],[\"下面是官方的bench\",{\"1\":{\"591\":1}}],[\"下面是队列的操作示意图\",{\"1\":{\"288\":1}}],[\"下面是站长的唠叨\",{\"1\":{\"225\":1}}],[\"下面是server虚拟主机的配置\",{\"1\":{\"106\":1}}],[\"下载指定版本的镜像\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"下载镜像\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"下载maven\",{\"1\":{\"701\":1}}],[\"下载地址\",{\"1\":{\"597\":1,\"701\":2,\"887\":1,\"888\":1}}],[\"下载和elasticsearch版本一致\",{\"1\":{\"412\":1,\"413\":1}}],[\"下载了某个网站的视频\",{\"1\":{\"140\":1}}],[\"下载\",{\"0\":{\"671\":1},\"1\":{\"125\":1,\"405\":1,\"408\":1,\"412\":1,\"413\":1,\"499\":1,\"597\":1,\"899\":1}}],[\"下\",{\"0\":{\"1239\":1,\"1412\":1},\"1\":{\"108\":1,\"412\":1,\"413\":1,\"820\":1}}],[\"当整个\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"当各个微服务对\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"当多个事务同时存在的时候\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"当多个事务尝试更新同一索引页时\",{\"1\":{\"508\":1}}],[\"当应用程序配置bean较多时\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"当应用增多相对复杂的系统中\",{\"1\":{\"594\":1}}],[\"当bean不再需要时\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"当客户向容器请求一个尚未初始化的bean时\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"当客户端发送一个命令到集群时\",{\"1\":{\"968\":1}}],[\"当对象a运行到需要对象b的时候\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"当对一个字段进行大量的更新操作时\",{\"1\":{\"508\":1}}],[\"当读取数据时\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"当sql语句比较复杂时候\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"当sql语句比较简单时候\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"当survivor区2也满了时\",{\"1\":{\"930\":1}}],[\"当survivor区1也满了时\",{\"1\":{\"930\":1}}],[\"当mybaits与spring整合的时候\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"当上下文\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"当积累到一定程度或者时间时会将消息发送到分区\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"当消费者消费到消息后\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"当消息的顺序性很重要时\",{\"1\":{\"978\":1}}],[\"当返回成功后\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"当一块用完的时候将活着的对象复制到另一块上\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"当一个队列的成员都聚齐时\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"当一个search请求发出的时候\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"当一个对象的状态发生改变时\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"当一个对象被锁定时\",{\"1\":{\"1022\":1}}],[\"当一个对象不再被使用时\",{\"1\":{\"636\":1}}],[\"当一个线程获取了一个对象的监视器锁后\",{\"1\":{\"1022\":1}}],[\"当一个线程访问一个被\",{\"1\":{\"1022\":6}}],[\"当一个线程尝试获取锁时\",{\"1\":{\"932\":1}}],[\"当一个值原来是x\",{\"1\":{\"1018\":1}}],[\"当一个类加载器收到类加载请求时\",{\"1\":{\"934\":1}}],[\"当一个任务需要执行时\",{\"1\":{\"926\":1}}],[\"当一个变量被声明为\",{\"1\":{\"924\":1}}],[\"当一个\",{\"1\":{\"844\":1}}],[\"当一个哈希只包含少量键值对\",{\"1\":{\"633\":1}}],[\"当一个列表只包含少量列表项\",{\"1\":{\"633\":1}}],[\"当一个表中包含自增字段时\",{\"1\":{\"559\":1}}],[\"当一个事务持有多个行锁\",{\"1\":{\"574\":1}}],[\"当一个事务想要在一个已经被其他事务加上间隙锁的范围内插入新行时\",{\"1\":{\"558\":1}}],[\"当一个事务打算在某个细粒度上请求锁\",{\"1\":{\"557\":1}}],[\"当一个事务对某行数据加上排他锁后\",{\"1\":{\"555\":1}}],[\"当一个应用难以再细粒度的垂直切分\",{\"1\":{\"518\":1}}],[\"当一个数据被用到时\",{\"1\":{\"274\":1}}],[\"当访问增多\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"当服务器处于该状态时\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"当服务器不需要\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"当服务器需要用到值为\",{\"1\":{\"635\":1}}],[\"当key的哈希码分布均匀时\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"当key存在时\",{\"1\":{\"603\":1}}],[\"当a线程遍历元素时就会发现两个变量不等\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"当计算出的\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"当计数器的值为\",{\"1\":{\"932\":5}}],[\"当传入\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"当进程在执行中继续申请资源时\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"当进程首次申请资源时\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"当打印完b\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"当在一个线程调用另一个线程的join方法时\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"当条件满足时\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"当阻塞指定毫秒后\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"当修改完毕后\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"当new一个integer时\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"当执行更新\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"当段合并时\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"当删除请求发送后\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"当候选数量为两个时\",{\"1\":{\"1074\":1,\"1278\":1}}],[\"当集群中的\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"当集群中的一个节点下线了\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"当集群中超过半数机器与该\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"当集群规模增加到几千个partition时zookeeper负载会过重\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"当集群\",{\"1\":{\"1074\":1,\"1278\":1}}],[\"当2到3页过去以后\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"当分片所在的节点接收到来自协调节点的请求后\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"当分值相同时\",{\"1\":{\"629\":1}}],[\"当有用户请求过来时\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"当有一台服务器server1启动时\",{\"1\":{\"166\":1}}],[\"当从cookie中不能取出数据时\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"当从\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"当操作执行成功或者失败时\",{\"1\":{\"1034\":1}}],[\"当操作完成时\",{\"1\":{\"577\":1}}],[\"当该线程执行完被\",{\"1\":{\"1022\":1}}],[\"当文档被索引到目标分片和副本后\",{\"1\":{\"1012\":1}}],[\"当用户要进行数据的写入时\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"当用户要进行数据的读取时\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"当用户搜索时\",{\"1\":{\"1006\":1}}],[\"当用户符合我设置的条件\",{\"1\":{\"485\":1}}],[\"当生产者发送消息时\",{\"1\":{\"996\":1}}],[\"当生产者发送消息到kafka集群时\",{\"1\":{\"994\":1}}],[\"当设置为1时\",{\"1\":{\"994\":1}}],[\"当设置为0时\",{\"1\":{\"994\":1}}],[\"当设置成\",{\"1\":{\"431\":1}}],[\"当leader副本发生故障时\",{\"1\":{\"986\":1}}],[\"当producer发送消息时\",{\"1\":{\"986\":1}}],[\"当主节点宕机后\",{\"1\":{\"1008\":1}}],[\"当主节点宕机时\",{\"1\":{\"968\":1}}],[\"当主服务器发生故障时\",{\"1\":{\"964\":1}}],[\"当redis服务重启数据会丢失\",{\"1\":{\"962\":1}}],[\"当系统发生故障时可以自动检测并恢复\",{\"1\":{\"950\":1}}],[\"当系统需要读取主存时\",{\"1\":{\"273\":1}}],[\"当事件触发时执行相应逻辑\",{\"1\":{\"950\":1}}],[\"当事务提交时\",{\"1\":{\"559\":1}}],[\"当事务要改动一条记录时\",{\"1\":{\"555\":1}}],[\"当事务要读取一条记录时\",{\"1\":{\"555\":1}}],[\"当堆中垃圾对象达到一定比例或内存不足时\",{\"1\":{\"936\":1}}],[\"当父类已经加载了某个类时\",{\"1\":{\"934\":1}}],[\"当锁被释放时\",{\"1\":{\"932\":1,\"1022\":1}}],[\"当所有线程都到达屏障点后\",{\"1\":{\"932\":3}}],[\"当所有的when都不执行时\",{\"1\":{\"785\":1}}],[\"当永久代空间不足时\",{\"1\":{\"930\":1}}],[\"当老年代空间不足时\",{\"1\":{\"930\":1}}],[\"当新创建的对象被分配到eden区时\",{\"1\":{\"930\":1}}],[\"当方法执行完毕后\",{\"1\":{\"930\":1}}],[\"当任务执行完成后\",{\"1\":{\"926\":1}}],[\"当冲突产生时\",{\"1\":{\"922\":1}}],[\"当获取连接失败重试次数\",{\"1\":{\"815\":1}}],[\"当user\",{\"1\":{\"724\":2}}],[\"当子工程中有需要并且自行添加了具体依赖后才有效\",{\"1\":{\"715\":1}}],[\"当线程访问某一个对象时候值的时候\",{\"1\":{\"692\":1}}],[\"当程序执行完\",{\"1\":{\"664\":1}}],[\"当程序要读取的数据不在主存中时\",{\"1\":{\"274\":1}}],[\"当使用到对应功能时\",{\"1\":{\"1229\":1,\"1404\":1}}],[\"当使用迭代器遍历集合时\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"当使用迭代器遍历\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"当使用连接池时\",{\"1\":{\"645\":1}}],[\"当使用like操作符进行模糊查询\",{\"1\":{\"501\":1}}],[\"当字典被用作数据库的底层实现\",{\"1\":{\"626\":1}}],[\"当哈希表保存的键值对数量太多或者太少时\",{\"1\":{\"625\":1}}],[\"当列表不存在时\",{\"1\":{\"604\":1}}],[\"当指定元素不存在于列表中时\",{\"1\":{\"604\":1}}],[\"当间隙锁被释放时\",{\"1\":{\"558\":1}}],[\"当索引列有大量数据重复时\",{\"0\":{\"536\":1}}],[\"当数据库执行\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"当数据库表加完索引后还不不能满足性能需求\",{\"1\":{\"525\":1}}],[\"当数列元素不是整数时\",{\"1\":{\"361\":1}}],[\"当数列最大最小值差距过大时\",{\"1\":{\"361\":1}}],[\"当单表的数据量达到\",{\"1\":{\"515\":1}}],[\"当你的应用部署在portlet容器中工作时\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"当你在实现a的时候\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"当你在搜索引擎中输入关键词\",{\"1\":{\"1006\":1}}],[\"当你添加或删除一个节点时\",{\"1\":{\"968\":1}}],[\"当你遇到查询性能问题时\",{\"1\":{\"510\":1}}],[\"当你尝试为一个已经存在大量数据的表添加索引时\",{\"1\":{\"509\":1}}],[\"当你要给自己的项目分层\",{\"1\":{\"91\":1}}],[\"当表数据量很大时\",{\"1\":{\"516\":1}}],[\"当表中的数据量非常大时\",{\"0\":{\"508\":1}}],[\"当表里存的是\",{\"1\":{\"501\":1}}],[\"当已经建好表结构\",{\"1\":{\"507\":1}}],[\"当已经超过10个心跳的时间\",{\"1\":{\"157\":1}}],[\"当需要加载一个类的时候\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"当需要进行大量数据的去重\",{\"1\":{\"656\":1}}],[\"当需要重复引用大型表或常用表中的某个数据集时\",{\"1\":{\"541\":1}}],[\"当需要这些数据时\",{\"1\":{\"504\":1}}],[\"当需要从磁盘读取数据时\",{\"1\":{\"274\":1}}],[\"当查询条件中包含\",{\"1\":{\"501\":1}}],[\"当查询不到用户信息时\",{\"1\":{\"186\":1}}],[\"当遇到慢\",{\"1\":{\"501\":1}}],[\"当涉及到多个字段查询\",{\"1\":{\"498\":1}}],[\"当只涉及到一个字段查询\",{\"1\":{\"498\":1}}],[\"当活动结束有些代币可能未被领取\",{\"1\":{\"488\":1}}],[\"当输入的字符串是数字的时候\",{\"1\":{\"439\":1}}],[\"当前日志文件中下一条待写信息的offset\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"当前最新的版本0\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"当前线程再由阻塞状态转变成就绪状态\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"当前线程阻塞等待被调用join方法的线程执行完毕才能继续执行\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"当前线程必须在lockobj上同步\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"当前线程会重新进入runnable状态\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"当前版本是\",{\"1\":{\"844\":1}}],[\"当前表\",{\"1\":{\"779\":1}}],[\"当前名称空间下的statement的唯一标识\",{\"1\":{\"775\":1,\"777\":1,\"778\":1}}],[\"当前开发中\",{\"1\":{\"664\":1}}],[\"当前小中厂可用\",{\"1\":{\"654\":1}}],[\"当前时间\",{\"1\":{\"388\":1}}],[\"当前时间戳\",{\"1\":{\"388\":1}}],[\"当前时间截\",{\"1\":{\"388\":1}}],[\"当前系统业务和数据存储的复杂度都在提升\",{\"1\":{\"381\":1}}],[\"当前leader是server2\",{\"1\":{\"166\":1}}],[\"当要被排序的数组内的数值是均匀分配的时候\",{\"1\":{\"348\":1}}],[\"当要进入某个目录时\",{\"1\":{\"91\":1}}],[\"当每个数据之间跨度过大\",{\"1\":{\"347\":1}}],[\"当时叫\",{\"1\":{\"225\":1}}],[\"当时用了好几个夜晚来做起名\",{\"1\":{\"225\":1}}],[\"当骑骏马踏平川\",{\"1\":{\"223\":1}}],[\"当日志级别是\",{\"1\":{\"195\":1}}],[\"当\",{\"1\":{\"193\":1,\"288\":1,\"431\":2,\"440\":1,\"624\":1,\"625\":1,\"962\":2,\"1071\":1,\"1084\":1,\"1091\":2,\"1116\":1,\"1160\":2,\"1176\":1,\"1178\":1,\"1275\":1,\"1285\":1,\"1292\":2,\"1311\":1,\"1348\":2,\"1361\":1,\"1363\":1}}],[\"当我们提交更新的时候\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"当我们序列化和反序列化一个对象\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"当我们检索文档时\",{\"1\":{\"1012\":1}}],[\"当我们索引一个文档时\",{\"1\":{\"1012\":1}}],[\"当我们搜索\",{\"1\":{\"1006\":1}}],[\"当我们添加文档时\",{\"1\":{\"1004\":1}}],[\"当我们往索引中添加数据时\",{\"1\":{\"1004\":1}}],[\"当我们使用java命令执行一个类时\",{\"1\":{\"934\":1}}],[\"当我们调用代理对象的方法时\",{\"1\":{\"1016\":1}}],[\"当我们调用代理对象的\",{\"1\":{\"1016\":1}}],[\"当我们调用\",{\"1\":{\"928\":2}}],[\"当我们在编写多线程程序时\",{\"1\":{\"924\":1}}],[\"当我们在做更新或者是插入操作时\",{\"1\":{\"723\":1}}],[\"当我们在查询条件中对索引列进行表达式计算\",{\"1\":{\"501\":1}}],[\"当我们要求\",{\"1\":{\"333\":1,\"339\":1}}],[\"当我们扩展为三台服务器集群\",{\"1\":{\"153\":1}}],[\"当我请求\",{\"1\":{\"177\":1}}],[\"当别人调用你的接口\",{\"1\":{\"177\":1}}],[\"当第二台服务器server2启动时\",{\"1\":{\"166\":1}}],[\"当zookeeper集群中的一台服务器出现以下两种情况之一时\",{\"1\":{\"166\":1}}],[\"当信息还没有同步完成时\",{\"1\":{\"153\":1}}],[\"当超过最大次数时\",{\"1\":{\"106\":1}}],[\"当然对于一些小公司划分的就没有这么细了\",{\"1\":{\"1439\":1}}],[\"当然不行\",{\"1\":{\"1431\":1}}],[\"当然不只是存里文档id这么简单\",{\"1\":{\"1069\":1,\"1273\":1}}],[\"当然在某些情况下\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"当然适当放大也可行\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"当然无论哪种方案\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"当然准备好了\",{\"1\":{\"1012\":1}}],[\"当然还有\",{\"1\":{\"978\":1,\"982\":1}}],[\"当然知道\",{\"1\":{\"978\":1,\"990\":1,\"1006\":1}}],[\"当然知道啦\",{\"1\":{\"926\":2}}],[\"当然有啦\",{\"1\":{\"974\":1,\"1002\":1}}],[\"当然有一些了解\",{\"1\":{\"972\":1}}],[\"当然有\",{\"1\":{\"970\":1,\"990\":1,\"1008\":1}}],[\"当然可以\",{\"1\":{\"928\":3,\"932\":8,\"970\":1,\"972\":1,\"990\":3,\"992\":1,\"1002\":3,\"1006\":1,\"1008\":2,\"1010\":3,\"1016\":5,\"1020\":4}}],[\"当然它们的哈希值会不一样\",{\"1\":{\"917\":1}}],[\"当然要完成这个功能还需要在全局配置文件mybatis\",{\"1\":{\"782\":1}}],[\"当然现在很少用到了\",{\"1\":{\"653\":1}}],[\"当然具体如何选择需要看查询需求\",{\"1\":{\"498\":1}}],[\"当然这是一种牺牲空间换取时间的做法\",{\"1\":{\"357\":1}}],[\"当然我们想减小误判到最小\",{\"1\":{\"335\":1}}],[\"当然我们在生产环境中一般使用较多的是\",{\"1\":{\"78\":1}}],[\"当然你也可以再添加一个尾节点指针\",{\"1\":{\"286\":1}}],[\"当然也不存在跨域问题\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"当然也可以自己设定一个值\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"当然也可以使用包扫描\",{\"1\":{\"772\":1}}],[\"当然也可以通过参数设置\",{\"1\":{\"272\":1}}],[\"当然也流产了\",{\"1\":{\"225\":1}}],[\"当然b+树也能够很好的完成范围查询\",{\"1\":{\"270\":1}}],[\"当然了\",{\"1\":{\"135\":2}}],[\"当然是第二种比较好\",{\"1\":{\"134\":1}}],[\"当然压缩时间也就越长\",{\"1\":{\"106\":1}}],[\"当然\",{\"1\":{\"90\":1,\"504\":1,\"602\":1,\"656\":1,\"906\":1,\"924\":1,\"930\":4,\"940\":1,\"946\":1,\"968\":1,\"970\":2,\"972\":3,\"974\":1,\"976\":4,\"978\":1,\"980\":5,\"982\":3,\"984\":3,\"986\":1,\"998\":4,\"1000\":3,\"1004\":2,\"1012\":1,\"1020\":1,\"1022\":9,\"1048\":1,\"1050\":1,\"1068\":1,\"1164\":1,\"1232\":1,\"1257\":1,\"1259\":1,\"1272\":1,\"1352\":1,\"1407\":1}}],[\"当被问到你知道哪些设计模式\",{\"1\":{\"76\":1}}],[\"并基于以上条件\",{\"1\":{\"1230\":1,\"1405\":1}}],[\"并抛出a\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"并验证\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"并最终返回给客户端\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"并最终返回响应\",{\"1\":{\"956\":1}}],[\"并行\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"并行分区的布隆过滤器\",{\"1\":{\"343\":1}}],[\"并睡眠一小段时间\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"并阻塞\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"并以轮询的方式与这些地址进行通信\",{\"1\":{\"1075\":1,\"1279\":1}}],[\"并删除那些旧的小段\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"并更新到缓存\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"并更新序列号\",{\"1\":{\"996\":1}}],[\"并定义了用于在该链上传播入站\",{\"1\":{\"1034\":1}}],[\"并定期审查和清理不再需要的索引\",{\"1\":{\"510\":1}}],[\"并没有实现真正意义上的异步\",{\"1\":{\"1031\":1}}],[\"并没有内部对象的概念\",{\"1\":{\"450\":1}}],[\"并监听连接事件\",{\"1\":{\"1020\":1}}],[\"并绑定到指定的端口\",{\"1\":{\"1020\":1}}],[\"并输出日志记录信息\",{\"1\":{\"1016\":1}}],[\"并动态地创建代理类和代理对象\",{\"1\":{\"1016\":1}}],[\"并等待它们的确认\",{\"1\":{\"1012\":1}}],[\"并记录下关键词出现的文档编号\",{\"1\":{\"1006\":1}}],[\"并插入了一篇文档\",{\"1\":{\"998\":1}}],[\"并保证消息的可靠传递\",{\"1\":{\"986\":1}}],[\"并保存数据\",{\"1\":{\"352\":1}}],[\"并从每个分区中拉取消息\",{\"1\":{\"984\":1}}],[\"并从运行时常量池中移除这个类的符号引用\",{\"1\":{\"934\":1}}],[\"并设置分区数为\",{\"1\":{\"982\":1}}],[\"并替换为上限\",{\"1\":{\"966\":1}}],[\"并开始解析aof文件\",{\"1\":{\"962\":1}}],[\"并追加到aof文件中\",{\"1\":{\"962\":1}}],[\"并把响应返回给客户端\",{\"1\":{\"956\":1}}],[\"并把允许入队的一端称为队尾\",{\"1\":{\"287\":1}}],[\"并返回true\",{\"1\":{\"970\":1}}],[\"并返回\",{\"1\":{\"956\":1}}],[\"并进行优化\",{\"1\":{\"950\":1}}],[\"并和其他类保持一致性\",{\"1\":{\"934\":1}}],[\"并为之创建一个class对象\",{\"1\":{\"934\":1}}],[\"并实现了\",{\"1\":{\"932\":1}}],[\"并实现里面的方法\",{\"1\":{\"830\":1}}],[\"并根据需要重写\",{\"1\":{\"926\":1}}],[\"并放入newtable对应的桶中\",{\"1\":{\"922\":1}}],[\"并会重新计算每个节点的hash值和索引位置\",{\"1\":{\"922\":1}}],[\"并会增加存储开销\",{\"0\":{\"538\":1}}],[\"并推送到远端\",{\"1\":{\"913\":1}}],[\"并初始化数据\",{\"1\":{\"824\":1}}],[\"并覆盖已读取的同名属性\",{\"1\":{\"766\":2}}],[\"并执行sql\",{\"0\":{\"747\":1}}],[\"并创建webapp目录放置web资源文件\",{\"1\":{\"704\":1}}],[\"并用该数据结构提供基数统计的功能\",{\"1\":{\"659\":1}}],[\"并非什么新的技术点\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"并非\",{\"1\":{\"659\":1}}],[\"并集\",{\"1\":{\"656\":1}}],[\"并将线程增加到与lockobj相关的\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"并将内容刷新到磁盘\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"并将方法的调用转发到\",{\"1\":{\"1016\":1}}],[\"并将方法的调用转发到指定的处理器上\",{\"1\":{\"1016\":3}}],[\"并将其加载到内存中\",{\"1\":{\"1016\":1}}],[\"并将其作为参考\",{\"1\":{\"1008\":1}}],[\"并将其附加到消息中\",{\"1\":{\"996\":1}}],[\"并将最小的节点作为主节点\",{\"1\":{\"1008\":1}}],[\"并将自己的id和版本号发送给zookeeper\",{\"1\":{\"1008\":1}}],[\"并将结果合并返回给用户\",{\"1\":{\"1002\":1}}],[\"并将每个分片复制到多个节点上\",{\"1\":{\"1000\":1}}],[\"并将键值对迁移到新的节点上\",{\"1\":{\"968\":1}}],[\"并将命令路由到相应的节点上进行处理\",{\"1\":{\"968\":1}}],[\"并将写命令同步给从服务器\",{\"1\":{\"964\":1}}],[\"并将锁分配给它\",{\"1\":{\"932\":1}}],[\"并将存活的对象移动到survivor区1\",{\"1\":{\"930\":1}}],[\"并将对应修改应用到当前的工作目录下\",{\"1\":{\"916\":1}}],[\"并将它的值设置为\",{\"1\":{\"625\":1}}],[\"并将\",{\"1\":{\"619\":1}}],[\"并将该元素添加到另一个列表并返回\",{\"1\":{\"604\":1}}],[\"并将该节点的子节点分割成\",{\"1\":{\"266\":1}}],[\"并存储在新的\",{\"1\":{\"607\":1}}],[\"并增加版本号\",{\"1\":{\"579\":1}}],[\"并防止其他事务的干扰\",{\"1\":{\"575\":1}}],[\"并加上相应的行锁或共享锁\",{\"1\":{\"575\":1}}],[\"并加绿色边框\",{\"1\":{\"140\":1}}],[\"并提供常见的拦截器\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"并提供高可用性和容错性\",{\"1\":{\"1012\":1}}],[\"并提供动态扩容机制来保证高效插入与查询\",{\"1\":{\"948\":1}}],[\"并提供多种语言的api\",{\"1\":{\"589\":1}}],[\"并提供一个全局访问点\",{\"1\":{\"78\":1}}],[\"并提高系统的整体性能\",{\"1\":{\"574\":1}}],[\"并发送请求给同样处理查询阶段的分片副本\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"并发的场景下\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"并发度低\",{\"1\":{\"988\":1}}],[\"并发度很高\",{\"1\":{\"988\":1}}],[\"并发情况下\",{\"1\":{\"988\":1}}],[\"并发和增量式回收\",{\"1\":{\"940\":1}}],[\"并发执行时\",{\"1\":{\"938\":1}}],[\"并发时会对程序性能产生一定影响\",{\"1\":{\"938\":1}}],[\"并发重置\",{\"1\":{\"938\":1,\"940\":1}}],[\"并发清除\",{\"1\":{\"938\":1,\"1150\":1,\"1341\":1}}],[\"并发清理\",{\"1\":{\"936\":1,\"940\":1}}],[\"并发标记阶段\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"并发标记阶段与用户线程一起运行\",{\"1\":{\"938\":1}}],[\"并发标记的\",{\"1\":{\"938\":1}}],[\"并发标记\",{\"1\":{\"936\":1,\"938\":1,\"940\":1,\"1150\":1,\"1341\":1}}],[\"并发标记清除\",{\"1\":{\"936\":1}}],[\"并发回收\",{\"1\":{\"936\":1}}],[\"并发量不大的场景可以使用数据库的悲观锁\",{\"1\":{\"594\":1}}],[\"并发量高时如果每次都请求数据库操作无疑是种挑战和压力\",{\"1\":{\"594\":1}}],[\"并发性\",{\"1\":{\"563\":1,\"564\":1,\"565\":1,\"566\":1,\"567\":1}}],[\"并发性更好\",{\"1\":{\"561\":1}}],[\"并发控制\",{\"1\":{\"553\":1}}],[\"并确保引用的数据的完整性\",{\"1\":{\"560\":1}}],[\"并说明如何检测和修复索引碎片化\",{\"0\":{\"511\":1}}],[\"并说明全文索引的使用场景\",{\"0\":{\"507\":1}}],[\"并通过节点之间的指针进行查找\",{\"1\":{\"499\":1}}],[\"并通过\",{\"1\":{\"450\":1,\"601\":1}}],[\"并支持\",{\"1\":{\"400\":1}}],[\"并同时满足堆积的性质\",{\"1\":{\"364\":1}}],[\"并移动到已排序集合中\",{\"1\":{\"351\":1}}],[\"并不会将这些失效的分区迁移到其他可用的\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"并不会释放他所持有的所有对象锁\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"并不能保证同一时刻所有replica\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"并不能保证全局有序\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"并不能直接交给底层操作系统去执行\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"并不简单归类\",{\"1\":{\"940\":1}}],[\"并不连续\",{\"1\":{\"938\":1}}],[\"并不是真的停止线程\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"并不是所有索引对查询都有效\",{\"0\":{\"536\":1}}],[\"并不是很难\",{\"1\":{\"90\":1}}],[\"并不适用于计数排序\",{\"1\":{\"361\":2}}],[\"并不存在元素的比较和交换操作\",{\"1\":{\"350\":1}}],[\"并使来自目标\",{\"1\":{\"329\":1}}],[\"并使用分布式写入协调器来确保数据的一致性\",{\"1\":{\"1012\":1}}],[\"并使用consumer\",{\"1\":{\"990\":1}}],[\"并使用producer\",{\"1\":{\"990\":1}}],[\"并使用\",{\"1\":{\"109\":1,\"443\":1,\"916\":1,\"1010\":5}}],[\"并查集\",{\"0\":{\"315\":1}}],[\"并调用成功\",{\"1\":{\"251\":1}}],[\"并且之后更新的所有视频和源码都可以获取观看\",{\"1\":{\"1429\":1}}],[\"并且选举出当前一个slave节点来转换成master节点\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"并且进行合理的批量压缩\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"并且使用默认分区器\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"并且已经废弃\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"并且改变搜索标准\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"并且该节点自己也选举自己\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"并且处于容错考虑\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"并且写时如何避免并发重复写入\",{\"1\":{\"1046\":1,\"1255\":1}}],[\"并且相比于直接使用\",{\"1\":{\"1032\":1}}],[\"并且需要动态地创建代理对象\",{\"1\":{\"1016\":1}}],[\"并且不会写入分区\",{\"1\":{\"996\":1}}],[\"并且不会将其写入分区\",{\"1\":{\"996\":1}}],[\"并且不可以重复发送\",{\"1\":{\"664\":1}}],[\"并且不可以被搜索\",{\"1\":{\"447\":1}}],[\"并且合理处理未确认的消息\",{\"1\":{\"994\":1}}],[\"并且文件会变得越来越大\",{\"1\":{\"962\":1}}],[\"并且设置这个键值对的过期时间为seconds秒\",{\"1\":{\"960\":1}}],[\"并且只执行一次\",{\"1\":{\"934\":1}}],[\"并且持续更新中\",{\"1\":{\"920\":1}}],[\"并且撤销\",{\"1\":{\"918\":1}}],[\"并且有\",{\"1\":{\"912\":1}}],[\"并且携带图书实体\",{\"1\":{\"826\":1}}],[\"并且一直无法关闭\",{\"1\":{\"789\":1}}],[\"并且要求xml文件和interface的名称要相同\",{\"1\":{\"772\":1}}],[\"并且为部署做准备\",{\"1\":{\"714\":1}}],[\"并且每个段会消耗cpu\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"并且每个列表项要么就是小整数值\",{\"1\":{\"633\":1}}],[\"并且每个数组对象都是一个\",{\"1\":{\"451\":1}}],[\"并且保证集合中不会出现\",{\"1\":{\"630\":1}}],[\"并且尽可能地节约了内存\",{\"1\":{\"630\":1}}],[\"并且这个强引用变量所在的方法已经弹出栈\",{\"1\":{\"936\":1}}],[\"并且这个强引用变量为\",{\"1\":{\"936\":1}}],[\"并且这个\",{\"1\":{\"626\":1}}],[\"并且这些行锁的数量超过了系统预设的阈值时\",{\"1\":{\"574\":1}}],[\"并且在事务\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"并且在多实例的情况下\",{\"1\":{\"615\":1}}],[\"并且在此基础上实现了\",{\"1\":{\"589\":1}}],[\"并且\",{\"1\":{\"615\":1}}],[\"并且由此增加的空间消耗相对于\",{\"1\":{\"602\":1}}],[\"并且连续的\",{\"1\":{\"559\":1}}],[\"并且应尽可能的让字段顺序与索引顺序相一致\",{\"0\":{\"534\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"并且您不能在该列中插入\",{\"1\":{\"526\":1}}],[\"并且可以实现更细粒度的锁控制\",{\"1\":{\"1022\":1}}],[\"并且可以使用选择器来实现多路复用\",{\"1\":{\"1020\":1}}],[\"并且可以在不同的线程之间共享\",{\"1\":{\"1020\":1}}],[\"并且可以在运行时调用这些属性和方法\",{\"1\":{\"1010\":1}}],[\"并且可以支持随机访问\",{\"1\":{\"1020\":1}}],[\"并且可以自由的控制何时执行切点\",{\"1\":{\"689\":1}}],[\"并且可以将这些数据库部署在不同服务器上\",{\"1\":{\"517\":1}}],[\"并且可能需要较长的时间来完成\",{\"1\":{\"511\":1}}],[\"并且磁盘空间也快不够了\",{\"1\":{\"517\":1}}],[\"并且对更多案例和细节有所了解\",{\"1\":{\"940\":1}}],[\"并且对于大表也拆分为若干小表\",{\"1\":{\"515\":1}}],[\"并且对桶中元素排序后\",{\"1\":{\"351\":1}}],[\"并且如果瓶颈在\",{\"1\":{\"515\":1}}],[\"并且经常需要根据某个字段进行排序\",{\"0\":{\"509\":1}}],[\"并且全文索引的列不能是null值\",{\"1\":{\"507\":1}}],[\"并且通过指针相互连接\",{\"1\":{\"503\":1}}],[\"并且模式以\",{\"1\":{\"501\":1}}],[\"并且也不仅仅只是一个全文搜索引擎\",{\"1\":{\"400\":1}}],[\"并且效率较高\",{\"1\":{\"388\":1}}],[\"并且整个分布式系统内不会产生id碰撞\",{\"1\":{\"388\":1}}],[\"并且让我们的接口更容易复用\",{\"1\":{\"178\":1}}],[\"并且还需要重新启动\",{\"1\":{\"162\":1}}],[\"并且偶然可能需要更新配置\",{\"1\":{\"162\":1}}],[\"并且给予可写权限\",{\"1\":{\"157\":1}}],[\"并且是一路处理器缓存大小的倍数\",{\"1\":{\"106\":1}}],[\"并在发生冲突时重试\",{\"1\":{\"1018\":1}}],[\"并在项目中运用的更加娴熟\",{\"1\":{\"1018\":1}}],[\"并在\",{\"1\":{\"1016\":1}}],[\"并在消费消息时按照偏移量的顺序进行消费\",{\"1\":{\"984\":1}}],[\"并在多个broker上创建副本来实现可靠性\",{\"1\":{\"974\":1}}],[\"并在两个线程中分别设置了不同的变量值\",{\"1\":{\"928\":1}}],[\"并在任务完成后回收线程\",{\"1\":{\"926\":1}}],[\"并在一个线程中修改它的值\",{\"1\":{\"924\":1}}],[\"并在实际工作中发挥其优势\",{\"1\":{\"922\":1}}],[\"并在等待获取其他事务持有的资源\",{\"1\":{\"562\":1}}],[\"并在事务提交时释放自增锁\",{\"1\":{\"559\":1}}],[\"并在业务低峰时段进行\",{\"1\":{\"511\":1}}],[\"并在相应的流部分中报告\",{\"1\":{\"143\":1}}],[\"并在逐步完善中\",{\"1\":{\"1\":1}}],[\"并能将其转化为流的开源计算机程序\",{\"1\":{\"122\":1}}],[\"实时性低\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"实时分析等\",{\"1\":{\"976\":1}}],[\"实时流处理\",{\"1\":{\"974\":1}}],[\"实时监控运行指标\",{\"1\":{\"942\":1}}],[\"实时推流\",{\"1\":{\"146\":1}}],[\"实践使用与论坛上的讨论\",{\"1\":{\"922\":1}}],[\"实体\",{\"0\":{\"825\":1}}],[\"实体类的全路径\",{\"1\":{\"768\":1}}],[\"实用的倒排索引还可以记载更多的信息\",{\"1\":{\"425\":1}}],[\"实例收到\",{\"1\":{\"962\":2}}],[\"实例化bean\",{\"1\":{\"1214\":2,\"1391\":2}}],[\"实例化阶段完成的\",{\"1\":{\"954\":1}}],[\"实例化阶段会调用\",{\"1\":{\"950\":1}}],[\"实例化前修改\",{\"1\":{\"952\":1}}],[\"实例化\",{\"1\":{\"950\":1,\"952\":1,\"1128\":1,\"1218\":1,\"1321\":1,\"1395\":1}}],[\"实例只能选择其一\",{\"1\":{\"771\":1}}],[\"实例中所有的\",{\"1\":{\"770\":1}}],[\"实例二\",{\"0\":{\"727\":1}}],[\"实例来操作数据\",{\"1\":{\"648\":1}}],[\"实例可用\",{\"1\":{\"648\":1}}],[\"实例时\",{\"1\":{\"648\":1}}],[\"实例\",{\"1\":{\"412\":1,\"604\":1,\"648\":3,\"952\":4,\"1159\":1,\"1347\":1}}],[\"实例题目\",{\"0\":{\"359\":1}}],[\"实际的io读写操作\",{\"1\":{\"1088\":2,\"1289\":2}}],[\"实际情况下\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"实际类型参数是替换类型参数的具体类型\",{\"1\":{\"966\":1}}],[\"实际容量\",{\"1\":{\"946\":1}}],[\"实际应用中要考虑的细节要更多\",{\"1\":{\"594\":1}}],[\"实际应用中其实很少会使用到\",{\"1\":{\"507\":1}}],[\"实际上就是通过反射的方式创建出一个bean对象\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"实际上就是dao的接口路径\",{\"1\":{\"772\":1}}],[\"实际上又是按照segment分段存储的\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"实际上是生成一个指针指向此对象\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"实际上是在当前线程的\",{\"1\":{\"928\":2}}],[\"实际上g1的设计极为复杂精巧\",{\"1\":{\"940\":1}}],[\"实际上这些参数与es的实现机制\",{\"1\":{\"440\":1}}],[\"实际上\",{\"1\":{\"333\":1,\"339\":1,\"450\":1,\"1072\":1,\"1276\":1}}],[\"实际是斜切向运动\",{\"1\":{\"274\":1}}],[\"实战直播课\",{\"1\":{\"211\":1}}],[\"实战这一篇就够了\",{\"0\":{\"148\":1,\"149\":1,\"697\":1,\"698\":1,\"730\":1,\"731\":1},\"1\":{\"738\":1}}],[\"实战练手项目\",{\"1\":{\"98\":1}}],[\"实战项目组\",{\"1\":{\"204\":1,\"205\":1}}],[\"实战项目直播教学等专属求职指南\",{\"1\":{\"49\":1}}],[\"实战项目\",{\"1\":{\"1\":1,\"101\":1}}],[\"实现业务逻辑\",{\"1\":{\"1439\":1}}],[\"实现数据\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"实现数据的最终一致性\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"实现诸如数据发布\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"实现程序间的松耦合\",{\"1\":{\"1229\":1,\"1404\":1}}],[\"实现beanfactoryaware接口可以获取到工厂对象beanfactory等\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"实现具有依\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"实现计数器功能\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"实现布隆过滤器\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"实现自定义插件\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"实现自动调优\",{\"1\":{\"940\":1}}],[\"实现日志打印\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"实现spring类\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"实现slf4j接口并整合\",{\"1\":{\"812\":1}}],[\"实现功能\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"实现登录校验\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"实现个性化搜索\",{\"1\":{\"1079\":1,\"1283\":1}}],[\"实现串行写\",{\"1\":{\"1050\":2,\"1259\":2}}],[\"实现限流的功能\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"实现本地缓存的功能\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"实现高可用\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"实现高吞吐量\",{\"1\":{\"940\":1}}],[\"实现消息推送系统\",{\"1\":{\"1033\":1}}],[\"实现一个即时通讯系统\",{\"1\":{\"1033\":1}}],[\"实现一个自己的\",{\"1\":{\"1033\":1}}],[\"实现一件事的并行处理\",{\"1\":{\"988\":1}}],[\"实现角度\",{\"1\":{\"1022\":1}}],[\"实现线程调度\",{\"1\":{\"1018\":1}}],[\"实现线程安全\",{\"1\":{\"988\":1}}],[\"实现非阻塞的数据结构\",{\"1\":{\"1018\":1}}],[\"实现锁的非阻塞式获取\",{\"1\":{\"1018\":1}}],[\"实现原子操作\",{\"1\":{\"1018\":1}}],[\"实现原理\",{\"0\":{\"374\":1},\"1\":{\"104\":1}}],[\"实现主从复制和数据一致性的效果\",{\"1\":{\"964\":1}}],[\"实现快速故障迁移\",{\"1\":{\"964\":1}}],[\"实现这个接口的\",{\"1\":{\"952\":1}}],[\"实现了\",{\"1\":{\"952\":4}}],[\"实现了业务逻辑\",{\"1\":{\"950\":1}}],[\"实现了细致且高效的分代\",{\"1\":{\"940\":1}}],[\"实现将对象间的依赖关系交给\",{\"1\":{\"950\":1}}],[\"实现栈结构\",{\"1\":{\"946\":1}}],[\"实现渐进式回收与低停顿\",{\"1\":{\"940\":1}}],[\"实现类使用了我们上边定义的异常方法\",{\"1\":{\"830\":1}}],[\"实现类中\",{\"1\":{\"761\":1}}],[\"实现类\",{\"1\":{\"761\":1,\"815\":1}}],[\"实现类似\",{\"1\":{\"436\":1}}],[\"实现分页查询\",{\"1\":{\"655\":1}}],[\"实现分布式锁有以下几种方式\",{\"1\":{\"576\":1}}],[\"实现方式\",{\"1\":{\"569\":1,\"570\":1}}],[\"实现信息检索\",{\"1\":{\"495\":1}}],[\"实现\",{\"0\":{\"78\":1,\"578\":1},\"1\":{\"251\":1,\"604\":1,\"956\":1,\"1044\":1,\"1092\":1,\"1162\":1,\"1253\":1,\"1293\":1,\"1350\":1}}],[\"所需要保持打开状态的文件句柄数也就越多\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"所谓编码就是具体使用哪种底层数据结构来实现\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"所谓同源指的是\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"所谓基数估算\",{\"1\":{\"659\":1}}],[\"所实现的\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"所示\",{\"1\":{\"619\":1}}],[\"所保存字符串的长度\",{\"1\":{\"619\":1}}],[\"所耗费时间叫做寻道时间\",{\"1\":{\"274\":1}}],[\"所在行\",{\"1\":{\"94\":1}}],[\"所以能保证只有一个能加锁成功\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"所以redis内存维护一个\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"所以克服所有问题\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"所以当前分区只能消费到\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"所以当读到某个值的时候\",{\"1\":{\"270\":1}}],[\"所以也是线程私有\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"所以也就不会影响其他进程对象的运行\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"所以分配的内存大小要在编译期就确认\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"所以分配的内存是在运行期确认的\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"所以性能快\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"所以性能更好\",{\"1\":{\"1018\":1}}],[\"所以有各种算法\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"所以第一次访问jsp较慢\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"所以为了提高效率\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"所以选择6是一种折中的考虑\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"所以选择8作为阈值\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"所以把hashcode的高16位与低16位进行异或操作\",{\"1\":{\"1121\":1,\"1316\":1}}],[\"所以hash值的高16位通常参与不了这个按位与操作\",{\"1\":{\"1121\":1,\"1316\":1}}],[\"所以线程b同时进行增删操作不会影响到线程a的遍历行为\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"所以如果我们不使用默认阻塞的锁\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"所以导致死锁\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"所以join的好处能够保证线程的执行顺序\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"所以jvm可以以\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"所以用了\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"所以用t表示\",{\"1\":{\"966\":1}}],[\"所以例如拼接字符串时候会产生很多无用的中间对象\",{\"1\":{\"1089\":1,\"1290\":1}}],[\"所以是非阻塞\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"所以决定了重写\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"所以数据的最终一致性是可以得到有效的保证的\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"所以简单来说\",{\"1\":{\"988\":1}}],[\"所以优化内存使用是非常重要的\",{\"1\":{\"972\":1}}],[\"所以无\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"所以无边界的\",{\"1\":{\"966\":1}}],[\"所以无法使用索引\",{\"1\":{\"501\":1}}],[\"所以边界的作用就是限制类型参数可以替换的实际类型\",{\"1\":{\"966\":1}}],[\"所以上下限主要是为了在广泛限制类型的同时\",{\"1\":{\"966\":1}}],[\"所以上述案例中虽然表面上只有\",{\"1\":{\"451\":1}}],[\"所以编译器会把所有的泛型类型全部擦除掉\",{\"1\":{\"966\":1}}],[\"所以编译器不允许这么做\",{\"1\":{\"966\":1}}],[\"所以类型参数是个未知的类型占位符\",{\"1\":{\"966\":1}}],[\"所以泛型最大的好处就是让代码类型安全\",{\"1\":{\"966\":1}}],[\"所以注解的\",{\"1\":{\"944\":1}}],[\"所以enum中的注解一般使用runtime\",{\"1\":{\"944\":1}}],[\"所以尽量减少stw次数\",{\"1\":{\"940\":1}}],[\"所以确定是因为大于号\",{\"1\":{\"800\":1}}],[\"所以就在sql中直接使用了\",{\"1\":{\"800\":1}}],[\"所以只有使用resultmap手动的进行映射\",{\"1\":{\"797\":1}}],[\"所以可以通过重写equals\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"所以可以不用加\",{\"1\":{\"826\":1}}],[\"所以可以直接引用\",{\"1\":{\"743\":1}}],[\"所以可以将桶中元素移动回原始集合即可\",{\"1\":{\"351\":1}}],[\"所以下定决心深入研究一下java并发方面的知识\",{\"1\":{\"692\":1}}],[\"所以其核心就是基数估算算法\",{\"1\":{\"659\":1}}],[\"所以实战很重要\",{\"1\":{\"652\":1}}],[\"所以添加\",{\"1\":{\"606\":1,\"607\":1}}],[\"所以锁的问题\",{\"1\":{\"552\":1}}],[\"所以怎样建索引需要慎重考虑\",{\"1\":{\"537\":1}}],[\"所以引擎大概率不会走索引\",{\"1\":{\"501\":1}}],[\"所以不必担心队列消息的丢失问题\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"所以不论在查询还是更新维护\",{\"1\":{\"500\":1}}],[\"所以不用限制桌面的帧率\",{\"1\":{\"145\":1}}],[\"所以将其记录在倒排列表中\",{\"1\":{\"425\":1}}],[\"所以需要修改最大映射文件的数量\",{\"1\":{\"403\":1}}],[\"所以使用\",{\"1\":{\"401\":1}}],[\"所以i1和i2指向的是同一个对象\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"所以id一般是正数\",{\"1\":{\"388\":1}}],[\"所以io一次就是读一页的大小\",{\"1\":{\"274\":1}}],[\"所以在运行的时候速度比较快\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"所以在单线程环境下\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"所以在不同场景有不同的使用优势\",{\"1\":{\"946\":1}}],[\"所以在另一个线程中调用\",{\"1\":{\"924\":1}}],[\"所以在选择上\",{\"1\":{\"499\":1}}],[\"所以在查询的时候减少了磁盘的随机读取\",{\"1\":{\"497\":1}}],[\"所以在\",{\"1\":{\"387\":1,\"1133\":1,\"1326\":1}}],[\"所以堆排序时间复杂度一般认为就是o\",{\"1\":{\"364\":1}}],[\"所以循环队列需要损失一个存储空间\",{\"1\":{\"288\":1}}],[\"所以我们可以使用\",{\"1\":{\"288\":1}}],[\"所以我们通常将数组弄成一个环状\",{\"1\":{\"288\":1}}],[\"所以没有按照传统的方法来写\",{\"1\":{\"286\":1}}],[\"所以一定要看一遍源码\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"所以一个页中能存储多少行数据呢\",{\"1\":{\"272\":1}}],[\"所以一般不会使用\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"所以一般b+树的叶节点和内节点大小不同\",{\"1\":{\"269\":1}}],[\"所以一般被用在文件系统及数据库中\",{\"1\":{\"266\":1}}],[\"所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘i\",{\"1\":{\"271\":1}}],[\"所以必须经历o\",{\"1\":{\"270\":1}}],[\"所以查询的时候可能不需要o\",{\"1\":{\"270\":1}}],[\"所以查询\",{\"1\":{\"270\":1}}],[\"所以说b\",{\"1\":{\"270\":1}}],[\"所以定位到最左侧的节点\",{\"1\":{\"267\":1}}],[\"所以作为多叉树的b树是更快的\",{\"1\":{\"266\":1}}],[\"所以新建节点时\",{\"1\":{\"266\":1}}],[\"所以这个对象永远是一个代理对象\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"所以这个阶段也是可以与用户线程同时并发的\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"所以这个最高位固定是0\",{\"1\":{\"387\":1}}],[\"所以这里的速度非常快\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"所以这里设置为分页大小\",{\"1\":{\"106\":2}}],[\"所以这也是为什么深度分页不能用from+size这种方式\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"所以这两个线程互不干扰\",{\"1\":{\"928\":1}}],[\"所以这类平衡二叉树在数据库和文件系统上的选择就被\",{\"1\":{\"266\":1}}],[\"所以这台机器压力会最轻\",{\"1\":{\"106\":1}}],[\"所以假如填写10240\",{\"1\":{\"106\":1}}],[\"所以最好与ulimit\",{\"1\":{\"106\":1}}],[\"所以最近想更新一个系列文章\",{\"1\":{\"84\":1}}],[\"所以\",{\"1\":{\"77\":1,\"516\":1,\"594\":1,\"622\":2,\"635\":1,\"658\":1,\"692\":1,\"922\":5,\"938\":3,\"940\":3,\"956\":2,\"966\":1,\"972\":1,\"1002\":1,\"1018\":2,\"1149\":1,\"1177\":1,\"1212\":3,\"1220\":1,\"1340\":1,\"1362\":1,\"1389\":3,\"1397\":1}}],[\"所有客户端在它下面创建临时顺序编号目录节点\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"所有客户端都去创建\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"所有进程\",{\"1\":{\"1242\":1,\"1415\":1}}],[\"所有事务逐个依次执行\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"所有依赖于它的对象都得到通知并自动更新\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"所有扫描过的行都会被锁上\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"所有partition的leader选举都由controller决定\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"所有与\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"所有副本\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"所有集合都是它的子类\",{\"1\":{\"1113\":1,\"1308\":1}}],[\"所有线程的共享变量都放在主内存中\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"所有线程就会被唤醒\",{\"1\":{\"932\":1}}],[\"所有请求全部达到\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"所有请求挂起\",{\"1\":{\"166\":1}}],[\"所有返回结果都使用它\",{\"1\":{\"830\":1}}],[\"所有编译期异常转换为运行期异常\",{\"1\":{\"830\":1}}],[\"所有抽离一个类\",{\"1\":{\"828\":1}}],[\"所有的对象通过彼此的合作\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"所有的消费者都属于某个消费者组\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"所有的故事都围绕切点发生\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"所有的项目配置信息都被定义在一个叫做pom\",{\"1\":{\"698\":1}}],[\"所有的内容会公众号第一时间更新\",{\"1\":{\"3\":1}}],[\"所有加上synchronized\",{\"1\":{\"692\":1}}],[\"所有键都是字符串\",{\"1\":{\"619\":1}}],[\"所有键值分布在整颗树中\",{\"1\":{\"265\":1}}],[\"所有我们在中间加一道缓存\",{\"1\":{\"616\":1}}],[\"所有给定集合的并集存储在\",{\"1\":{\"606\":1}}],[\"所有数据都会存储在叶子节点上\",{\"1\":{\"495\":1}}],[\"所有单词的倒排列表往往顺序地存储在磁盘的某个文件里\",{\"1\":{\"424\":1}}],[\"所有元素都处于桶中\",{\"1\":{\"351\":1}}],[\"所有半径相同的磁道组成一个柱面\",{\"1\":{\"274\":1}}],[\"所有磁头任何时候都是重叠的\",{\"1\":{\"274\":1}}],[\"所有\",{\"1\":{\"270\":1,\"1166\":1,\"1354\":1,\"1443\":1}}],[\"所有关键字存储在叶子节点出现\",{\"1\":{\"269\":1}}],[\"所有静态文件由nginx直接读取不经过tomcat或resin\",{\"1\":{\"106\":1}}],[\"所有jsp的页面均交由tomcat或resin处理\",{\"1\":{\"106\":1}}],[\"所有文章非特别说明都为\",{\"1\":{\"49\":1}}],[\"无连接\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"无状态\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"无边界的\",{\"1\":{\"966\":1}}],[\"无序列表\",{\"1\":{\"656\":1}}],[\"无重复的方式保存集合元素\",{\"1\":{\"630\":1}}],[\"无锁\",{\"1\":{\"569\":1}}],[\"无锁的情况下就可能出现\",{\"1\":{\"553\":1}}],[\"无需过多干预\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"无需再处理\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"无需服务器\",{\"0\":{\"906\":1},\"1\":{\"906\":1}}],[\"无需查询最新的列表\",{\"1\":{\"594\":1}}],[\"无需进行多次磁盘i\",{\"1\":{\"497\":1}}],[\"无需频繁创建销毁\",{\"1\":{\"77\":1}}],[\"无法做到像编程式事务那样可以作用到代码块级别\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"无法清除垃圾碎片\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"无法直接访问对方工作内存中的变量\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"无法代理类\",{\"1\":{\"1016\":1}}],[\"无法使用这个实际类型\",{\"1\":{\"966\":1}}],[\"无法处理其他请求\",{\"1\":{\"962\":1}}],[\"无法结束\",{\"1\":{\"954\":1}}],[\"无法完全实例化\",{\"1\":{\"954\":1}}],[\"无法正常实例化\",{\"1\":{\"954\":1}}],[\"无法识别\",{\"1\":{\"950\":1}}],[\"无法移动对象\",{\"1\":{\"938\":1}}],[\"无法保证缓存一致性\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"无法保证递增\",{\"1\":{\"385\":1}}],[\"无法保持原有的顺序\",{\"1\":{\"499\":1}}],[\"无法获得id\",{\"1\":{\"383\":1}}],[\"无法出队\",{\"1\":{\"289\":1}}],[\"无法很好的利用磁盘预读\",{\"1\":{\"266\":1}}],[\"无法定位出现了什么类型的异常\",{\"1\":{\"197\":1}}],[\"无论当前存不存在事务\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"无论何时我们调用一个对象的clone方法\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"无论数千还是数十亿的唯一值\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"无论目标方法是否正常完成都会执行\",{\"1\":{\"944\":1}}],[\"无论是创建还是使用对象b\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"无论是\",{\"1\":{\"769\":1}}],[\"无论是通过commit提交事务还是通过rollback回滚事务\",{\"1\":{\"578\":1}}],[\"无论是主键索引还是二级索引\",{\"1\":{\"575\":1}}],[\"无论是开源还是私有\",{\"1\":{\"400\":1}}],[\"无论是归并排序\",{\"1\":{\"359\":1}}],[\"无论使用firefox4\",{\"1\":{\"106\":1}}],[\"无论使用firefox还是ie浏览器\",{\"1\":{\"106\":1}}],[\"无论我们创建多少次\",{\"1\":{\"77\":1}}],[\"会进行销毁操作\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"会发现好像刚刚的更改对于某些数据未起作用\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"会发生什么\",{\"1\":{\"968\":1}}],[\"会判断是否\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"会为每个日志段文件打开一个\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"会为每个分区缓存消息\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"会为该文档指定一个版本号\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"会造成多个watch被触发\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"会造成非必要的数学开销\",{\"1\":{\"922\":1}}],[\"会被gc自动回收掉\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"会比较占用你服务器的性能\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"会基于原数组拷贝出一个新的数组\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"会根据\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"会有点大材小用浪费空间\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"会不知疲倦地一页一页的获取网页直到你的服务崩溃的罪魁祸首一般是机器人或者web\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"会不定时分享一些我的看法\",{\"1\":{\"211\":1}}],[\"会创建一个大小为\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"会合并小段到一个较大的段\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"会更灵活\",{\"1\":{\"966\":1}}],[\"会单独创建\",{\"1\":{\"962\":1}}],[\"会直接从缓存中获取数据\",{\"1\":{\"958\":1}}],[\"会直接丢弃新的任务\",{\"1\":{\"926\":1}}],[\"会提前暴露一个\",{\"1\":{\"954\":1}}],[\"会首先创建目标对象\",{\"1\":{\"954\":1}}],[\"会延迟加载\",{\"1\":{\"952\":1}}],[\"会话都会创建一个\",{\"1\":{\"952\":2}}],[\"会调用该方法\",{\"1\":{\"952\":2}}],[\"会调用\",{\"1\":{\"952\":5}}],[\"会返回一个\",{\"1\":{\"950\":1}}],[\"会加大开发难度\",{\"1\":{\"938\":1}}],[\"会导致短时间大量请求落在数据库上\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"会导致集群节点响应时间变慢\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"会导致内存垃圾回收延长\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"会导致jvm的堆内存交换到磁盘上\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"会导致缓存和\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"会导致非垃圾对象被清除\",{\"1\":{\"938\":1}}],[\"会导致发号重复或者服务会处于不可用状态\",{\"1\":{\"387\":1}}],[\"会产生大量空间碎片\",{\"1\":{\"938\":1}}],[\"会产生\",{\"1\":{\"938\":1}}],[\"会抛出oom异常\",{\"1\":{\"936\":1}}],[\"会停顿其他线程\",{\"1\":{\"936\":1}}],[\"会触发垃圾回收\",{\"1\":{\"936\":1}}],[\"会触发初始化\",{\"1\":{\"934\":5}}],[\"会触发一次full\",{\"1\":{\"930\":1}}],[\"会触发一个缺页异常\",{\"1\":{\"274\":1}}],[\"会从等待队列中取出一个线程\",{\"1\":{\"932\":1}}],[\"会丢弃任务队列中最早的任务\",{\"1\":{\"926\":1}}],[\"会保留至运行时\",{\"1\":{\"944\":1}}],[\"会保证每次读取都从内存中读取最新的值\",{\"1\":{\"924\":1}}],[\"会保存60张图片\",{\"1\":{\"141\":1}}],[\"会退化为链表\",{\"1\":{\"922\":1}}],[\"会的\",{\"1\":{\"920\":1}}],[\"会清空缓存\",{\"1\":{\"789\":1}}],[\"会极大地节省存储空间\",{\"1\":{\"658\":1}}],[\"会占用较长时间和大量系统资源\",{\"1\":{\"645\":1}}],[\"会共享值为\",{\"1\":{\"636\":1}}],[\"会先对我们的输入作哈希运算\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"会先将数据写入到一个临时文件中\",{\"1\":{\"962\":1}}],[\"会先去二级缓存中查找是否有数据\",{\"1\":{\"958\":1}}],[\"会先检查给定键的类型能否执行指定的命令\",{\"1\":{\"636\":1}}],[\"会先根据二级索引定位到数据所在的磁盘位置\",{\"1\":{\"497\":1}}],[\"会在对象创建完成后\",{\"1\":{\"954\":1}}],[\"会在\",{\"1\":{\"924\":1,\"952\":4}}],[\"会在链表中追加元素\",{\"1\":{\"922\":1}}],[\"会在初始化服务器时\",{\"1\":{\"635\":1}}],[\"会在索引列\",{\"1\":{\"558\":1}}],[\"会定期把缓存保存到硬盘\",{\"1\":{\"615\":1}}],[\"会用它做爬虫采集系统中队列使用\",{\"1\":{\"594\":1}}],[\"会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件\",{\"1\":{\"589\":1}}],[\"会变成当前读\",{\"1\":{\"575\":1}}],[\"会阻止其他事务访问整个表\",{\"1\":{\"574\":1}}],[\"会影响是否启用表锁以及何时进行锁升级\",{\"1\":{\"574\":1}}],[\"会锁定查询到的行\",{\"1\":{\"571\":1}}],[\"会分配一个新的自增值给插入的行\",{\"1\":{\"559\":1}}],[\"会让他们做一些任务\",{\"1\":{\"483\":1}}],[\"会将数据复制到另一份副本当中\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"会将分区\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"会将应用程序未用到的内存交换出去\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"会将请求写入到\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"会将其中的存活对象移动到老年代\",{\"1\":{\"930\":1}}],[\"会将其中的存活对象移动到survivor区2\",{\"1\":{\"930\":1}}],[\"会将其转换为\",{\"1\":{\"451\":1}}],[\"会将其转换为以下格式\",{\"1\":{\"450\":1}}],[\"会将任务分配给调用线程来执行\",{\"1\":{\"926\":1}}],[\"会将\",{\"1\":{\"916\":1,\"1162\":1,\"1350\":1}}],[\"会将原\",{\"1\":{\"450\":1}}],[\"会额外增加内存消耗量\",{\"1\":{\"440\":1}}],[\"会自动调用代理类中的方法\",{\"1\":{\"1016\":1}}],[\"会自动调用\",{\"1\":{\"1016\":1}}],[\"会自动尝试重连\",{\"1\":{\"964\":1}}],[\"会自动去除\",{\"1\":{\"786\":1}}],[\"会自动对应\",{\"1\":{\"779\":1}}],[\"会自动增加\",{\"1\":{\"439\":1}}],[\"会自动设置成\",{\"1\":{\"439\":1}}],[\"会默认忽略该值\",{\"1\":{\"434\":1}}],[\"会读取若干个\",{\"1\":{\"270\":1}}],[\"会员逻辑\",{\"1\":{\"200\":1}}],[\"会员\",{\"1\":{\"200\":1}}],[\"会对你有所帮助\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"会对该段代码采取排他锁\",{\"1\":{\"1018\":1}}],[\"会对分片集群有什么影响呢\",{\"1\":{\"968\":1}}],[\"会对\",{\"1\":{\"950\":1}}],[\"会对比数据库表中保存的版本\",{\"1\":{\"864\":1}}],[\"会对系统和有业务造成伤害\",{\"1\":{\"191\":1}}],[\"会对没有依赖关系的代码进行重排序\",{\"1\":{\"80\":1}}],[\"会浪费大量资源\",{\"1\":{\"77\":1}}],[\"会使用自增锁来确保在并发环境下\",{\"1\":{\"559\":1}}],[\"会使用\",{\"1\":{\"29\":1}}],[\"本质的区别来源于两者的底层实现\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"本质是参数化类型\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"本质是一个线程安全的可修改的字符序列\",{\"1\":{\"1089\":1,\"1290\":1}}],[\"本质就是不同的硬件\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"本质区别\",{\"1\":{\"496\":1}}],[\"本系列\",{\"1\":{\"1026\":1,\"1030\":1,\"1056\":1,\"1126\":1,\"1171\":1,\"1223\":1,\"1236\":1}}],[\"本系列从实战出发手把手一起对接口响应慢问题做优化\",{\"1\":{\"525\":1}}],[\"本回答只能简要提及\",{\"1\":{\"940\":1}}],[\"本功能全部完成\",{\"1\":{\"918\":1}}],[\"本文没一句废话\",{\"1\":{\"895\":1}}],[\"本文主要是\",{\"1\":{\"587\":1}}],[\"本次在root权限下安装\",{\"1\":{\"852\":1}}],[\"本案例主要通过俩个实操讲解\",{\"1\":{\"683\":1}}],[\"本身来说很小\",{\"1\":{\"602\":1}}],[\"本身那么提高硬件也是很有限的\",{\"1\":{\"515\":1}}],[\"本教程涉及到的一些代码都是\",{\"1\":{\"648\":1}}],[\"本教程致力于最实用教程\",{\"1\":{\"586\":1}}],[\"本教程是系列教程\",{\"1\":{\"411\":1,\"428\":1,\"460\":1,\"524\":1}}],[\"本教程纯手打\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"648\":1,\"698\":1,\"732\":1}}],[\"本课程是实战课程\",{\"1\":{\"394\":1}}],[\"本地接口\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"本地方法是指使用其他语言\",{\"1\":{\"930\":1}}],[\"本地方法栈和程序计数器的运行是线程私有的内存区域\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"本地方法栈的作用是为本地方法提供内存空间\",{\"1\":{\"930\":1}}],[\"本地方法栈与java虚拟机栈类似\",{\"1\":{\"930\":1}}],[\"本地方法栈\",{\"1\":{\"930\":1,\"936\":1,\"1142\":2,\"1333\":2}}],[\"本地预览\",{\"0\":{\"912\":1}}],[\"本地仓库\",{\"1\":{\"705\":2}}],[\"本地缓存的实时性怎么保证\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"本地缓存\",{\"1\":{\"615\":1,\"1045\":1,\"1048\":1,\"1178\":1,\"1254\":1,\"1257\":1,\"1363\":1}}],[\"本地调用\",{\"1\":{\"385\":1}}],[\"本地动静分离反向代理配置\",{\"1\":{\"106\":1}}],[\"本篇是代码篇\",{\"1\":{\"807\":1}}],[\"本篇是数据类型底层实现\",{\"1\":{\"613\":1}}],[\"本篇是系列文章\",{\"1\":{\"525\":1}}],[\"本篇继续学习\",{\"1\":{\"613\":1}}],[\"本篇主要是\",{\"1\":{\"587\":1}}],[\"本篇主要讲述几个在实战中注意优化的性能点供大家参考\",{\"1\":{\"525\":1}}],[\"本篇都是基于前面搭建的环境来讲解\",{\"1\":{\"460\":1}}],[\"本篇幅是继上一篇\",{\"1\":{\"411\":1,\"428\":1,\"460\":1}}],[\"本篇幅是继上一篇springboot2\",{\"1\":{\"397\":1}}],[\"本篇就以最简单的方式讲解\",{\"1\":{\"364\":1}}],[\"本篇介绍如何在生产环境使用单例模式\",{\"1\":{\"76\":1}}],[\"本页面就是一个示例\",{\"1\":{\"20\":1}}],[\"相同点\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"相同\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"相同的消息会在一个分区下\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"相同的sql和参数\",{\"1\":{\"789\":1}}],[\"相同的分值\",{\"1\":{\"629\":1}}],[\"相同的值可以复制到多个字段\",{\"1\":{\"436\":1}}],[\"相比于其他基于内存存储的系统而言\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"相比于框架的源码\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"相比于行锁\",{\"1\":{\"566\":1}}],[\"相比nio更进一步\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"相比方案一来说\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"相比传统的\",{\"1\":{\"1020\":1}}],[\"相比cms无碎片和高效\",{\"1\":{\"936\":1}}],[\"相当于资源注入\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"相当于\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"相当于java程序中的this\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"相当于wait\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"相当于是一个连接一个线程\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"相当于是独占记录\",{\"1\":{\"555\":1}}],[\"相当于sql语句中的statement\",{\"1\":{\"779\":1}}],[\"相当于preparedstatement使用占位符去替换参数\",{\"1\":{\"779\":1}}],[\"相当于执行了这样一条sql\",{\"1\":{\"779\":1}}],[\"相互独立\",{\"1\":{\"711\":1}}],[\"相互等待对方持有的资源\",{\"1\":{\"562\":1}}],[\"相似\",{\"1\":{\"706\":1}}],[\"相信大家看到很多类似这种回答\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"相信大家都会有种及眼熟又陌生的感觉\",{\"1\":{\"1026\":1,\"1030\":1,\"1041\":1,\"1056\":1,\"1067\":1,\"1083\":1,\"1097\":1,\"1111\":1,\"1126\":1,\"1141\":1,\"1155\":1,\"1171\":1,\"1184\":1,\"1197\":1,\"1210\":1,\"1223\":1,\"1236\":1,\"1249\":1}}],[\"相信是每个java攻城狮都遇到过的\",{\"1\":{\"700\":1}}],[\"相信你对\",{\"1\":{\"608\":1}}],[\"相信没有一个攻城狮不懂单例模式\",{\"1\":{\"76\":1}}],[\"相等的值\",{\"1\":{\"604\":1}}],[\"相等的元素\",{\"1\":{\"604\":2}}],[\"相对于beanfactory\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"相对于当前上下文对象\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"相对于hibernate\",{\"1\":{\"1173\":1,\"1358\":1}}],[\"相对于内存存取\",{\"1\":{\"271\":1}}],[\"相对灵活\",{\"1\":{\"1173\":1,\"1358\":1}}],[\"相对哈希索引来说操作更复杂\",{\"1\":{\"499\":1}}],[\"相关概念\",{\"0\":{\"1188\":1,\"1371\":1}}],[\"相关的\",{\"1\":{\"1032\":1}}],[\"相关的核心类之一\",{\"1\":{\"1023\":1}}],[\"相关的源码\",{\"1\":{\"1023\":1}}],[\"相关联\",{\"1\":{\"559\":1}}],[\"相关术语解析\",{\"0\":{\"415\":1}}],[\"相关配置文档请见\",{\"1\":{\"6\":1}}],[\"相反\",{\"1\":{\"375\":1}}],[\"相反也一样\",{\"1\":{\"135\":1}}],[\"打头的\",{\"1\":{\"944\":1}}],[\"打包安装这两个模块到本地\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"打包成\",{\"1\":{\"854\":1}}],[\"打包成可发布的格式\",{\"1\":{\"713\":1}}],[\"打包构建docker镜像\",{\"0\":{\"854\":1}}],[\"打包构建后的\",{\"1\":{\"844\":1}}],[\"打包时不执行测试\",{\"1\":{\"705\":1}}],[\"打包项目\",{\"1\":{\"705\":1}}],[\"打包\",{\"0\":{\"850\":1},\"1\":{\"698\":1,\"711\":2,\"713\":1}}],[\"打开即可看到暴露的信息\",{\"1\":{\"885\":1}}],[\"打开sqlsession回话\",{\"0\":{\"747\":1}}],[\"打开cmd\",{\"1\":{\"703\":1}}],[\"打开\",{\"1\":{\"597\":1,\"702\":1,\"837\":1}}],[\"打印\",{\"1\":{\"934\":2,\"1151\":1,\"1342\":1}}],[\"打印sql\",{\"0\":{\"725\":1}}],[\"打印语句\",{\"1\":{\"692\":1}}],[\"打印所有\",{\"1\":{\"604\":1}}],[\"打印关键信息\",{\"1\":{\"201\":1}}],[\"打印全部的异常信息\",{\"0\":{\"197\":1}}],[\"打印出的日志包含堆栈信息\",{\"1\":{\"196\":1}}],[\"打印日志\",{\"0\":{\"196\":1}}],[\"打印日志对象要做判空处理\",{\"0\":{\"193\":1}}],[\"打印日志非常重要\",{\"1\":{\"190\":1}}],[\"打印入参\",{\"1\":{\"192\":1}}],[\"打印按钮\",{\"1\":{\"23\":1}}],[\"打铁还要自身硬\",{\"1\":{\"76\":1}}],[\"作用是在对象和视图之间做数据的交互\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"作用是能够提供不精确的去重计数\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"作用分别是什么\",{\"0\":{\"1127\":1,\"1320\":1}}],[\"作用\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"作用域的\",{\"1\":{\"952\":2}}],[\"作用域开始和结束时触发\",{\"1\":{\"952\":1}}],[\"作为预分配空间保留\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"作为循环队列必要适用\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"作为队列使用\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"作为主键回显\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"作为主页内容渲染\",{\"1\":{\"911\":1}}],[\"作为sql回显\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"作为当前partition的leader\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"作为缓存\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"作为\",{\"1\":{\"1033\":2}}],[\"作为锁对象\",{\"1\":{\"1022\":1}}],[\"作为整个流程的控制器\",{\"1\":{\"956\":1}}],[\"作为jvm调优的进阶\",{\"1\":{\"942\":1}}],[\"作为回收和管理的基本单元\",{\"1\":{\"940\":1}}],[\"作为仓库使用\",{\"1\":{\"698\":1}}],[\"作为最基本的类型\",{\"1\":{\"653\":1}}],[\"作为连接键的列\",{\"1\":{\"502\":1}}],[\"作为服务端处理时定制化\",{\"1\":{\"183\":1}}],[\"作为后端工程师\",{\"1\":{\"175\":1}}],[\"作为leader\",{\"1\":{\"153\":1}}],[\"作为数据源来可视化监控数据了\",{\"1\":{\"109\":1}}],[\"作为数据源\",{\"1\":{\"109\":1}}],[\"作为一个技术人\",{\"1\":{\"76\":1}}],[\"作者\",{\"1\":{\"493\":1,\"552\":1,\"876\":1,\"1004\":1}}],[\"作者生于\",{\"1\":{\"223\":1}}],[\"作者档案\",{\"1\":{\"214\":1,\"217\":1}}],[\"作者设置为\",{\"1\":{\"44\":1}}],[\"作者照片\",{\"1\":{\"2\":1}}],[\"作者信息\",{\"0\":{\"217\":1},\"1\":{\"2\":1,\"705\":1}}],[\"最细粒度只能作用到方法级别\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"最直观的一定是\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"最多只能同时满足其中两项\",{\"1\":{\"1078\":2,\"1282\":1}}],[\"最多可以有上千个子节点\",{\"1\":{\"263\":1}}],[\"最初的90个结果会被丢弃\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"最为主流和常用\",{\"1\":{\"1045\":1,\"1254\":1}}],[\"最不经常使用\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"最容易搞混的两个概念\",{\"1\":{\"966\":1}}],[\"最基本的收集器\",{\"1\":{\"936\":1}}],[\"最常使用命令集\",{\"1\":{\"915\":1}}],[\"最低优先级的是\",{\"1\":{\"766\":1}}],[\"最简单的maven项目模板\",{\"1\":{\"703\":1}}],[\"最大缓存大小\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"最大容量\",{\"1\":{\"948\":1}}],[\"最大线程数是线程池中最多的线程数\",{\"1\":{\"926\":1}}],[\"最大线程数\",{\"1\":{\"926\":1}}],[\"最大的特点是有个分数可以自定义排序规则\",{\"1\":{\"657\":1}}],[\"最大长度\",{\"1\":{\"632\":1}}],[\"最大连接数=连接数\",{\"1\":{\"106\":1}}],[\"最主要的特点是轻量以及快速\",{\"1\":{\"615\":1}}],[\"最新列表\",{\"1\":{\"594\":1}}],[\"最后看\",{\"1\":{\"1431\":1}}],[\"最后判断这个bean是否配置了dlestroy\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"最后合并计算结果\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"最后join的实现其实是基于等待通知机制的\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"最后两个小问题\",{\"1\":{\"966\":1}}],[\"最后两个问题\",{\"1\":{\"958\":1}}],[\"最后由\",{\"1\":{\"956\":1}}],[\"最后一个问题\",{\"1\":{\"930\":1,\"944\":1,\"950\":2,\"974\":1}}],[\"最后发现提交到了测试分支\",{\"1\":{\"917\":1}}],[\"最后将结果数据显示到指定页面\",{\"1\":{\"832\":1}}],[\"最后读取作为方法参数传递的属性\",{\"1\":{\"766\":1}}],[\"最后从远程仓库\",{\"1\":{\"715\":1}}],[\"最后\",{\"1\":{\"425\":1,\"922\":3,\"934\":2,\"944\":1,\"952\":1,\"978\":2,\"992\":1,\"1012\":1,\"1016\":1}}],[\"最小的\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"最小的高可用配置是2台服务器\",{\"1\":{\"422\":1}}],[\"最小值设定为超过能成为master节点的n\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"最小支持\",{\"1\":{\"404\":1}}],[\"最小生成树\",{\"0\":{\"322\":1}}],[\"最快的掌握方式就是先学会使用\",{\"1\":{\"397\":1}}],[\"最高位是0<br>\",{\"1\":{\"388\":1}}],[\"最高位是符号位\",{\"1\":{\"388\":1}}],[\"最终成功创建的那个客户端也即拥有了这把锁\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"最终调用getcandidateconfigurations\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"最终就会导致oom问题的出现\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"最终实现系统的业务逻辑\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"最终可能超过底层操作系统配置的文件句柄数量限制\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"最终挂掉的情况\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"最终通知\",{\"1\":{\"944\":1}}],[\"最终标记阶段是cms算法关键\",{\"1\":{\"938\":1}}],[\"最终标记阶段需要stop\",{\"1\":{\"938\":1}}],[\"最终标记\",{\"1\":{\"936\":1,\"938\":1,\"940\":1}}],[\"最终的目标是帮助大家更好的掌控面试\",{\"1\":{\"920\":1}}],[\"最终解决方案\",{\"1\":{\"779\":1}}],[\"最终a依赖的x的版本为2\",{\"1\":{\"709\":1}}],[\"最终在某个时间点上\",{\"1\":{\"625\":1}}],[\"最终使得整个序列有序\",{\"1\":{\"364\":1}}],[\"最终\",{\"1\":{\"359\":1}}],[\"最终完成排序\",{\"1\":{\"348\":1}}],[\"最短路径\",{\"0\":{\"323\":1}}],[\"最好的一种方法\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"最好的策略是启动时就把热点数据加载好\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"最好的情况是o\",{\"1\":{\"263\":1}}],[\"最好坚持一种模式\",{\"1\":{\"602\":1}}],[\"最好使用导出表\",{\"1\":{\"541\":1}}],[\"最好在测试环境中进行评估\",{\"1\":{\"511\":1}}],[\"最好\",{\"1\":{\"364\":1}}],[\"最好为o\",{\"1\":{\"270\":1}}],[\"最好情况o\",{\"1\":{\"265\":1}}],[\"最早诞生于\",{\"1\":{\"225\":1}}],[\"最长不能超过多少个ticktime的时间长度\",{\"1\":{\"157\":1}}],[\"最坏的情况下在内存中查找的次数为2\",{\"1\":{\"106\":1}}],[\"最少必要面试\",{\"1\":{\"100\":1}}],[\"最少必要面试题\",{\"0\":{\"1039\":1,\"1168\":1,\"1249\":1},\"1\":{\"49\":1,\"1026\":1,\"1027\":1,\"1030\":1,\"1036\":1,\"1041\":1,\"1056\":1,\"1064\":1,\"1123\":1,\"1126\":1,\"1138\":1,\"1171\":1,\"1177\":1,\"1181\":1,\"1220\":1,\"1223\":1,\"1233\":1,\"1236\":1,\"1246\":1,\"1249\":1,\"1362\":1,\"1419\":1},\"2\":{\"1028\":1,\"1037\":1,\"1040\":1,\"1054\":1,\"1065\":1,\"1081\":1,\"1095\":1,\"1109\":1,\"1124\":1,\"1139\":1,\"1153\":1,\"1169\":1,\"1182\":1,\"1195\":1,\"1208\":1,\"1221\":1,\"1234\":1,\"1247\":1,\"1420\":1}}],[\"最近最少使用\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"最近我在更新\",{\"1\":{\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1023\":1}}],[\"最近我手头一些活\",{\"1\":{\"175\":1}}],[\"最近帝都疫情又严重\",{\"1\":{\"640\":1}}],[\"最近有些同学在后台问我\",{\"1\":{\"90\":1}}],[\"最近各大互联网公司都传出裁员消息\",{\"1\":{\"76\":1}}],[\"我给他起个名字就叫\",{\"1\":{\"1439\":1}}],[\"我加个描述\",{\"1\":{\"1431\":1}}],[\"我觉得可以分两部分答\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"我觉得kafka就像是一个多面手\",{\"1\":{\"976\":1}}],[\"我曾经使用过\",{\"1\":{\"1022\":1}}],[\"我有使用过\",{\"1\":{\"1022\":1}}],[\"我有个朋友是初学者\",{\"0\":{\"98\":1}}],[\"我看到你的简历上写着你熟悉\",{\"1\":{\"1022\":1}}],[\"我使用过synchronized作为悲观锁\",{\"1\":{\"1018\":1}}],[\"我一定会继续加深理解的\",{\"1\":{\"1018\":1}}],[\"我一直听说kafka的幂等性很重要\",{\"1\":{\"996\":1}}],[\"我一直想了解一下kafka的ack机制是怎么回事\",{\"1\":{\"994\":1}}],[\"我一直对kafka很好奇\",{\"1\":{\"986\":1}}],[\"我一直在研究关注区块链和\",{\"1\":{\"211\":1}}],[\"我通过面试了吗\",{\"1\":{\"1016\":1}}],[\"我通过阅读源码\",{\"1\":{\"922\":1}}],[\"我了解一些\",{\"1\":{\"1010\":1}}],[\"我喜欢吃橙子\",{\"1\":{\"1006\":1}}],[\"我喜欢吃香蕉\",{\"1\":{\"1006\":1}}],[\"我喜欢吃苹果\",{\"1\":{\"1006\":1}}],[\"我喜欢对多单词的字段名中加上一个点\",{\"1\":{\"602\":1}}],[\"我来给你解释一下\",{\"1\":{\"996\":1}}],[\"我迫不及待想了解更多\",{\"1\":{\"986\":1}}],[\"我随时都可以回答\",{\"1\":{\"982\":1,\"1006\":1}}],[\"我认为在使用redis分布式锁时\",{\"1\":{\"970\":1}}],[\"我认为作为提高生产力的技术\",{\"1\":{\"76\":1}}],[\"我可以给你演示一下源码实现吗\",{\"1\":{\"970\":1}}],[\"我可以查询其中的\",{\"1\":{\"506\":1}}],[\"我自己在准备和回答的过程中\",{\"1\":{\"966\":1}}],[\"我以前也常常搞不清这两者的差别\",{\"1\":{\"966\":1}}],[\"我也花了不少时间去理解和实践\",{\"1\":{\"1018\":1}}],[\"我也非常欣赏这次交流\",{\"1\":{\"966\":1}}],[\"我也在这个过程中对泛型有了更深的理解\",{\"1\":{\"966\":1}}],[\"我也觉得把一个复杂的技术问题变成一个故事或场景会让人更容易理解其中的逻辑和流程\",{\"1\":{\"934\":1}}],[\"我都会尽力帮助解答\",{\"1\":{\"990\":1}}],[\"我都差不多明白了\",{\"1\":{\"966\":1}}],[\"我都不好意思问你其他的了\",{\"1\":{\"966\":1}}],[\"我都明白了\",{\"1\":{\"966\":1}}],[\"我现在对倒排索引有了更清晰的认识\",{\"1\":{\"1006\":1}}],[\"我现在全明白了\",{\"1\":{\"964\":1}}],[\"我现阶段没有其他问题了\",{\"1\":{\"922\":1}}],[\"我再问你几个\",{\"1\":{\"960\":1}}],[\"我叫小明\",{\"1\":{\"956\":1}}],[\"我相信面试一定会取得很好的表现\",{\"1\":{\"952\":1}}],[\"我相信你一定会越来越精进\",{\"1\":{\"922\":1}}],[\"我明白了\",{\"1\":{\"950\":1,\"994\":1}}],[\"我这里仅解析其基本结构与重要流程\",{\"1\":{\"948\":1}}],[\"我最常用的当属hashmap\",{\"1\":{\"948\":1}}],[\"我仍需不断学习与总结\",{\"1\":{\"948\":1}}],[\"我还想提一下elasticsearch的分布式特性\",{\"1\":{\"1000\":1}}],[\"我还希望进一步学习的内容如下\",{\"1\":{\"948\":1}}],[\"我还需要继续学习\",{\"1\":{\"948\":1}}],[\"我还需要继续学习和总结\",{\"1\":{\"922\":1}}],[\"我还不太清楚或想进一步学习的内容如下\",{\"1\":{\"946\":1}}],[\"我还在不断学习与理解中\",{\"1\":{\"946\":1}}],[\"我还未能全部掌握\",{\"1\":{\"946\":1}}],[\"我亟需在实践中不断磨练这些理论知识\",{\"1\":{\"940\":1}}],[\"我的博客提供了\",{\"1\":{\"1079\":1,\"1283\":1}}],[\"我的jvm调优进阶学习计划如下\",{\"1\":{\"942\":1}}],[\"我的表述确实有失妥当\",{\"1\":{\"940\":1}}],[\"我的任务终于可以开始执行了\",{\"1\":{\"934\":1}}],[\"我就不高兴了\",{\"1\":{\"940\":1}}],[\"我就尝试过搞自媒体\",{\"1\":{\"225\":1}}],[\"我首先得搞清楚要运行的这个类到底在哪儿\",{\"1\":{\"934\":1}}],[\"我很享受这次面试\",{\"1\":{\"974\":1}}],[\"我很高兴能帮助你理解倒排索引\",{\"1\":{\"1006\":1}}],[\"我很高兴能有这次面试机会\",{\"1\":{\"1000\":1}}],[\"我很高兴能与您分享这些知识\",{\"1\":{\"1002\":1}}],[\"我很高兴能与您分享我的知识\",{\"1\":{\"984\":1}}],[\"我很高兴能与您分享我的见解\",{\"1\":{\"970\":1}}],[\"我很高兴能与你分享这些方法\",{\"1\":{\"982\":1}}],[\"我很高兴能够帮助\",{\"1\":{\"972\":1}}],[\"我很高兴能够分享我的知识\",{\"1\":{\"928\":1,\"990\":1}}],[\"我很高兴能参加这次面试\",{\"1\":{\"968\":1,\"998\":1}}],[\"我很欣赏你的学习热情与主动性\",{\"1\":{\"948\":1}}],[\"我很荣幸能够参加这次面试\",{\"1\":{\"930\":1}}],[\"我知道它是用来确保消息的可靠性传递的\",{\"1\":{\"994\":1}}],[\"我知道\",{\"1\":{\"928\":1}}],[\"我对kafka的幂等性有了更深入的理解\",{\"1\":{\"996\":1}}],[\"我对kafka的ack机制有了更清晰的理解了\",{\"1\":{\"994\":1}}],[\"我对kafka的架构设计有了更深入的了解\",{\"1\":{\"986\":1}}],[\"我对kafka的热爱让我对它的使用场景有了更深入的了解\",{\"1\":{\"976\":1}}],[\"我对这个话题有一些想法\",{\"1\":{\"982\":1}}],[\"我对你的表现印象深刻\",{\"1\":{\"998\":1}}],[\"我对你的理解和表达能力印象深刻\",{\"1\":{\"984\":1}}],[\"我对你的回答非常满意\",{\"1\":{\"976\":1}}],[\"我对你的回答印象深刻\",{\"1\":{\"970\":1}}],[\"我对你的学习态度和理解能力很为欣赏\",{\"1\":{\"946\":1}}],[\"我对分布式锁的实现方式很感兴趣\",{\"1\":{\"970\":1}}],[\"我对redis分片集群有一些了解\",{\"1\":{\"968\":1}}],[\"我对泛型也有了更全面的认识\",{\"1\":{\"966\":1}}],[\"我对java集合还在学习中\",{\"1\":{\"946\":1}}],[\"我对jvm调优还在学习中\",{\"1\":{\"942\":1}}],[\"我对线程池非常了解\",{\"1\":{\"926\":1}}],[\"我对很多技术内容有了进一步的认识和提高\",{\"1\":{\"922\":1}}],[\"我会尽力用人话解释它\",{\"1\":{\"1006\":1}}],[\"我会尽力帮助您\",{\"1\":{\"984\":1}}],[\"我会继续深入学习cas相关内容\",{\"1\":{\"1018\":1}}],[\"我会继续加深理解并运用的\",{\"1\":{\"988\":1}}],[\"我会继续努力学习的\",{\"1\":{\"954\":1}}],[\"我会继续努力学习和研究垃圾收集theory与实践\",{\"1\":{\"938\":1}}],[\"我会继续努力学习\",{\"1\":{\"922\":1,\"940\":1,\"958\":1,\"1010\":1,\"1016\":1}}],[\"我会根据这份清单进一步深入阅读源码\",{\"1\":{\"948\":1}}],[\"我会根据这份清单继续深入阅读源码\",{\"1\":{\"946\":1}}],[\"我会持续加深理解\",{\"1\":{\"946\":1}}],[\"我会持续努力\",{\"1\":{\"922\":1}}],[\"我会持之以恒\",{\"1\":{\"940\":1}}],[\"我会不断复习和运用这些知识\",{\"1\":{\"934\":1}}],[\"我会努力运用所学的知识\",{\"1\":{\"934\":1}}],[\"我想问一下你对\",{\"1\":{\"1020\":1}}],[\"我想问你作为hashmap的替代\",{\"1\":{\"922\":1}}],[\"我想知道\",{\"1\":{\"1008\":1}}],[\"我想知道kafka在实际应用中的一些最佳实践和常见问题解答\",{\"1\":{\"992\":1}}],[\"我想知道kafka的消费者是如何处理消息的失败和重试的\",{\"1\":{\"980\":1}}],[\"我想强调一点\",{\"1\":{\"968\":1,\"1002\":1}}],[\"我想你应该可以轻松应付与类加载相关的面试题了\",{\"1\":{\"934\":1}}],[\"我想你都知道了\",{\"1\":{\"121\":1}}],[\"我在代码中加了注释\",{\"1\":{\"928\":1}}],[\"我在后台收到很多读者的描述\",{\"1\":{\"920\":1}}],[\"我在课件放了插件的压缩包\",{\"1\":{\"413\":1}}],[\"我在课件里有插件压缩包\",{\"1\":{\"412\":1}}],[\"我把这篇完整粘贴出来\",{\"1\":{\"844\":1}}],[\"我常用的打包命令\",{\"1\":{\"705\":1}}],[\"我前面发过一些实战项目\",{\"1\":{\"698\":1}}],[\"我搞java也有段时间了\",{\"1\":{\"698\":1}}],[\"我只说明关键的地方\",{\"1\":{\"692\":1}}],[\"我关注的人也关注他\",{\"1\":{\"656\":1}}],[\"我去到\",{\"1\":{\"656\":1}}],[\"我推荐一款我经常用的\",{\"1\":{\"643\":1}}],[\"我日常工作中最常用的list实现类就是arraylist\",{\"1\":{\"946\":1}}],[\"我日常工作中最常用的jvm参数和监控工具如下\",{\"1\":{\"942\":1}}],[\"我日常工作中\",{\"1\":{\"594\":1}}],[\"我构建了\",{\"1\":{\"500\":1}}],[\"我已经单独安装\",{\"1\":{\"251\":1}}],[\"我当时即将大学毕业\",{\"1\":{\"225\":1}}],[\"我做过的项目\",{\"0\":{\"219\":1}}],[\"我每天都会处理邮件\",{\"1\":{\"211\":1}}],[\"我建议学习一些实战项目\",{\"1\":{\"101\":1}}],[\"我建议你从kafka\",{\"1\":{\"974\":1}}],[\"我建议你跟着课程详细学习\",{\"1\":{\"98\":1}}],[\"我建议你先将课程中的东西掌握\",{\"1\":{\"98\":1}}],[\"我不建议慢工出细活\",{\"1\":{\"100\":1}}],[\"我之前给大家推荐了一个可以免费使用\",{\"1\":{\"90\":1}}],[\"我没有\",{\"1\":{\"90\":1}}],[\"我是主节点\",{\"1\":{\"1008\":1}}],[\"我是今天的面试官\",{\"1\":{\"956\":1}}],[\"我是pub哥\",{\"1\":{\"388\":1,\"398\":1}}],[\"我是\",{\"1\":{\"90\":1,\"190\":1,\"408\":1,\"425\":1,\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1022\":1,\"1026\":1,\"1030\":1,\"1126\":1,\"1443\":1}}],[\"我是javapub\",{\"1\":{\"76\":1,\"275\":1,\"906\":1,\"1056\":1,\"1141\":1,\"1155\":1,\"1171\":1,\"1210\":1,\"1223\":1,\"1236\":1}}],[\"我们公司现在已经\",{\"1\":{\"1439\":1}}],[\"我们现在看到的画面\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"我们现在知道\",{\"1\":{\"619\":1}}],[\"我们再来看看\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"我们再来做个试验\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"我们再举个例子\",{\"1\":{\"966\":1}}],[\"我们直接调用接口方法就可以\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"我们先简单介绍几个概念\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"我们先要知道什么是\",{\"1\":{\"364\":1}}],[\"我们同样用\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"我们得了解这两种机制背后的实现原理\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"我们通过\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"我们必须同时获得两个账户上的锁\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"我们强烈建议你不要使用深分页\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"我们称这个对象为\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"我们称之为\",{\"1\":{\"1072\":1,\"1116\":1,\"1276\":1,\"1311\":1}}],[\"我们称为一页\",{\"1\":{\"266\":1}}],[\"我们要保证\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"我们可能缓存用户钱包的余额在缓存中\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"我们可以开启手动提交位移\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"我们可以\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"我们可以实现一个可以聊天类似微信的即时通讯系统\",{\"1\":{\"1033\":1}}],[\"我们可以自己实现一个简单的\",{\"1\":{\"1033\":1}}],[\"我们可以自定义运行时注解\",{\"1\":{\"944\":1}}],[\"我们可以遍历所有文档\",{\"1\":{\"1006\":1}}],[\"我们可以看到\",{\"1\":{\"1004\":1,\"1212\":1,\"1389\":1}}],[\"我们可以并行处理数据\",{\"1\":{\"1004\":1}}],[\"我们可以定义这个索引的字段\",{\"1\":{\"1004\":1}}],[\"我们可以定义一个\",{\"1\":{\"924\":1}}],[\"我们可以给它起个名字\",{\"1\":{\"1004\":1}}],[\"我们可以深入探讨kafka的最佳实践和解决方案\",{\"1\":{\"992\":1}}],[\"我们可以及时发现并解决潜在的问题\",{\"1\":{\"984\":1}}],[\"我们可以记录每个分区的偏移量\",{\"1\":{\"984\":1}}],[\"我们可以采取一些措施\",{\"1\":{\"984\":1}}],[\"我们可以将多个消息打包成一个批次\",{\"1\":{\"982\":1}}],[\"我们可以将整个对象缓存到\",{\"1\":{\"654\":1}}],[\"我们可以增加\",{\"1\":{\"982\":1}}],[\"我们可以这样定义一个泛型方法\",{\"1\":{\"966\":1}}],[\"我们可以这样定义箱子\",{\"1\":{\"966\":1}}],[\"我们可以通过同步或者异步获取响应结果\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"我们可以通过这个newinstance方法调用有参数的和私有的构造函数\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"我们可以通过配置参数\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"我们可以通过增加分区\",{\"1\":{\"980\":1}}],[\"我们可以通过实现\",{\"1\":{\"958\":1}}],[\"我们可以通过\",{\"1\":{\"952\":1}}],[\"我们可以通过继承\",{\"1\":{\"926\":1}}],[\"我们可以从jvm源码中看到cmscollector在清除对象后直接造成碎片\",{\"1\":{\"938\":1}}],[\"我们可以创建一个\",{\"1\":{\"932\":2}}],[\"我们可以使用动态代理来实现一个简单的日志记录器\",{\"1\":{\"1016\":1}}],[\"我们可以使用反射来动态地调用方法\",{\"1\":{\"1010\":1}}],[\"我们可以使用反射来动态地创建对象\",{\"1\":{\"1010\":1}}],[\"我们可以使用elasticsearch来搜索这个索引\",{\"1\":{\"1000\":1}}],[\"我们可以使用lucene来构建一个索引\",{\"1\":{\"1000\":1}}],[\"我们可以使用查询语句来进行搜索\",{\"1\":{\"998\":1}}],[\"我们可以使用kafka的监控工具来实时监控kafka集群的状态和性能指标\",{\"1\":{\"984\":1}}],[\"我们可以使用kafka的消息确认机制\",{\"1\":{\"984\":1}}],[\"我们可以使用数据结构来减少内存占用\",{\"1\":{\"972\":1}}],[\"我们可以使用\",{\"1\":{\"924\":1,\"932\":2,\"1060\":1,\"1105\":1,\"1266\":1,\"1303\":1}}],[\"我们可以在客户端每次与服务器交互时检查sessionid\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"我们可以在一定程度上减少内存使用\",{\"1\":{\"972\":1}}],[\"我们可以在父\",{\"1\":{\"844\":1}}],[\"我们可以在配置中修改\",{\"1\":{\"597\":1}}],[\"我们可以得到最简单的倒排索引\",{\"1\":{\"425\":1}}],[\"我们可以利用磁盘预读原理提前将这些数据读入内存\",{\"1\":{\"270\":1}}],[\"我们指的更多的是最终一致性\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"我们如果使用被动读\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"我们如何在面试中自然的对答\",{\"1\":{\"920\":1}}],[\"我们仍然将这个空结果进行缓存\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"我们将\",{\"1\":{\"1043\":1,\"1244\":1,\"1252\":1,\"1417\":1}}],[\"我们不难看出来\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"我们不能立刻得知消息是否已经被处理了\",{\"1\":{\"1034\":1}}],[\"我们不知道使用者会替换成什么类型\",{\"1\":{\"966\":1}}],[\"我们应该尽量避免使用反射来访问私有属性和方法\",{\"1\":{\"1010\":1}}],[\"我们就以一个需求的生命周期来分析\",{\"1\":{\"1439\":1}}],[\"我们就可以发现spring中存在的配置错误\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"我们就可以根据这些字段来搜索和过滤数据了\",{\"1\":{\"1004\":1}}],[\"我们就不能提前发现一些存在的spring的配置问题\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"我们就聊到这里\",{\"1\":{\"952\":1}}],[\"我们配置了kafka的地址\",{\"1\":{\"990\":1}}],[\"我们配置了kafka的地址和序列化器\",{\"1\":{\"990\":1}}],[\"我们还应该考虑到网络延迟和故障的情况\",{\"1\":{\"970\":1}}],[\"我们还可以根据具体的业务需求进行自定义的\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"我们还可以考虑优化消费者的配置\",{\"1\":{\"982\":1}}],[\"我们还可以通过增加分区数来提高吞吐量\",{\"1\":{\"982\":1}}],[\"我们还可以通过实现\",{\"1\":{\"926\":1}}],[\"我们还可以使用kafka的分区机制来实现消息的负载均衡\",{\"1\":{\"984\":1}}],[\"我们还可以使用kafka的偏移量\",{\"1\":{\"984\":1}}],[\"我们还可以使用kafka的监控工具来实时监测和调整kafka集群的性能\",{\"1\":{\"980\":1}}],[\"我们还可以使用redis的持久化机制来将数据存储到磁盘上\",{\"1\":{\"972\":1}}],[\"我们还可以使用redis的过期时间来自动清理不再使用的键值对\",{\"1\":{\"972\":1}}],[\"我们还可以使用redis的哨兵机制或者使用redis\",{\"1\":{\"968\":1}}],[\"我们还可以使用压缩算法来减少存储在redis中的数据量\",{\"1\":{\"972\":1}}],[\"我们还可以自定义\",{\"1\":{\"952\":1}}],[\"我们删除锁并返回true\",{\"1\":{\"970\":1}}],[\"我们首先检查锁的值是否与传入的值相等\",{\"1\":{\"970\":1}}],[\"我们返回false\",{\"1\":{\"970\":1}}],[\"我们设置锁的过期时间\",{\"1\":{\"970\":1}}],[\"我们使用springboot拦截器实现这样一个功能\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"我们使用setnx命令来尝试获取锁\",{\"1\":{\"970\":1}}],[\"我们使用缓存只要是提高读操作的性能\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"我们使用比较多的数据库是\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"我们使用\",{\"1\":{\"1010\":6}}],[\"我们使用了一个\",{\"1\":{\"924\":1}}],[\"我们来对比一下\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"我们来看一下它是如何工作的\",{\"1\":{\"986\":1}}],[\"我们来看看它的缺点吧\",{\"1\":{\"978\":1}}],[\"我们来看看b\",{\"1\":{\"267\":1}}],[\"我们来一起探索一下吧\",{\"1\":{\"986\":1}}],[\"我们来聊聊泛型\",{\"1\":{\"966\":1}}],[\"我们聊聊吧\",{\"1\":{\"952\":1}}],[\"我们聊一聊类加载过程的双亲委派模型在哪些方面带来的好处\",{\"1\":{\"934\":1}}],[\"我们以更口语的方式探讨下类加载过程\",{\"1\":{\"934\":1}}],[\"我们有一个任务需要分成多个子任务来执行\",{\"1\":{\"932\":1}}],[\"我们有一个位数组bitarray\",{\"1\":{\"333\":1,\"339\":1}}],[\"我们创建了一个\",{\"1\":{\"928\":1}}],[\"我们定义了一个\",{\"1\":{\"924\":1,\"1016\":2}}],[\"我们定义为作用于方法上\",{\"1\":{\"688\":2}}],[\"我们定义为运行时\",{\"1\":{\"688\":2}}],[\"我们进行了广泛而深入的探讨\",{\"1\":{\"922\":1}}],[\"我们拿到需求后\",{\"1\":{\"917\":1}}],[\"我们经常遇到代码从一个分支迁移到另一个分支的需求\",{\"1\":{\"917\":1}}],[\"我们选择\",{\"1\":{\"916\":1}}],[\"我们会在\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"我们会尽快通知你面试结果\",{\"1\":{\"926\":1}}],[\"我们会指定\",{\"1\":{\"844\":1}}],[\"我们会出多个实战课带大家手把手做项目\",{\"1\":{\"211\":1}}],[\"我们一般都会对返回的数据做一个封装\",{\"1\":{\"1431\":1}}],[\"我们一般通过cpa理论分析\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"我们一般使用\",{\"1\":{\"1033\":1}}],[\"我们一般这样\",{\"1\":{\"918\":1}}],[\"我们一般不用动\",{\"1\":{\"844\":1}}],[\"我们一般无法判断是行锁还是临键锁\",{\"1\":{\"556\":1}}],[\"我们作为服务端\",{\"1\":{\"831\":1}}],[\"我们所有的后台代码都通过单元测试啦~~\",{\"1\":{\"830\":1}}],[\"我们都需要统一规范\",{\"1\":{\"1431\":1}}],[\"我们都知道\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"我们都知道计算机在存储数据的时候\",{\"1\":{\"272\":1}}],[\"我们都会定义一个统一的返回格式\",{\"1\":{\"829\":1}}],[\"我们的返回结构这样定义\",{\"1\":{\"1431\":1}}],[\"我们的对话也达到了我的目的\",{\"1\":{\"934\":1}}],[\"我们的演示源代码仓库\",{\"1\":{\"913\":1}}],[\"我们的\",{\"1\":{\"829\":1,\"906\":1}}],[\"我们的系统绝大多不是单机系统\",{\"1\":{\"553\":1}}],[\"我们这里分三层\",{\"1\":{\"815\":1}}],[\"我们这里主要实现入队\",{\"1\":{\"287\":1}}],[\"我们更多的是选择使用spring来管理数据源\",{\"1\":{\"771\":1}}],[\"我们并不知道是哪条错误\",{\"1\":{\"728\":1}}],[\"我们平时在命令行输入的命令总会对应于一个特定的阶段\",{\"1\":{\"712\":1}}],[\"我们平时开发\",{\"1\":{\"90\":1}}],[\"我们开始真正深入的讨论volatile的具体作用\",{\"1\":{\"692\":1}}],[\"我们大多情况要在数毫秒级别就完成\",{\"1\":{\"645\":1}}],[\"我们至少会创建俩个对象\",{\"1\":{\"635\":1}}],[\"我们也可以使用class类的newinstance方法创建对象\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"我们也可以将容器视为\",{\"1\":{\"1057\":1,\"1263\":1}}],[\"我们也可以在创建值的时候设置超时时间\",{\"1\":{\"603\":1}}],[\"我们也可以看出这两个锁的作用\",{\"1\":{\"555\":1}}],[\"我们在使用spring容器的时候\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"我们在分布式系统中\",{\"1\":{\"1033\":1}}],[\"我们在\",{\"1\":{\"1016\":1}}],[\"我们在web包下新建bookcontroller\",{\"1\":{\"831\":1}}],[\"我们在建表时多数情况都会让主键\",{\"1\":{\"559\":1}}],[\"我们在开发的时候\",{\"1\":{\"162\":1}}],[\"我们为\",{\"1\":{\"505\":1}}],[\"我们知道导致死锁有一个因素是阻塞\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"我们知道\",{\"1\":{\"438\":1,\"632\":1}}],[\"我们知道整数的取值范围是从0到10\",{\"1\":{\"359\":1}}],[\"我们想使用任何东西\",{\"1\":{\"401\":1}}],[\"我们下期再见\",{\"1\":{\"408\":1,\"425\":1}}],[\"我们下期见\",{\"1\":{\"388\":1}}],[\"我们下面假设磁盘只有一个盘片和一个磁头\",{\"1\":{\"274\":1}}],[\"我们借助\",{\"1\":{\"342\":1}}],[\"我们需要定义状态的枚举值\",{\"1\":{\"1431\":1}}],[\"我们需要在不同微服务之间共享\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"我们需要让我们的类实现serializable接口\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"我们需要先实现cloneable接口并实现其定义的clone方法\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"我们需要对比俩个对象是否相等\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"我们需要解决缓存并行写\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"我们需要了解一下elasticsearch底层索引文档的过程\",{\"1\":{\"1012\":1}}],[\"我们需要创建一个消费者\",{\"1\":{\"984\":1}}],[\"我们需要一些技巧来提高吞吐量\",{\"1\":{\"982\":1}}],[\"我们需要确保只有持有锁的客户端才能释放锁\",{\"1\":{\"970\":1}}],[\"我们需要确保在业务逻辑执行期间锁不会过期\",{\"1\":{\"970\":1}}],[\"我们需要注意两个主要问题\",{\"1\":{\"970\":1}}],[\"我们需要仔细考虑数据分布\",{\"1\":{\"968\":1}}],[\"我们需要重写\",{\"1\":{\"926\":1}}],[\"我们需要使用其他的同步机制\",{\"1\":{\"924\":1}}],[\"我们需要做到这两点\",{\"1\":{\"348\":1}}],[\"我们需要多少个哈希函数\",{\"1\":{\"339\":1}}],[\"我们需要提供一个接口文档\",{\"1\":{\"175\":1}}],[\"我们继续往下看\",{\"1\":{\"339\":1}}],[\"我们分别取hash对应bitarray中位置的值\",{\"1\":{\"333\":1,\"339\":1}}],[\"我们假设每个url的大小为64b\",{\"1\":{\"330\":1}}],[\"我们把向队列中插入元素的过程称为入队\",{\"1\":{\"287\":1}}],[\"我们把锁加在\",{\"1\":{\"83\":1}}],[\"我们从基础开始问吧\",{\"1\":{\"958\":1}}],[\"我们从\",{\"1\":{\"266\":1}}],[\"我们只需要引入依赖就可以直接使用了\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"我们只需要查找关键词对应的文档编号\",{\"1\":{\"1006\":1}}],[\"我们只需要创建一个\",{\"1\":{\"928\":1}}],[\"我们只需要对尾指针或头指针进行自增操作即可\",{\"1\":{\"288\":1}}],[\"我们只需要用synchronized或者lock就能实现互斥操作\",{\"1\":{\"163\":1}}],[\"我们只记录关键有效的日志\",{\"1\":{\"192\":1}}],[\"我们才能看的更远\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"641\":1,\"698\":1,\"732\":1}}],[\"我们没有必要再使用\",{\"1\":{\"82\":1}}],[\"我们支持\",{\"1\":{\"53\":1,\"59\":1}}],[\"大体分为\",{\"1\":{\"1439\":1}}],[\"大约花费\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"大脑\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"大小是固定的\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"大的账户上的锁\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"大多用于\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"大多是指内存\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"大多数操作系统会将内存使用到文件系统缓存\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"大多数应用都会部署多个节点\",{\"1\":{\"664\":1}}],[\"大多数数据库都自带死锁检测机制\",{\"1\":{\"580\":1}}],[\"大师傅\",{\"1\":{\"994\":1}}],[\"大神\",{\"1\":{\"763\":1}}],[\"大鹏\",{\"1\":{\"757\":1}}],[\"大大简化了开发所需的繁杂配置\",{\"1\":{\"1229\":1,\"1404\":1}}],[\"大大降低数据库压力\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"大大减少停顿\",{\"1\":{\"938\":1}}],[\"大大影响了数据库的性能\",{\"1\":{\"594\":1}}],[\"大大提升性能\",{\"1\":{\"520\":2}}],[\"大薅\",{\"1\":{\"481\":1}}],[\"大概阅读10分钟\",{\"1\":{\"428\":1}}],[\"大概只有220w\",{\"1\":{\"385\":1}}],[\"大顶堆\",{\"1\":{\"364\":1}}],[\"大白话讲解布隆过滤器\",{\"0\":{\"328\":1},\"1\":{\"1202\":1,\"1382\":1}}],[\"大部分自定义注解都使用runtime\",{\"1\":{\"944\":1}}],[\"大部分数据只能存放在磁盘上\",{\"1\":{\"266\":1}}],[\"大部分都免费开源到\",{\"1\":{\"209\":1}}],[\"大于500元\",{\"1\":{\"865\":1}}],[\"大于\",{\"1\":{\"244\":1}}],[\"大于这个值\",{\"1\":{\"106\":1}}],[\"大语言模型\",{\"1\":{\"244\":1}}],[\"大家看到了吧\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"大家看下效果图\",{\"1\":{\"906\":1}}],[\"大家可以用这个来理解学习\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"大家可以根据自己的应用场景来权衡\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"大家可能有些陌生\",{\"1\":{\"658\":1}}],[\"大家爱好相同\",{\"1\":{\"656\":1}}],[\"大家都身处时代洪流中\",{\"1\":{\"640\":1}}],[\"大家都知道我最近在做一套javapub系列面试题\",{\"1\":{\"521\":1}}],[\"大家都叫他王哥\",{\"1\":{\"217\":1}}],[\"大家在面试的时候\",{\"1\":{\"262\":1}}],[\"大家也可以在自己的电脑上安装虚拟机来操作\",{\"1\":{\"90\":1}}],[\"大家好\",{\"1\":{\"76\":1,\"90\":1,\"190\":1,\"398\":1,\"906\":1}}],[\"大学生都会的linux命令v2\",{\"0\":{\"92\":1}}],[\"大学生都会的linux命令\",{\"0\":{\"89\":1}}],[\"大数据\",{\"0\":{\"66\":1},\"1\":{\"223\":1},\"2\":{\"67\":1}}],[\"ognl\",{\"1\":{\"1177\":5,\"1362\":5}}],[\"oop\",{\"1\":{\"1023\":2}}],[\"observer角色减轻了投票的压力\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"observer角色除了不能投票\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"observer\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"observing\",{\"1\":{\"1239\":2,\"1412\":2}}],[\"obtainfreshbeanfactory\",{\"1\":{\"950\":2}}],[\"obj为垃圾\",{\"1\":{\"936\":1}}],[\"obj\",{\"1\":{\"624\":2,\"628\":1,\"936\":3,\"938\":4,\"940\":2,\"966\":11,\"1010\":3,\"1023\":10,\"1084\":4,\"1093\":1,\"1285\":4,\"1294\":1}}],[\"object的同名类并放在classpath中\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"objectinputstream\",{\"1\":{\"1093\":2,\"1294\":2}}],[\"object类中本身就有equals\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"objectmonitor\",{\"1\":{\"1023\":5}}],[\"objectfactory<\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"objectfactory\",{\"1\":{\"954\":2}}],[\"objects\",{\"1\":{\"936\":1,\"1101\":2,\"1299\":2}}],[\"object>>\",{\"1\":{\"654\":1}}],[\"object和value\",{\"1\":{\"602\":1}}],[\"object\",{\"1\":{\"284\":1,\"285\":5,\"286\":3,\"288\":1,\"435\":1,\"449\":1,\"450\":1,\"589\":1,\"602\":2,\"689\":3,\"698\":2,\"770\":4,\"928\":4,\"936\":1,\"938\":2,\"940\":2,\"946\":4,\"952\":2,\"954\":1,\"956\":4,\"958\":2,\"966\":5,\"988\":1,\"1016\":6,\"1023\":2,\"1084\":1,\"1087\":1,\"1092\":6,\"1100\":1,\"1142\":1,\"1177\":1,\"1216\":5,\"1285\":1,\"1288\":1,\"1293\":6,\"1298\":1,\"1333\":1,\"1362\":1,\"1393\":5}}],[\"omgdi\",{\"1\":{\"865\":19}}],[\"omgdi=\",{\"1\":{\"865\":1}}],[\"omgdc\",{\"1\":{\"865\":6}}],[\"omgdc=\",{\"1\":{\"865\":1}}],[\"omg\",{\"1\":{\"865\":4}}],[\"omega^i\",{\"1\":{\"35\":1}}],[\"omega^r\",{\"1\":{\"35\":1}}],[\"omega\",{\"1\":{\"35\":4}}],[\"od\",{\"1\":{\"794\":1,\"795\":3}}],[\"ok\",{\"1\":{\"603\":7,\"866\":1,\"962\":1,\"964\":1,\"966\":1,\"1191\":1,\"1374\":1,\"1431\":1}}],[\"other\",{\"1\":{\"559\":1,\"1101\":1,\"1299\":1}}],[\"otherwise>\",{\"1\":{\"785\":1}}],[\"otherwise\",{\"0\":{\"785\":1},\"1\":{\"526\":1,\"787\":1,\"1177\":1,\"1362\":1}}],[\"oldtab\",{\"1\":{\"922\":2}}],[\"oldcap\",{\"1\":{\"922\":2}}],[\"old\",{\"1\":{\"542\":2,\"940\":1,\"948\":7,\"1151\":3,\"1342\":3}}],[\"ollama轻松打造本地llm应用\",{\"1\":{\"244\":1}}],[\"ollama本地调用大模型\",{\"0\":{\"244\":1}}],[\"ollama官网\",{\"1\":{\"241\":1}}],[\"ollama\",{\"0\":{\"241\":1,\"245\":1},\"1\":{\"238\":1,\"241\":3,\"245\":1,\"246\":1,\"247\":3,\"248\":2,\"251\":2,\"252\":2},\"2\":{\"242\":1,\"243\":1,\"253\":1,\"254\":1}}],[\"o次数\",{\"1\":{\"503\":1,\"508\":1}}],[\"o优化\",{\"1\":{\"503\":1}}],[\"o维度\",{\"1\":{\"499\":1}}],[\"owner\",{\"1\":{\"487\":5,\"488\":7,\"1023\":3}}],[\"overriding\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"override确保你正确重写了方法\",{\"1\":{\"944\":1}}],[\"overrides\",{\"1\":{\"724\":1}}],[\"override\",{\"1\":{\"286\":13,\"754\":5,\"830\":3,\"932\":3,\"950\":1,\"958\":1,\"1044\":1,\"1092\":6,\"1104\":4,\"1105\":2,\"1107\":3,\"1253\":1,\"1293\":6,\"1302\":4,\"1303\":2,\"1305\":3}}],[\"overload\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"overlay=0\",{\"1\":{\"139\":1}}],[\"overlay=w\",{\"1\":{\"139\":2}}],[\"overlay\",{\"1\":{\"139\":1}}],[\"o效率很高\",{\"1\":{\"497\":1}}],[\"o效率\",{\"1\":{\"274\":1}}],[\"o的时间消耗是巨大的\",{\"1\":{\"274\":1}}],[\"o的存取次数\",{\"1\":{\"271\":1}}],[\"o存在机械运动耗费\",{\"1\":{\"274\":1}}],[\"o存取的消耗要高几个数量级\",{\"1\":{\"271\":1}}],[\"o操作中可以读取更多的索引信息\",{\"1\":{\"503\":1}}],[\"o操作\",{\"1\":{\"274\":1,\"497\":1,\"503\":1}}],[\"o操作次数的渐进复杂度\",{\"1\":{\"271\":1}}],[\"o消耗\",{\"1\":{\"271\":1}}],[\"o\",{\"1\":{\"270\":2,\"274\":1,\"348\":1,\"357\":1,\"371\":1,\"372\":1,\"495\":1,\"503\":3,\"606\":1,\"620\":1,\"793\":6,\"794\":4,\"795\":4,\"962\":1,\"966\":2,\"1020\":8,\"1034\":1,\"1092\":2,\"1167\":1,\"1293\":2,\"1355\":1}}],[\"outof\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"outofmemoryerror\",{\"1\":{\"285\":4}}],[\"outcome==\",{\"1\":{\"865\":4}}],[\"out\",{\"1\":{\"145\":4,\"146\":1,\"159\":1,\"282\":1,\"287\":1,\"288\":3,\"289\":3,\"337\":5,\"352\":1,\"360\":1,\"364\":1,\"377\":1,\"388\":3,\"648\":2,\"689\":2,\"692\":3,\"737\":4,\"747\":2,\"757\":2,\"763\":5,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"789\":6,\"790\":2,\"793\":2,\"794\":2,\"795\":3,\"828\":6,\"830\":1,\"928\":2,\"932\":4,\"934\":2,\"944\":1,\"966\":1,\"984\":1,\"990\":1,\"1008\":2,\"1016\":3,\"1020\":3,\"1044\":4,\"1084\":2,\"1085\":2,\"1086\":15,\"1092\":4,\"1104\":9,\"1105\":4,\"1107\":3,\"1127\":1,\"1176\":1,\"1253\":4,\"1285\":2,\"1286\":2,\"1287\":15,\"1293\":4,\"1302\":9,\"1303\":4,\"1305\":3,\"1320\":1,\"1361\":1}}],[\"outfile\",{\"1\":{\"127\":2}}],[\"outputencoding>\",{\"1\":{\"844\":1}}],[\"outputencoding>utf\",{\"1\":{\"844\":1}}],[\"output\",{\"1\":{\"94\":1,\"129\":1,\"131\":2,\"132\":2,\"133\":1,\"134\":3,\"135\":4,\"136\":1,\"138\":1,\"139\":4,\"140\":1}}],[\"osr\",{\"1\":{\"1160\":3,\"1348\":3}}],[\"os\",{\"1\":{\"122\":1}}],[\"osi\",{\"1\":{\"104\":1}}],[\"oracle\",{\"1\":{\"1084\":1,\"1101\":1,\"1285\":1,\"1299\":1}}],[\"oracle可以用\",{\"1\":{\"383\":1}}],[\"orange等\",{\"1\":{\"966\":1}}],[\"orange\",{\"1\":{\"966\":1}}],[\"orm\",{\"1\":{\"958\":1,\"1211\":1,\"1388\":1}}],[\"oriented\",{\"1\":{\"950\":1}}],[\"origin\",{\"1\":{\"406\":1,\"913\":2,\"1136\":1,\"1329\":1}}],[\"originalstream\",{\"1\":{\"146\":1}}],[\"ordinals\",{\"1\":{\"903\":1}}],[\"ord\",{\"1\":{\"903\":2}}],[\"orderly\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"orderaccess\",{\"1\":{\"924\":5}}],[\"orderid\",{\"1\":{\"794\":1,\"795\":1}}],[\"orderdetail类\",{\"1\":{\"795\":1}}],[\"orderdetail\",{\"1\":{\"794\":3,\"795\":6,\"797\":1}}],[\"order类\",{\"1\":{\"794\":1}}],[\"ordermapper\",{\"1\":{\"793\":4,\"794\":1,\"795\":1}}],[\"ordermapper接口\",{\"1\":{\"793\":1}}],[\"orderuserlazyresultmap\",{\"1\":{\"797\":1}}],[\"orderuserdetailitemresultmap\",{\"1\":{\"795\":2}}],[\"orderuserdetailresultmap\",{\"1\":{\"794\":2}}],[\"orderuserresultmap\",{\"1\":{\"793\":2}}],[\"orderuser\",{\"1\":{\"793\":6}}],[\"ordernumber\",{\"1\":{\"792\":1,\"793\":1,\"794\":1}}],[\"ordered\",{\"1\":{\"593\":1}}],[\"order\",{\"1\":{\"377\":6,\"690\":4,\"792\":3,\"793\":11,\"794\":10,\"795\":14,\"797\":1,\"827\":1,\"1192\":1,\"1375\":1}}],[\"org\",{\"1\":{\"122\":1,\"125\":1,\"152\":1,\"194\":2,\"343\":1,\"385\":1,\"388\":3,\"689\":5,\"698\":1,\"701\":1,\"705\":1,\"715\":8,\"739\":1,\"743\":2,\"744\":2,\"745\":2,\"747\":4,\"754\":1,\"755\":2,\"757\":6,\"762\":4,\"763\":8,\"766\":1,\"770\":1,\"772\":6,\"779\":3,\"782\":2,\"789\":6,\"790\":4,\"800\":1,\"812\":5,\"815\":9,\"817\":2,\"818\":11,\"819\":12,\"820\":4,\"826\":2,\"827\":4,\"828\":7,\"830\":7,\"831\":6,\"844\":4,\"849\":3,\"865\":10,\"876\":2,\"904\":1,\"958\":1,\"984\":5,\"990\":4,\"1093\":1,\"1232\":2,\"1294\":1,\"1407\":2,\"1444\":1}}],[\"or\",{\"0\":{\"528\":1},\"1\":{\"112\":1,\"388\":2,\"501\":3,\"526\":1,\"527\":1,\"528\":1,\"727\":1,\"766\":1,\"837\":2,\"886\":1,\"1023\":2,\"1192\":1,\"1216\":2,\"1375\":1,\"1393\":2}}],[\"ofmillis\",{\"1\":{\"990\":1}}],[\"of源代码和动态的思考过程增加了解释的轻松和趣味性\",{\"1\":{\"934\":1}}],[\"oftype\",{\"1\":{\"797\":1}}],[\"oftype=\",{\"1\":{\"794\":1,\"795\":1,\"797\":1}}],[\"of\",{\"1\":{\"106\":1,\"112\":1,\"143\":2,\"152\":3,\"353\":1,\"419\":1,\"824\":2,\"934\":1,\"950\":2,\"954\":1,\"1071\":1,\"1072\":1,\"1101\":4,\"1212\":1,\"1213\":1,\"1216\":1,\"1275\":1,\"1276\":1,\"1299\":4,\"1389\":1,\"1390\":1,\"1393\":1}}],[\"offset\",{\"1\":{\"607\":1,\"658\":1,\"826\":3,\"827\":1,\"984\":1,\"1023\":19,\"1069\":1,\"1157\":1,\"1161\":2,\"1273\":1,\"1345\":1,\"1349\":2}}],[\"offsets\",{\"1\":{\"433\":1,\"440\":3}}],[\"offects\",{\"1\":{\"433\":1}}],[\"offer\",{\"1\":{\"100\":1,\"1039\":1}}],[\"off\",{\"1\":{\"106\":3}}],[\"o处理速度\",{\"1\":{\"106\":1}}],[\"ocean\",{\"1\":{\"589\":1}}],[\"octet\",{\"1\":{\"106\":1}}],[\"ocw\",{\"1\":{\"71\":1}}],[\"once\",{\"1\":{\"887\":1}}],[\"only\",{\"0\":{\"588\":1},\"1\":{\"487\":1,\"488\":1,\"940\":1,\"962\":2,\"1201\":1,\"1381\":1}}],[\"only设置为on\",{\"1\":{\"106\":1}}],[\"one\",{\"1\":{\"106\":1,\"887\":1,\"1078\":1,\"1282\":1}}],[\"on\",{\"1\":{\"106\":17,\"505\":2,\"526\":1,\"648\":2,\"793\":2,\"794\":2,\"795\":3,\"820\":2,\"824\":1,\"827\":1,\"952\":1,\"962\":1,\"1020\":1,\"1060\":2,\"1101\":1,\"1128\":1,\"1266\":2,\"1299\":1,\"1321\":1}}],[\"op\",{\"1\":{\"1020\":2}}],[\"operator\",{\"1\":{\"436\":1}}],[\"openssl\",{\"1\":{\"899\":1}}],[\"opensession\",{\"1\":{\"747\":2,\"757\":1,\"763\":1,\"790\":1}}],[\"opencv\",{\"1\":{\"896\":2,\"898\":1}}],[\"opentsdb等\",{\"1\":{\"884\":1}}],[\"opening\",{\"1\":{\"789\":3,\"790\":1}}],[\"open=\",{\"1\":{\"724\":1,\"787\":1}}],[\"open\",{\"1\":{\"106\":10,\"152\":1,\"251\":6,\"252\":2,\"614\":1,\"787\":1,\"962\":1,\"1008\":1,\"1020\":2}}],[\"opened\",{\"1\":{\"106\":1}}],[\"opts\",{\"1\":{\"702\":1}}],[\"optional>\",{\"1\":{\"708\":1,\"709\":1}}],[\"options\",{\"0\":{\"433\":1},\"1\":{\"127\":3,\"406\":1,\"433\":2,\"440\":1}}],[\"optimistic\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"optimization\",{\"1\":{\"527\":3,\"548\":1}}],[\"optimize\",{\"1\":{\"511\":4}}],[\"optimalnumofhashfunctions\",{\"1\":{\"340\":1}}],[\"optimalnumofbits\",{\"1\":{\"340\":1}}],[\"opt\",{\"1\":{\"94\":2}}],[\"ojq9fmnpu\",{\"1\":{\"71\":1}}],[\"原数据不放到rollback\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"原型设计\",{\"1\":{\"1439\":1}}],[\"原型\",{\"1\":{\"952\":1,\"1219\":1,\"1396\":1,\"1439\":1}}],[\"原来如此\",{\"1\":{\"940\":1,\"956\":1,\"966\":1,\"994\":1}}],[\"原来jvm已经把这事儿都帮我干了\",{\"1\":{\"934\":1}}],[\"原有的hash值都需要重新计算\",{\"1\":{\"922\":1}}],[\"原子操作\",{\"1\":{\"664\":1}}],[\"原子递增\",{\"1\":{\"603\":1}}],[\"原子\",{\"1\":{\"593\":1}}],[\"原子性\",{\"1\":{\"553\":1}}],[\"原理又是什么\",{\"1\":{\"952\":1}}],[\"原理\",{\"0\":{\"349\":1,\"373\":1},\"1\":{\"770\":1}}],[\"原理介绍\",{\"0\":{\"333\":1},\"1\":{\"339\":1}}],[\"原因如下\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"原因和前面说的类型擦除有关\",{\"1\":{\"966\":1}}],[\"原因\",{\"1\":{\"759\":1,\"1073\":1,\"1277\":1}}],[\"原因为\",{\"1\":{\"286\":1}}],[\"原因当数据量非常大时\",{\"1\":{\"266\":1}}],[\"原文地址\",{\"1\":{\"1431\":1,\"1439\":1,\"1444\":1}}],[\"原文\",{\"1\":{\"71\":1,\"147\":1,\"252\":1,\"664\":1,\"675\":1}}],[\"原创\",{\"1\":{\"49\":1}}],[\"技术选型\",{\"1\":{\"1439\":2}}],[\"技术人的成长记录\",{\"1\":{\"1026\":1,\"1030\":1,\"1056\":1,\"1126\":1,\"1141\":1,\"1155\":1,\"1171\":1,\"1210\":1,\"1223\":1,\"1236\":1}}],[\"技术人员走的最远的\",{\"1\":{\"922\":1}}],[\"技术生涯也会更上一层楼\",{\"1\":{\"948\":1}}],[\"技术来为每个线程分配一块私有的内存缓冲区\",{\"1\":{\"930\":1}}],[\"技术也不错\",{\"1\":{\"922\":1}}],[\"技术还会更上一层楼\",{\"1\":{\"922\":1}}],[\"技术实现的内存回收机制\",{\"1\":{\"635\":1}}],[\"技术自媒体\",{\"1\":{\"195\":1}}],[\"技术和业务角度看区块链\",{\"1\":{\"68\":1,\"478\":1}}],[\"技术书籍\",{\"0\":{\"9\":1}}],[\"绘画\",{\"1\":{\"64\":1}}],[\"a和bean\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"a和b相互引用\",{\"1\":{\"936\":1}}],[\"a线程在通过迭代器遍历一个\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"aof重写机制我现在全明白了\",{\"1\":{\"962\":1}}],[\"aof重写的基本流程是\",{\"1\":{\"962\":1}}],[\"aof重写的机制原理能详细说下么\",{\"1\":{\"962\":1}}],[\"aof重写也采用fork方式进行\",{\"1\":{\"962\":1}}],[\"aof的优点是每次修改都会同步到磁盘\",{\"1\":{\"962\":1}}],[\"aof文件就是一个命令的记录\",{\"1\":{\"962\":1}}],[\"aof\",{\"1\":{\"962\":4,\"1201\":1,\"1381\":1}}],[\"aop是通过动态代理实现的\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"aop里面的几个名词的概念\",{\"0\":{\"1217\":1,\"1394\":1}}],[\"aop举例说明\",{\"0\":{\"1212\":1,\"1389\":1}}],[\"aop模块是spring的aop库\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"aop中\",{\"1\":{\"1217\":2,\"1394\":2}}],[\"aop中最重要的注解有\",{\"1\":{\"944\":1}}],[\"aop中的注解呢\",{\"1\":{\"944\":1}}],[\"aop中有大量使用\",{\"1\":{\"682\":1}}],[\"aop\",{\"1\":{\"689\":1,\"950\":6,\"952\":2,\"954\":1,\"1016\":2,\"1211\":1,\"1388\":1},\"2\":{\"691\":1}}],[\"aop切点类\",{\"0\":{\"689\":1}}],[\"aop<\",{\"1\":{\"687\":1,\"1092\":1,\"1293\":1}}],[\"aqs\",{\"1\":{\"932\":12}}],[\"await\",{\"1\":{\"932\":4,\"1104\":3,\"1302\":3}}],[\"awk\",{\"0\":{\"93\":1},\"1\":{\"94\":4}}],[\"a^\",{\"1\":{\"917\":1}}],[\"azk8s\",{\"1\":{\"852\":1}}],[\"a>\",{\"1\":{\"832\":1}}],[\"ajax\",{\"1\":{\"831\":1,\"1136\":1,\"1329\":1}}],[\"attributes\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"atomicity\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"atomicinteger\",{\"1\":{\"1018\":2}}],[\"atomicreplacefile\",{\"1\":{\"962\":1}}],[\"atomic\",{\"1\":{\"924\":10,\"1243\":1,\"1416\":1}}],[\"at\",{\"1\":{\"762\":4}}],[\"a项目依赖于log4j\",{\"1\":{\"708\":1}}],[\"advice\",{\"1\":{\"1217\":3,\"1394\":3}}],[\"advice通知\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"adminclient\",{\"1\":{\"982\":1}}],[\"admin\",{\"1\":{\"888\":2,\"1232\":1,\"1407\":1,\"1444\":1}}],[\"adlist\",{\"1\":{\"621\":1}}],[\"addpathpatterns\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"addinterceptor\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"addinterceptors\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"addifnotexist\",{\"1\":{\"337\":2}}],[\"addlistener\",{\"1\":{\"1034\":1}}],[\"adddocument\",{\"1\":{\"1004\":1}}],[\"addtorememberedsets\",{\"1\":{\"940\":1}}],[\"addtomarked\",{\"1\":{\"936\":1}}],[\"addentry\",{\"1\":{\"948\":1}}],[\"added\",{\"1\":{\"887\":1}}],[\"addelements\",{\"1\":{\"286\":3}}],[\"addelem\",{\"1\":{\"284\":1,\"285\":3,\"286\":3}}],[\"addattribute\",{\"1\":{\"831\":2}}],[\"addall\",{\"1\":{\"284\":1,\"285\":2,\"286\":2,\"353\":1}}],[\"addobject\",{\"1\":{\"831\":1,\"832\":1}}],[\"addnodeiterator\",{\"1\":{\"286\":3}}],[\"addnodeheader\",{\"1\":{\"286\":4}}],[\"addnode\",{\"1\":{\"286\":7}}],[\"addreplyerror\",{\"1\":{\"964\":1}}],[\"addrememberedsetentry\",{\"1\":{\"940\":1}}],[\"address\",{\"1\":{\"487\":3,\"488\":4}}],[\"addr\",{\"1\":{\"106\":4,\"648\":2}}],[\"addr与$http\",{\"1\":{\"106\":1}}],[\"add拿到的ip地址是反向代理服务器的ip地址\",{\"1\":{\"106\":1}}],[\"add\",{\"1\":{\"94\":1,\"106\":2,\"109\":1,\"251\":1,\"337\":3,\"353\":1,\"507\":1,\"526\":1,\"589\":1,\"852\":1,\"866\":1,\"913\":2,\"915\":1,\"918\":4,\"946\":1,\"966\":3,\"982\":3,\"1004\":2}}],[\"age=20\",{\"1\":{\"789\":6,\"790\":2}}],[\"age=22\",{\"1\":{\"759\":1}}],[\"age\",{\"1\":{\"439\":1,\"501\":1,\"505\":5,\"736\":3,\"737\":1,\"747\":5,\"755\":6,\"759\":2,\"763\":4,\"782\":2,\"785\":6,\"786\":8,\"793\":1,\"960\":1,\"1431\":1,\"1444\":6}}],[\"agent\",{\"1\":{\"106\":2,\"183\":1}}],[\"a3\",{\"1\":{\"266\":2}}],[\"amend\",{\"1\":{\"918\":1}}],[\"amd64\",{\"1\":{\"898\":1}}],[\"amp\",{\"1\":{\"743\":2}}],[\"amount\",{\"1\":{\"487\":4,\"488\":4}}],[\"am\",{\"1\":{\"201\":1}}],[\"a8e65c040d47\",{\"1\":{\"181\":1}}],[\"a=b\",{\"1\":{\"157\":1}}],[\"aftercompletion\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"afterpropertiesset\",{\"1\":{\"952\":6}}],[\"afterexecute\",{\"1\":{\"926\":1}}],[\"afterthrowing\",{\"1\":{\"689\":2,\"944\":1}}],[\"afterreturning\",{\"1\":{\"689\":2,\"944\":1}}],[\"after\",{\"1\":{\"152\":1,\"603\":1,\"689\":3,\"944\":1,\"1016\":1,\"1217\":3,\"1394\":3}}],[\"a是\",{\"1\":{\"145\":1}}],[\"aac\",{\"1\":{\"132\":3,\"145\":5}}],[\"acl\",{\"1\":{\"1008\":1}}],[\"acks\",{\"1\":{\"1163\":6,\"1351\":6}}],[\"ack\",{\"1\":{\"994\":2}}],[\"acquired\",{\"1\":{\"1023\":1}}],[\"acquire\",{\"1\":{\"932\":1,\"970\":1,\"1023\":1}}],[\"acquireretryattempts\",{\"1\":{\"815\":1}}],[\"actually\",{\"1\":{\"950\":1}}],[\"actuator\",{\"1\":{\"885\":1,\"887\":1,\"1231\":1,\"1406\":1}}],[\"actuator<\",{\"1\":{\"885\":1}}],[\"active\",{\"1\":{\"958\":1}}],[\"activiti会对数据库中所有表进行更新操作\",{\"1\":{\"864\":1}}],[\"activiti在启动时\",{\"1\":{\"864\":1}}],[\"activate\",{\"1\":{\"864\":1}}],[\"acid\",{\"1\":{\"553\":1,\"1187\":1,\"1370\":1}}],[\"ac37\",{\"1\":{\"181\":1}}],[\"according\",{\"1\":{\"887\":1}}],[\"acc是一种常见默认视频\",{\"1\":{\"132\":1}}],[\"acc\",{\"1\":{\"132\":1}}],[\"acceptor\",{\"1\":{\"1243\":4,\"1416\":4}}],[\"accept\",{\"1\":{\"106\":1,\"183\":3,\"831\":1,\"1020\":2}}],[\"accessed\",{\"1\":{\"112\":1}}],[\"access\",{\"1\":{\"106\":8}}],[\"acodec\",{\"1\":{\"127\":1,\"129\":1,\"132\":2,\"145\":1}}],[\"ac\",{\"1\":{\"127\":1}}],[\"ar=isr+osr\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"ar又代表什么\",{\"0\":{\"1156\":1,\"1344\":1}}],[\"arbitrary\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"arg\",{\"1\":{\"932\":2,\"1219\":6,\"1396\":6}}],[\"args\",{\"1\":{\"288\":1,\"289\":1,\"337\":1,\"352\":1,\"364\":1,\"377\":1,\"388\":1,\"692\":2,\"737\":1,\"747\":1,\"770\":1,\"928\":1,\"932\":2,\"984\":1,\"990\":1,\"1008\":1,\"1016\":3,\"1020\":1,\"1085\":1,\"1086\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1286\":1,\"1287\":1,\"1302\":2,\"1303\":1,\"1305\":1}}],[\"architecture\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"archive\",{\"1\":{\"94\":2,\"413\":1,\"919\":1}}],[\"archetype\",{\"1\":{\"703\":4,\"704\":4}}],[\"around\",{\"1\":{\"689\":4,\"944\":1,\"1092\":1,\"1293\":1}}],[\"artifact\",{\"1\":{\"812\":1,\"838\":1,\"839\":1}}],[\"artifactid\",{\"1\":{\"705\":2}}],[\"artifactid>\",{\"1\":{\"648\":1,\"687\":1,\"708\":2,\"709\":4,\"710\":3,\"715\":9,\"735\":1,\"742\":1,\"756\":1,\"812\":25,\"844\":6,\"862\":3,\"874\":2,\"885\":3,\"1092\":1,\"1293\":1,\"1444\":2}}],[\"articles\",{\"1\":{\"507\":2,\"1212\":1,\"1389\":1}}],[\"article\",{\"1\":{\"232\":1,\"251\":2,\"275\":1,\"388\":1,\"394\":2,\"425\":1,\"520\":1,\"655\":1,\"675\":1,\"917\":1,\"919\":2,\"1030\":1}}],[\"arrindex++\",{\"1\":{\"352\":1}}],[\"arrindex\",{\"1\":{\"352\":1}}],[\"arrappend\",{\"1\":{\"352\":2}}],[\"array\",{\"1\":{\"352\":2,\"353\":1,\"360\":8,\"1020\":1,\"1085\":1,\"1286\":1}}],[\"arraycopy是调用native方法\",{\"1\":{\"285\":1}}],[\"arraycopy\",{\"1\":{\"285\":3}}],[\"arrays\",{\"1\":{\"285\":2,\"352\":6,\"360\":1,\"364\":3,\"377\":2,\"689\":2}}],[\"arraylist每次扩容的大小为原来的1\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"arraylist的底层是数组\",{\"1\":{\"1117\":1,\"1119\":1,\"1312\":1,\"1314\":1}}],[\"arraylist的源码分析得也比较到位\",{\"1\":{\"946\":1}}],[\"arraylist线程安全吗\",{\"1\":{\"988\":1}}],[\"arraylist底层采用动态数组实现\",{\"1\":{\"946\":1}}],[\"arraylist<map\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"arraylist<integer>\",{\"1\":{\"946\":1}}],[\"arraylist<>\",{\"1\":{\"285\":1,\"286\":1,\"946\":1,\"982\":1,\"1004\":2}}],[\"arraylist<e>\",{\"1\":{\"285\":1,\"946\":1}}],[\"arraylist\",{\"0\":{\"1117\":1,\"1312\":1},\"1\":{\"285\":3,\"353\":2,\"946\":3,\"988\":4,\"1112\":1,\"1119\":5,\"1307\":1,\"1314\":5}}],[\"arr\",{\"1\":{\"352\":31,\"364\":32}}],[\"area\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"are\",{\"1\":{\"152\":2,\"157\":1,\"526\":1,\"779\":2,\"821\":1}}],[\"ar\",{\"1\":{\"127\":1,\"1156\":1,\"1157\":1,\"1160\":2,\"1344\":1,\"1345\":1,\"1348\":2}}],[\"also\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"algorithm\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"alerting\",{\"1\":{\"887\":1}}],[\"alertmanagers\",{\"1\":{\"887\":1}}],[\"alertmanager\",{\"1\":{\"887\":2}}],[\"aliyuncs\",{\"1\":{\"1444\":1}}],[\"aliyun\",{\"1\":{\"837\":1,\"838\":1,\"873\":1,\"885\":1}}],[\"aliases\",{\"1\":{\"1444\":1}}],[\"alias=\",{\"1\":{\"768\":2}}],[\"alias\",{\"1\":{\"106\":2,\"768\":1}}],[\"alter\",{\"1\":{\"507\":2,\"511\":3}}],[\"already\",{\"1\":{\"487\":1,\"488\":1,\"1216\":1,\"1393\":1}}],[\"always\",{\"1\":{\"251\":1}}],[\"allocate\",{\"1\":{\"1020\":1,\"1099\":2,\"1297\":2}}],[\"allocation\",{\"1\":{\"930\":1}}],[\"allowpublickeyretrieval=true\",{\"1\":{\"1444\":1}}],[\"allowearlyreference\",{\"1\":{\"1216\":3,\"1393\":3}}],[\"allows\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"allowmultiqueries=true\",{\"1\":{\"743\":1}}],[\"allow\",{\"1\":{\"406\":2,\"950\":1,\"954\":1}}],[\"allkeys\",{\"1\":{\"636\":1}}],[\"all字段中\",{\"1\":{\"440\":1}}],[\"all字段解读\",{\"1\":{\"394\":1}}],[\"all的作用\",{\"1\":{\"436\":1}}],[\"all在7\",{\"1\":{\"436\":1}}],[\"all\",{\"0\":{\"435\":1},\"1\":{\"106\":1,\"440\":1,\"528\":1,\"932\":4,\"1078\":1,\"1101\":1,\"1163\":1,\"1282\":1,\"1299\":1,\"1351\":1}}],[\"anno\",{\"1\":{\"944\":3}}],[\"annotationattributes\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"annotationmetadata\",{\"1\":{\"1228\":3,\"1403\":3}}],[\"annotation方式可以指定被哪些注解修饰的代码进行拦截\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"annotation表示这个切点切到一个注解上\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"annotation包中可以找到\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"annotation等\",{\"1\":{\"944\":1}}],[\"annotations\",{\"1\":{\"826\":2}}],[\"annotation\",{\"1\":{\"681\":1,\"686\":1,\"688\":3,\"689\":6,\"690\":1,\"818\":1,\"819\":1,\"828\":2,\"830\":3,\"831\":2,\"849\":3,\"876\":1,\"1092\":2,\"1293\":2},\"2\":{\"691\":1}}],[\"any\",{\"1\":{\"887\":1,\"1101\":1,\"1299\":1}}],[\"anyhow\",{\"1\":{\"153\":1}}],[\"anotationmethodhandleradapter\",{\"1\":{\"819\":1}}],[\"another\",{\"1\":{\"106\":2,\"1023\":1}}],[\"answer\",{\"1\":{\"457\":4}}],[\"analyzed字段不能使用\",{\"1\":{\"440\":1}}],[\"analyzed字段\",{\"1\":{\"440\":1}}],[\"analyze\",{\"1\":{\"437\":3}}],[\"analyzer\",{\"0\":{\"437\":1},\"1\":{\"411\":7,\"437\":2,\"440\":4,\"443\":1}}],[\"analysis\",{\"1\":{\"412\":2,\"413\":1}}],[\"anxn+1\",{\"1\":{\"266\":1}}],[\"an+1\",{\"1\":{\"266\":1}}],[\"an\",{\"1\":{\"127\":1,\"133\":1,\"136\":1,\"266\":2,\"457\":1,\"526\":2,\"614\":1,\"1101\":2,\"1216\":1,\"1299\":2,\"1393\":1}}],[\"anull\",{\"1\":{\"106\":1}}],[\"android\",{\"1\":{\"950\":3}}],[\"andt1\",{\"1\":{\"801\":1}}],[\"and\",{\"1\":{\"106\":1,\"112\":1,\"152\":6,\"193\":1,\"198\":2,\"201\":2,\"436\":1,\"505\":1,\"506\":1,\"511\":1,\"526\":1,\"529\":1,\"556\":1,\"558\":2,\"562\":1,\"573\":1,\"579\":1,\"614\":1,\"763\":1,\"779\":4,\"784\":2,\"785\":4,\"786\":3,\"800\":8,\"801\":5,\"827\":2,\"887\":1,\"936\":1,\"940\":1,\"958\":1,\"964\":1,\"1018\":1,\"1101\":1,\"1105\":2,\"1216\":1,\"1299\":1,\"1303\":2,\"1393\":1}}],[\"apring\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"append|o\",{\"1\":{\"962\":1}}],[\"append\",{\"1\":{\"962\":2,\"1092\":1,\"1201\":1,\"1293\":1,\"1381\":1}}],[\"appender>\",{\"1\":{\"821\":1}}],[\"applicaton\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"applicationcontext还能以声明的方式创建\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"applicationcontext启动后预载入所有的单实例bean\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"applicationcontext\",{\"1\":{\"1218\":2,\"1226\":1,\"1230\":1,\"1395\":2,\"1401\":1,\"1405\":1}}],[\"applicationcontext接口作为beanfactory的子类\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"applications\",{\"1\":{\"152\":4}}],[\"application\",{\"1\":{\"106\":1,\"183\":1,\"406\":1,\"436\":3,\"831\":2,\"1092\":1,\"1127\":1,\"1133\":1,\"1226\":1,\"1293\":1,\"1320\":1,\"1326\":1,\"1401\":1,\"1444\":1}}],[\"apple就是实际类型参数\",{\"1\":{\"966\":1}}],[\"apple\",{\"1\":{\"966\":7}}],[\"applybeanpostprocessorsafterinstantiation\",{\"1\":{\"954\":1}}],[\"apply\",{\"1\":{\"866\":1,\"916\":5}}],[\"appointexception\",{\"1\":{\"829\":4,\"830\":2}}],[\"appointexecution\",{\"1\":{\"829\":6,\"830\":10,\"831\":6}}],[\"appointstateenum\",{\"1\":{\"829\":9,\"830\":5,\"831\":4}}],[\"appointtime\",{\"1\":{\"825\":1}}],[\"appoint\",{\"1\":{\"824\":1,\"827\":1,\"829\":1,\"830\":6,\"831\":8}}],[\"appointmentdaotest\",{\"1\":{\"828\":3}}],[\"appointmentdao\",{\"1\":{\"826\":2,\"827\":3,\"828\":4,\"830\":5}}],[\"appointment\",{\"1\":{\"824\":3,\"825\":3,\"826\":3,\"827\":3,\"828\":5,\"829\":7,\"830\":4}}],[\"app>\",{\"1\":{\"820\":1}}],[\"app\",{\"1\":{\"251\":1,\"659\":1,\"820\":2,\"850\":2,\"934\":2}}],[\"apiresponse<>\",{\"1\":{\"1431\":3}}],[\"apiresponse<t>\",{\"1\":{\"1431\":1}}],[\"apiresponse\",{\"1\":{\"1431\":3}}],[\"apifather\",{\"1\":{\"1431\":1}}],[\"api我会单独写一个代码案例做讲解\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"api和分布式特性\",{\"1\":{\"1000\":1}}],[\"api<\",{\"1\":{\"812\":1}}],[\"api管理swagger\",{\"1\":{\"394\":1}}],[\"apikey\",{\"1\":{\"183\":1}}],[\"api\",{\"1\":{\"177\":2,\"181\":3,\"249\":2,\"251\":1,\"252\":1,\"284\":1,\"400\":1,\"438\":1,\"613\":1,\"706\":1,\"1032\":3,\"1034\":1,\"1068\":1,\"1272\":1,\"1431\":1}}],[\"apache\",{\"1\":{\"106\":2,\"152\":1,\"157\":1,\"388\":3,\"400\":1,\"698\":1,\"701\":2,\"702\":1,\"709\":1,\"710\":1,\"715\":6,\"747\":4,\"754\":1,\"757\":4,\"762\":4,\"763\":4,\"779\":3,\"789\":6,\"790\":4,\"812\":4,\"826\":2,\"844\":4,\"984\":5,\"990\":4,\"1444\":1}}],[\"audio的缩与\",{\"1\":{\"145\":1}}],[\"autoconfigure\",{\"1\":{\"1232\":2,\"1407\":2}}],[\"autoconfiguration\",{\"1\":{\"1232\":3,\"1407\":3}}],[\"autocommitonclose\",{\"1\":{\"815\":1}}],[\"autoboxing\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"autowired就是运行期读取的\",{\"1\":{\"944\":1}}],[\"autowired\",{\"1\":{\"828\":4,\"830\":5,\"831\":2,\"944\":3}}],[\"automapping\",{\"1\":{\"793\":1,\"794\":1}}],[\"automapping=\",{\"1\":{\"793\":2,\"794\":3,\"795\":4,\"797\":2}}],[\"auto\",{\"1\":{\"383\":1,\"507\":1,\"559\":5,\"575\":1,\"726\":2,\"792\":2,\"795\":4,\"824\":2,\"885\":1,\"1107\":3,\"1305\":3}}],[\"autoindex\",{\"1\":{\"106\":1}}],[\"authormapper\",{\"1\":{\"772\":2}}],[\"author\",{\"1\":{\"288\":1,\"289\":1,\"337\":1,\"352\":1,\"377\":1,\"688\":1,\"689\":1,\"737\":1,\"825\":2,\"826\":2,\"828\":3,\"829\":5,\"830\":4,\"831\":1,\"849\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1175\":1,\"1302\":2,\"1303\":1,\"1305\":1,\"1360\":1}}],[\"authorization\",{\"1\":{\"183\":2,\"406\":1}}],[\"auth\",{\"1\":{\"106\":2,\"964\":1}}],[\"aux\",{\"1\":{\"94\":1}}],[\"avoid\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"available\",{\"1\":{\"779\":2}}],[\"availability\",{\"1\":{\"601\":1,\"1078\":2,\"1240\":1,\"1282\":1,\"1413\":1}}],[\"avl\",{\"1\":{\"266\":2}}],[\"av1903594994\",{\"1\":{\"251\":1}}],[\"avfoundation\",{\"1\":{\"145\":7,\"146\":1}}],[\"avi文件转为mp4\",{\"1\":{\"131\":1}}],[\"avi\",{\"1\":{\"131\":1}}],[\"av\",{\"1\":{\"94\":1}}],[\"aba\",{\"1\":{\"1018\":2}}],[\"abstract\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"abstractautowirecapablebeanfactory\",{\"1\":{\"952\":2,\"954\":1}}],[\"abstractapplicationcontext\",{\"1\":{\"950\":2}}],[\"abstractxmlapplicationcontext\",{\"1\":{\"950\":1}}],[\"abstractlist<e>\",{\"1\":{\"946\":1}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"932\":3}}],[\"abortpolicy\",{\"1\":{\"926\":2}}],[\"above\",{\"1\":{\"440\":3}}],[\"abc\",{\"1\":{\"530\":2,\"532\":2,\"597\":1,\"1192\":1,\"1375\":1}}],[\"ab\",{\"1\":{\"94\":1}}],[\"a2\",{\"1\":{\"94\":1,\"266\":2}}],[\"a1\",{\"1\":{\"94\":1,\"266\":2}}],[\"a\",{\"1\":{\"90\":1,\"94\":1,\"112\":3,\"145\":5,\"146\":1,\"152\":4,\"252\":1,\"288\":2,\"339\":1,\"353\":1,\"364\":2,\"411\":1,\"420\":1,\"457\":1,\"498\":2,\"526\":1,\"535\":2,\"603\":2,\"604\":2,\"614\":1,\"635\":1,\"707\":3,\"827\":7,\"887\":2,\"917\":8,\"924\":1,\"934\":2,\"936\":4,\"950\":2,\"952\":2,\"954\":2,\"966\":2,\"1018\":2,\"1068\":1,\"1078\":2,\"1088\":1,\"1101\":3,\"1104\":14,\"1188\":4,\"1212\":1,\"1214\":2,\"1216\":2,\"1218\":1,\"1220\":1,\"1272\":1,\"1282\":1,\"1289\":1,\"1299\":3,\"1302\":14,\"1371\":4,\"1389\":1,\"1391\":2,\"1393\":2,\"1395\":1,\"1397\":1,\"1439\":2}}],[\"aio\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"airdrop\",{\"1\":{\"487\":3,\"488\":3}}],[\"airdropcontract\",{\"1\":{\"487\":1,\"488\":1}}],[\"ai\",{\"1\":{\"64\":1,\"211\":1,\"252\":1,\"559\":1},\"2\":{\"230\":1,\"231\":1,\"233\":1,\"234\":1,\"236\":1,\"237\":1,\"239\":1,\"240\":1,\"242\":1,\"243\":1,\"253\":1,\"254\":1}}],[\"aspirant\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"aspect切面可以看成\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"aspects<\",{\"1\":{\"715\":1}}],[\"aspectj\",{\"1\":{\"689\":4,\"1217\":1,\"1394\":1}}],[\"aspect\",{\"1\":{\"127\":1,\"689\":3,\"944\":1,\"950\":1,\"1092\":1,\"1217\":1,\"1293\":1,\"1394\":1}}],[\"asm\",{\"1\":{\"924\":7}}],[\"async\",{\"1\":{\"864\":1,\"1078\":1,\"1282\":1}}],[\"assignee=\",{\"1\":{\"865\":1}}],[\"assigned\",{\"1\":{\"821\":1,\"1156\":1,\"1344\":1}}],[\"association>\",{\"1\":{\"793\":1,\"794\":1,\"795\":2,\"797\":1}}],[\"association\",{\"1\":{\"793\":1,\"794\":1}}],[\"as碎片化百分比\",{\"1\":{\"511\":1}}],[\"as\",{\"1\":{\"43\":1,\"152\":2,\"614\":1,\"755\":9,\"759\":9,\"795\":1,\"887\":1,\"1101\":1,\"1299\":1}}],[\"功能设计\",{\"1\":{\"1439\":1}}],[\"功能上将过期时间存在\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"功能和\",{\"1\":{\"954\":1}}],[\"功能搭建网站\",{\"1\":{\"913\":1}}],[\"功能稳定的系统提供给用户\",{\"1\":{\"154\":1}}],[\"功能详情\",{\"1\":{\"55\":1,\"61\":1}}],[\"功能\",{\"0\":{\"52\":1,\"58\":1},\"1\":{\"53\":1,\"59\":1,\"912\":1,\"950\":1,\"1439\":1}}],[\"功能亮点\",{\"0\":{\"15\":1}}],[\"分为自测和提测\",{\"1\":{\"1439\":1}}],[\"分为一主一从或一主多从\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"分针和秒\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"分数\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"分数从高到低排序\",{\"1\":{\"607\":1}}],[\"分数从高到低\",{\"1\":{\"607\":1}}],[\"分代算法\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"分代\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"分代回收\",{\"1\":{\"940\":1}}],[\"分钟\",{\"1\":{\"1047\":1,\"1071\":1,\"1256\":1,\"1275\":1}}],[\"分担服务器压力\",{\"1\":{\"964\":1}}],[\"分担出错概率\",{\"1\":{\"728\":1}}],[\"分模块避免\",{\"1\":{\"954\":1}}],[\"分值\",{\"1\":{\"628\":1}}],[\"分割线\",{\"1\":{\"624\":1}}],[\"分场合可以对关系数据库起到很好的补充作用\",{\"1\":{\"589\":1}}],[\"分到多个同一个数据库的多张表中\",{\"1\":{\"520\":1}}],[\"分到多个不同的库\",{\"1\":{\"520\":1}}],[\"分别有哨兵集群与redis的主从集群\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"分别有什么作用\",{\"0\":{\"1034\":1}}],[\"分别用于保证读操作\",{\"1\":{\"924\":1}}],[\"分别对应上面两个dao接口\",{\"1\":{\"827\":1}}],[\"分别是快照方式\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"分别是0~6\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"分别是什么\",{\"1\":{\"956\":1}}],[\"分别是\",{\"1\":{\"926\":1,\"1006\":1,\"1239\":1,\"1412\":1}}],[\"分别是无库存异常\",{\"1\":{\"829\":1}}],[\"分别是dao\",{\"1\":{\"815\":1}}],[\"分别是顺序表和链表\",{\"1\":{\"282\":1}}],[\"分别存放在不同的库\",{\"1\":{\"520\":1}}],[\"分出来的小表中只包含一部分数据\",{\"1\":{\"519\":1}}],[\"分库分表包括分库和分表两个部分\",{\"1\":{\"515\":1}}],[\"分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题\",{\"1\":{\"515\":1}}],[\"分表分库解决思路\",{\"0\":{\"514\":1,\"515\":1}}],[\"分区容错性\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"分区分段+索引kafka\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"分区越多则副本之间的同步数量就越多\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"分区越多\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"分区数量越多\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"分区数越大消费线程数也就越多\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"分区数越大\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"分区数越多越好吗\",{\"0\":{\"1166\":1,\"1354\":1}}],[\"分区数和性能也是成正比的\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"分区数的数量是和吞吐量成正比的\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"分区选择算法\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"分区有什么问题呢\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"分区再分配的原理就是通化控制器给分区新增新的副本\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"分区再分配主要是用来维护\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"分区再分配是做什么的\",{\"0\":{\"1164\":1,\"1352\":1}}],[\"分区相当于一个日志文件\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"分区中的所有\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"分区是将topic分成多个较小的部分\",{\"1\":{\"986\":1}}],[\"分区和副本\",{\"1\":{\"986\":1}}],[\"分区\",{\"1\":{\"509\":1,\"601\":1,\"1161\":1,\"1349\":1}}],[\"分散到不同的物理表中\",{\"1\":{\"509\":1}}],[\"分析文档内容\",{\"1\":{\"1012\":1}}],[\"分析案例并实践\",{\"1\":{\"948\":1}}],[\"分析案例并实践使用\",{\"1\":{\"946\":1}}],[\"分析定位问题\",{\"1\":{\"942\":1}}],[\"分析原因\",{\"1\":{\"762\":1}}],[\"分析\",{\"0\":{\"749\":1},\"1\":{\"659\":1,\"998\":1}}],[\"分析慢sql\",{\"1\":{\"525\":1}}],[\"分析一下问题出现在哪儿呢\",{\"1\":{\"515\":1}}],[\"分析数据分布\",{\"1\":{\"510\":1}}],[\"分析查询逻辑\",{\"1\":{\"504\":1}}],[\"分析器相关参数\",{\"1\":{\"440\":1}}],[\"分析日志也会非常困难\",{\"1\":{\"196\":1}}],[\"分词器\",{\"1\":{\"443\":1}}],[\"分词器analyzer和arch\",{\"0\":{\"437\":1}}],[\"分词字段的null值也会被分词\",{\"1\":{\"440\":1}}],[\"分词字段默认配置\",{\"1\":{\"440\":1}}],[\"分词字段默认是position\",{\"1\":{\"440\":1}}],[\"分布到不同的数据库上面\",{\"1\":{\"517\":1}}],[\"分布在多台node节点上存储\",{\"1\":{\"421\":1}}],[\"分布式协调\",{\"1\":{\"1237\":1,\"1244\":1,\"1410\":1,\"1417\":1}}],[\"分布式协调通知等也是常用的场景\",{\"1\":{\"165\":1}}],[\"分布式应用程序可以基于\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"分布式应用部署\",{\"1\":{\"664\":1}}],[\"分布式系统在遇到任何网络分区故障时候\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"分布式系统中多个主机之间是否能够保持数据一致性的特性\",{\"1\":{\"1240\":1,\"1413\":1}}],[\"分布式系统不可能同时满足一致性\",{\"1\":{\"1078\":2,\"1282\":1}}],[\"分布式系统是目前使用非常普遍的解决方案\",{\"1\":{\"381\":1}}],[\"分布式阶段由以下步骤构成\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"分布式缓存\",{\"1\":{\"1045\":1,\"1199\":1,\"1254\":1,\"1379\":1}}],[\"分布式写入\",{\"1\":{\"1012\":1}}],[\"分布式搜索\",{\"1\":{\"1002\":1}}],[\"分布式\",{\"2\":{\"665\":1,\"666\":1}}],[\"分布式技术带来的技术挑战是对同一个资源的并发访问\",{\"1\":{\"594\":1}}],[\"分布式会话\",{\"1\":{\"594\":1,\"1199\":1,\"1379\":1}}],[\"分布式数据库\",{\"1\":{\"509\":1}}],[\"分布式部署的时候会使用相同的配置\",{\"1\":{\"387\":1}}],[\"分布式环境不推荐使用\",{\"1\":{\"385\":1}}],[\"分布式id生成器\",{\"0\":{\"384\":1}}],[\"分布式唯一id解决方案\",{\"0\":{\"380\":1}}],[\"分布式集群开发的目的就是为了保证系统的稳定运行\",{\"1\":{\"166\":1}}],[\"分布式就是将一个系统拆分到多个独立运行的应用中\",{\"1\":{\"165\":1}}],[\"分布式队列\",{\"0\":{\"164\":1},\"1\":{\"1244\":1,\"1417\":1}}],[\"分布式同步\",{\"1\":{\"154\":1}}],[\"分布式锁和分布式队列等功能\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"分布式锁就成为一个必要\",{\"1\":{\"664\":1}}],[\"分布式锁控制\",{\"1\":{\"153\":1}}],[\"分布式锁\",{\"0\":{\"163\":1},\"1\":{\"113\":1,\"577\":1,\"594\":1,\"1199\":1,\"1244\":2,\"1379\":1,\"1417\":2}}],[\"分布式场景中如何单例模型\",{\"1\":{\"98\":1}}],[\"分片将会在一个不同的节点上重建\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"分片的数量和你使用的硬件\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"分片的回收\",{\"1\":{\"940\":1}}],[\"分片加载文档体\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"分片数\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"分片有多少\",{\"0\":{\"1068\":1,\"1272\":1}}],[\"分片就像是把一本大书分成多个小册子\",{\"1\":{\"1004\":1}}],[\"分片是如何工作的呢\",{\"1\":{\"1004\":1}}],[\"分片增量回收\",{\"1\":{\"940\":1}}],[\"分片\",{\"1\":{\"421\":1,\"1002\":1}}],[\"分页插件的原理就是使用\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"分页助手\",{\"1\":{\"958\":1}}],[\"分页查询网站首页的新闻资讯\",{\"1\":{\"655\":1}}],[\"分页处理\",{\"1\":{\"394\":1}}],[\"分页大小可以用命令getconf\",{\"1\":{\"106\":2}}],[\"分开\",{\"1\":{\"388\":1}}],[\"分配对象的内存空间\",{\"1\":{\"1099\":2,\"1297\":2}}],[\"分配空间\",{\"1\":{\"625\":1}}],[\"分配式排序\",{\"1\":{\"371\":1}}],[\"分配内存失败\",{\"1\":{\"285\":1}}],[\"分成4个范围\",{\"1\":{\"266\":1}}],[\"分的\",{\"1\":{\"266\":1}}],[\"分享一个直观的代码\",{\"1\":{\"1104\":1,\"1302\":1}}],[\"分享等等\",{\"1\":{\"483\":1}}],[\"分享和在看是对我最大的鼓励\",{\"1\":{\"388\":1}}],[\"分享了很多资源和源码等\",{\"1\":{\"209\":1}}],[\"分享高昂分成\",{\"1\":{\"49\":1}}],[\"分支名也是可以的\",{\"1\":{\"917\":1}}],[\"分支名\",{\"1\":{\"94\":2}}],[\"分支\",{\"1\":{\"94\":1,\"917\":1,\"958\":1}}],[\"分类为\",{\"1\":{\"44\":1}}],[\"费时费力\",{\"1\":{\"49\":1}}],[\"还包括\",{\"1\":{\"1069\":1,\"1273\":1}}],[\"还包括用户唯一标识\",{\"1\":{\"192\":1}}],[\"还可以使用\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"还可能会导致死锁等问题\",{\"1\":{\"1022\":1}}],[\"还没选上\",{\"1\":{\"1008\":1}}],[\"还没开始的同学\",{\"1\":{\"411\":1,\"428\":1,\"460\":1}}],[\"还给出了源码示例\",{\"1\":{\"1004\":1}}],[\"还得感谢jvm这位大恩人\",{\"1\":{\"934\":1}}],[\"还是尤为重要\",{\"1\":{\"1126\":1}}],[\"还是以数据库为准\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"还是直接返回\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"还是从结果集中取出一个值时\",{\"1\":{\"769\":1}}],[\"还是难免产生重复\",{\"1\":{\"387\":1}}],[\"还不是很了解\",{\"1\":{\"1030\":1}}],[\"还不想花\",{\"1\":{\"906\":1}}],[\"还不行则可配置此项\",{\"1\":{\"715\":1}}],[\"还不会编写\",{\"1\":{\"27\":1}}],[\"还将继续介绍\",{\"1\":{\"608\":1}}],[\"还能为你的职业发展打下坚实的基础\",{\"1\":{\"978\":1}}],[\"还能大大降低数据库的压力\",{\"1\":{\"594\":1}}],[\"还能提升部分性能\",{\"1\":{\"520\":1}}],[\"还支持\",{\"1\":{\"593\":1}}],[\"还支持对几个操作全并后的原子性执行\",{\"1\":{\"593\":1}}],[\"还要解决数据路由的问题\",{\"1\":{\"520\":1}}],[\"还要做好接口授权访问\",{\"1\":{\"184\":1}}],[\"还需要对很多这个过程涉及到的其他知识点进行深入学习和理解\",{\"1\":{\"952\":1}}],[\"还需要更新所有相关的索引\",{\"1\":{\"508\":1}}],[\"还需要指明接口的域名或ip\",{\"1\":{\"177\":1}}],[\"还会顺带将\",{\"1\":{\"625\":1}}],[\"还会分配额外的空闲空间\",{\"1\":{\"620\":1}}],[\"还会增加数据插入\",{\"1\":{\"502\":1}}],[\"还会执行\",{\"1\":{\"195\":1}}],[\"还记载了单词频率信息\",{\"1\":{\"425\":1}}],[\"还提供免费的面包和桶面😄\",{\"1\":{\"225\":1}}],[\"还提供了更完整的框架功能\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"还提供了一个完整的流式处理框架\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"还提供了\",{\"1\":{\"97\":1,\"1092\":1,\"1293\":1}}],[\"还有些需求是产品经理拍脑袋产生的\",{\"1\":{\"1439\":1}}],[\"还有些书籍翻译成为\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"还有些细节想问一下\",{\"1\":{\"966\":1}}],[\"还有个问题是\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"还有调用了sqlsession的修改\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"还有大家已知的俩点\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"还有其他你想补充的吗\",{\"1\":{\"1000\":1}}],[\"还有其他的缺点吗\",{\"1\":{\"978\":2}}],[\"还有其他的优点吗\",{\"1\":{\"978\":3}}],[\"还有其他的优化策略吗\",{\"1\":{\"970\":1}}],[\"还有其他的使用场景吗\",{\"1\":{\"976\":2}}],[\"还有其他的内存优化技巧吗\",{\"1\":{\"972\":1}}],[\"还有其他的方法吗\",{\"1\":{\"972\":1,\"982\":1}}],[\"还有什么其他有趣的事情你想分享吗\",{\"1\":{\"998\":1}}],[\"还有什么你想补充的吗\",{\"1\":{\"968\":1}}],[\"还有没有其他的技巧\",{\"1\":{\"982\":1}}],[\"还有各种\",{\"1\":{\"615\":1}}],[\"还有需要更多技术博文可以留言催更\",{\"1\":{\"608\":1}}],[\"还有在后台管理系统中做分布式\",{\"1\":{\"594\":1}}],[\"还有来领取原版\",{\"1\":{\"586\":1}}],[\"还有一个实现上的小细节区别\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"还有一个有趣的命令\",{\"1\":{\"603\":1}}],[\"还有一些常用的工具类等\",{\"1\":{\"1439\":1}}],[\"还有一些其他的建议\",{\"1\":{\"984\":1}}],[\"还有一些自动识别如下图所示\",{\"1\":{\"439\":1}}],[\"还有一些参数是\",{\"1\":{\"183\":1}}],[\"还有一点也是为了可以筛选加入的小伙伴是真正要学习编程的同学\",{\"1\":{\"212\":1}}],[\"还有命名服务\",{\"1\":{\"165\":1}}],[\"还有\",{\"1\":{\"100\":1,\"960\":1}}],[\"还有这样做违fa\",{\"1\":{\"49\":1}}],[\"还想发到个人博客上去\",{\"0\":{\"97\":1}}],[\"抄袭不会长久\",{\"1\":{\"49\":1}}],[\"求个\",{\"1\":{\"49\":1}}],[\"求星星✨\",{\"1\":{\"1\":1}}],[\"天啊\",{\"1\":{\"934\":1}}],[\"天天开心\",{\"1\":{\"640\":1}}],[\"天不满意可以全额退款\",{\"1\":{\"212\":1}}],[\"天\",{\"1\":{\"49\":1,\"658\":1}}],[\"天才源自刻意练习\",{\"1\":{\"10\":1}}],[\"3a\",{\"1\":{\"1018\":1}}],[\"3整理阶段压缩空间\",{\"1\":{\"936\":1}}],[\"3<\",{\"1\":{\"812\":2}}],[\"37<\",{\"1\":{\"812\":1}}],[\"37\",{\"1\":{\"660\":1,\"865\":2}}],[\"34\",{\"1\":{\"444\":1}}],[\"347\",{\"1\":{\"353\":1}}],[\"32gb\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"32<\",{\"1\":{\"735\":1}}],[\"32\",{\"1\":{\"387\":4,\"388\":2,\"597\":1,\"629\":1,\"726\":1,\"736\":4,\"762\":1,\"830\":1,\"924\":1,\"1022\":2}}],[\"32k\",{\"1\":{\"106\":2,\"145\":1}}],[\"36\",{\"1\":{\"821\":1}}],[\"361389\",{\"1\":{\"660\":1}}],[\"365\",{\"1\":{\"387\":1,\"388\":1,\"658\":1}}],[\"360\",{\"1\":{\"789\":1}}],[\"360doc\",{\"1\":{\"136\":1}}],[\"360收录\",{\"1\":{\"4\":1}}],[\"335\",{\"1\":{\"790\":1}}],[\"3330851033429007657l\",{\"1\":{\"790\":1}}],[\"33tyyg\",{\"1\":{\"766\":1}}],[\"3306\",{\"1\":{\"737\":1,\"743\":2,\"745\":1,\"816\":1,\"824\":1,\"1444\":1}}],[\"33\",{\"1\":{\"377\":2}}],[\"399\",{\"1\":{\"789\":1}}],[\"39\",{\"1\":{\"375\":5,\"377\":2,\"406\":2,\"659\":1,\"790\":8,\"830\":1}}],[\"390310\",{\"1\":{\"336\":1}}],[\"359\",{\"1\":{\"789\":1}}],[\"35\",{\"1\":{\"329\":1,\"789\":11,\"790\":2,\"795\":1}}],[\"35812205\",{\"1\":{\"232\":1}}],[\"30秒后\",{\"1\":{\"960\":1}}],[\"30秒后过期\",{\"1\":{\"960\":1}}],[\"30pm\",{\"1\":{\"916\":1}}],[\"30\",{\"1\":{\"145\":2,\"289\":1,\"329\":1,\"603\":2,\"759\":2,\"815\":1,\"829\":1,\"865\":2,\"948\":1,\"960\":2,\"1071\":1,\"1275\":1,\"1444\":1}}],[\"3000\",{\"1\":{\"109\":1,\"251\":3,\"888\":1,\"912\":1}}],[\"302\",{\"1\":{\"104\":1,\"1027\":1}}],[\"301\",{\"1\":{\"104\":1}}],[\"315\",{\"1\":{\"865\":1}}],[\"3182\",{\"1\":{\"660\":1}}],[\"310733557\",{\"1\":{\"136\":1}}],[\"3128\",{\"1\":{\"106\":2}}],[\"31\",{\"1\":{\"94\":1,\"387\":2,\"388\":1,\"658\":2,\"829\":2}}],[\"38669394\",{\"1\":{\"394\":1}}],[\"3888是zookeeper与其他应用程序通讯的端口\",{\"1\":{\"157\":1}}],[\"3888\",{\"1\":{\"157\":2}}],[\"38\",{\"1\":{\"94\":1,\"660\":1,\"795\":2,\"1105\":1,\"1303\":1}}],[\"3\",{\"0\":{\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"130\":1,\"131\":2,\"132\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":2,\"141\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"146\":1,\"153\":1,\"155\":1,\"159\":1,\"178\":1,\"334\":1,\"336\":1,\"338\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"343\":1,\"352\":1,\"360\":1,\"372\":1,\"376\":1,\"377\":1,\"496\":1,\"528\":1,\"557\":1,\"562\":1,\"579\":1,\"590\":1,\"591\":1,\"592\":1,\"593\":2,\"604\":1,\"616\":1,\"623\":1,\"624\":1,\"625\":1,\"626\":2,\"673\":1,\"688\":1,\"701\":1,\"702\":1,\"705\":1,\"708\":1,\"713\":1,\"727\":1,\"736\":1,\"740\":1,\"744\":1,\"755\":1,\"763\":1,\"768\":1,\"777\":1,\"780\":1,\"786\":1,\"794\":1,\"898\":1,\"1044\":1,\"1059\":1,\"1070\":1,\"1086\":1,\"1100\":1,\"1114\":1,\"1129\":1,\"1144\":1,\"1160\":1,\"1174\":1,\"1187\":1,\"1200\":1,\"1213\":1,\"1226\":1,\"1239\":1,\"1253\":1,\"1265\":1,\"1274\":1,\"1287\":1,\"1298\":1,\"1309\":1,\"1322\":1,\"1335\":1,\"1348\":1,\"1359\":1,\"1370\":1,\"1380\":1,\"1390\":1,\"1401\":1,\"1412\":1},\"1\":{\"49\":1,\"76\":1,\"106\":2,\"125\":3,\"153\":1,\"157\":3,\"158\":1,\"159\":1,\"166\":3,\"212\":1,\"263\":2,\"266\":1,\"270\":2,\"288\":1,\"289\":3,\"329\":3,\"337\":1,\"351\":1,\"352\":2,\"359\":7,\"360\":3,\"364\":3,\"375\":2,\"377\":1,\"387\":2,\"402\":1,\"429\":1,\"436\":1,\"460\":1,\"525\":1,\"529\":2,\"532\":1,\"594\":1,\"603\":1,\"604\":4,\"605\":1,\"606\":1,\"607\":1,\"648\":1,\"658\":1,\"659\":2,\"701\":1,\"702\":2,\"709\":1,\"710\":1,\"723\":1,\"726\":2,\"727\":4,\"737\":1,\"739\":1,\"743\":2,\"744\":2,\"745\":2,\"751\":1,\"755\":2,\"763\":3,\"782\":2,\"812\":4,\"815\":1,\"817\":2,\"819\":2,\"820\":2,\"827\":4,\"830\":1,\"837\":1,\"838\":1,\"839\":1,\"862\":1,\"916\":1,\"924\":2,\"934\":1,\"952\":2,\"966\":1,\"1044\":7,\"1047\":1,\"1071\":5,\"1072\":4,\"1074\":1,\"1077\":3,\"1092\":1,\"1099\":3,\"1100\":1,\"1104\":5,\"1161\":1,\"1162\":1,\"1163\":2,\"1165\":1,\"1166\":1,\"1167\":1,\"1190\":1,\"1211\":1,\"1216\":1,\"1217\":1,\"1219\":2,\"1220\":1,\"1253\":7,\"1256\":1,\"1275\":5,\"1276\":4,\"1278\":1,\"1281\":3,\"1293\":1,\"1297\":3,\"1298\":1,\"1302\":5,\"1349\":1,\"1350\":1,\"1351\":2,\"1353\":1,\"1354\":1,\"1355\":1,\"1373\":1,\"1388\":1,\"1393\":1,\"1394\":1,\"1396\":2,\"1397\":1,\"1439\":1,\"1444\":1}}],[\"在企业中\",{\"1\":{\"1439\":1}}],[\"在后端接口封装中\",{\"1\":{\"1431\":1}}],[\"在那些多个应用共用一个\",{\"1\":{\"1245\":1,\"1418\":1}}],[\"在特定的目录下创建\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"在约定目录下创建临时目录节点\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"在以前通过增\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"在以前没有开源连接池时\",{\"1\":{\"647\":1}}],[\"在微服务中\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"在容器中开始实例化我们需要的\",{\"1\":{\"1230\":1,\"1405\":1}}],[\"在容器启动时\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"在new对象的时候就会堵塞住了\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"在目标对象\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"在目标方法抛出异常后执行\",{\"1\":{\"944\":1}}],[\"在目标方法正常返回后执行\",{\"1\":{\"944\":1}}],[\"在目标方法调用前执行\",{\"1\":{\"944\":1}}],[\"在采用面向对象方法设计的软件系统中\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"在恢复时\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"在插件的拦截方法内\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"在第\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"在第一轮投票中\",{\"1\":{\"166\":1}}],[\"在默认情况下\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"在复制完成后\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"在复合索引中\",{\"1\":{\"498\":1}}],[\"在其他机器上选举出新的\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"在其中运行的只是应用\",{\"1\":{\"1058\":1,\"1264\":1}}],[\"在保证同一个\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"在2\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"在面试kafka中\",{\"1\":{\"1155\":1,\"1343\":1}}],[\"在面试中\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"在虚拟机启动时创建\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"在请求完毕后\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"在请求bean范围内为每一个来自客户端的网络请求创建一个实例\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"在请求地址中添加\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"在请求头中\",{\"1\":{\"183\":1}}],[\"在只在\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"在初始化阶段\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"在下列时刻会加载servlet\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"在笔试的时候可能还会考一些集合的使用\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"在计算机中\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"在计算机中磁盘存储数据最小单元是扇区\",{\"1\":{\"272\":1}}],[\"在极端情况下\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"在上述情况下没有抛出异常\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"在上面举的例子中\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"在上面的代码中\",{\"1\":{\"1022\":3,\"1023\":3}}],[\"在适合单线程使用的集合容器中很好地实现了\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"在适当的时候自动释放对象并进行内存回收\",{\"1\":{\"635\":1}}],[\"在日常的使用中\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"在日常使用中\",{\"1\":{\"164\":1}}],[\"在涉及到要同时申请两个锁的方法中\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"在每一个\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"在每个分支首行都打印日志\",{\"0\":{\"200\":1}}],[\"在当前线程掉用了join\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"在当前线程内可以任意存取数据\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"在当前分支进行紧急需求开发提交\",{\"1\":{\"916\":1}}],[\"在lockobj\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"在基于偏序关系的happens\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"在反序列化时\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"在步骤二中的indexcontroller写一个sourcec进行测试\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"在阻塞式里面\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"在任意子类中定义了重名和同样的参数列表就构成方法重写\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"在通过valueof方法创建integer对象的时候\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"在主分片上面执行请求\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"在该机制下这些资源就不再是全局的了\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"在该示例中\",{\"1\":{\"505\":1}}],[\"在继续下一个容器之前不会等待容器准备就绪\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"在所有有效的\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"在刚启动的缓存系统中\",{\"1\":{\"1051\":1,\"1260\":1}}],[\"在读请求时\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"在写入的时候先把当前的数据以rdb的形式写入到文件的开头\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"在写入消息之前\",{\"1\":{\"996\":1}}],[\"在写请求时\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"在开始说解决方案之前\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"在开发初期未考虑系统扩展性\",{\"1\":{\"950\":1}}],[\"在开发调试阶段\",{\"1\":{\"191\":1}}],[\"在开发中我们有常见的四种日志打印等级\",{\"1\":{\"191\":1}}],[\"在前端查询钱包余额时\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"在前面的判断中\",{\"1\":{\"334\":1}}],[\"在低并发量下没什么问题\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"在缓存服务的基础上\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"在流量大时\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"在理解核心组件以前\",{\"1\":{\"1033\":1}}],[\"在文件操作中\",{\"1\":{\"1020\":1}}],[\"在网络编程中\",{\"1\":{\"1020\":1}}],[\"在项目上线前\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"在项目我玩的贼6\",{\"1\":{\"1018\":1}}],[\"在项目中\",{\"1\":{\"1018\":1}}],[\"在项目开发中可以\",{\"1\":{\"922\":1}}],[\"在变量前面追加版本号version\",{\"1\":{\"1018\":1}}],[\"在底层\",{\"1\":{\"1012\":1}}],[\"在elasticsearch中\",{\"1\":{\"1012\":1}}],[\"在电商网站中\",{\"1\":{\"1006\":1}}],[\"在发送消息之前\",{\"1\":{\"996\":1}}],[\"在生产者部分\",{\"1\":{\"990\":1}}],[\"在生产中通常包括\",{\"1\":{\"515\":1}}],[\"在kafka中\",{\"1\":{\"990\":1,\"994\":1,\"996\":1}}],[\"在消费者消费消息后\",{\"1\":{\"984\":1}}],[\"在选择是否启用压缩时\",{\"1\":{\"972\":1}}],[\"在选举时每个节点都有一个\",{\"1\":{\"166\":1}}],[\"在聊了泛型这么多后\",{\"1\":{\"966\":1}}],[\"在实际工作中\",{\"1\":{\"1439\":1}}],[\"在实际开发中的应用吗\",{\"1\":{\"1020\":1}}],[\"在实际的索引系统里可以包含\",{\"1\":{\"425\":1}}],[\"在实例化对象后\",{\"1\":{\"954\":1}}],[\"在源码层面\",{\"1\":{\"952\":3}}],[\"在满足需求前提下保持最简实现\",{\"1\":{\"950\":1}}],[\"在你的工作中\",{\"1\":{\"994\":1}}],[\"在你的项目中是如何设计一个高并发的系统的\",{\"1\":{\"950\":1}}],[\"在你的系统中检查这个目录是否存在\",{\"1\":{\"157\":1}}],[\"在gc的时候也要考虑到不连续的分配\",{\"1\":{\"1144\":1,\"1335\":1}}],[\"在gc日志前输出时间戳\",{\"1\":{\"942\":1}}],[\"在gc时优先处理\",{\"1\":{\"940\":1}}],[\"在gc时结合使用\",{\"1\":{\"940\":1}}],[\"在回收时只处理\",{\"1\":{\"940\":1}}],[\"在并发环境下一定会发生脏数据问题\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"在并发情况下\",{\"0\":{\"1078\":1,\"1282\":1}}],[\"在并发清除阶段\",{\"1\":{\"938\":1}}],[\"在并发标记阶段\",{\"1\":{\"938\":1}}],[\"在标记过程中对象图可能被修改\",{\"1\":{\"938\":1}}],[\"在工作实践中不断进步\",{\"1\":{\"934\":1}}],[\"在工程实践中\",{\"1\":{\"659\":1}}],[\"在类加载过程中\",{\"1\":{\"934\":1}}],[\"在jsp运行过程中\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"在jdk8之后\",{\"1\":{\"930\":1}}],[\"在jdk8之前\",{\"1\":{\"930\":1}}],[\"在java中\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"在java编程中\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"在java程序中\",{\"1\":{\"930\":1}}],[\"在java8之前使用分段锁\",{\"1\":{\"922\":1}}],[\"在java线程并发处理中\",{\"1\":{\"692\":1}}],[\"在java实例化对象会分为三步\",{\"1\":{\"80\":1}}],[\"在自动化布署方面\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"在自定义线程池时\",{\"1\":{\"926\":1}}],[\"在自己的对象系统中构建了一个\",{\"1\":{\"635\":1}}],[\"在扩容时\",{\"1\":{\"922\":1}}],[\"在扩展空间时\",{\"1\":{\"620\":1}}],[\"在内存映射中\",{\"1\":{\"1020\":1}}],[\"在内存去重\",{\"1\":{\"656\":1}}],[\"在内部实现上主要包含以下几个结构\",{\"1\":{\"922\":1}}],[\"在哪里可以看到全集\",{\"1\":{\"920\":1}}],[\"在搭建之前\",{\"1\":{\"907\":1}}],[\"在cmd中安装\",{\"1\":{\"898\":1}}],[\"在conf目录下\",{\"1\":{\"157\":1}}],[\"在acquire\",{\"1\":{\"970\":1}}],[\"在activiti启动时删除原来的旧表\",{\"1\":{\"864\":1}}],[\"在activiti启动时创建表\",{\"1\":{\"864\":1}}],[\"在application\",{\"1\":{\"885\":1}}],[\"在关闭时删除表\",{\"1\":{\"864\":1}}],[\"在关键字全集内做一次查找\",{\"1\":{\"265\":1}}],[\"在spring中\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"在spring中有两种表现\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"在spring\",{\"1\":{\"1217\":2,\"1394\":2}}],[\"在stw阶段\",{\"1\":{\"940\":1}}],[\"在source下面选择master\",{\"1\":{\"913\":1}}],[\"在service包下新建bookservice\",{\"1\":{\"830\":1}}],[\"在sql语句中使用别名\",{\"1\":{\"759\":2}}],[\"在里面新建一个枚举类\",{\"1\":{\"829\":1}}],[\"在dao包新建接口\",{\"1\":{\"826\":1}}],[\"在doc下面输入\",{\"1\":{\"692\":1}}],[\"在release\",{\"1\":{\"970\":1}}],[\"在redis分片集群中\",{\"1\":{\"968\":1}}],[\"在recources文件夹里新建mybatis\",{\"1\":{\"817\":1}}],[\"在rr隔离级别下\",{\"1\":{\"575\":2}}],[\"在接口所在的包中定义mapper\",{\"1\":{\"772\":1}}],[\"在接下来还会持续更新\",{\"1\":{\"521\":1}}],[\"在mybatis\",{\"1\":{\"772\":1}}],[\"在mybatis中\",{\"1\":{\"772\":1,\"789\":1}}],[\"在mysql的可重复读\",{\"1\":{\"575\":1}}],[\"在mysql中\",{\"1\":{\"565\":1}}],[\"在mysql中我们的innodb页的大小默认是16k\",{\"1\":{\"272\":1}}],[\"在mysql\",{\"1\":{\"507\":1}}],[\"在预处理语句\",{\"1\":{\"769\":1}}],[\"在子工程中的pom\",{\"1\":{\"715\":1}}],[\"在依赖节点dependency中的<optional>可以控制当前的依赖是否向下传递\",{\"1\":{\"708\":1}}],[\"在平面几何中坐标\",{\"1\":{\"705\":1}}],[\"在用户的目录下都只有一个\",{\"1\":{\"705\":1}}],[\"在用一个\",{\"1\":{\"648\":1}}],[\"在安装maven后并不会创建\",{\"1\":{\"705\":1}}],[\"在远程仓库中又分成了3种\",{\"1\":{\"705\":1}}],[\"在命令行中可以通过maven中的命令\",{\"1\":{\"703\":1}}],[\"在pom中的依赖节点中\",{\"1\":{\"710\":1}}],[\"在postgresql中\",{\"1\":{\"566\":1}}],[\"在path中追加\",{\"1\":{\"702\":1}}],[\"在试试我们的程序吧\",{\"1\":{\"692\":1}}],[\"在修改完之后的某一个时刻\",{\"1\":{\"692\":1}}],[\"在运行时\",{\"1\":{\"1016\":1}}],[\"在运行时期间不会存在任何泛型类型的参数信息\",{\"1\":{\"966\":1}}],[\"在运行时候的内存分配过程\",{\"1\":{\"692\":1}}],[\"在运行期间\",{\"1\":{\"166\":1}}],[\"在多线程并发环境下\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"在多线程下也可能产生死循环\",{\"1\":{\"988\":1}}],[\"在多线程访问的时候\",{\"1\":{\"692\":1}}],[\"在多粒度锁定协议中\",{\"1\":{\"575\":1}}],[\"在语言内部引入了\",{\"1\":{\"692\":1}}],[\"在进行io操作的时候再用一个线程去处理就可以了\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"在进行真正的构建之前进行一些清理工作\",{\"1\":{\"711\":1}}],[\"在进行多线程并发处理的时候就可以万事大吉\",{\"1\":{\"692\":1}}],[\"在进行完最低位数的分配后再合并回单一的数组中\",{\"1\":{\"375\":1}}],[\"在切点返回内容后\",{\"1\":{\"689\":1}}],[\"在切点之前\",{\"1\":{\"689\":1}}],[\"在方法上增加\",{\"1\":{\"689\":1}}],[\"在线创建\",{\"0\":{\"837\":1}}],[\"在线地址\",{\"1\":{\"668\":1}}],[\"在线视频有时候\",{\"1\":{\"134\":1}}],[\"在签到统计中\",{\"1\":{\"658\":1}}],[\"在程序开发过程中\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"在程序运行时通过反射读取注解\",{\"1\":{\"944\":1}}],[\"在程序中用\",{\"1\":{\"659\":1}}],[\"在程序中也用\",{\"1\":{\"658\":1}}],[\"在程序出现大量请求是就会出现\",{\"1\":{\"616\":1}}],[\"在处理一个任务时\",{\"1\":{\"645\":1}}],[\"在有需要时\",{\"1\":{\"630\":1}}],[\"在有序集合中计算指定字典区间内成员数量\",{\"1\":{\"607\":1}}],[\"在同一个事务内\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"在同一个\",{\"1\":{\"958\":1}}],[\"在同一个命名空间下保持唯一\",{\"1\":{\"744\":1,\"755\":1,\"763\":4,\"776\":1}}],[\"在同一个跳跃表中\",{\"1\":{\"629\":1}}],[\"在同一台机器上启动两个elasticsearch实例\",{\"1\":{\"417\":1}}],[\"在字典中维持一个索引计数器变量\",{\"1\":{\"625\":1}}],[\"在列表中添加一个或多个值\",{\"1\":{\"604\":1}}],[\"在列表的元素前或者后插入元素\",{\"1\":{\"604\":1}}],[\"在很多互联网公司中都使用了分布式技术\",{\"1\":{\"594\":1}}],[\"在应用不多的情况下一般使用容器自带的\",{\"1\":{\"594\":1}}],[\"在应用程序中\",{\"1\":{\"382\":1}}],[\"在部署时\",{\"0\":{\"1073\":1,\"1277\":1}}],[\"在部\",{\"1\":{\"589\":1}}],[\"在高冲突环境下\",{\"1\":{\"570\":1}}],[\"在高并发的更新操作中\",{\"1\":{\"508\":1}}],[\"在数据更新时\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"在数据表中添加一个版本号字段或时间戳字段\",{\"1\":{\"569\":1}}],[\"在数据量及访问压力不是特别大的情况\",{\"1\":{\"520\":1}}],[\"在事务\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"在事务提交时检测冲突\",{\"1\":{\"569\":1}}],[\"在事务使用完毕之前\",{\"1\":{\"562\":1}}],[\"在冲突较少的情况下\",{\"1\":{\"569\":1}}],[\"在innodb存储引擎中\",{\"1\":{\"561\":1,\"564\":1}}],[\"在id为10到20的范围内设置间隙锁\",{\"1\":{\"558\":1}}],[\"在许多数据库系统中\",{\"1\":{\"561\":1}}],[\"在许多操作系统中\",{\"1\":{\"274\":1}}],[\"在此复制期间还会有一系列保证性能的操作\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"在此同时由于\",{\"1\":{\"692\":1}}],[\"在此分享给大家\",{\"1\":{\"692\":1}}],[\"在此基础上做一些预案设定\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"在此基础上\",{\"1\":{\"589\":1}}],[\"在此期间\",{\"1\":{\"561\":1}}],[\"在此事务中\",{\"1\":{\"556\":1,\"571\":1}}],[\"在编程中提升设计能力也非常重要\",{\"1\":{\"552\":1}}],[\"在编写代码时\",{\"1\":{\"988\":1}}],[\"在编写代码时要时刻考虑清楚\",{\"1\":{\"988\":1}}],[\"在编写查询时\",{\"1\":{\"504\":1}}],[\"在编写核心业务逻辑代码时\",{\"1\":{\"200\":1}}],[\"在编写接口文档时\",{\"1\":{\"185\":1}}],[\"在结果集中包括\",{\"1\":{\"546\":1}}],[\"在存储过程的最后务必将所有的临时表显式删除\",{\"0\":{\"543\":1}}],[\"在存储和检索中有至关重要的作用\",{\"1\":{\"381\":1}}],[\"在新的文档被创建时\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"在新版本中\",{\"1\":{\"648\":1}}],[\"在新版的elasticsearch中已经废弃\",{\"1\":{\"419\":1}}],[\"在新建临时表时\",{\"0\":{\"542\":1}}],[\"在使用start\",{\"1\":{\"1186\":1,\"1369\":1}}],[\"在使用钱包余额时\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"在使用反射时需要格外小心\",{\"1\":{\"1010\":1}}],[\"在使用kafka的push模式时\",{\"1\":{\"990\":1}}],[\"在使用redis分布式锁时\",{\"1\":{\"970\":1}}],[\"在使用注解时可以忽略该值\",{\"1\":{\"944\":1}}],[\"在使用的时候子工程直接继承父工程的依赖版本号\",{\"1\":{\"715\":1}}],[\"在使用时要注意\",{\"1\":{\"541\":1}}],[\"在使用索引字段作为条件时\",{\"0\":{\"534\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"在系统设计阶段就应该根据业务耦合松紧来确定垂直分库\",{\"1\":{\"520\":1}}],[\"在执行完目标方法之后根据执行情况提交或者回滚事务\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"在执行时\",{\"1\":{\"800\":1}}],[\"在执行这些操作之前\",{\"1\":{\"511\":1}}],[\"在执行表连接操作时\",{\"1\":{\"502\":1}}],[\"在建表时就要添加必要的索引\",{\"1\":{\"509\":1}}],[\"在二叉树中\",{\"1\":{\"503\":1}}],[\"在最坏的情况下\",{\"1\":{\"503\":1}}],[\"在最短的时间学会使用elasticsearch7\",{\"1\":{\"394\":1}}],[\"在考虑建立索引时\",{\"1\":{\"502\":1}}],[\"在order对象中添加user属性\",{\"1\":{\"793\":1}}],[\"在order对象中添加user对象\",{\"1\":{\"793\":1}}],[\"在order\",{\"1\":{\"502\":1}}],[\"在某些情况下\",{\"1\":{\"501\":1,\"574\":1,\"581\":1}}],[\"在某些时候\",{\"1\":{\"371\":1}}],[\"在这样的齿轮组中\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"在这个配置类中通过条件注解来决定一个配置是否生效\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"在这个阶段中\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"在这个例子中\",{\"1\":{\"1010\":4,\"1016\":1}}],[\"在这个流程中\",{\"1\":{\"956\":1}}],[\"在这个示例中\",{\"1\":{\"559\":1,\"571\":1,\"924\":1}}],[\"在这种情况下\",{\"1\":{\"499\":1,\"924\":1,\"1166\":1,\"1180\":1,\"1354\":1,\"1365\":1}}],[\"在这里整理这些容易忘记的重点知识及\",{\"1\":{\"1026\":1,\"1030\":1,\"1249\":1}}],[\"在这里定义好后\",{\"1\":{\"844\":1}}],[\"在这里我需要说明一下\",{\"1\":{\"692\":1}}],[\"在这里简单介绍下\",{\"1\":{\"455\":1}}],[\"在这里插入图片描述\",{\"1\":{\"76\":1,\"263\":1,\"264\":1,\"269\":1,\"394\":1,\"515\":2,\"586\":1,\"587\":1,\"597\":1,\"613\":1,\"614\":1,\"616\":1,\"619\":1,\"621\":1,\"624\":3,\"628\":2,\"630\":1,\"633\":1,\"648\":1,\"684\":1,\"689\":1,\"690\":1,\"855\":1,\"860\":1,\"1092\":2,\"1098\":1,\"1275\":1,\"1276\":1,\"1293\":2,\"1296\":1}}],[\"在等值查询下\",{\"1\":{\"499\":1}}],[\"在叶子节点存储的是表主键和索引列\",{\"1\":{\"495\":1}}],[\"在原\",{\"1\":{\"451\":1}}],[\"在创建消息是\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"在创建多列索引时\",{\"1\":{\"510\":1}}],[\"在创建复合索引时\",{\"1\":{\"498\":1}}],[\"在创建一个索引的时候\",{\"1\":{\"431\":1}}],[\"在创建索引的时候可以直接指定分片的数量即可\",{\"1\":{\"421\":1}}],[\"在单词对应的倒排列表中不仅记录了文档编号\",{\"1\":{\"425\":1}}],[\"在如此处理结束后\",{\"1\":{\"425\":1}}],[\"在7\",{\"1\":{\"419\":1}}],[\"在索引中内进行逻辑细分\",{\"1\":{\"419\":1}}],[\"在看和分享是对我最大的鼓励\",{\"1\":{\"408\":1,\"425\":1}}],[\"在启动前\",{\"1\":{\"406\":1}}],[\"在研究底层代码\",{\"1\":{\"397\":1}}],[\"在大数据搜索中\",{\"1\":{\"397\":1}}],[\"在大数量\",{\"1\":{\"385\":1}}],[\"在大多数服务中要用到\",{\"1\":{\"106\":1}}],[\"在走访数值时将它们分配至编号\",{\"1\":{\"375\":1}}],[\"在交换并重建堆的过程中\",{\"1\":{\"364\":1}}],[\"在取值范围不是很大的情况下\",{\"1\":{\"359\":1}}],[\"在对象实例化之后\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"在对哈希表进行扩展或者收缩操作时\",{\"1\":{\"625\":1,\"626\":1}}],[\"在对各个桶中元素进行排序时\",{\"1\":{\"350\":1}}],[\"在对准确率要求不高的业务场景使用广泛\",{\"1\":{\"330\":1}}],[\"在额外空间上对桶进行排序\",{\"1\":{\"348\":1}}],[\"在额外空间充足的情况下\",{\"1\":{\"348\":1}}],[\"在吴军博士的\",{\"1\":{\"339\":1}}],[\"在构造一个布隆过滤器时\",{\"1\":{\"339\":1}}],[\"在磁盘的一侧有磁头支架\",{\"1\":{\"274\":1}}],[\"在一定条件下\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"在一个循环中\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"在一个线程内调用该线程锁对象的wait方法\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"在一个聊天室应用中\",{\"1\":{\"1020\":1}}],[\"在一个生命周期中\",{\"1\":{\"712\":1}}],[\"在一个相对较小的字段内搜索效率显然要高些\",{\"0\":{\"539\":1}}],[\"在一次磁盘i\",{\"1\":{\"503\":1}}],[\"在一次\",{\"1\":{\"270\":1}}],[\"在一起\",{\"1\":{\"270\":1}}],[\"在一家大型安全公司实习\",{\"1\":{\"225\":1}}],[\"在树中的位置有关\",{\"1\":{\"270\":1}}],[\"在行首打印日志\",{\"1\":{\"200\":1}}],[\"在嵌套逻辑代码中打印重复日志\",{\"1\":{\"198\":1}}],[\"在服务器更新资源\",{\"1\":{\"178\":2}}],[\"在服务器新建一个资源\",{\"1\":{\"178\":1}}],[\"在zookeeper运行期间\",{\"1\":{\"166\":1}}],[\"在集群初始化阶段\",{\"1\":{\"166\":1}}],[\"在我们使用spring框架后\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"在我们正常人的思维中\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"在我们需要保证原子性操作时\",{\"1\":{\"603\":1}}],[\"在我们开发过程中\",{\"1\":{\"383\":1}}],[\"在我们日常的开发中\",{\"1\":{\"163\":1}}],[\"在我的mac上\",{\"1\":{\"145\":1}}],[\"在分布式系统中\",{\"1\":{\"153\":1,\"1078\":1,\"1282\":1}}],[\"在操作前\",{\"1\":{\"127\":1}}],[\"在需要使用负载均衡的server中增加\",{\"1\":{\"106\":1}}],[\"在upstream中加入hash语句\",{\"1\":{\"106\":1}}],[\"在减少了在内存中的存取次数后\",{\"1\":{\"106\":1}}],[\"在学习的同学\",{\"1\":{\"101\":1}}],[\"在学习\",{\"0\":{\"101\":1}}],[\"在准备面试\",{\"0\":{\"100\":1}}],[\"在准备面试的朋友可以优先阅读面试专栏\",{\"1\":{\"49\":1}}],[\"在fs之前强制加个begin\",{\"1\":{\"94\":1}}],[\"在\",{\"1\":{\"84\":1,\"385\":1,\"429\":1,\"443\":2,\"445\":1,\"495\":1,\"526\":1,\"625\":1,\"635\":1,\"692\":2,\"762\":1,\"766\":1,\"807\":1,\"816\":1,\"818\":1,\"819\":1,\"821\":1,\"825\":1,\"827\":1,\"829\":2,\"830\":1,\"839\":1,\"920\":1,\"924\":2,\"952\":5,\"954\":2,\"962\":1,\"1022\":6,\"1023\":1,\"1045\":1,\"1047\":1,\"1050\":1,\"1059\":2,\"1071\":1,\"1076\":1,\"1077\":1,\"1092\":1,\"1137\":1,\"1166\":1,\"1176\":1,\"1179\":1,\"1232\":1,\"1254\":1,\"1256\":1,\"1259\":1,\"1265\":2,\"1275\":1,\"1280\":1,\"1281\":1,\"1293\":1,\"1330\":1,\"1354\":1,\"1361\":1,\"1364\":1,\"1407\":1,\"1444\":2}}],[\"在页面禁用功能与布局\",{\"1\":{\"20\":1}}],[\"🔔提示\",{\"1\":{\"49\":1}}],[\"编辑\",{\"1\":{\"911\":1}}],[\"编辑器\",{\"1\":{\"811\":1}}],[\"编辑此页链接\",{\"1\":{\"20\":1}}],[\"编译不通过\",{\"1\":{\"1084\":2,\"1285\":2}}],[\"编译错误\",{\"1\":{\"966\":1}}],[\"编译后存在于字节码文件中\",{\"1\":{\"944\":2}}],[\"编译后失效\",{\"1\":{\"944\":2}}],[\"编译阶段\",{\"1\":{\"944\":1}}],[\"编译期\",{\"1\":{\"944\":1}}],[\"编译期使用\",{\"1\":{\"944\":1}}],[\"编译器会检查\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"编译器会禁止一些优化\",{\"1\":{\"924\":1}}],[\"编译器的工作原理与调优手段\",{\"1\":{\"942\":1}}],[\"编译器不会将\",{\"1\":{\"924\":1}}],[\"编译器优化\",{\"1\":{\"924\":1}}],[\"编译原理\",{\"1\":{\"824\":1}}],[\"编译测试源代码\",{\"1\":{\"713\":1}}],[\"编译项目的源代码\",{\"1\":{\"713\":1}}],[\"编译\",{\"1\":{\"672\":1,\"698\":1,\"705\":1,\"711\":2,\"1130\":1,\"1323\":1}}],[\"编译时间较长\",{\"1\":{\"125\":1}}],[\"编号最小的获得锁\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"编号\",{\"1\":{\"658\":2,\"723\":1}}],[\"编者荐语\",{\"1\":{\"397\":1}}],[\"编写工具类\",{\"0\":{\"876\":1}}],[\"编写测试类\",{\"1\":{\"828\":1}}],[\"编写测试案例也要给出测试数据\",{\"1\":{\"185\":1}}],[\"编写mapper配置\",{\"1\":{\"785\":1}}],[\"编写mapper\",{\"1\":{\"784\":1}}],[\"编写userdao的测试用例\",{\"0\":{\"757\":1}}],[\"编写userdao对应mapper\",{\"0\":{\"755\":1}}],[\"编写专门的打印函数\",{\"1\":{\"619\":1}}],[\"编写的方法\",{\"1\":{\"930\":1}}],[\"编写的真人1对1面试对话教程\",{\"1\":{\"920\":1}}],[\"编写的\",{\"1\":{\"400\":1}}],[\"编写接口请求示例\",{\"0\":{\"180\":1}}],[\"编码不同将直接影响数据的内存占用和读写效率\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"编码优化\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"编码方式\",{\"1\":{\"630\":1}}],[\"编码的字符串\",{\"1\":{\"447\":1}}],[\"编码\",{\"0\":{\"813\":1,\"875\":1},\"1\":{\"116\":1,\"635\":1,\"1439\":2}}],[\"编程式事务管理使用\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"编程方式避免\",{\"1\":{\"954\":1}}],[\"编程规范\",{\"0\":{\"169\":1},\"2\":{\"170\":1,\"171\":1,\"173\":1,\"174\":1,\"187\":1,\"188\":1,\"202\":1,\"203\":1}}],[\"编程基础\",{\"1\":{\"98\":1}}],[\"编程指南的优势\",{\"0\":{\"211\":1}}],[\"编程指南知识星球\",{\"1\":{\"49\":1,\"210\":1}}],[\"编程指南\",{\"0\":{\"49\":1},\"1\":{\"906\":1}}],[\"这与\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"这道题相信大家都有所了解\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"这道题是spring一道标准题目\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"这道题目较难\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"这极有可能发生sql注入\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"这得益于其消息持久化和多副本机制\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"这侧面说明如果链表的长度达到了8\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"这并不符合我们的业务\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"这听起来不错\",{\"1\":{\"1006\":1}}],[\"这听起来很直观\",{\"1\":{\"986\":1}}],[\"这么灵活\",{\"1\":{\"994\":1}}],[\"这么多请求方式\",{\"1\":{\"178\":1}}],[\"这正是我们下一次面试的话题\",{\"1\":{\"992\":1}}],[\"这只是一个简化的示例\",{\"1\":{\"986\":1}}],[\"这段崭新的内存还没有初始化\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"这段代码模拟了一个分片的实现\",{\"1\":{\"1004\":1}}],[\"这段代码很好地展示了kafka的push和pull模式\",{\"1\":{\"990\":1}}],[\"这段代码看起来很简单明了\",{\"1\":{\"984\":1}}],[\"这段官方文档已经说的很明白\",{\"1\":{\"698\":1}}],[\"这次面试对我来说非常有意义\",{\"1\":{\"980\":1}}],[\"这次是根据十位数来分配\",{\"1\":{\"375\":1}}],[\"这可以通过\",{\"1\":{\"1022\":2}}],[\"这可以避免\",{\"1\":{\"1022\":1}}],[\"这可以确保变量的可见性\",{\"1\":{\"1022\":1}}],[\"这可以用来阻止其他会话访问这些表\",{\"1\":{\"572\":1}}],[\"这可能会对逻辑产生意料之外的影响\",{\"1\":{\"1018\":1}}],[\"这可能会增加硬件成本\",{\"1\":{\"978\":1}}],[\"这整个同步过程可以保证从服务器快速获取主服务器的数据\",{\"1\":{\"964\":1}}],[\"这两种类型的节点重点是后面的\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"这两个方案\",{\"1\":{\"1047\":1,\"1049\":1,\"1256\":1,\"1258\":1}}],[\"这两个概念容易混淆\",{\"1\":{\"966\":1}}],[\"这两个阶段互相循环\",{\"1\":{\"964\":1}}],[\"这两点好处使得java类加载机制更加完备和安全\",{\"1\":{\"934\":1}}],[\"这对于刚入行的技术人员来说非常有帮助\",{\"1\":{\"1004\":1}}],[\"这对于数据分析和故障排除非常有帮助\",{\"1\":{\"978\":1}}],[\"这对于构建可靠的数据管道非常重要\",{\"1\":{\"978\":1}}],[\"这对于处理实时数据和大规模应用非常有用\",{\"1\":{\"978\":1}}],[\"这对一个入门的开发者来说很难得\",{\"1\":{\"956\":1}}],[\"这对我加深理解g1有很大帮助\",{\"1\":{\"940\":1}}],[\"这对我来说很宝贵\",{\"1\":{\"922\":1}}],[\"这四个组件协同工作\",{\"1\":{\"956\":1}}],[\"这四种是解决死锁的办法\",{\"1\":{\"581\":1}}],[\"这涉及到\",{\"1\":{\"952\":1}}],[\"这份学习清单也同样具有针对性\",{\"1\":{\"948\":1}}],[\"这份学习清单涵盖的内容非常全面且具有针对性\",{\"1\":{\"946\":1}}],[\"这需要根据你的业务需求来决定\",{\"1\":{\"972\":1}}],[\"这需要不断实践和总结\",{\"1\":{\"952\":1}}],[\"这需要投入大量时间与精力\",{\"1\":{\"948\":1}}],[\"这需要我继续学习和努力\",{\"1\":{\"940\":1}}],[\"这展现出你的自我认知能力\",{\"1\":{\"946\":1}}],[\"这无疑需要一段长期的学习与总结过程\",{\"1\":{\"946\":1}}],[\"这取决于应用的需求\",{\"1\":{\"946\":1}}],[\"这在技术面试中是很重要的一点\",{\"1\":{\"934\":1}}],[\"这肯定是个苦力活\",{\"1\":{\"934\":1}}],[\"这包括bootstrap\",{\"1\":{\"934\":1}}],[\"这一点很容易造成问题\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"这一点有些人是不知道的\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"这一整个过程是原子的\",{\"1\":{\"1018\":1}}],[\"这一过程实际上和cms非常相似\",{\"1\":{\"940\":1}}],[\"这一步可以有效提高性能\",{\"1\":{\"922\":1}}],[\"这一步可以减少hash冲突\",{\"1\":{\"922\":1}}],[\"这一步可以提高查询效率\",{\"1\":{\"922\":1}}],[\"这一步通过key的hashcode\",{\"1\":{\"922\":1}}],[\"这一节将结合计算机组成原理相关知识讨论b\",{\"1\":{\"271\":1}}],[\"这几年自媒体原来热\",{\"1\":{\"906\":1}}],[\"这端点是一个http接口\",{\"1\":{\"883\":1}}],[\"这部分的缓存也就越大\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"这部分可以过了\",{\"1\":{\"924\":1}}],[\"这部分包含了项目构建相关的信息\",{\"1\":{\"844\":1}}],[\"这部分定义了项目所依赖的其他项目\",{\"1\":{\"844\":1}}],[\"这部分定义了一些用于\",{\"1\":{\"844\":1}}],[\"这句需要再琢磨\",{\"1\":{\"764\":1}}],[\"这条命令的作用是\",{\"1\":{\"960\":1}}],[\"这条sql的意思是\",{\"1\":{\"727\":1}}],[\"这条在大多数业务场景不会使用到\",{\"1\":{\"541\":1}}],[\"这也为你成长为资深工程师奠定基础\",{\"1\":{\"946\":1}}],[\"这也使得我在研究这个课题上收获颇丰\",{\"1\":{\"940\":1}}],[\"这也使我有机会重温\",{\"1\":{\"922\":1}}],[\"这也太官方了吧\",{\"1\":{\"934\":1}}],[\"这也就是为什么运行mvn\",{\"1\":{\"713\":1}}],[\"这也是为什么泛型类不能有基本类型的参数的原因\",{\"1\":{\"966\":1}}],[\"这也是日常开发中经常使用的并发list\",{\"1\":{\"946\":1}}],[\"这也是它成为我最爱的map实现类的原因\",{\"1\":{\"948\":1}}],[\"这也是它成为java最常用的map实现的原因\",{\"1\":{\"922\":1}}],[\"这也是它能达到高性能的关键\",{\"1\":{\"940\":1}}],[\"这也是它被g1等收集器替代的原因之一\",{\"1\":{\"938\":1}}],[\"这也是我在日常使用中最欣赏arraylist的地方\",{\"1\":{\"946\":1}}],[\"这也是我在博客和公众号里常用的一种讲解方式\",{\"1\":{\"934\":1}}],[\"这也是我作为面试官最喜欢看到的\",{\"1\":{\"922\":1}}],[\"这也是\",{\"1\":{\"692\":1,\"952\":1}}],[\"这也是这门语言的特点\",{\"1\":{\"488\":1}}],[\"这地址可以在settings\",{\"1\":{\"702\":1}}],[\"这不是个别人能左右的\",{\"1\":{\"640\":1}}],[\"这五种类型的键的底层实现数据结构\",{\"1\":{\"619\":1}}],[\"这没有什么问题\",{\"1\":{\"602\":1}}],[\"这使得操作在主分片和副本分片都完成后才会返回\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"这使得\",{\"1\":{\"589\":1}}],[\"这使得索引无法有效定位数据\",{\"1\":{\"501\":1}}],[\"这类key\",{\"1\":{\"589\":1}}],[\"这将是一件多么美好的事情\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"这将导致这个不存在的数据每次请求都要到\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"这将导致引擎放弃使用索引而进行全表扫描\",{\"0\":{\"531\":1,\"532\":1},\"1\":{\"1192\":2,\"1375\":2}}],[\"这将设置一个插入意向锁\",{\"1\":{\"558\":1}}],[\"这将锁定id在1到10之间的所有行\",{\"1\":{\"556\":1}}],[\"这通常比\",{\"1\":{\"511\":1}}],[\"这会唤醒原来等待的线程\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"这会导致\",{\"1\":{\"954\":1}}],[\"这会导致性能开销增加\",{\"1\":{\"508\":1}}],[\"这会在当前分支生成两个对应的新提交\",{\"1\":{\"917\":1}}],[\"这会在当前分支产生一个新的提交\",{\"1\":{\"917\":1}}],[\"这会为查询结果中的每行添加排他锁\",{\"1\":{\"556\":1}}],[\"这会降低查询和连接的性能\",{\"0\":{\"538\":1}}],[\"这会降低并发性能\",{\"1\":{\"508\":1}}],[\"这会增加数据库在执行查询操作时的磁盘i\",{\"1\":{\"508\":1}}],[\"这意味着两者的开发可以并行进行\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"这意味着段的数量越多\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"这意味着在同一时间只有一个线程可以访问这些方法\",{\"1\":{\"1022\":1}}],[\"这意味着在同一时间只有一个线程可以访问该代码块\",{\"1\":{\"1022\":1}}],[\"这意味着在同一时间只有一个线程可以访问该方法\",{\"1\":{\"1022\":1}}],[\"这意味着在锁定期间\",{\"1\":{\"561\":1}}],[\"这意味着你可以轻松地找到各种工具和插件来扩展和定制你的kafka部署\",{\"1\":{\"978\":1}}],[\"这意味着你可以在\",{\"1\":{\"46\":1}}],[\"这意味着可以用任何二进制序列作为key值\",{\"1\":{\"602\":1}}],[\"这意味着即使数据分布极不均匀\",{\"1\":{\"503\":1}}],[\"这用于存储已经领取过空投的代币地址\",{\"1\":{\"488\":1}}],[\"这主要基于产品设计的方案\",{\"1\":{\"485\":1}}],[\"这三个方法都是用来协调线程间通信的\",{\"1\":{\"988\":1}}],[\"这三个家伙\",{\"1\":{\"956\":1}}],[\"这三个产品被设计成一个集成解决方案\",{\"1\":{\"400\":1}}],[\"这三套生命周期分别是\",{\"1\":{\"711\":1}}],[\"这三种排序算法都利用了桶的概念\",{\"1\":{\"370\":1}}],[\"这篇干货查漏补缺\",{\"1\":{\"844\":1}}],[\"这篇文章从\",{\"1\":{\"807\":1}}],[\"这篇文章可以跳过\",{\"1\":{\"701\":1}}],[\"这篇文章学习再来一起学习\",{\"1\":{\"698\":1}}],[\"这篇是附加篇\",{\"1\":{\"394\":1}}],[\"这篇主要讲解如何定义合适的位数组长度\",{\"1\":{\"339\":1}}],[\"这种范围确保不管接受多少请求\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"这种bean范围是默认的\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"这种情形就完全改变了\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"这种情况可以通过使用treemap来改进\",{\"1\":{\"922\":1}}],[\"这种情况如果出错\",{\"1\":{\"728\":1}}],[\"这种情况下\",{\"1\":{\"504\":1,\"1122\":1,\"1317\":1}}],[\"这种情况就对上面提到的出现了不确定情况\",{\"1\":{\"387\":1}}],[\"这种分区分段+索引的设计\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"这种分布式的架构使得kafka具备了高可用性和高吞吐量的特点\",{\"1\":{\"984\":1}}],[\"这种自动选主的机制保证了集群的高可用性和容错性\",{\"1\":{\"1008\":1}}],[\"这种有序列表的维护是通过zookeeper的顺序节点\",{\"1\":{\"1008\":1}}],[\"这种并行处理的方式使得kafka能够轻松应对高并发的场景\",{\"1\":{\"980\":1}}],[\"这种问答的形式确实是学习的好方法\",{\"1\":{\"966\":1}}],[\"这种委派机制可以避免重复加载\",{\"1\":{\"934\":1}}],[\"这种积极主动的学习态度很难得\",{\"1\":{\"922\":1}}],[\"这种方案的问题在于\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"这种方案成本很高\",{\"1\":{\"515\":1}}],[\"这种方式也可以做到很方便的分离多个环境\",{\"1\":{\"771\":1}}],[\"这种方法通过在select语句后增加for\",{\"1\":{\"578\":1}}],[\"这种方法通过尝试向一个表中插入具有唯一索引的记录来实现锁的获取\",{\"1\":{\"577\":1}}],[\"这种结构使得范围查询和顺序访问更加高效\",{\"1\":{\"503\":1}}],[\"这种排序算法不是基于元素比较\",{\"1\":{\"359\":1}}],[\"这点在正常情况下是不会发生的\",{\"1\":{\"387\":1}}],[\"这\",{\"1\":{\"387\":2}}],[\"这已经相当小了\",{\"1\":{\"339\":1}}],[\"这显然是不符合实际情况的\",{\"1\":{\"330\":1}}],[\"这就叫做缓存穿透\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"这就叫幻读\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"这就可能造成不同replica的响应不一致\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"这就像是你在书架上找一本书\",{\"1\":{\"1006\":1}}],[\"这就像是你在餐厅点菜的时候的两种方式\",{\"1\":{\"994\":1}}],[\"这就会产生数据丢失的问题\",{\"1\":{\"988\":1}}],[\"这就涉及到kafka的副本机制了\",{\"1\":{\"974\":1}}],[\"这就要涉及到spring\",{\"1\":{\"952\":1}}],[\"这就解释了为什么在主线程\",{\"1\":{\"692\":1}}],[\"这就解决了键冲突的问题\",{\"1\":{\"624\":1}}],[\"这就意味着集合中不能出现重复的数据\",{\"1\":{\"606\":1}}],[\"这就意味着b+树单次磁盘\",{\"1\":{\"270\":1}}],[\"这就是控制反转\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"这就是有人把ioc容器比喻成\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"这就是脏读\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"这就是双亲委派模式\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"这就是java中内存泄露的发生场景\",{\"1\":{\"1145\":1,\"1336\":1}}],[\"这就是漏洞\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"这就是elasticsearch索引文档的底层过程\",{\"1\":{\"1012\":1}}],[\"这就是为什么kafka能够实现高吞吐量和可伸缩性的原因之一\",{\"1\":{\"986\":1}}],[\"这就是类型不安全\",{\"1\":{\"966\":1}}],[\"这就是remembered\",{\"1\":{\"940\":1}}],[\"这就是初始化阶段\",{\"1\":{\"934\":1}}],[\"这就是解析阶段\",{\"1\":{\"934\":1}}],[\"这就是\",{\"1\":{\"624\":1,\"658\":1,\"692\":1,\"950\":1,\"1212\":1,\"1389\":1}}],[\"这就是我们提到的\",{\"1\":{\"988\":1}}],[\"这就是我们\",{\"1\":{\"536\":1}}],[\"这就是计数排序的基本过程\",{\"1\":{\"359\":1}}],[\"这就是leader在团队里的\",{\"1\":{\"153\":1}}],[\"这就和哈希表中哈希冲突的情况一样\",{\"1\":{\"333\":1,\"339\":1}}],[\"这就好比我们今天进行现金的流通最小单位是一毛\",{\"1\":{\"272\":1}}],[\"这就时b+树在一次io里面\",{\"1\":{\"270\":1}}],[\"这说明你对收集器的认知已逐步深入\",{\"1\":{\"940\":1}}],[\"这说明你在学习和工作中确实遇到过一定的困惑\",{\"1\":{\"922\":1}}],[\"这说明b\",{\"1\":{\"267\":1}}],[\"这说明程序大部分时间会阻塞在磁盘\",{\"1\":{\"266\":1}}],[\"这行日志就会抛空指针异常\",{\"1\":{\"193\":1}}],[\"这些datasource可能是不同的数据库\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"这些对象类通过封装以\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"这些对象包含了从\",{\"1\":{\"635\":1}}],[\"这些齿轮相互啮合在一起\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"这些算是java基础\",{\"1\":{\"1123\":1,\"1318\":1}}],[\"这些元素的查询效率就会从o\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"这些类型和它们所支持的类在java\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"这些类使用了更高效的同步机制\",{\"1\":{\"1022\":1}}],[\"这些文档可能来自和最初搜索请求有关的一个\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"这些被\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"这些请求发现缓存过期一般都会从\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"这些组件共同构成了\",{\"1\":{\"1020\":1}}],[\"这些知识点确实对并发编程来说是基础中的基础\",{\"1\":{\"1018\":1}}],[\"这些知识点解释的很透彻\",{\"1\":{\"988\":1}}],[\"这些知识对于刚入行的技术人员来说非常重要\",{\"1\":{\"992\":1}}],[\"这些内容对我以后的学习和工作会很有帮助\",{\"1\":{\"988\":1}}],[\"这些概念我都知道\",{\"1\":{\"986\":1}}],[\"这些是kafka的一些缺点\",{\"1\":{\"978\":1}}],[\"这些是我进阶jvm调优所制定的学习计划\",{\"1\":{\"942\":1}}],[\"这些又是常见的面试重点\",{\"1\":{\"952\":1}}],[\"这些点精彩极了\",{\"1\":{\"952\":1}}],[\"这些方法的调用是在\",{\"1\":{\"952\":2}}],[\"这些方法分别对应着获取锁\",{\"1\":{\"932\":1}}],[\"这些方面搭配得当\",{\"1\":{\"950\":1}}],[\"这些都是非常重要的多线程知识点\",{\"1\":{\"988\":1}}],[\"这些都是非常有用的建议\",{\"1\":{\"972\":1}}],[\"这些都是非常实用的技巧\",{\"1\":{\"972\":1}}],[\"这些都是成为一名优秀工程师必不可少的素质\",{\"1\":{\"948\":1}}],[\"这些都是我想继续学习与理解的map相关内容\",{\"1\":{\"948\":1}}],[\"这些都是我想进一步学习与理解的list相关内容与知识点\",{\"1\":{\"946\":1}}],[\"这些都是g1高性能与低停顿的关键\",{\"1\":{\"940\":1}}],[\"这些aop注解通过在方法上标记\",{\"1\":{\"944\":1}}],[\"这些注解的作用和spring差不多\",{\"1\":{\"944\":1}}],[\"这些注解大大简化了spring的配置\",{\"1\":{\"944\":1}}],[\"这些参数和工具在我日常工作的jvm调优和问题排查中发挥了很大作用\",{\"1\":{\"942\":1}}],[\"这些思想为我们设计低停顿\",{\"1\":{\"938\":1}}],[\"这些空隙会产生空间碎片\",{\"1\":{\"938\":1}}],[\"这些关于类的生命周期和初始化阶段的知识点对我来说均很重要\",{\"1\":{\"934\":1}}],[\"这些设置只在类第一次被加载时执行\",{\"1\":{\"934\":1}}],[\"这些测试代码不会被打包或部署\",{\"1\":{\"713\":1}}],[\"这些连接准备好被任何需要它们的线程使用\",{\"1\":{\"645\":1}}],[\"这些数据类型都支持push\",{\"1\":{\"589\":1}}],[\"这些加锁规则共同作用\",{\"1\":{\"575\":1}}],[\"这些行为确保在执行涉及外键的插入或更新操作时\",{\"1\":{\"560\":1}}],[\"这些原则都是原则上建议\",{\"1\":{\"537\":1}}],[\"这些库可以分布在不同服务器\",{\"1\":{\"520\":2}}],[\"这些库可以放在不同的存储设备上\",{\"1\":{\"516\":1}}],[\"这些树在一般情况下查询性能非常好\",{\"1\":{\"266\":1}}],[\"这些比较低的日志级别\",{\"1\":{\"195\":1}}],[\"这些新变更可能影响用户的\",{\"1\":{\"181\":1}}],[\"这些命令大学生都会\",{\"0\":{\"90\":1}}],[\"这里以\",{\"1\":{\"1444\":1}}],[\"这里选用\",{\"1\":{\"1443\":1}}],[\"这里选取3台机器组成的服务器集群为例\",{\"1\":{\"166\":1}}],[\"这里可以根据异常类型返回不同的错误状态码和消息\",{\"1\":{\"1431\":1}}],[\"这里可以看出\",{\"1\":{\"273\":1}}],[\"这里采用的就是顺序读写\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"这里简单提一下\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"这里说一个通俗的解答方式\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"这里不做源码层面解读\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"这里不需要写\",{\"1\":{\"827\":1}}],[\"这里\",{\"1\":{\"988\":1}}],[\"这里我们可以借助\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"这里我们指定t必须是number或其子类型\",{\"1\":{\"966\":1}}],[\"这里我们下载\",{\"1\":{\"597\":1}}],[\"这里通过讲解\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"这里通过\",{\"1\":{\"958\":1}}],[\"这里有一篇生产环境使用volatile的例子\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"这里有一个简单的java代码示例\",{\"1\":{\"984\":1}}],[\"这里有几个方面可以进一步加深对\",{\"1\":{\"952\":1}}],[\"这里有几点建议\",{\"1\":{\"950\":1}}],[\"这里有个自定义注解的示例\",{\"1\":{\"944\":1}}],[\"这里主要以我的经验给大家一个参照\",{\"1\":{\"920\":1}}],[\"这里主要说关于动态扩容\",{\"1\":{\"342\":1}}],[\"这里还是用一个开源的流程文件\",{\"1\":{\"865\":1}}],[\"这里比较重要的一点是\",{\"1\":{\"844\":1}}],[\"这里建议使用阿里云的镜像\",{\"1\":{\"838\":1}}],[\"这里对前端代码只写较少部分\",{\"1\":{\"832\":1}}],[\"这里演示预约图书业务\",{\"1\":{\"830\":1}}],[\"这里为什么要给方法的参数添加\",{\"1\":{\"826\":1}}],[\"这里为4095\",{\"1\":{\"388\":1}}],[\"这里使用了\",{\"1\":{\"1431\":1}}],[\"这里使用了插入排序\",{\"1\":{\"352\":1}}],[\"这里使用的是\",{\"1\":{\"811\":1}}],[\"这里关闭\",{\"1\":{\"790\":1}}],[\"这里所谓的mapper接口路径\",{\"1\":{\"772\":1}}],[\"这里所说的客户端不是用户连接zookeeper服务器的客户端\",{\"1\":{\"157\":1}}],[\"这里必须是接口的全路径名\",{\"1\":{\"763\":1}}],[\"这里是字面描述\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"这里是一个经典的生产者消费者模型来解释这三个方法\",{\"1\":{\"988\":1}}],[\"这里是\",{\"1\":{\"956\":1,\"1429\":1}}],[\"这里是用户id\",{\"1\":{\"747\":2}}],[\"这里是通过userid修改userstatus\",{\"1\":{\"724\":1}}],[\"这里是否放弃使用索引取决于\",{\"1\":{\"527\":1}}],[\"这里数据库中存储了下划线式\",{\"1\":{\"724\":1}}],[\"这里经常用到的是site阶段和site\",{\"1\":{\"714\":1}}],[\"这里其实应该使用\",{\"1\":{\"689\":1}}],[\"这里实现了对自定义注解的环绕增强切点\",{\"1\":{\"689\":1}}],[\"这里基于\",{\"1\":{\"664\":1}}],[\"这里返回了包含详细信息的输出\",{\"1\":{\"581\":1}}],[\"这里指定了空投合约拥有者地址和发型代币总数\",{\"1\":{\"488\":1}}],[\"这里会涉及到一些运营的知识\",{\"1\":{\"483\":1}}],[\"这里只介绍\",{\"1\":{\"408\":1}}],[\"这里提供一种解决思路\",{\"1\":{\"387\":1}}],[\"这里称为两个桶\",{\"1\":{\"348\":1}}],[\"这里没有调用addelem来添加元素\",{\"1\":{\"286\":1}}],[\"这里将其简化成一个二维地址\",{\"1\":{\"273\":1}}],[\"这里本文抛却具体差别\",{\"1\":{\"273\":1}}],[\"这里的文章是整个项目中要用到的知识重点\",{\"1\":{\"1429\":1}}],[\"这里的数值想想都有很多\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"这里的事件很广泛\",{\"1\":{\"1034\":1}}],[\"这里的心酸😔\",{\"1\":{\"917\":1}}],[\"这里的的开始时间截\",{\"1\":{\"388\":1}}],[\"这里的线性指逻辑上的\",{\"1\":{\"282\":1}}],[\"这里的\",{\"1\":{\"263\":1,\"770\":1,\"844\":1}}],[\"这里zookeeper就可以很方便的实现类似的功能\",{\"1\":{\"162\":1}}],[\"这时可以选择更高效的序列化工具\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"这时我们也可以打破死锁的那个闭环\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"这时需要额外采取其他措施解决\",{\"1\":{\"1018\":1}}],[\"这时线程b利用cas把节点从a改成c\",{\"1\":{\"1018\":1}}],[\"这时已经错失了一次更改的机会\",{\"1\":{\"1018\":1}}],[\"这时另一个线程在读或添加元素\",{\"1\":{\"988\":1}}],[\"这时发现b项目没有依赖slf4j\",{\"1\":{\"708\":1}}],[\"这时的\",{\"1\":{\"692\":1}}],[\"这时程序将\",{\"1\":{\"625\":1}}],[\"这时就需要锁来保证谁拥有这件商品\",{\"1\":{\"553\":1}}],[\"这时就会涉及到zookeeper的其他几点特性\",{\"1\":{\"153\":1}}],[\"这时有人来拜访看到已上锁\",{\"1\":{\"553\":1}}],[\"这时候是使用不到一级缓存的\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"这时候我们要使用cookie+数据库的方式实现\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"这时候静态方法已经创建完了\",{\"1\":{\"966\":1}}],[\"这时候\",{\"1\":{\"924\":1,\"1212\":1,\"1389\":1}}],[\"这时候就需要进行水平分库了\",{\"1\":{\"518\":1}}],[\"这时候整个数列已经排序完毕\",{\"1\":{\"375\":1}}],[\"这时\",{\"1\":{\"364\":1,\"664\":1,\"917\":1}}],[\"这时leader们信息还没有同步\",{\"1\":{\"153\":1}}],[\"这时会返回502错误\",{\"1\":{\"106\":1}}],[\"这隐藏了\",{\"1\":{\"143\":1}}],[\"这样有利于检查所依赖属性是否注入\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"这样比起原来的sqlsession提供的方法我们可以有更加灵活的选择和设置\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"这样基本能满足消息的顺序性的需求\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"这样该副本被认为故障\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"这样至少能有两个好处\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"这样我们可以并行处理数据\",{\"1\":{\"1004\":1}}],[\"这样我们就可以在\",{\"1\":{\"952\":1}}],[\"这样一来\",{\"1\":{\"986\":1,\"996\":1}}],[\"这样一次就能排除四分之三的数据\",{\"1\":{\"263\":1}}],[\"这样直接调用\",{\"1\":{\"958\":1}}],[\"这样只有在\",{\"1\":{\"954\":1}}],[\"这样在堆中的对象的值就产生变化了\",{\"1\":{\"692\":1}}],[\"这样列表永远为n个id\",{\"1\":{\"594\":1}}],[\"这样做能小幅提升性能\",{\"1\":{\"520\":1}}],[\"这样做的理论依据是计算机科学中著名的局部性原理\",{\"1\":{\"274\":1}}],[\"这样既能保证重启时的速度\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"这样既能使业务清晰\",{\"1\":{\"520\":1}}],[\"这样既降低误判发生的概率\",{\"1\":{\"339\":1}}],[\"这样表中字段长度较短且访问频率较高\",{\"1\":{\"516\":1}}],[\"这样\",{\"1\":{\"503\":1,\"504\":1,\"558\":1,\"918\":1,\"924\":1,\"984\":2,\"996\":1,\"1004\":2,\"1006\":2,\"1012\":1,\"1051\":1,\"1212\":1,\"1218\":2,\"1260\":1,\"1389\":1,\"1395\":2}}],[\"这样可以避免在网络上频繁传输单个消息带来的延迟和带宽开销\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"这样可以避免系统表的较长时间锁定\",{\"0\":{\"543\":1}}],[\"这样可以大大提高服务器的并发性能\",{\"1\":{\"1020\":2}}],[\"这样可以提高数据的可用性和容错性\",{\"1\":{\"1012\":1}}],[\"这样可以提高搜索的准确性和效率\",{\"1\":{\"1012\":1}}],[\"这样可以确保具有相同路由值的文档被索引到同一个分片中\",{\"1\":{\"1012\":1}}],[\"这样可以确保我们的缓存始终保持在一个合理的大小\",{\"1\":{\"972\":1}}],[\"这样可以一次性获取更多的消息\",{\"1\":{\"982\":1}}],[\"这样可以一次性获取更多的数据\",{\"1\":{\"982\":1}}],[\"这样可以减少网络传输的次数\",{\"1\":{\"982\":1}}],[\"这样可以减少不必要的数据访问\",{\"1\":{\"504\":1}}],[\"这样可以保证\",{\"1\":{\"962\":1}}],[\"这样可以在一个索引中完成查询\",{\"1\":{\"504\":1}}],[\"这样可以使得每个节点包含更多的键值对\",{\"1\":{\"503\":1}}],[\"这样可以比read系统调用少一次内存拷贝\",{\"1\":{\"403\":1}}],[\"这样可以最大限度防止\",{\"1\":{\"387\":1}}],[\"这样可以节省双方时间\",{\"1\":{\"175\":1}}],[\"这样从最低位排序一直到最高位排序完成以后\",{\"1\":{\"374\":1}}],[\"这样会得到n个元素的次小值\",{\"1\":{\"364\":1}}],[\"这样显然无法进行计数排序\",{\"1\":{\"361\":1}}],[\"这样就实现了\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"这样就实现了一个节点只需要一次\",{\"1\":{\"266\":1}}],[\"这样就会影响集群的负载均衡\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"这样就会在满足条件的行上加上排他锁\",{\"1\":{\"578\":1}}],[\"这样就打破了死锁的闭环\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"这样就无法形成导致死锁的那个闭环\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"这样就能保证高可用性了\",{\"1\":{\"986\":1}}],[\"这样就能保证消息的顺序性\",{\"1\":{\"984\":1}}],[\"这样就成功的撤销了你的\",{\"1\":{\"918\":1}}],[\"这样就为配置提供了诸多灵活选择\",{\"1\":{\"766\":1}}],[\"这样就形成了\",{\"1\":{\"288\":1}}],[\"这样就不能获取到客户的ip地址了\",{\"1\":{\"106\":1}}],[\"这样逻辑上很近的节点实际可能非常远\",{\"1\":{\"266\":1}}],[\"这样的好处是\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"这样的唤醒肯定不会阻塞\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"这样的动态\",{\"1\":{\"958\":1}}],[\"这样的话搜索速度真的会快很多\",{\"1\":{\"1006\":1}}],[\"这样的话\",{\"1\":{\"271\":1,\"1088\":1,\"1289\":1}}],[\"这样的分支条件\",{\"1\":{\"200\":1}}],[\"这样的系统\",{\"1\":{\"153\":1}}],[\"这样每个访客固定访问一个后端服务器\",{\"1\":{\"106\":1}}],[\"这块是比较重要一块\",{\"1\":{\"106\":1}}],[\"这俩个不太理解\",{\"1\":{\"106\":1}}],[\"这个配置会将执行的sql打印出来\",{\"1\":{\"1444\":1}}],[\"这个系统作为用户管理\",{\"1\":{\"1439\":1}}],[\"这个字段是为了更规范而加的\",{\"1\":{\"1431\":1}}],[\"这个字段也可以被索引\",{\"1\":{\"431\":1}}],[\"这个毋庸置疑\",{\"1\":{\"1431\":1}}],[\"这个队列才可用\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"这个队列是一个排序好的top\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"这个之前也有提过\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"这个名称的由来\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"这个概念\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"这个概念叫做误算率\",{\"1\":{\"333\":1,\"339\":1}}],[\"这个需要掌握redis底层的数据结构\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"这个需要根据你系统平台的实际情况选择\",{\"1\":{\"597\":1}}],[\"这个操作会放到rollback\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"这个操作有什么用\",{\"1\":{\"603\":1}}],[\"这个方案的问题很明显\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"这个方法就是最终方法\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"这个方法听起来很厉害\",{\"1\":{\"982\":1}}],[\"这个方法听起来很简单有效\",{\"1\":{\"982\":1}}],[\"这个方法可以传递\",{\"1\":{\"966\":1}}],[\"这个方法可以传递任何类型的box进来\",{\"1\":{\"966\":1}}],[\"这个参数有三个值\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"这个参数用来指定分区中有多少个副本收到这条消息\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"这个问题给一个官方答案\",{\"1\":{\"1200\":1,\"1380\":1}}],[\"这个问题主要是对比jdbc来看\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"这个问题设计的点比较多\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"这个问题要先了解上一个问题的概念\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"这个问题单独一篇\",{\"1\":{\"1151\":1}}],[\"这个问题大概率会引出以下问题\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"这个阶段的停顿时间通常会比初始标记阶段稍长一些\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"这个阶段的主要任务仅仅只是标记出\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"这个可能不是要考察的点\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"这个可以玩儿很多的花样\",{\"1\":{\"657\":1}}],[\"这个可以根据你的系统分页大小来设置\",{\"1\":{\"106\":2}}],[\"这个newinstance方法调用无参的构造函数创建对象\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"这个query会被广播到索引里面的每一个shard\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"这个从\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"这个大家应该不陌生\",{\"1\":{\"1033\":1}}],[\"这个示例代码实现了一个简单的聊天室应用\",{\"1\":{\"1020\":1}}],[\"这个示例代码中\",{\"1\":{\"928\":1}}],[\"这个底层过程非常重要\",{\"1\":{\"1012\":1}}],[\"这个查询会返回所有内容中包含\",{\"1\":{\"998\":1}}],[\"这个查询将使用索引\",{\"1\":{\"530\":1}}],[\"这个设计真巧妙\",{\"1\":{\"996\":1}}],[\"这个机制实现依赖于wait\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"这个机制非常重要\",{\"1\":{\"994\":1}}],[\"这个机制可以确保你的消息在传递过程中不会丢失\",{\"1\":{\"994\":1}}],[\"这个机制对于我在实际工作中有什么帮助呢\",{\"1\":{\"994\":1}}],[\"这个批量发送消息的方法听起来很实用\",{\"1\":{\"982\":1}}],[\"这个比喻很形象\",{\"1\":{\"974\":1,\"976\":1}}],[\"这个接口可以监听\",{\"1\":{\"952\":2}}],[\"这个接口只有一个方法\",{\"1\":{\"952\":1}}],[\"这个解释我喜欢\",{\"1\":{\"934\":1}}],[\"这个专题\",{\"1\":{\"920\":1}}],[\"这个为默认参数\",{\"1\":{\"918\":1}}],[\"这个时候需要红黑树来保证性能\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"这个时候线程a就会抛出并发修改异常\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"这个时候\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"这个时候就需要\",{\"1\":{\"1033\":1}}],[\"这个时候有两种命令可选\",{\"1\":{\"916\":1}}],[\"这个时候进行bug修复提交\",{\"1\":{\"916\":1}}],[\"这个时候还没有修改完\",{\"1\":{\"916\":1}}],[\"这个时间可以用于计算对象的\",{\"1\":{\"636\":1}}],[\"这个工具可以方便的在本地调试预览网站\",{\"1\":{\"909\":1}}],[\"这个教程必要做到保姆级\",{\"1\":{\"906\":1}}],[\"这个app\",{\"1\":{\"850\":1}}],[\"这个其实可选\",{\"1\":{\"827\":1}}],[\"这个例子中的\",{\"1\":{\"766\":1}}],[\"这个的clean是clean生命周期的一个阶段\",{\"1\":{\"712\":1}}],[\"这个统一的位置\",{\"1\":{\"705\":1}}],[\"这个代码有很明显的问题\",{\"1\":{\"664\":1}}],[\"这个邮件服务是一个死循环\",{\"1\":{\"664\":1}}],[\"这个对象里的某个字段值\",{\"1\":{\"654\":1}}],[\"这个对象不可以在嵌套其他对象\",{\"1\":{\"654\":1}}],[\"这个数组以有序\",{\"1\":{\"630\":1}}],[\"这个结构带有表头节点指针\",{\"1\":{\"622\":1}}],[\"这个不能和专业的消息中间件相比\",{\"1\":{\"594\":1}}],[\"这个表展示了哪些事务被锁定\",{\"1\":{\"580\":1}}],[\"这个要根据业务场景来选择锁\",{\"1\":{\"573\":1}}],[\"这个\",{\"0\":{\"1175\":1,\"1360\":1},\"1\":{\"571\":1,\"960\":1,\"1049\":1,\"1232\":1,\"1258\":1,\"1407\":1}}],[\"这个在项目中使用频率较高\",{\"1\":{\"710\":1}}],[\"这个在上面的例子中有提到过\",{\"1\":{\"571\":1}}],[\"这个在评论中会再出一篇参考文章\",{\"1\":{\"387\":1}}],[\"这个命令只在键\",{\"1\":{\"960\":1}}],[\"这个命令用于设置\",{\"1\":{\"960\":1}}],[\"这个命令有什么作用\",{\"1\":{\"960\":1}}],[\"这个命令的作用是给指定的\",{\"1\":{\"960\":1}}],[\"这个命令也会尝试优化表\",{\"1\":{\"511\":1}}],[\"这个命令很有用\",{\"1\":{\"91\":1}}],[\"这个玩法从诞生起就很适合传播\",{\"1\":{\"483\":1}}],[\"这个属性用于将当前字段拷贝到指定字段\",{\"1\":{\"436\":1}}],[\"这个属性现在使用很少\",{\"1\":{\"435\":1}}],[\"这个文档可以被索引进\",{\"1\":{\"431\":1}}],[\"这个文档包含一个字段\",{\"1\":{\"431\":1}}],[\"这个文件即被称之为倒排文件\",{\"1\":{\"424\":1}}],[\"这个信息在搜索结果排序计算中是非常重要的一个因子\",{\"1\":{\"425\":1}}],[\"这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数\",{\"1\":{\"388\":1}}],[\"这个漏洞曾被用于寻找梅丽莎病毒的制作者位置\",{\"1\":{\"385\":1}}],[\"这个就是布隆过滤器的特点\",{\"1\":{\"334\":1}}],[\"这个过程耗时较长但是不需要停顿用户线程\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"这个过程耗费的时间叫做旋转时间\",{\"1\":{\"274\":1}}],[\"这个过程称为擦除\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"这个过程叫做\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"这个过程叫做寻道\",{\"1\":{\"274\":1}}],[\"这个过程是自动的\",{\"1\":{\"1008\":1}}],[\"这个过程可能会导致一些数据迁移的延迟\",{\"1\":{\"968\":1}}],[\"这个过程就是准备阶段\",{\"1\":{\"934\":1}}],[\"这个过程就称为回表查询\",{\"1\":{\"504\":1}}],[\"这个很好理解\",{\"1\":{\"270\":1}}],[\"这个账号的定位是写软文\",{\"1\":{\"225\":1}}],[\"这个价格很低\",{\"1\":{\"212\":1}}],[\"这个端口就是客户端连接zookeeper服务器的端口\",{\"1\":{\"157\":1}}],[\"这个必须要根据提示要求进行设置\",{\"1\":{\"145\":1}}],[\"这个项目最早由fabrice\",{\"1\":{\"122\":1}}],[\"这个是扫描所有jar包类路径下\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"这个是开发时自定义的\",{\"1\":{\"844\":1}}],[\"这个是大多数系统的通病\",{\"1\":{\"540\":1}}],[\"这个是不常用的\",{\"1\":{\"136\":1}}],[\"这个是较长使用的配置\",{\"1\":{\"106\":1}}],[\"这个是指多长时间检查一次缓存的有效信息\",{\"1\":{\"106\":1}}],[\"这个指令指定是否在搜索一个文件时记录cache错误\",{\"1\":{\"106\":1}}],[\"这个指令指定了在open\",{\"1\":{\"106\":1}}],[\"这个指令指定了何时需要检查open\",{\"1\":{\"106\":1}}],[\"这个指令是指当一个nginx进程打开的最多文件描述符数目\",{\"1\":{\"106\":1}}],[\"这个将为打开文件指定缓存\",{\"1\":{\"106\":1}}],[\"这是为了定一个统一的规范\",{\"1\":{\"1431\":1}}],[\"这是协同工作的基础\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"这是乐观锁最常用的一种实现方式\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"这是hashmap的作者根据概率论的知识得到的\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"这是你一定会被问\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"这是我们就需要重写\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"这是我们可以通过显式mapping的方式来解决\",{\"1\":{\"438\":1}}],[\"这是在\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"这是学以致用的好例子\",{\"1\":{\"1018\":1}}],[\"这是kafka的源码示例\",{\"1\":{\"992\":1}}],[\"这是kafka\",{\"1\":{\"986\":1}}],[\"这是个\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"这是个好问题\",{\"1\":{\"984\":1}}],[\"这是个不错的入门\",{\"1\":{\"942\":1}}],[\"这是两者的主要区别\",{\"1\":{\"966\":1}}],[\"这是java集合的基础\",{\"1\":{\"946\":1}}],[\"这是它的重要创新点\",{\"1\":{\"940\":1}}],[\"这是它的核心优雅与高效之处\",{\"1\":{\"922\":1}}],[\"这是通过哈希算法实现的\",{\"1\":{\"922\":1}}],[\"这是通俗易懂的\",{\"1\":{\"657\":1}}],[\"这是maven相当强大的功能\",{\"1\":{\"714\":1}}],[\"这是maven很重要的一个规则\",{\"1\":{\"712\":1}}],[\"这是后这个锁就永久无法释放了\",{\"1\":{\"664\":1}}],[\"这是\",{\"1\":{\"591\":1,\"952\":1,\"960\":1}}],[\"这是一道涉猎很广泛的题目\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"这是一次非常有价值的交流\",{\"1\":{\"922\":1}}],[\"这是一套科学的约定\",{\"1\":{\"702\":1}}],[\"这是一篇文档型文章\",{\"1\":{\"698\":1}}],[\"这是一些redis介绍\",{\"1\":{\"589\":1}}],[\"这是一个很大的话题\",{\"1\":{\"1439\":1}}],[\"这是一个很好的观点\",{\"1\":{\"972\":1}}],[\"这是一个很好的问题\",{\"1\":{\"968\":1}}],[\"这是一个基础问题\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"这是一个基本概念的题目\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"这是一个简单的python代码示例\",{\"1\":{\"970\":1}}],[\"这是一个具有rfc标准的uuid\",{\"1\":{\"385\":1}}],[\"这是一个档案主页的案例\",{\"1\":{\"6\":1}}],[\"这是sql\",{\"1\":{\"542\":1}}],[\"这是因为hashmap采用开放定址法来解决冲突\",{\"1\":{\"922\":1}}],[\"这是因为\",{\"1\":{\"922\":1,\"938\":1,\"1219\":1,\"1396\":1}}],[\"这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符\",{\"1\":{\"538\":1}}],[\"这是因为以\",{\"1\":{\"501\":1}}],[\"这是因为nginx调度时分配请求到进程并不是那么的均衡\",{\"1\":{\"106\":1}}],[\"这是目前使用较多分布式id解决方案\",{\"1\":{\"386\":1}}],[\"这是就要考验我的接口是否规范化\",{\"1\":{\"175\":1}}],[\"这是对我最大的鼓励\",{\"1\":{\"49\":1}}],[\"标识共有7条消息\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"标准误差为\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"标准化的\",{\"1\":{\"699\":1}}],[\"标记无用对象\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"标记有用对象\",{\"1\":{\"1146\":1,\"1337\":1}}],[\"标记字会被清除\",{\"1\":{\"1022\":1}}],[\"标记一个切面\",{\"1\":{\"944\":1}}],[\"标记dao\",{\"1\":{\"944\":1}}],[\"标记这个控制器直接返回json或xml数据\",{\"1\":{\"944\":1}}],[\"标记这个类是配置类\",{\"1\":{\"944\":1}}],[\"标记这个类是springboot的主配置类\",{\"1\":{\"944\":1}}],[\"标记配置类\",{\"1\":{\"944\":1}}],[\"标记数据访问组件\",{\"1\":{\"944\":1}}],[\"标记控制层组件\",{\"1\":{\"944\":1}}],[\"标记业务层组件\",{\"1\":{\"944\":1}}],[\"标记和清除过程需要占用cpu资源\",{\"1\":{\"938\":1}}],[\"标记\",{\"1\":{\"936\":1,\"940\":7,\"1092\":1,\"1144\":2,\"1146\":2,\"1293\":1,\"1335\":2,\"1337\":2}}],[\"标记gc\",{\"1\":{\"936\":1,\"940\":1}}],[\"标记的sql语句中的\",{\"1\":{\"801\":1}}],[\"标记方法\",{\"1\":{\"689\":1}}],[\"标签中添加\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"标签实现了动态条件查询\",{\"1\":{\"958\":1}}],[\"标签内部\",{\"1\":{\"776\":1,\"777\":1,\"778\":1}}],[\"标签包裹的部分的前面或者后面添加内容\",{\"1\":{\"724\":1}}],[\"标签为\",{\"1\":{\"44\":1}}],[\"标题\",{\"1\":{\"175\":1}}],[\"标题会被视为页面标题\",{\"1\":{\"43\":1}}],[\"标题和页面信息\",{\"1\":{\"23\":1}}],[\"日常业务中\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"日常工作用的最多哪些jvm参数和监控工具\",{\"1\":{\"942\":1}}],[\"日期类型\",{\"0\":{\"445\":1},\"1\":{\"442\":1}}],[\"日期\",{\"1\":{\"182\":1}}],[\"日志记录等\",{\"1\":{\"1133\":1,\"1217\":1,\"1326\":1,\"1394\":1}}],[\"日志\",{\"0\":{\"750\":1,\"821\":1},\"1\":{\"394\":1,\"789\":2,\"790\":1,\"812\":1},\"2\":{\"202\":1,\"203\":1}}],[\"日志一定要携带业务信息相关内容\",{\"1\":{\"201\":1}}],[\"日志链路\",{\"0\":{\"201\":1}}],[\"日志尽量使用英文\",{\"0\":{\"199\":1}}],[\"日志级别\",{\"1\":{\"198\":1}}],[\"日志是我们定位问题的得力助手\",{\"1\":{\"190\":1}}],[\"日志打印的11条建议\",{\"0\":{\"189\":1},\"1\":{\"189\":1}}],[\"日志存放的位置\",{\"1\":{\"157\":1}}],[\"日志格式设定\",{\"1\":{\"106\":1}}],[\"日志位置和日志级别\",{\"1\":{\"106\":1}}],[\"日\",{\"1\":{\"44\":1}}],[\"月份打卡次数\",{\"1\":{\"658\":1}}],[\"月\",{\"1\":{\"44\":1,\"658\":1}}],[\"的集中式管理和数据的动态更新\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"的集群架构\",{\"0\":{\"1068\":1,\"1272\":1}}],[\"的典型应用场景\",{\"0\":{\"1244\":1,\"1417\":1}}],[\"的报错\",{\"1\":{\"1238\":1,\"1411\":1}}],[\"的同步操作对开发人员而言是透明的\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"的同学都会用到的三件套\",{\"1\":{\"1443\":1}}],[\"的同学都会用\",{\"1\":{\"844\":1}}],[\"的同学\",{\"1\":{\"652\":1}}],[\"的启动\",{\"1\":{\"1230\":1,\"1405\":1}}],[\"的配置\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"的配置一般连续或相近\",{\"1\":{\"387\":1}}],[\"的情况下\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"的情况更加是几乎不可能的事\",{\"1\":{\"387\":1}}],[\"的历史难题\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"的由来\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"的认为拿锁多半是会成功的\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"的认为获取锁是非常有可能失败的\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"的环境等配置信息构建会话工厂\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"的运行环境等信息\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"的运用\",{\"1\":{\"1018\":1}}],[\"的功能\",{\"1\":{\"1177\":2,\"1362\":2}}],[\"的功能更加丰富\",{\"1\":{\"1045\":1,\"1254\":1}}],[\"的恢复将会增加约\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"的元数据信息用于初始化数据\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"的元素加\",{\"1\":{\"359\":2}}],[\"的增多\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"的可靠性是怎么保证的\",{\"0\":{\"1163\":1,\"1351\":1}}],[\"的消息是有序的\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"的消息内容是不相同的\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"的进度时\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"的每个分区都有若干个副本\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"的每秒请求数\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"的架构是怎么样的\",{\"0\":{\"1159\":1,\"1347\":1}}],[\"的直接关联对象开始遍历整个对象图的过程\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"的作用\",{\"0\":{\"1143\":1,\"1334\":1},\"1\":{\"1212\":1,\"1389\":1}}],[\"的作用域之间有什么区别\",{\"0\":{\"1215\":1,\"1392\":1}}],[\"的作用域\",{\"1\":{\"952\":1}}],[\"的作用域有\",{\"1\":{\"952\":1}}],[\"的作用域都有哪些\",{\"1\":{\"952\":1}}],[\"的组件\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"的拦截器与\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"的新实例时\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"的全局配置文件\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"的全过程\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"的全称是\",{\"1\":{\"962\":1}}],[\"的全称叫\",{\"1\":{\"422\":1}}],[\"的查询效率\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"的做法是用链表和红黑树存储相同\",{\"1\":{\"1116\":1,\"1311\":1}}],[\"的要高\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"的键和值都允许有\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"的角色\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"的著名算法\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"的公共汽车上\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"的必要性\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"的对象\",{\"1\":{\"1084\":1,\"1217\":1,\"1285\":1,\"1394\":1}}],[\"的对象系统带有引用计数实现的\",{\"1\":{\"636\":1}}],[\"的保留关键字\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"的聚合如何实现\",{\"0\":{\"1077\":1,\"1281\":1}}],[\"的被删除\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"的本地有序优先队列中\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"的空优先队列\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"的空间大小\",{\"1\":{\"659\":1}}],[\"的选主是\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"的倒排索引是什么\",{\"0\":{\"1069\":1,\"1273\":1}}],[\"的操作\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"的性能要比\",{\"1\":{\"1045\":1,\"1254\":1}}],[\"的读取压力\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"的读写性能好很多\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"的热点数据\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"的介质中\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"的介质的数据保存在读写速度\",{\"1\":{\"1042\":1,\"1251\":1}}],[\"的请求\",{\"1\":{\"1033\":1}}],[\"的请求处理流程\",{\"1\":{\"956\":1}}],[\"的请求处理流程示意图\",{\"1\":{\"956\":1}}],[\"的请求处理流程你能画一个示意图来表示一下吗\",{\"1\":{\"956\":1}}],[\"的异步还是基于多路复用的\",{\"1\":{\"1031\":1}}],[\"的应用场景非常广泛\",{\"1\":{\"1020\":1}}],[\"的应用场景吗\",{\"1\":{\"1020\":1}}],[\"的应用程序更高效\",{\"1\":{\"950\":1}}],[\"的特点主要有以下几点\",{\"1\":{\"1020\":1}}],[\"的特点吗\",{\"1\":{\"1020\":1}}],[\"的了解\",{\"1\":{\"1020\":1}}],[\"的了解非常深入\",{\"1\":{\"928\":1}}],[\"的用处是什么\",{\"1\":{\"1018\":1}}],[\"的用户\",{\"1\":{\"785\":2}}],[\"的用户在\",{\"1\":{\"658\":1}}],[\"的用户中心信息时\",{\"1\":{\"177\":1}}],[\"的原子指令\",{\"1\":{\"1018\":1}}],[\"的原理其实很简单\",{\"1\":{\"928\":1}}],[\"的原理是什么\",{\"1\":{\"928\":1}}],[\"的反射机制和动态生成字节码技术\",{\"1\":{\"1016\":1}}],[\"的索引\",{\"1\":{\"998\":1}}],[\"的索引值\",{\"1\":{\"263\":1}}],[\"的机制\",{\"1\":{\"996\":1}}],[\"的机制来保证数据的可靠性的\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"的机制来保证高可用性\",{\"1\":{\"968\":1}}],[\"的机制来确定键值对应的分片\",{\"1\":{\"968\":1}}],[\"的主分片目前被分配在\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"的主要区别在于\",{\"1\":{\"988\":1}}],[\"的主从架构以及同步原理\",{\"1\":{\"964\":1}}],[\"的线程安全问题\",{\"1\":{\"988\":1}}],[\"的线程安全版\",{\"1\":{\"922\":1}}],[\"的远程用户吞吐量\",{\"1\":{\"982\":1}}],[\"的概念\",{\"1\":{\"980\":1}}],[\"的概念是一个常见的混淆源\",{\"1\":{\"526\":1}}],[\"的子类型不包括\",{\"1\":{\"966\":1}}],[\"的子类\",{\"1\":{\"966\":1}}],[\"的过期时间\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"的过程就叫做\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"的过程\",{\"1\":{\"966\":1,\"1217\":1,\"1394\":1}}],[\"的过滤语句\",{\"1\":{\"141\":1}}],[\"的简写\",{\"1\":{\"960\":1}}],[\"的简单字符串到一个\",{\"1\":{\"602\":1}}],[\"的插件机制也很强大\",{\"1\":{\"958\":1}}],[\"的方法区内\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"的方法可以调用lockobj\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"的方法\",{\"1\":{\"958\":2,\"1010\":1,\"1217\":1,\"1394\":1}}],[\"的方式与\",{\"1\":{\"375\":1}}],[\"的缓存淘汰策略就是很好的实践方式\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"的缓存机制和插件机制能说一下吗\",{\"1\":{\"958\":1}}],[\"的缓冲区数目和大小\",{\"1\":{\"106\":1}}],[\"的条件判断\",{\"1\":{\"958\":1}}],[\"的动态\",{\"1\":{\"958\":1}}],[\"的工厂\",{\"1\":{\"958\":1}}],[\"的工作原理很简单\",{\"1\":{\"962\":1}}],[\"的工作原理如下\",{\"1\":{\"958\":1}}],[\"的工作原理能说一下吗\",{\"1\":{\"958\":1}}],[\"的工作原理有了更深的理解\",{\"1\":{\"956\":1}}],[\"的工作原理是\",{\"1\":{\"956\":1}}],[\"的工作原理吗\",{\"1\":{\"956\":1}}],[\"的工作原理主要是\",{\"1\":{\"950\":1}}],[\"的目的\",{\"1\":{\"958\":1}}],[\"的执行结果映射成\",{\"1\":{\"958\":1}}],[\"的执行\",{\"1\":{\"956\":1}}],[\"的适配器\",{\"1\":{\"956\":1}}],[\"的类和接口还挺了解的嘛\",{\"1\":{\"956\":1}}],[\"的类型\",{\"1\":{\"630\":1}}],[\"的提问\",{\"1\":{\"954\":1}}],[\"的唯一性\",{\"1\":{\"954\":1}}],[\"的单例性\",{\"1\":{\"954\":1}}],[\"的代理对象\",{\"1\":{\"954\":2}}],[\"的代码\",{\"1\":{\"352\":1}}],[\"的构造器又注入\",{\"1\":{\"954\":1}}],[\"的构造器注入\",{\"1\":{\"954\":1}}],[\"的构造方法\",{\"1\":{\"926\":1}}],[\"的循环依赖有哪些场景\",{\"1\":{\"954\":1}}],[\"的具体应用\",{\"1\":{\"952\":1}}],[\"的加载时机\",{\"1\":{\"952\":1}}],[\"的加载\",{\"1\":{\"952\":1}}],[\"的初始化也会延迟到\",{\"1\":{\"952\":1}}],[\"的初始化依赖\",{\"1\":{\"952\":1}}],[\"的初始化前后\",{\"1\":{\"952\":1}}],[\"的初始化和销毁方法\",{\"1\":{\"952\":1}}],[\"的初始化过程很清楚\",{\"1\":{\"952\":1}}],[\"的生命周期控制就会很得心应手了\",{\"1\":{\"952\":1}}],[\"的生命周期产生怎样的影响\",{\"1\":{\"952\":1}}],[\"的生命周期\",{\"0\":{\"1214\":1,\"1391\":1},\"1\":{\"952\":3,\"1214\":1,\"1391\":1}}],[\"的生命周期可以分为\",{\"1\":{\"952\":1}}],[\"的生命周期至此结束\",{\"1\":{\"950\":1}}],[\"的实例化及生命周期管理\",{\"1\":{\"950\":1}}],[\"的实现依赖于\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"的实现算法\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"的实现原理\",{\"0\":{\"1116\":1,\"1311\":1}}],[\"的实现原理是基于一个双向链表和一个\",{\"1\":{\"932\":1}}],[\"的实现原理吗\",{\"1\":{\"932\":2}}],[\"的实现使用分段锁\",{\"1\":{\"922\":1}}],[\"的实现类\",{\"1\":{\"827\":1}}],[\"的实现类中对sqlsession的使用方式很类似\",{\"1\":{\"761\":1}}],[\"的源码中\",{\"1\":{\"950\":1}}],[\"的源码实现\",{\"1\":{\"928\":1}}],[\"的事件机制\",{\"1\":{\"950\":1}}],[\"的依赖关系\",{\"1\":{\"950\":1}}],[\"的能力\",{\"1\":{\"950\":1}}],[\"的确\",{\"1\":{\"948\":1}}],[\"的region\",{\"1\":{\"940\":1}}],[\"的分段\",{\"1\":{\"940\":1}}],[\"的分析和可视化平台一起开发的\",{\"1\":{\"400\":1}}],[\"的核心组件包括缓冲区\",{\"1\":{\"1020\":1}}],[\"的核心组件吗\",{\"1\":{\"1020\":1}}],[\"的核心组件主要有\",{\"1\":{\"958\":1}}],[\"的核心\",{\"1\":{\"956\":1}}],[\"的核心目标就是达到并发收集\",{\"1\":{\"938\":1}}],[\"的核心数据结构就是一个\",{\"1\":{\"922\":1}}],[\"的设置有哪些优化方法\",{\"0\":{\"1073\":1,\"1277\":1}}],[\"的设置坐下介绍\",{\"1\":{\"429\":1}}],[\"的设计思想\",{\"1\":{\"934\":1}}],[\"的示例代码\",{\"1\":{\"932\":2}}],[\"的缺点是它可能会导致内存泄漏问题\",{\"1\":{\"928\":1}}],[\"的使用者可以零配置使用\",{\"1\":{\"950\":1}}],[\"的使用也可能会导致上下文切换的开销增加\",{\"1\":{\"928\":1}}],[\"的使用方法非常简单\",{\"1\":{\"928\":2}}],[\"的使用方法\",{\"1\":{\"928\":1}}],[\"的使用目前存在很大的混淆\",{\"1\":{\"692\":1}}],[\"的编译器会对代码进行优化\",{\"1\":{\"924\":1}}],[\"的内容我们就先讲到这里\",{\"1\":{\"958\":1}}],[\"的内容对你有所帮助\",{\"1\":{\"49\":1}}],[\"的内存模型规定了共享变量的访问方式\",{\"1\":{\"924\":1}}],[\"的这些缺点\",{\"1\":{\"922\":1}}],[\"的并发度更高\",{\"1\":{\"922\":1}}],[\"的重要性\",{\"1\":{\"906\":1}}],[\"的镜像\",{\"1\":{\"854\":1}}],[\"的基础架构\",{\"1\":{\"1020\":1}}],[\"的基础配置\",{\"1\":{\"822\":1}}],[\"的基本命令\",{\"1\":{\"960\":1}}],[\"的基数估算\",{\"1\":{\"659\":1}}],[\"的基数排序适用于位数小的数列\",{\"1\":{\"375\":1}}],[\"的解决方案\",{\"0\":{\"799\":1}}],[\"的二级缓存也会多一步序列化和反序列化\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"的二级缓存的作用域是一个mapper的namespace\",{\"1\":{\"790\":1}}],[\"的二进制类型\",{\"1\":{\"442\":1}}],[\"的几个属性说明\",{\"1\":{\"776\":1,\"778\":1}}],[\"的仓库目录\",{\"1\":{\"705\":1}}],[\"的文章\",{\"1\":{\"692\":1}}],[\"的文档\",{\"1\":{\"451\":1,\"998\":1}}],[\"的优点是轻量\",{\"1\":{\"962\":1}}],[\"的优点是可以重复使用\",{\"1\":{\"932\":1}}],[\"的优点是实现简单\",{\"1\":{\"932\":1}}],[\"的优点是它可以让每个线程都拥有自己的变量副本\",{\"1\":{\"928\":1}}],[\"的优缺点吗\",{\"1\":{\"932\":1}}],[\"的优缺点是什么\",{\"1\":{\"928\":1}}],[\"的优势\",{\"1\":{\"658\":1}}],[\"的优劣起了决定性作用\",{\"1\":{\"336\":1}}],[\"的底层\",{\"1\":{\"1022\":1}}],[\"的底层原理之一\",{\"1\":{\"952\":1}}],[\"的底层实现也是基于\",{\"1\":{\"932\":1}}],[\"的底层实现是基于\",{\"1\":{\"932\":1}}],[\"的底层实现原理吗\",{\"1\":{\"932\":1}}],[\"的底层实现之一\",{\"1\":{\"630\":1}}],[\"的底层数据结构用的是\",{\"1\":{\"658\":1}}],[\"的微博\",{\"1\":{\"656\":1}}],[\"的结合\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"的结果文档深分页\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"的结构\",{\"1\":{\"654\":1}}],[\"的结点与满二叉树中编号为i的结点在二叉树中的位置相同\",{\"1\":{\"364\":1}}],[\"的属性\",{\"1\":{\"632\":1,\"952\":1}}],[\"的字段\",{\"1\":{\"1010\":1}}],[\"的字符串对象\",{\"1\":{\"636\":1}}],[\"的字符串对象时\",{\"1\":{\"635\":1}}],[\"的字符串对象作为值对象\",{\"1\":{\"635\":2}}],[\"的字符串大小作为元素的大小\",{\"1\":{\"632\":1}}],[\"的字典使用哈希表作为底层实现\",{\"1\":{\"624\":1}}],[\"的跳跃表实现由\",{\"1\":{\"629\":1}}],[\"的跳跃表由\",{\"1\":{\"628\":1}}],[\"的详细步骤\",{\"1\":{\"625\":1}}],[\"的哈希表使用链地址法\",{\"1\":{\"624\":1}}],[\"的链表可以用于保存各种不同类型的值\",{\"1\":{\"622\":1}}],[\"的链表实现是无环链表\",{\"1\":{\"622\":1}}],[\"的链表实现是双端链表\",{\"1\":{\"622\":1}}],[\"的各种功能\",{\"1\":{\"622\":1,\"626\":1}}],[\"的默认字符串表示\",{\"1\":{\"619\":1}}],[\"的默认行为是\",{\"1\":{\"440\":1}}],[\"的抽象类型\",{\"1\":{\"619\":1}}],[\"的讲解\",{\"1\":{\"613\":1}}],[\"的一套指令集规范\",{\"1\":{\"1143\":1,\"1334\":1}}],[\"的一致性文件系统\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"的一致性\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"的一致性问题\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"的一致性如何保证\",{\"0\":{\"1050\":1,\"1259\":1},\"1\":{\"1046\":1,\"1255\":1}}],[\"的一些配置参数来提高吞吐量\",{\"1\":{\"982\":1}}],[\"的一些高级用法\",{\"1\":{\"608\":1}}],[\"的一部分\",{\"1\":{\"956\":1}}],[\"的一种方式\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"的一种\",{\"1\":{\"1020\":1}}],[\"的一种具体存储形式\",{\"1\":{\"424\":1}}],[\"的一种归纳结果\",{\"1\":{\"348\":1}}],[\"的成员变量进行赋值\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"的成员变量\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"的成员\",{\"1\":{\"606\":1}}],[\"的值加入到容器中\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"的值\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"的值等于事务中第一条消息的位置\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"的值为\",{\"1\":{\"960\":1}}],[\"的值同样\",{\"1\":{\"692\":1}}],[\"的值设为\",{\"1\":{\"605\":1}}],[\"的值保持一致\",{\"1\":{\"106\":1}}],[\"的所有提交\",{\"1\":{\"917\":1}}],[\"的所有整数值\",{\"1\":{\"635\":1}}],[\"的所有键值对都会被\",{\"1\":{\"625\":1}}],[\"的所有字段和值\",{\"1\":{\"605\":1}}],[\"的所有操作都是原子性的\",{\"1\":{\"593\":1}}],[\"的映射表\",{\"1\":{\"605\":1}}],[\"的绝对值\",{\"1\":{\"604\":1}}],[\"的setnx功能来编写分布式的锁\",{\"1\":{\"594\":1}}],[\"的官网地址\",{\"1\":{\"589\":1}}],[\"的出现\",{\"1\":{\"589\":1}}],[\"的开发由pivotal赞助\",{\"1\":{\"589\":1}}],[\"的入门\",{\"1\":{\"587\":1}}],[\"的隔离级别下加锁规则\",{\"0\":{\"575\":1}}],[\"的某个表加锁\",{\"0\":{\"572\":1}}],[\"的行会被锁定\",{\"1\":{\"571\":1}}],[\"的行将被加上排他锁\",{\"1\":{\"571\":1}}],[\"的锁\",{\"1\":{\"561\":1}}],[\"的系统中\",{\"1\":{\"558\":1}}],[\"的关键性技术之一\",{\"1\":{\"553\":1}}],[\"的关联丢失了\",{\"1\":{\"451\":1}}],[\"的例程通常要比使用游标执行的速度快\",{\"1\":{\"546\":1}}],[\"的效率\",{\"0\":{\"537\":2}}],[\"的效率会比较好\",{\"1\":{\"375\":1}}],[\"的版本\",{\"1\":{\"527\":1,\"837\":1}}],[\"的个别引擎中是支持的\",{\"1\":{\"526\":1}}],[\"的个数比\",{\"1\":{\"342\":1}}],[\"的列表\",{\"1\":{\"982\":1}}],[\"的列\",{\"1\":{\"510\":1}}],[\"的时钟周\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"的时间复杂度\",{\"1\":{\"922\":2}}],[\"的时间复杂度为线性\",{\"1\":{\"503\":1}}],[\"的时候就是把\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"的时候会将sql中的\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"的时候\",{\"1\":{\"713\":1,\"759\":1,\"789\":1,\"1177\":2,\"1362\":2}}],[\"的时候都强制它去主内存中取值呢\",{\"1\":{\"692\":1}}],[\"的时候拿到的仍然是\",{\"1\":{\"692\":1}}],[\"的时候才能够派上用场\",{\"1\":{\"425\":1}}],[\"的时候其效率反而不如基于比较的排序\",{\"1\":{\"357\":1}}],[\"的多列索引\",{\"1\":{\"501\":1}}],[\"的父文档\",{\"1\":{\"457\":1}}],[\"的父类\",{\"1\":{\"457\":1}}],[\"的差值\",{\"1\":{\"445\":1}}],[\"的格式\",{\"1\":{\"439\":1}}],[\"的指针\",{\"1\":{\"424\":1,\"619\":1,\"628\":1}}],[\"的数据日志文件目录中\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"的数据类型\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"的数据可能会丢失\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"的数据\",{\"1\":{\"1049\":1,\"1050\":2,\"1258\":1,\"1259\":2}}],[\"的数据收集和日志解析引擎以及名为\",{\"1\":{\"400\":1}}],[\"的数量和消息的批处理大小\",{\"1\":{\"980\":1}}],[\"的数量来提高kafka的吞吐量\",{\"1\":{\"980\":1}}],[\"的数组\",{\"1\":{\"288\":1}}],[\"的复杂性\",{\"1\":{\"400\":1}}],[\"的复杂度\",{\"1\":{\"270\":1}}],[\"的小白\",{\"1\":{\"397\":1,\"411\":1,\"428\":1,\"460\":1}}],[\"的整数对象池\",{\"1\":{\"1204\":2,\"1384\":2}}],[\"的整数值\",{\"1\":{\"630\":1}}],[\"的整数是\",{\"1\":{\"387\":1}}],[\"的整倍数\",{\"1\":{\"106\":1,\"274\":1}}],[\"的场景使用\",{\"1\":{\"966\":2}}],[\"的场景\",{\"1\":{\"383\":1}}],[\"的桶子中\",{\"1\":{\"375\":1}}],[\"的排序\",{\"1\":{\"359\":1}}],[\"的改进\",{\"1\":{\"347\":1}}],[\"的信息量大于b\",{\"1\":{\"270\":1}}],[\"的副本分片上\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"的副本\",{\"1\":{\"270\":1}}],[\"的节点类型\",{\"0\":{\"1238\":1,\"1411\":1}}],[\"的节点\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"的节点将来也可能被访问\",{\"1\":{\"270\":1}}],[\"的节点就在第一层\",{\"1\":{\"270\":1}}],[\"的次数就缩减为了\",{\"1\":{\"266\":1}}],[\"的次数\",{\"1\":{\"266\":1,\"270\":1}}],[\"的话\",{\"1\":{\"193\":1,\"1212\":1,\"1389\":1}}],[\"的利器\",{\"1\":{\"190\":1}}],[\"的投票信息\",{\"1\":{\"166\":1}}],[\"的参数\",{\"1\":{\"145\":2,\"1175\":1,\"1360\":1}}],[\"的缩写\",{\"1\":{\"145\":1,\"263\":1,\"1177\":1,\"1238\":1,\"1362\":1,\"1411\":1}}],[\"的四种类型\",{\"0\":{\"110\":1}}],[\"的七层模型都有哪些\",{\"1\":{\"104\":1}}],[\"的区别主要体现在两个方面\",{\"1\":{\"1114\":1,\"1309\":1}}],[\"的区别是什么\",{\"0\":{\"1089\":1,\"1174\":1,\"1290\":1,\"1359\":1}}],[\"的区别在于\",{\"1\":{\"1049\":2,\"1258\":2}}],[\"的区别有了更深的理解\",{\"1\":{\"988\":1}}],[\"的区别\",{\"0\":{\"1117\":1,\"1312\":1},\"1\":{\"104\":1,\"988\":1,\"1027\":1}}],[\"的在线网站\",{\"1\":{\"90\":1}}],[\"的\",{\"0\":{\"668\":1},\"1\":{\"43\":1,\"44\":1,\"109\":2,\"183\":1,\"209\":1,\"264\":1,\"270\":2,\"342\":1,\"558\":1,\"601\":1,\"606\":1,\"615\":1,\"620\":1,\"629\":1,\"658\":1,\"772\":1,\"820\":1,\"922\":3,\"928\":2,\"932\":3,\"950\":2,\"952\":4,\"954\":1,\"956\":1,\"1018\":2,\"1071\":1,\"1092\":1,\"1117\":1,\"1119\":1,\"1123\":1,\"1128\":3,\"1133\":1,\"1136\":1,\"1167\":2,\"1175\":1,\"1178\":1,\"1244\":1,\"1275\":1,\"1293\":1,\"1312\":1,\"1314\":1,\"1318\":1,\"1321\":3,\"1326\":1,\"1329\":1,\"1355\":2,\"1360\":1,\"1363\":1,\"1417\":1}}],[\"上的一个\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"上的\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"上的贡献\",{\"1\":{\"374\":1}}],[\"上执行的动作\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"上亿量级\",{\"0\":{\"1077\":1,\"1281\":1}}],[\"上个面试官对你的基础有了一定了解\",{\"1\":{\"1018\":1}}],[\"上限的使用场景是当需要获取t的子类型对象时\",{\"1\":{\"966\":1}}],[\"上下文\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"上下文切换\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"上下文目录\",{\"1\":{\"950\":1}}],[\"上下角标\",{\"0\":{\"38\":1}}],[\"上述代码其实对应的sql\",{\"1\":{\"801\":1}}],[\"上建了索引也对查询效率起不了作用\",{\"1\":{\"536\":1}}],[\"上设置默认值\",{\"1\":{\"526\":1}}],[\"上表现更好\",{\"1\":{\"505\":1}}],[\"上图的线程工作内存\",{\"1\":{\"692\":1}}],[\"上图有个冲突\",{\"1\":{\"624\":1}}],[\"上图是java内存模型\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"上图是\",{\"1\":{\"619\":1}}],[\"上图是一棵简化的b\",{\"1\":{\"266\":1}}],[\"上图是一颗简单的平衡二叉树\",{\"1\":{\"266\":1}}],[\"上图所示索引系统除了记录文档编号和单词频率信息外\",{\"1\":{\"425\":1}}],[\"上次生成id的时间截\",{\"1\":{\"388\":3}}],[\"上文有写到链表的实现\",{\"1\":{\"289\":1}}],[\"上文说过\",{\"1\":{\"271\":1,\"274\":1}}],[\"上\",{\"1\":{\"266\":1,\"597\":1,\"1016\":1,\"1071\":1,\"1159\":1,\"1164\":3,\"1233\":1,\"1275\":1,\"1347\":1,\"1352\":3,\"1408\":1}}],[\"上一章做了介绍\",{\"1\":{\"160\":1}}],[\"上一篇咱们有一定了解\",{\"1\":{\"615\":1}}],[\"上一篇都是对一些\",{\"1\":{\"613\":1}}],[\"上一篇\",{\"1\":{\"20\":1,\"613\":1}}],[\"上边是zookeeper官网的描述\",{\"1\":{\"152\":1}}],[\"上面五种分区算法都是选择preferredreplica\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"上面操作2依赖于操作1\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"上面是文档在节点间分发的过程\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"上面是我们在原理介绍讲到的\",{\"1\":{\"339\":1}}],[\"上面代码表示将feature分支的最近一次提交\",{\"1\":{\"917\":1}}],[\"上面命令就会将指定的提交commithash\",{\"1\":{\"917\":1}}],[\"上面我们已经在\",{\"1\":{\"827\":1}}],[\"上面我们了解过\",{\"1\":{\"84\":1}}],[\"上面的代码中i1和i2的数值为100\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"上面的代码是通过标记flag来控制\",{\"1\":{\"692\":1}}],[\"上面的命令可以转移从\",{\"1\":{\"917\":1}}],[\"上面的命令将\",{\"1\":{\"917\":1}}],[\"上面的操作完成以后\",{\"1\":{\"917\":1}}],[\"上面的\",{\"1\":{\"826\":1}}],[\"上面的插件将会拦截在\",{\"1\":{\"770\":1}}],[\"上面的叙述看似并没有什么问题\",{\"1\":{\"692\":1}}],[\"上面说了一个节点需要进行一次\",{\"1\":{\"266\":1}}],[\"上面这种写法可以保证线程安全\",{\"1\":{\"79\":1}}],[\"2+1\",{\"1\":{\"1070\":2,\"1274\":2}}],[\"2b\",{\"1\":{\"1018\":1}}],[\"2清除阶段删除垃圾\",{\"1\":{\"936\":1}}],[\"2<\",{\"1\":{\"812\":4}}],[\"27\",{\"1\":{\"998\":1}}],[\"2742\",{\"1\":{\"660\":1}}],[\"2703kbps\",{\"1\":{\"134\":1}}],[\"2=100\",{\"1\":{\"531\":1}}],[\"2^64\",{\"1\":{\"659\":1}}],[\"2^32\",{\"1\":{\"655\":1}}],[\"2^\",{\"1\":{\"387\":7}}],[\"222\",{\"1\":{\"762\":1}}],[\"22\",{\"0\":{\"547\":1},\"1\":{\"375\":5,\"377\":2,\"525\":1,\"635\":1,\"688\":1,\"736\":2,\"759\":2}}],[\"220\",{\"1\":{\"140\":1}}],[\"2i+2\",{\"1\":{\"364\":2}}],[\"2i+1\",{\"1\":{\"364\":2}}],[\"2亿\",{\"1\":{\"347\":1}}],[\"242355057\",{\"1\":{\"789\":3}}],[\"24t10\",{\"1\":{\"439\":1}}],[\"24\",{\"1\":{\"337\":1,\"387\":1,\"388\":1,\"709\":1,\"710\":1,\"849\":1,\"1444\":1}}],[\"23\",{\"0\":{\"548\":1},\"1\":{\"337\":1,\"440\":1,\"790\":8,\"800\":1}}],[\"232\",{\"1\":{\"159\":1,\"604\":1,\"605\":1,\"607\":1}}],[\"250\",{\"1\":{\"952\":1}}],[\"2501\",{\"1\":{\"866\":1}}],[\"2500k\",{\"1\":{\"134\":1}}],[\"255\",{\"1\":{\"507\":1,\"792\":1,\"795\":3,\"865\":2}}],[\"256\",{\"1\":{\"440\":1,\"591\":1,\"962\":1}}],[\"25\",{\"1\":{\"263\":1,\"266\":2,\"267\":2,\"329\":1,\"688\":1,\"689\":1,\"1022\":1}}],[\"26~\",{\"1\":{\"263\":1}}],[\"26\",{\"1\":{\"159\":1,\"337\":1,\"829\":1,\"849\":1}}],[\"2696\",{\"1\":{\"159\":1}}],[\"281\",{\"1\":{\"865\":2}}],[\"285\",{\"1\":{\"865\":1}}],[\"28\",{\"1\":{\"375\":5,\"377\":3,\"759\":2,\"865\":2,\"1087\":2,\"1288\":2,\"1444\":1}}],[\"2888端口是zookeeper服务之间的通讯的端口\",{\"1\":{\"157\":1}}],[\"2888\",{\"1\":{\"157\":2}}],[\"2831kbps\",{\"1\":{\"134\":2}}],[\"295\",{\"1\":{\"865\":4}}],[\"29\",{\"1\":{\"145\":1,\"439\":1,\"525\":1,\"795\":1}}],[\"2的平均值是1\",{\"1\":{\"134\":1}}],[\"2181\",{\"1\":{\"157\":1,\"159\":1,\"1008\":1}}],[\"21\",{\"0\":{\"546\":1},\"1\":{\"94\":1,\"352\":1,\"826\":2,\"828\":3,\"829\":1,\"830\":1,\"831\":1,\"1444\":1}}],[\"2>\",{\"1\":{\"94\":1}}],[\"2092769598\",{\"1\":{\"790\":2}}],[\"20100524\",{\"1\":{\"865\":4}}],[\"201807010001\",{\"1\":{\"793\":2,\"794\":1,\"795\":2}}],[\"2018\",{\"1\":{\"439\":1,\"759\":2,\"789\":42,\"790\":14,\"795\":2,\"919\":1}}],[\"2015\",{\"1\":{\"388\":1}}],[\"2017\",{\"1\":{\"225\":1}}],[\"2019\",{\"1\":{\"217\":1,\"223\":1,\"225\":1}}],[\"20190215\",{\"1\":{\"94\":1}}],[\"20190216\",{\"1\":{\"94\":1}}],[\"2016\",{\"1\":{\"159\":8}}],[\"208\",{\"1\":{\"141\":1}}],[\"2003\",{\"1\":{\"824\":1}}],[\"2002\",{\"1\":{\"824\":1}}],[\"2001\",{\"1\":{\"715\":2,\"812\":1,\"815\":1,\"818\":1,\"819\":1,\"820\":1,\"824\":1,\"844\":1,\"865\":2}}],[\"200\",{\"1\":{\"648\":1,\"829\":1,\"1085\":2,\"1286\":2,\"1431\":6}}],[\"200m\",{\"1\":{\"406\":1}}],[\"2000=4秒\",{\"1\":{\"157\":1}}],[\"2000=10秒\",{\"1\":{\"157\":1}}],[\"2000\",{\"1\":{\"157\":1,\"692\":3,\"795\":1,\"824\":1,\"1104\":1,\"1302\":1}}],[\"2000k\",{\"1\":{\"134\":5}}],[\"2004年至2015年间由michael\",{\"1\":{\"122\":1}}],[\"200k左右的图片\",{\"1\":{\"106\":1}}],[\"204\",{\"1\":{\"94\":1}}],[\"20\",{\"0\":{\"545\":1,\"1074\":1,\"1278\":1},\"1\":{\"94\":3,\"134\":2,\"141\":1,\"347\":1,\"377\":1,\"505\":1,\"558\":1,\"603\":2,\"607\":1,\"725\":1,\"726\":3,\"763\":1,\"786\":1,\"824\":6,\"825\":2,\"829\":1,\"1107\":1,\"1166\":1,\"1305\":1,\"1354\":1,\"1444\":1}}],[\"2023\",{\"1\":{\"998\":1}}],[\"20231229223856569\",{\"1\":{\"913\":1}}],[\"20231229223449073\",{\"1\":{\"913\":1}}],[\"20231229223519373\",{\"1\":{\"913\":1}}],[\"20231229222424668\",{\"1\":{\"913\":1}}],[\"20231229224826134\",{\"1\":{\"906\":1}}],[\"20231229215720402\",{\"1\":{\"909\":1}}],[\"20231229214604013\",{\"1\":{\"906\":1}}],[\"20231216130625976\",{\"1\":{\"91\":1}}],[\"20231216130058600\",{\"1\":{\"91\":1}}],[\"20231216131826484\",{\"1\":{\"90\":1}}],[\"20231216131924099\",{\"1\":{\"90\":1}}],[\"20231216125353767\",{\"1\":{\"91\":1}}],[\"20231216125205177\",{\"1\":{\"91\":1}}],[\"20231216124857718\",{\"1\":{\"91\":1}}],[\"20231216124628242\",{\"1\":{\"91\":1}}],[\"20231216124523478\",{\"1\":{\"91\":1}}],[\"202753974\",{\"1\":{\"692\":1}}],[\"2022\",{\"1\":{\"688\":1,\"689\":1,\"849\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1302\":2,\"1303\":1,\"1305\":1}}],[\"2024\",{\"1\":{\"658\":1}}],[\"20240515145153527\",{\"1\":{\"844\":1}}],[\"20240515142850887\",{\"1\":{\"844\":1}}],[\"20240515142652362\",{\"1\":{\"844\":1}}],[\"20240515142447148\",{\"1\":{\"844\":1}}],[\"20240515142322426\",{\"1\":{\"844\":1}}],[\"20240515141832844\",{\"1\":{\"844\":1}}],[\"20240515141503878\",{\"1\":{\"844\":1}}],[\"20240515141415120\",{\"1\":{\"844\":1}}],[\"20240527182546406\",{\"1\":{\"581\":1}}],[\"20240527184946810\",{\"1\":{\"554\":1}}],[\"20240521105043027\",{\"1\":{\"185\":1}}],[\"20240521104901378\",{\"1\":{\"186\":1}}],[\"20240521104647299\",{\"1\":{\"184\":1}}],[\"20240521104426851\",{\"1\":{\"183\":1}}],[\"202401\",{\"1\":{\"658\":3}}],[\"20240325201704103\",{\"1\":{\"510\":1}}],[\"20240325202047594\",{\"1\":{\"502\":1}}],[\"20240325200012764\",{\"1\":{\"494\":1}}],[\"20240325195743437\",{\"1\":{\"495\":1}}],[\"20240325195000388\",{\"1\":{\"493\":1}}],[\"20240314155834611\",{\"1\":{\"199\":1}}],[\"20240314165434764\",{\"1\":{\"190\":1}}],[\"20240314214848607\",{\"1\":{\"201\":1}}],[\"20240314214836800\",{\"1\":{\"198\":1}}],[\"20240314214823572\",{\"1\":{\"197\":1}}],[\"20240314214801114\",{\"1\":{\"195\":1}}],[\"20240314214745191\",{\"1\":{\"194\":1}}],[\"20240314214712731\",{\"1\":{\"193\":1}}],[\"20240314214637143\",{\"1\":{\"192\":1}}],[\"20240314214602647\",{\"1\":{\"191\":1}}],[\"20210111140639166\",{\"1\":{\"657\":1}}],[\"20210111140054296\",{\"1\":{\"657\":1}}],[\"20210111133958782\",{\"1\":{\"656\":1}}],[\"20210111133831044\",{\"1\":{\"656\":1}}],[\"20210111133650920\",{\"1\":{\"656\":1}}],[\"20210111133506484\",{\"1\":{\"656\":1}}],[\"20210111131949452\",{\"1\":{\"656\":1}}],[\"20210111131808595\",{\"1\":{\"656\":1}}],[\"20210110223728047\",{\"1\":{\"654\":1}}],[\"2021\",{\"1\":{\"521\":1,\"525\":1}}],[\"2028\",{\"1\":{\"182\":2}}],[\"20200610231456317\",{\"1\":{\"705\":1}}],[\"20200610230144920\",{\"1\":{\"704\":1}}],[\"20200610225900548\",{\"1\":{\"703\":1}}],[\"20200610223813357\",{\"1\":{\"702\":1}}],[\"20200610223114895\",{\"1\":{\"701\":1}}],[\"2020\",{\"1\":{\"44\":1,\"288\":1,\"289\":1,\"337\":1,\"352\":1,\"377\":1,\"445\":2,\"824\":1,\"825\":2,\"826\":2,\"828\":3,\"829\":5,\"830\":4,\"831\":1,\"917\":1,\"919\":1}}],[\"2050\",{\"1\":{\"1\":1}}],[\"2\",{\"0\":{\"123\":1,\"124\":1,\"125\":2,\"128\":1,\"129\":1,\"130\":2,\"139\":1,\"144\":1,\"152\":1,\"154\":1,\"158\":1,\"177\":1,\"264\":1,\"333\":1,\"335\":1,\"337\":1,\"340\":1,\"341\":1,\"342\":1,\"343\":2,\"349\":1,\"350\":1,\"351\":2,\"358\":1,\"359\":2,\"371\":1,\"373\":1,\"374\":1,\"375\":2,\"495\":1,\"527\":1,\"554\":1,\"555\":1,\"556\":2,\"557\":1,\"558\":1,\"559\":1,\"560\":1,\"561\":1,\"578\":1,\"589\":1,\"592\":1,\"598\":1,\"602\":1,\"603\":1,\"615\":1,\"620\":1,\"621\":1,\"622\":2,\"625\":1,\"629\":1,\"633\":1,\"636\":1,\"644\":1,\"645\":2,\"646\":1,\"647\":1,\"648\":2,\"672\":1,\"687\":1,\"699\":1,\"700\":2,\"702\":1,\"704\":1,\"707\":1,\"712\":1,\"716\":1,\"724\":1,\"725\":1,\"726\":2,\"735\":1,\"743\":1,\"751\":1,\"754\":1,\"762\":1,\"767\":1,\"776\":1,\"779\":1,\"785\":1,\"790\":1,\"793\":1,\"801\":1,\"897\":1,\"1043\":1,\"1058\":1,\"1069\":1,\"1085\":1,\"1099\":1,\"1113\":1,\"1128\":1,\"1143\":1,\"1159\":1,\"1173\":1,\"1186\":1,\"1199\":1,\"1212\":1,\"1225\":1,\"1238\":1,\"1252\":1,\"1264\":1,\"1273\":1,\"1286\":1,\"1297\":1,\"1308\":1,\"1321\":1,\"1334\":1,\"1347\":1,\"1358\":1,\"1369\":1,\"1379\":1,\"1389\":1,\"1400\":1,\"1411\":1},\"1\":{\"36\":1,\"76\":1,\"77\":1,\"106\":5,\"141\":2,\"153\":1,\"157\":1,\"166\":7,\"232\":1,\"270\":2,\"284\":1,\"288\":1,\"289\":3,\"339\":1,\"340\":3,\"351\":2,\"352\":2,\"359\":2,\"360\":3,\"361\":1,\"364\":9,\"375\":2,\"387\":2,\"429\":1,\"434\":1,\"436\":2,\"457\":1,\"501\":1,\"525\":1,\"529\":1,\"531\":1,\"591\":2,\"594\":1,\"598\":3,\"603\":1,\"604\":4,\"605\":1,\"606\":1,\"607\":1,\"619\":1,\"624\":1,\"658\":1,\"659\":3,\"660\":1,\"690\":1,\"692\":1,\"701\":2,\"702\":2,\"708\":1,\"709\":4,\"723\":1,\"725\":3,\"726\":2,\"727\":4,\"736\":1,\"737\":1,\"742\":1,\"751\":2,\"759\":1,\"763\":3,\"785\":1,\"787\":1,\"789\":1,\"795\":5,\"800\":1,\"801\":2,\"812\":3,\"815\":2,\"819\":3,\"829\":1,\"830\":1,\"837\":1,\"838\":1,\"839\":1,\"849\":1,\"874\":2,\"898\":1,\"916\":1,\"928\":2,\"934\":2,\"948\":1,\"952\":3,\"966\":4,\"1022\":1,\"1044\":6,\"1047\":4,\"1049\":2,\"1060\":1,\"1071\":2,\"1072\":1,\"1073\":1,\"1077\":3,\"1088\":1,\"1092\":1,\"1099\":3,\"1100\":1,\"1104\":6,\"1105\":2,\"1107\":1,\"1151\":1,\"1162\":1,\"1163\":2,\"1165\":3,\"1166\":2,\"1167\":1,\"1190\":1,\"1211\":1,\"1212\":1,\"1216\":1,\"1217\":1,\"1219\":3,\"1220\":1,\"1238\":1,\"1245\":1,\"1253\":6,\"1256\":4,\"1258\":2,\"1266\":1,\"1275\":2,\"1276\":1,\"1277\":1,\"1281\":3,\"1289\":1,\"1293\":1,\"1297\":3,\"1298\":1,\"1302\":6,\"1303\":2,\"1305\":1,\"1342\":1,\"1350\":1,\"1351\":2,\"1353\":3,\"1354\":2,\"1355\":1,\"1373\":1,\"1388\":1,\"1389\":1,\"1393\":1,\"1394\":1,\"1396\":3,\"1397\":1,\"1411\":1,\"1418\":1,\"1431\":1,\"1444\":1}}],[\"^0\",{\"1\":{\"487\":1,\"488\":1}}],[\"^\",{\"1\":{\"35\":1,\"388\":3}}],[\"^i\",{\"1\":{\"35\":1}}],[\"^r\",{\"1\":{\"35\":2}}],[\"1和http2\",{\"0\":{\"1138\":1,\"1331\":1}}],[\"1和all\",{\"1\":{\"994\":1}}],[\"1a\",{\"1\":{\"1018\":1}}],[\"1标记阶段标记垃圾\",{\"1\":{\"936\":1}}],[\"1<\",{\"1\":{\"709\":1,\"710\":1,\"812\":1,\"844\":1}}],[\"1l\",{\"1\":{\"388\":8,\"737\":1}}],[\"1位标识\",{\"1\":{\"388\":1}}],[\"1位\",{\"1\":{\"387\":1}}],[\"1次\",{\"1\":{\"364\":1}}],[\"1=1\",{\"1\":{\"364\":1}}],[\"1=5\",{\"1\":{\"364\":1}}],[\"1=localhost\",{\"1\":{\"157\":1}}],[\"1个元素重新构造成一个堆\",{\"1\":{\"364\":1}}],[\"1≤i≤n\",{\"1\":{\"364\":1}}],[\"1那种\",{\"1\":{\"333\":1,\"339\":1}}],[\"180\",{\"1\":{\"439\":1}}],[\"18\",{\"0\":{\"511\":1,\"543\":1},\"1\":{\"288\":1,\"289\":1,\"329\":1,\"493\":1,\"607\":1,\"759\":2,\"789\":12,\"790\":2,\"812\":1,\"828\":1,\"1431\":1,\"1444\":1}}],[\"1~\",{\"1\":{\"263\":3}}],[\"1代表桌面\",{\"1\":{\"145\":1}}],[\"1m\",{\"1\":{\"106\":1,\"885\":1}}],[\"1h\",{\"1\":{\"106\":2}}],[\"1k\",{\"1\":{\"106\":1}}],[\"17<\",{\"1\":{\"709\":1}}],[\"17版本\",{\"1\":{\"709\":1}}],[\"17\",{\"0\":{\"510\":1,\"542\":1},\"1\":{\"94\":1,\"445\":2,\"598\":3,\"607\":1,\"709\":1,\"789\":25,\"790\":10,\"800\":1}}],[\"16¥\",{\"1\":{\"1429\":1}}],[\"16383\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"169\",{\"1\":{\"865\":1}}],[\"16版本\",{\"1\":{\"709\":1}}],[\"16611295681062\",{\"1\":{\"865\":1}}],[\"166\",{\"1\":{\"660\":1}}],[\"166274\",{\"1\":{\"660\":1}}],[\"1628\",{\"1\":{\"159\":1}}],[\"16k\",{\"1\":{\"106\":1}}],[\"16\",{\"0\":{\"509\":1,\"541\":1},\"1\":{\"94\":1,\"212\":1,\"266\":1,\"329\":1,\"607\":1,\"658\":1,\"757\":1,\"785\":1,\"824\":1,\"829\":4,\"830\":3,\"928\":2,\"1044\":1,\"1104\":1,\"1205\":1,\"1253\":1,\"1302\":1,\"1385\":1}}],[\"168\",{\"1\":{\"94\":1,\"106\":7}}],[\"15s\",{\"1\":{\"887\":2}}],[\"15s开始向后6s\",{\"1\":{\"129\":1}}],[\"150\",{\"1\":{\"865\":6}}],[\"156\",{\"1\":{\"789\":1}}],[\"1516\",{\"1\":{\"660\":1}}],[\"152\",{\"1\":{\"603\":1}}],[\"1534\",{\"1\":{\"159\":1}}],[\"15d\",{\"1\":{\"106\":1}}],[\"15\",{\"0\":{\"508\":1,\"540\":1},\"1\":{\"94\":1,\"106\":2,\"129\":1,\"136\":1,\"146\":1,\"337\":1,\"352\":1,\"558\":1,\"606\":1,\"607\":1,\"658\":2,\"660\":1,\"688\":1,\"689\":1,\"789\":12,\"790\":2,\"887\":2,\"1107\":1,\"1305\":1}}],[\"14231428021\",{\"1\":{\"1431\":1}}],[\"1489111610226l\",{\"1\":{\"388\":1}}],[\"1415\",{\"1\":{\"361\":1}}],[\"14tmfik7m\",{\"1\":{\"212\":1}}],[\"14\",{\"0\":{\"507\":1,\"539\":1,\"799\":1,\"800\":1,\"801\":1},\"1\":{\"94\":1,\"106\":2,\"157\":3,\"329\":1,\"375\":5,\"377\":2,\"605\":1,\"606\":1,\"607\":1,\"1105\":1,\"1303\":1}}],[\"1d\",{\"1\":{\"94\":1}}],[\"136294283\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"1384083044983\",{\"1\":{\"865\":1}}],[\"130\",{\"1\":{\"865\":1}}],[\"13084517\",{\"1\":{\"136\":1}}],[\"135\",{\"1\":{\"865\":1}}],[\"13<\",{\"1\":{\"844\":1}}],[\"1392757660167\",{\"1\":{\"865\":1}}],[\"139320266\",{\"1\":{\"251\":1}}],[\"139744309\",{\"1\":{\"251\":1}}],[\"131709720\",{\"1\":{\"232\":1}}],[\"13\",{\"0\":{\"146\":1,\"506\":1,\"538\":1,\"581\":1,\"798\":1},\"1\":{\"94\":1,\"136\":1,\"159\":1,\"288\":1,\"352\":1,\"552\":1,\"605\":1,\"606\":1,\"607\":1,\"660\":1,\"789\":11,\"790\":2,\"898\":1,\"1104\":1,\"1219\":1,\"1302\":1,\"1396\":1}}],[\"124781454\",{\"1\":{\"1030\":1}}],[\"124857707\",{\"1\":{\"675\":1}}],[\"12<\",{\"1\":{\"756\":1,\"812\":2}}],[\"12k\",{\"1\":{\"659\":1}}],[\"12+5\",{\"1\":{\"388\":1}}],[\"12l\",{\"1\":{\"388\":1}}],[\"12位的计数顺序号支持每个节点每毫秒\",{\"1\":{\"388\":1}}],[\"12位序列\",{\"1\":{\"388\":1}}],[\"12位\",{\"1\":{\"387\":2}}],[\"127\",{\"1\":{\"106\":10,\"159\":1,\"248\":1,\"251\":1,\"591\":1,\"597\":1,\"648\":1,\"654\":1,\"655\":2,\"659\":3,\"690\":2,\"737\":1,\"743\":2,\"745\":1,\"888\":1,\"1085\":3,\"1286\":3}}],[\"122\",{\"1\":{\"106\":1,\"166\":1}}],[\"121\",{\"1\":{\"106\":1}}],[\"1280x720\",{\"1\":{\"146\":1}}],[\"128kbps\",{\"1\":{\"134\":1}}],[\"128k\",{\"1\":{\"106\":1}}],[\"128\",{\"1\":{\"106\":1,\"789\":1,\"1085\":4,\"1286\":4}}],[\"12345678910l\",{\"1\":{\"828\":2,\"830\":1}}],[\"123456\",{\"1\":{\"648\":1,\"736\":2,\"737\":1,\"743\":2,\"745\":1,\"757\":1,\"759\":1,\"763\":3,\"786\":1,\"789\":6,\"790\":2,\"1176\":1,\"1361\":1}}],[\"1234\",{\"1\":{\"444\":1}}],[\"123\",{\"1\":{\"94\":3,\"106\":1,\"166\":1,\"439\":1}}],[\"12\",{\"0\":{\"145\":1,\"505\":1,\"537\":1,\"580\":1,\"791\":1,\"792\":1,\"793\":1,\"794\":1,\"795\":1,\"796\":1,\"797\":1,\"1138\":1,\"1331\":1},\"1\":{\"94\":2,\"288\":1,\"289\":1,\"329\":1,\"387\":1,\"406\":2,\"444\":1,\"605\":1,\"606\":1,\"607\":1,\"659\":1,\"824\":1,\"849\":1,\"1219\":1,\"1396\":1}}],[\"12084012\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"120284492\",{\"1\":{\"275\":1}}],[\"120\",{\"1\":{\"94\":1}}],[\"190\",{\"1\":{\"865\":2}}],[\"1999\",{\"1\":{\"865\":1}}],[\"1993\",{\"1\":{\"736\":1,\"759\":1}}],[\"1990\",{\"1\":{\"736\":1,\"757\":1}}],[\"1996年\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"1996\",{\"1\":{\"217\":1,\"223\":1,\"1087\":2,\"1288\":2}}],[\"19765415\",{\"1\":{\"728\":1}}],[\"1970\",{\"1\":{\"445\":1}}],[\"1937\",{\"1\":{\"159\":1}}],[\"1935\",{\"1\":{\"146\":1}}],[\"19\",{\"0\":{\"544\":1},\"1\":{\"94\":1,\"288\":1,\"289\":1,\"439\":1,\"607\":1,\"795\":2}}],[\"192\",{\"1\":{\"94\":1,\"106\":7}}],[\"19th\",{\"1\":{\"38\":1}}],[\"11228555\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"11248192\",{\"1\":{\"628\":1}}],[\"110\",{\"1\":{\"743\":2,\"865\":4}}],[\"110000次\",{\"1\":{\"591\":1,\"960\":1}}],[\"115556\",{\"1\":{\"660\":1}}],[\"11306690\",{\"1\":{\"633\":1}}],[\"11434\",{\"1\":{\"248\":2,\"249\":2}}],[\"11条军规\",{\"1\":{\"175\":1}}],[\"11\",{\"0\":{\"142\":1,\"143\":1,\"144\":1,\"186\":1,\"504\":1,\"536\":1,\"576\":1,\"577\":1,\"578\":1,\"579\":1,\"715\":1,\"716\":1,\"788\":1,\"789\":1,\"790\":1,\"1078\":1,\"1079\":1,\"1137\":1,\"1283\":1,\"1330\":1},\"1\":{\"94\":1,\"337\":1,\"605\":1,\"606\":1,\"607\":1,\"726\":1,\"792\":2,\"795\":6,\"824\":1}}],[\"10道不得不会的springboot面试题\",{\"1\":{\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的spring面试题\",{\"0\":{\"1210\":1},\"1\":{\"1027\":1,\"1036\":1,\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1210\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的缓存面试题\",{\"0\":{\"1041\":1},\"1\":{\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的netty面试题\",{\"1\":{\"1027\":1,\"1036\":1}}],[\"10道不得不会的docker面试题\",{\"1\":{\"1027\":1,\"1036\":1,\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的zookeeper面试题\",{\"1\":{\"1027\":1,\"1036\":1,\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的kafka面试题\",{\"1\":{\"1027\":1,\"1036\":1,\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的redis面试题\",{\"0\":{\"1197\":1},\"1\":{\"1027\":1,\"1036\":1,\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的elasticsearch面试题\",{\"0\":{\"1067\":1},\"1\":{\"1027\":1,\"1036\":1,\"1053\":1,\"1064\":1,\"1067\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的mybatis面试题\",{\"1\":{\"1027\":1,\"1036\":1,\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的mysql基础面试题\",{\"0\":{\"1184\":1},\"1\":{\"1027\":1,\"1036\":1,\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1184\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的jvm面试题\",{\"0\":{\"1141\":1},\"1\":{\"1027\":1,\"1036\":1,\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1141\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的java容器面试题\",{\"0\":{\"1111\":1},\"1\":{\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1111\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的javaee面试题\",{\"1\":{\"1027\":1,\"1036\":1,\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的java并发基础面试题\",{\"0\":{\"1097\":1},\"1\":{\"1027\":1,\"1036\":1,\"1053\":1,\"1064\":1,\"1080\":1,\"1094\":1,\"1097\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的java基础面试题\",{\"0\":{\"1083\":1},\"1\":{\"1027\":1,\"1036\":1,\"1053\":1,\"1064\":1,\"1080\":1,\"1083\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1220\":1,\"1233\":1,\"1246\":1}}],[\"10道不得不会的\",{\"0\":{\"1026\":1,\"1030\":1,\"1056\":1,\"1126\":1,\"1155\":1,\"1171\":1,\"1223\":1,\"1236\":1},\"1\":{\"1026\":1,\"1030\":1,\"1041\":1,\"1056\":1,\"1126\":1,\"1155\":1,\"1171\":1,\"1197\":1,\"1223\":1,\"1236\":1}}],[\"10485760\",{\"1\":{\"982\":1}}],[\"10s\",{\"1\":{\"887\":1}}],[\"10<\",{\"1\":{\"715\":1}}],[\"103\",{\"1\":{\"660\":1}}],[\"103z\",{\"1\":{\"439\":1}}],[\"102\",{\"1\":{\"603\":1}}],[\"1024\",{\"1\":{\"106\":1,\"387\":1,\"648\":1,\"1020\":1}}],[\"101\",{\"1\":{\"603\":1}}],[\"10位的数据机器位\",{\"1\":{\"388\":1}}],[\"10位\",{\"1\":{\"387\":1}}],[\"1089\",{\"1\":{\"159\":1}}],[\"1056\",{\"1\":{\"159\":1}}],[\"1003\",{\"1\":{\"831\":1}}],[\"100491744\",{\"1\":{\"520\":1}}],[\"100g\",{\"1\":{\"515\":1}}],[\"10000个partition\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"10000\",{\"1\":{\"648\":2,\"795\":1,\"815\":1}}],[\"100000\",{\"1\":{\"591\":1}}],[\"1000000+\",{\"1\":{\"388\":1}}],[\"1000w\",{\"1\":{\"515\":1}}],[\"1000l\",{\"1\":{\"388\":1}}],[\"1000\",{\"1\":{\"387\":1,\"602\":3,\"828\":4,\"830\":1,\"990\":1,\"1008\":1,\"1104\":1,\"1302\":1}}],[\"100一次就能筛选走四分之三的数据\",{\"1\":{\"266\":1}}],[\"100个数\",{\"1\":{\"266\":1}}],[\"1002\",{\"1\":{\"186\":1,\"501\":1}}],[\"1001\",{\"1\":{\"186\":1,\"830\":1}}],[\"100\",{\"1\":{\"140\":1,\"263\":3,\"266\":1,\"377\":2,\"440\":1,\"487\":1,\"488\":1,\"500\":1,\"511\":1,\"603\":2,\"635\":2,\"770\":1,\"824\":1,\"865\":3,\"958\":1,\"982\":2,\"984\":1,\"1085\":2,\"1105\":2,\"1286\":2,\"1303\":2}}],[\"10d\",{\"1\":{\"106\":1}}],[\"10mb\",{\"1\":{\"982\":1}}],[\"10m\",{\"1\":{\"106\":2}}],[\"106\",{\"1\":{\"94\":1}}],[\"10\",{\"0\":{\"141\":1,\"185\":1,\"503\":1,\"535\":1,\"575\":1,\"783\":1,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"1051\":1,\"1074\":2,\"1077\":1,\"1093\":1,\"1107\":1,\"1122\":1,\"1136\":1,\"1151\":1,\"1167\":1,\"1181\":1,\"1220\":1,\"1233\":1,\"1260\":1,\"1278\":2,\"1282\":1,\"1294\":1,\"1305\":1,\"1317\":1,\"1329\":1,\"1342\":1,\"1355\":1,\"1366\":1,\"1397\":1,\"1408\":1},\"1\":{\"94\":1,\"141\":1,\"182\":1,\"225\":1,\"266\":1,\"285\":1,\"329\":1,\"359\":2,\"377\":5,\"387\":3,\"556\":1,\"558\":1,\"603\":3,\"605\":1,\"606\":1,\"607\":1,\"655\":1,\"725\":1,\"726\":1,\"736\":1,\"789\":8,\"795\":3,\"815\":1,\"946\":1,\"982\":2,\"1027\":1,\"1072\":2,\"1156\":1,\"1177\":3,\"1181\":1,\"1276\":2,\"1344\":1,\"1362\":3,\"1366\":1}}],[\"1\",{\"0\":{\"122\":1,\"124\":1,\"127\":1,\"129\":1,\"138\":1,\"143\":1,\"151\":1,\"152\":1,\"153\":1,\"157\":1,\"176\":1,\"263\":1,\"331\":2,\"332\":3,\"333\":2,\"334\":2,\"335\":1,\"336\":1,\"337\":1,\"338\":1,\"339\":2,\"340\":1,\"342\":1,\"348\":1,\"350\":1,\"357\":2,\"358\":1,\"360\":1,\"361\":1,\"369\":1,\"370\":2,\"371\":1,\"372\":1,\"374\":1,\"377\":1,\"494\":1,\"526\":1,\"553\":1,\"555\":1,\"577\":1,\"588\":1,\"591\":1,\"596\":1,\"597\":2,\"598\":1,\"601\":1,\"614\":1,\"618\":1,\"619\":2,\"620\":1,\"624\":1,\"628\":1,\"632\":1,\"635\":1,\"642\":1,\"643\":2,\"646\":1,\"647\":2,\"648\":1,\"671\":1,\"686\":1,\"699\":1,\"701\":1,\"703\":1,\"706\":1,\"711\":1,\"715\":1,\"723\":1,\"725\":1,\"733\":1,\"734\":2,\"735\":1,\"736\":1,\"737\":1,\"738\":1,\"742\":1,\"750\":1,\"753\":1,\"761\":1,\"766\":1,\"774\":1,\"775\":2,\"776\":1,\"777\":1,\"778\":1,\"784\":1,\"789\":1,\"792\":1,\"800\":1,\"896\":1,\"1027\":1,\"1031\":1,\"1042\":1,\"1057\":1,\"1068\":1,\"1084\":1,\"1098\":1,\"1112\":1,\"1121\":1,\"1127\":1,\"1142\":1,\"1158\":1,\"1172\":1,\"1185\":1,\"1198\":1,\"1211\":1,\"1224\":1,\"1237\":1,\"1251\":1,\"1263\":1,\"1272\":1,\"1285\":1,\"1296\":1,\"1307\":1,\"1316\":1,\"1320\":1,\"1333\":1,\"1346\":1,\"1357\":1,\"1368\":1,\"1378\":1,\"1388\":1,\"1399\":1,\"1410\":1},\"1\":{\"35\":1,\"36\":1,\"44\":2,\"46\":2,\"76\":1,\"77\":1,\"94\":1,\"106\":17,\"125\":3,\"134\":2,\"138\":2,\"140\":1,\"141\":2,\"143\":4,\"145\":4,\"146\":1,\"153\":1,\"159\":10,\"166\":6,\"195\":1,\"248\":1,\"251\":1,\"263\":1,\"265\":1,\"266\":1,\"270\":4,\"284\":1,\"285\":8,\"286\":4,\"288\":7,\"289\":5,\"337\":2,\"339\":3,\"340\":1,\"351\":1,\"352\":9,\"353\":3,\"359\":6,\"360\":5,\"361\":1,\"364\":6,\"375\":2,\"377\":2,\"387\":8,\"388\":1,\"406\":5,\"420\":1,\"429\":1,\"431\":1,\"434\":1,\"436\":8,\"439\":2,\"440\":1,\"451\":1,\"457\":4,\"487\":1,\"488\":1,\"525\":1,\"529\":2,\"532\":1,\"535\":1,\"556\":2,\"573\":5,\"579\":1,\"591\":1,\"594\":1,\"597\":1,\"603\":5,\"604\":8,\"605\":2,\"606\":2,\"607\":3,\"619\":1,\"620\":1,\"624\":4,\"625\":5,\"629\":1,\"648\":3,\"654\":1,\"655\":3,\"658\":9,\"659\":5,\"663\":1,\"664\":1,\"688\":2,\"689\":2,\"690\":3,\"701\":1,\"702\":1,\"703\":2,\"704\":2,\"708\":2,\"709\":2,\"710\":1,\"715\":4,\"723\":2,\"725\":2,\"726\":4,\"727\":4,\"735\":1,\"736\":2,\"737\":3,\"743\":3,\"744\":1,\"745\":2,\"747\":2,\"751\":2,\"755\":1,\"757\":4,\"763\":6,\"779\":3,\"782\":1,\"785\":1,\"786\":1,\"787\":1,\"789\":26,\"790\":6,\"795\":6,\"800\":5,\"801\":1,\"807\":1,\"812\":8,\"815\":2,\"817\":1,\"818\":1,\"819\":4,\"820\":3,\"821\":1,\"827\":3,\"829\":2,\"830\":1,\"837\":1,\"838\":1,\"839\":1,\"844\":2,\"849\":1,\"854\":1,\"855\":1,\"862\":1,\"865\":1,\"887\":2,\"888\":1,\"916\":2,\"922\":3,\"924\":1,\"928\":5,\"932\":6,\"934\":1,\"946\":1,\"948\":2,\"952\":2,\"958\":1,\"962\":1,\"966\":4,\"982\":1,\"998\":1,\"1018\":1,\"1020\":1,\"1022\":1,\"1044\":5,\"1047\":4,\"1049\":4,\"1068\":1,\"1071\":4,\"1072\":2,\"1077\":3,\"1085\":1,\"1086\":3,\"1088\":1,\"1092\":1,\"1099\":2,\"1100\":1,\"1104\":10,\"1105\":3,\"1107\":2,\"1117\":2,\"1122\":1,\"1138\":1,\"1151\":1,\"1162\":1,\"1163\":5,\"1166\":1,\"1167\":1,\"1176\":2,\"1190\":1,\"1193\":1,\"1211\":1,\"1212\":1,\"1216\":1,\"1217\":1,\"1219\":3,\"1220\":1,\"1253\":5,\"1256\":4,\"1258\":4,\"1272\":1,\"1275\":4,\"1276\":2,\"1281\":3,\"1286\":1,\"1287\":3,\"1289\":1,\"1293\":1,\"1297\":2,\"1298\":1,\"1302\":10,\"1303\":3,\"1305\":2,\"1312\":2,\"1317\":1,\"1331\":1,\"1342\":1,\"1350\":1,\"1351\":5,\"1354\":1,\"1355\":1,\"1361\":2,\"1373\":1,\"1376\":1,\"1388\":1,\"1389\":1,\"1393\":1,\"1394\":1,\"1396\":3,\"1397\":1,\"1429\":1,\"1431\":5,\"1444\":1}}],[\"i4\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"i3==i4\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"i3\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"i2\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"i1==i2\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"i1\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"illegalstateexception\",{\"1\":{\"950\":1}}],[\"illegalargumentexception\",{\"1\":{\"388\":2}}],[\"ibatis\",{\"1\":{\"747\":4,\"754\":1,\"757\":4,\"762\":4,\"763\":4,\"779\":3,\"789\":6,\"790\":4,\"826\":2,\"1444\":1}}],[\"ix\",{\"1\":{\"557\":1}}],[\"ignore来避免违反唯一约束时产生的错误\",{\"1\":{\"577\":1}}],[\"ignore\",{\"1\":{\"440\":4,\"577\":1,\"827\":2}}],[\"ik\",{\"1\":{\"411\":1,\"412\":5,\"413\":1,\"440\":2}}],[\"ik分词器插件安装\",{\"0\":{\"412\":1},\"1\":{\"394\":1}}],[\"ietf\",{\"1\":{\"385\":1}}],[\"ih2\",{\"1\":{\"339\":1}}],[\"i++\",{\"1\":{\"285\":7,\"286\":2,\"289\":1,\"337\":2,\"352\":2,\"360\":3,\"377\":1,\"388\":1,\"692\":5,\"928\":1,\"932\":2,\"1104\":1,\"1105\":1,\"1302\":1,\"1303\":1}}],[\"i+1\",{\"1\":{\"35\":1}}],[\"idempotent\",{\"1\":{\"996\":1}}],[\"identified\",{\"1\":{\"1431\":1}}],[\"identifier\",{\"1\":{\"487\":1,\"488\":1}}],[\"identityhashmap\",{\"1\":{\"948\":1}}],[\"ide\",{\"1\":{\"837\":1,\"1444\":1}}],[\"idea\",{\"0\":{\"838\":1},\"1\":{\"808\":1,\"811\":1,\"854\":2,\"855\":2}}],[\"ids\",{\"1\":{\"787\":4,\"1008\":1}}],[\"id属性\",{\"1\":{\"775\":1,\"777\":1,\"778\":1}}],[\"id`\",{\"1\":{\"726\":1,\"824\":6}}],[\"idle\",{\"1\":{\"648\":2}}],[\"id>\",{\"1\":{\"581\":1,\"844\":1}}],[\"id为3时\",{\"1\":{\"724\":1}}],[\"id为1时\",{\"1\":{\"724\":1}}],[\"id为1的行将被锁定\",{\"1\":{\"556\":1}}],[\"id为2的记录\",{\"1\":{\"434\":1}}],[\"idx\",{\"1\":{\"505\":2}}],[\"idf算法和其他评分算法来计算文档的相关性得分\",{\"1\":{\"1002\":1}}],[\"idf算法\",{\"1\":{\"440\":1}}],[\"idworker\",{\"1\":{\"388\":3}}],[\"id才算是有效的\",{\"1\":{\"383\":1}}],[\"id生成器\",{\"0\":{\"382\":1}}],[\"id=2507\",{\"1\":{\"866\":1}}],[\"id=i\",{\"1\":{\"795\":1}}],[\"id=od\",{\"1\":{\"794\":1,\"795\":1}}],[\"id=u\",{\"1\":{\"793\":2,\"794\":1,\"795\":1}}],[\"id=1669639041722396699\",{\"1\":{\"1030\":1}}],[\"id=1\",{\"1\":{\"555\":1,\"690\":1}}],[\"id=\",{\"1\":{\"201\":2,\"724\":2,\"725\":2,\"727\":4,\"737\":1,\"743\":2,\"744\":1,\"745\":1,\"755\":7,\"759\":2,\"763\":8,\"779\":7,\"780\":2,\"782\":7,\"784\":1,\"785\":1,\"786\":2,\"787\":1,\"789\":6,\"790\":2,\"793\":3,\"794\":2,\"795\":2,\"797\":1,\"815\":2,\"818\":1,\"827\":5,\"865\":31,\"952\":2,\"958\":2,\"1175\":1,\"1176\":1,\"1219\":2,\"1360\":1,\"1361\":1,\"1396\":2}}],[\"id\",{\"0\":{\"201\":1},\"1\":{\"192\":1,\"200\":2,\"381\":2,\"383\":2,\"385\":1,\"387\":3,\"388\":5,\"420\":1,\"433\":4,\"436\":1,\"457\":2,\"501\":7,\"505\":1,\"507\":2,\"526\":2,\"528\":3,\"529\":2,\"530\":2,\"531\":2,\"532\":2,\"556\":2,\"558\":2,\"559\":1,\"573\":4,\"579\":2,\"581\":1,\"658\":2,\"724\":1,\"725\":1,\"727\":6,\"736\":2,\"743\":1,\"744\":3,\"745\":1,\"747\":5,\"753\":4,\"754\":4,\"755\":10,\"759\":4,\"763\":16,\"776\":1,\"782\":6,\"786\":2,\"787\":3,\"789\":6,\"790\":1,\"792\":4,\"793\":7,\"794\":10,\"795\":24,\"797\":1,\"826\":3,\"827\":16,\"831\":1,\"838\":1,\"839\":1,\"885\":1,\"958\":3,\"984\":1,\"990\":1,\"1071\":3,\"1072\":2,\"1105\":2,\"1175\":3,\"1176\":6,\"1177\":3,\"1179\":1,\"1275\":3,\"1276\":2,\"1303\":2,\"1360\":3,\"1361\":6,\"1362\":3,\"1364\":1,\"1431\":5,\"1444\":6}}],[\"ivan\",{\"1\":{\"159\":2}}],[\"iz2zehz5b1m03ahtrhebcaz\",{\"1\":{\"158\":1,\"159\":2}}],[\"io线程\",{\"1\":{\"1186\":1,\"1369\":1}}],[\"ioexception\",{\"1\":{\"950\":1,\"1020\":3}}],[\"ioc容器会在运行时检测此循环引用\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"ioc容器会主动创建一个对象b注入到对象a需要的地方\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"ioc容器的核心接口\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"ioc容器成了整个系统的关键核心\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"ioc容器\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"ioc解耦过程\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"ioc理论提出的观点大体是这样的\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"ioc理论的背景\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"ioc是inversion\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"ioc\",{\"0\":{\"1212\":1,\"1213\":1,\"1389\":1,\"1390\":1},\"1\":{\"950\":8,\"1133\":1,\"1212\":2,\"1213\":2,\"1326\":1,\"1389\":2,\"1390\":2}}],[\"io\",{\"1\":{\"112\":1,\"116\":1,\"251\":1,\"266\":8,\"267\":2,\"270\":7,\"499\":1,\"519\":1,\"589\":1,\"598\":1,\"614\":1,\"747\":2,\"757\":2,\"763\":2,\"837\":1,\"852\":1,\"876\":1,\"887\":1,\"913\":1,\"946\":1,\"1020\":1,\"1031\":1,\"1167\":1,\"1355\":1}}],[\"ipc\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"ipv6\",{\"1\":{\"456\":1}}],[\"ipv4\",{\"1\":{\"456\":1}}],[\"ip+9200\",{\"1\":{\"407\":1}}],[\"ip+port\",{\"1\":{\"406\":1}}],[\"ip地址是服务器对外访问地址\",{\"1\":{\"406\":1}}],[\"ip\",{\"0\":{\"456\":1},\"1\":{\"94\":4,\"106\":6,\"387\":3,\"455\":2,\"456\":4,\"648\":1,\"659\":1,\"906\":1}}],[\"immediately\",{\"1\":{\"603\":1}}],[\"impl\",{\"1\":{\"757\":1,\"830\":3,\"1444\":1}}],[\"implements\",{\"1\":{\"285\":1,\"286\":1,\"754\":1,\"770\":1,\"790\":1,\"830\":1,\"946\":1,\"958\":1,\"1016\":2,\"1092\":2,\"1293\":2}}],[\"implementing\",{\"1\":{\"152\":1}}],[\"implement\",{\"1\":{\"152\":1}}],[\"import\",{\"1\":{\"194\":2,\"337\":1,\"352\":1,\"364\":1,\"377\":1,\"388\":5,\"688\":1,\"689\":8,\"706\":1,\"737\":4,\"747\":8,\"753\":2,\"754\":4,\"757\":12,\"763\":11,\"825\":8,\"826\":5,\"828\":12,\"829\":3,\"830\":25,\"831\":14,\"849\":3,\"876\":7,\"932\":4,\"984\":5,\"990\":5,\"1020\":8,\"1104\":2,\"1105\":4,\"1302\":2,\"1303\":4}}],[\"img\",{\"1\":{\"91\":1,\"176\":1,\"180\":1,\"346\":1,\"348\":1,\"351\":1,\"353\":1,\"358\":1,\"359\":4,\"555\":1,\"557\":1}}],[\"images``\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"images\",{\"1\":{\"854\":1}}],[\"image2\",{\"1\":{\"141\":2}}],[\"image\",{\"1\":{\"90\":2,\"91\":7,\"141\":1,\"183\":1,\"184\":1,\"185\":1,\"186\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":1,\"194\":1,\"195\":1,\"197\":1,\"198\":1,\"199\":1,\"201\":1,\"251\":2,\"493\":1,\"494\":1,\"495\":1,\"502\":1,\"510\":1,\"554\":1,\"581\":1,\"654\":1,\"656\":6,\"657\":2,\"671\":1,\"701\":1,\"702\":1,\"703\":1,\"704\":1,\"705\":1,\"844\":8,\"854\":2,\"855\":2,\"867\":3,\"881\":1,\"885\":2,\"887\":4,\"888\":4,\"889\":8,\"895\":1,\"896\":1,\"898\":1,\"899\":2,\"906\":2,\"909\":1,\"913\":4,\"1034\":1,\"1060\":1,\"1061\":1,\"1266\":1,\"1267\":1,\"1333\":1,\"1338\":2,\"1339\":1,\"1341\":1,\"1342\":2,\"1384\":1,\"1385\":2,\"1444\":4}}],[\"ismodified\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"issingletoncurrentlyincreation\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"issuccess\",{\"1\":{\"829\":1}}],[\"isolation\",{\"1\":{\"1187\":1,\"1220\":5,\"1370\":1,\"1397\":5}}],[\"isr集合当中的\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"isr是由leader维护\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"isr\",{\"1\":{\"1156\":1,\"1160\":5,\"1161\":2,\"1163\":2,\"1344\":1,\"1348\":5,\"1349\":2,\"1351\":2}}],[\"isr的伸缩又指什么\",{\"0\":{\"1156\":1,\"1344\":1}}],[\"isreadable\",{\"1\":{\"1020\":1}}],[\"isinterrupted\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"isvalid\",{\"1\":{\"1020\":1}}],[\"isvip\",{\"1\":{\"200\":1,\"439\":1}}],[\"isacceptable\",{\"1\":{\"1020\":1}}],[\"isadmin\",{\"1\":{\"439\":1}}],[\"isproduced\",{\"1\":{\"988\":5}}],[\"isheldexclusively\",{\"1\":{\"932\":2}}],[\"isexternallymanagedinitmethod\",{\"1\":{\"952\":2}}],[\"isexecutable=\",{\"1\":{\"865\":1}}],[\"iselignored=\",{\"1\":{\"832\":1}}],[\"isempty\",{\"1\":{\"284\":1,\"285\":1,\"286\":1}}],[\"isclosed\",{\"1\":{\"770\":1}}],[\"isfull\",{\"1\":{\"288\":3}}],[\"isnull\",{\"1\":{\"288\":3,\"289\":5}}],[\"isdebugenabled\",{\"1\":{\"195\":1}}],[\"is\",{\"1\":{\"90\":1,\"112\":1,\"152\":3,\"195\":1,\"248\":1,\"411\":1,\"420\":1,\"457\":2,\"526\":1,\"527\":2,\"548\":1,\"557\":1,\"614\":1,\"757\":2,\"762\":1,\"887\":4,\"932\":2,\"1016\":3,\"1023\":4,\"1085\":1,\"1101\":2,\"1286\":1,\"1299\":2}}],[\"if>\",{\"1\":{\"724\":1,\"727\":2,\"755\":6,\"763\":6,\"784\":1,\"786\":8,\"800\":2,\"958\":1}}],[\"ifconfig\",{\"1\":{\"90\":1}}],[\"if\",{\"0\":{\"784\":1},\"1\":{\"80\":1,\"83\":3,\"84\":2,\"106\":1,\"195\":1,\"200\":2,\"267\":2,\"285\":13,\"286\":16,\"288\":5,\"289\":4,\"337\":1,\"352\":5,\"353\":3,\"360\":1,\"364\":3,\"377\":1,\"388\":5,\"526\":1,\"624\":1,\"648\":2,\"664\":1,\"736\":1,\"737\":3,\"787\":2,\"824\":2,\"829\":1,\"830\":2,\"831\":3,\"876\":2,\"922\":7,\"924\":2,\"928\":10,\"932\":1,\"940\":1,\"946\":1,\"948\":2,\"952\":7,\"954\":1,\"958\":1,\"960\":1,\"962\":2,\"964\":5,\"970\":2,\"1004\":1,\"1008\":2,\"1020\":6,\"1023\":5,\"1044\":1,\"1085\":2,\"1092\":1,\"1101\":3,\"1105\":4,\"1176\":1,\"1177\":1,\"1216\":4,\"1253\":1,\"1286\":2,\"1293\":1,\"1299\":3,\"1303\":4,\"1361\":1,\"1362\":1,\"1393\":4,\"1431\":2}}],[\"inherently\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"inherited\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"inetsocketaddress\",{\"1\":{\"1020\":2}}],[\"inet4address\",{\"1\":{\"388\":2}}],[\"injection\",{\"1\":{\"950\":1,\"952\":1}}],[\"inline\",{\"1\":{\"924\":15}}],[\"inner\",{\"1\":{\"827\":1,\"829\":1,\"830\":2,\"831\":1}}],[\"innodb使用意向锁\",{\"1\":{\"575\":1}}],[\"innodb可能会使用自增锁\",{\"1\":{\"575\":1}}],[\"innodb可能会将行锁升级为表锁\",{\"1\":{\"575\":1}}],[\"innodb会使用next\",{\"1\":{\"575\":1}}],[\"innodb会在查询涉及的范围上加上足够的间隙锁\",{\"1\":{\"575\":1}}],[\"innodb会在相关索引的间隙上加上间隙锁\",{\"1\":{\"575\":1}}],[\"innodb会在这些具体的索引项上加上行锁\",{\"1\":{\"575\":1}}],[\"innodb存储引擎采用了一系列加锁规则来保证事务的隔离性\",{\"1\":{\"575\":1}}],[\"innodb存储引擎都有各自的最小存储单元\",{\"1\":{\"272\":1}}],[\"innodb分配自增值并锁定它\",{\"1\":{\"559\":1}}],[\"innodb\",{\"0\":{\"554\":1},\"1\":{\"495\":2,\"511\":2,\"526\":2,\"558\":2,\"559\":2,\"580\":1,\"581\":1}}],[\"invoking\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"invoke\",{\"1\":{\"952\":2,\"1010\":2,\"1016\":4}}],[\"invocationhandler\",{\"1\":{\"1016\":2}}],[\"invocation\",{\"1\":{\"770\":3,\"958\":3}}],[\"inversion\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"inverse\",{\"1\":{\"950\":1}}],[\"inverted\",{\"1\":{\"424\":2,\"1002\":1}}],[\"indicates\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"indicate\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"indian\",{\"1\":{\"589\":1}}],[\"index文件\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"index文件的内容跟我们暂存前是一样的\",{\"1\":{\"916\":1}}],[\"indexcontroller\",{\"1\":{\"1092\":2,\"1293\":2}}],[\"indexfor\",{\"1\":{\"922\":1}}],[\"index=\",{\"1\":{\"724\":2,\"727\":3,\"1219\":6,\"1396\":6}}],[\"indexes\",{\"1\":{\"527\":1}}],[\"indexed\",{\"1\":{\"526\":1}}],[\"index属性控制\",{\"1\":{\"432\":1}}],[\"index++\",{\"1\":{\"286\":2,\"360\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"285\":4,\"286\":4}}],[\"indexof\",{\"1\":{\"284\":1,\"285\":2,\"286\":1}}],[\"index\",{\"0\":{\"418\":1,\"432\":1,\"433\":1},\"1\":{\"106\":15,\"284\":6,\"285\":22,\"286\":23,\"352\":3,\"360\":1,\"424\":1,\"432\":2,\"433\":2,\"436\":4,\"437\":3,\"440\":3,\"457\":3,\"505\":2,\"506\":8,\"507\":3,\"526\":1,\"558\":1,\"604\":2,\"724\":2,\"727\":3,\"829\":2,\"904\":1,\"911\":1,\"998\":5,\"1002\":2,\"1166\":1,\"1354\":1}}],[\"inconsistent\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"inclusion\",{\"1\":{\"934\":1}}],[\"include>\",{\"1\":{\"782\":4}}],[\"include\",{\"1\":{\"106\":2,\"440\":1,\"885\":1}}],[\"incrby\",{\"1\":{\"603\":2}}],[\"incr\",{\"1\":{\"594\":1,\"603\":3,\"1199\":1,\"1379\":1}}],[\"increament\",{\"1\":{\"440\":1}}],[\"increments\",{\"1\":{\"946\":1}}],[\"increment=1004\",{\"1\":{\"824\":1}}],[\"increment=3\",{\"1\":{\"795\":1}}],[\"increment=2\",{\"1\":{\"792\":1,\"795\":1}}],[\"increment=5\",{\"1\":{\"726\":1}}],[\"increment\",{\"1\":{\"383\":1,\"507\":1,\"559\":5,\"575\":1,\"605\":4,\"607\":2,\"726\":1,\"792\":1,\"795\":2,\"824\":1,\"1022\":2}}],[\"initinstance\",{\"1\":{\"1099\":2,\"1297\":2}}],[\"initiator\",{\"1\":{\"865\":2}}],[\"initialmark\",{\"1\":{\"938\":1,\"940\":1}}],[\"initialized\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"initializebean\",{\"1\":{\"952\":2}}],[\"initializingbean\",{\"1\":{\"952\":6}}],[\"initialization\",{\"1\":{\"934\":1,\"950\":1,\"952\":1}}],[\"initializr\",{\"1\":{\"838\":1}}],[\"initial\",{\"1\":{\"406\":1,\"832\":1,\"928\":1,\"940\":1,\"948\":1,\"1150\":1,\"1341\":1}}],[\"initialcapacity\",{\"1\":{\"285\":3,\"946\":3}}],[\"initiallist\",{\"1\":{\"285\":3}}],[\"initmethod\",{\"1\":{\"952\":2}}],[\"initmethodname\",{\"1\":{\"952\":5}}],[\"initbeandefinitionreader\",{\"1\":{\"950\":1}}],[\"init\",{\"1\":{\"337\":2,\"820\":1,\"910\":1,\"913\":2,\"952\":6,\"1128\":1,\"1321\":1,\"1444\":1}}],[\"initqueue\",{\"1\":{\"288\":1,\"289\":2}}],[\"initlimit\",{\"1\":{\"157\":1}}],[\"initlimit这个配置项是用来配置zookeeper接受客户端\",{\"1\":{\"157\":1}}],[\"instead\",{\"1\":{\"954\":1}}],[\"instantiated\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"instantiation\",{\"1\":{\"952\":1}}],[\"instanceof\",{\"0\":{\"1084\":1,\"1285\":1},\"1\":{\"922\":1,\"952\":2,\"1020\":1,\"1084\":6,\"1285\":6}}],[\"instance\",{\"1\":{\"79\":2,\"80\":4,\"83\":6,\"84\":5,\"715\":2,\"800\":1,\"812\":1,\"815\":1,\"818\":1,\"819\":1,\"820\":1,\"844\":1,\"865\":1,\"954\":1,\"1099\":4,\"1297\":4}}],[\"installed\",{\"1\":{\"852\":1}}],[\"install\",{\"1\":{\"109\":4,\"114\":1,\"125\":2,\"247\":1,\"672\":1,\"705\":2,\"711\":1,\"713\":2,\"852\":2,\"896\":5,\"898\":2}}],[\"insert=\",{\"1\":{\"828\":1}}],[\"insertappointment\",{\"1\":{\"826\":1,\"827\":1,\"828\":1,\"830\":1}}],[\"insert>\",{\"1\":{\"755\":1,\"763\":1,\"827\":1,\"1176\":1,\"1361\":1}}],[\"insertuser\",{\"1\":{\"753\":1,\"754\":2,\"755\":1,\"757\":2,\"763\":3}}],[\"insert\",{\"0\":{\"537\":1,\"776\":1},\"1\":{\"526\":1,\"537\":1,\"558\":1,\"559\":1,\"577\":1,\"726\":1,\"736\":2,\"754\":1,\"755\":1,\"763\":1,\"776\":1,\"789\":1,\"795\":5,\"824\":4,\"827\":1,\"828\":2,\"830\":2,\"1176\":3,\"1188\":1,\"1361\":3,\"1371\":1,\"1444\":5}}],[\"insertsort\",{\"1\":{\"352\":5}}],[\"insertelem\",{\"1\":{\"284\":1,\"285\":1,\"286\":1}}],[\"int类型\",{\"1\":{\"1120\":1,\"1315\":1}}],[\"int的默认值是0\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"intptr\",{\"1\":{\"1023\":19}}],[\"intvalue\",{\"1\":{\"966\":1,\"1085\":1,\"1286\":1}}],[\"int8\",{\"1\":{\"630\":1}}],[\"int32\",{\"1\":{\"630\":1}}],[\"int16\",{\"1\":{\"630\":1}}],[\"int64\",{\"1\":{\"624\":2,\"630\":1}}],[\"into\",{\"0\":{\"542\":1},\"1\":{\"526\":1,\"542\":1,\"559\":1,\"577\":1,\"726\":1,\"736\":2,\"755\":1,\"763\":1,\"795\":5,\"824\":4,\"827\":1,\"936\":1,\"1176\":1,\"1361\":1,\"1444\":5}}],[\"intset\",{\"1\":{\"630\":3}}],[\"ints\",{\"1\":{\"388\":4}}],[\"int\",{\"1\":{\"284\":7,\"285\":23,\"286\":17,\"288\":7,\"289\":2,\"337\":11,\"340\":2,\"352\":30,\"353\":6,\"360\":11,\"364\":21,\"377\":14,\"388\":7,\"501\":1,\"505\":2,\"507\":1,\"619\":2,\"621\":1,\"624\":3,\"628\":1,\"635\":1,\"648\":1,\"692\":2,\"726\":1,\"736\":2,\"792\":2,\"795\":7,\"824\":1,\"825\":1,\"826\":4,\"828\":2,\"829\":5,\"830\":2,\"922\":3,\"928\":20,\"932\":6,\"934\":2,\"946\":3,\"948\":4,\"958\":1,\"962\":1,\"988\":1,\"1018\":3,\"1020\":3,\"1022\":2,\"1023\":19,\"1044\":2,\"1084\":1,\"1085\":8,\"1104\":2,\"1105\":1,\"1176\":1,\"1253\":2,\"1285\":1,\"1286\":8,\"1302\":2,\"1303\":1,\"1361\":1,\"1431\":4,\"1444\":1}}],[\"introduction\",{\"1\":{\"232\":1,\"1217\":1,\"1394\":1}}],[\"intellij\",{\"0\":{\"838\":1}}],[\"integration\",{\"1\":{\"713\":3}}],[\"integercachehighpropvalue\",{\"1\":{\"1085\":2,\"1286\":2}}],[\"integercache\",{\"1\":{\"1085\":4,\"1286\":4}}],[\"integer的默认值是null\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"integer实际是对象的引用\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"integer变量必须实例化后才能使用\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"integer>\",{\"1\":{\"353\":1,\"948\":4,\"1044\":3,\"1253\":3}}],[\"integers\",{\"1\":{\"353\":1}}],[\"integer\",{\"1\":{\"192\":1,\"444\":1,\"448\":1,\"603\":9,\"604\":6,\"648\":4,\"660\":1,\"725\":2,\"747\":6,\"785\":1,\"786\":1,\"792\":1,\"793\":3,\"794\":4,\"795\":4,\"1084\":1,\"1085\":13,\"1086\":3,\"1285\":1,\"1286\":13,\"1287\":3}}],[\"intention\",{\"1\":{\"558\":1,\"575\":3}}],[\"interview\",{\"1\":{\"1193\":2,\"1376\":2}}],[\"interval设置为\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"interval\",{\"1\":{\"887\":4}}],[\"interrupt\",{\"1\":{\"1100\":1,\"1101\":3,\"1298\":1,\"1299\":3}}],[\"interruptedexception\",{\"1\":{\"932\":2,\"988\":2,\"1104\":1,\"1105\":3,\"1107\":2,\"1302\":1,\"1303\":3,\"1305\":2}}],[\"interger\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"interpreterruntime\",{\"1\":{\"1023\":4}}],[\"interpreter\",{\"1\":{\"1023\":2}}],[\"interface自定义注解\",{\"1\":{\"944\":1}}],[\"interface\",{\"1\":{\"284\":1,\"688\":1,\"753\":1,\"762\":1,\"763\":1,\"793\":1,\"826\":2,\"830\":1,\"944\":3,\"956\":5,\"958\":1,\"1016\":1,\"1092\":2,\"1143\":1,\"1293\":2,\"1334\":1}}],[\"interceptorregistry\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"interceptortrainconfigurer\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"interceptor=\",{\"1\":{\"770\":1,\"958\":1}}],[\"interceptor\",{\"1\":{\"770\":1,\"958\":2}}],[\"intercepts\",{\"1\":{\"770\":1}}],[\"intercept\",{\"1\":{\"106\":1,\"770\":1,\"958\":1}}],[\"internalresourceviewresolver\",{\"1\":{\"819\":1}}],[\"internal\",{\"1\":{\"106\":1,\"251\":1,\"1431\":1}}],[\"inputstream\",{\"1\":{\"746\":3,\"747\":4,\"757\":2,\"763\":4}}],[\"input\",{\"1\":{\"129\":1,\"131\":2,\"133\":1,\"134\":3,\"135\":4,\"136\":1,\"138\":1,\"139\":4,\"140\":1,\"141\":3,\"143\":1}}],[\"inflexdb\",{\"1\":{\"884\":1}}],[\"inf\",{\"1\":{\"819\":1,\"820\":1,\"831\":1,\"1228\":2,\"1232\":1,\"1403\":2,\"1407\":1}}],[\"infile\",{\"1\":{\"127\":2}}],[\"information\",{\"1\":{\"506\":3,\"511\":3,\"580\":1}}],[\"info\",{\"1\":{\"106\":2,\"143\":1,\"191\":3,\"193\":1,\"195\":3,\"198\":2,\"200\":2,\"201\":2,\"689\":6,\"690\":2,\"885\":1}}],[\"inactive=60s\",{\"1\":{\"106\":1}}],[\"inactive是指经过多长时间文件没被请求后删除缓存\",{\"1\":{\"106\":1}}],[\"in\",{\"0\":{\"529\":2,\"535\":1},\"1\":{\"43\":1,\"106\":1,\"112\":1,\"152\":1,\"282\":1,\"287\":1,\"440\":1,\"495\":1,\"506\":1,\"527\":2,\"529\":2,\"535\":3,\"555\":2,\"558\":2,\"575\":1,\"614\":1,\"624\":1,\"724\":1,\"725\":1,\"727\":1,\"787\":1,\"942\":1,\"1044\":1,\"1072\":1,\"1093\":2,\"1101\":3,\"1156\":1,\"1165\":1,\"1192\":3,\"1253\":1,\"1276\":1,\"1294\":2,\"1299\":3,\"1344\":1,\"1353\":1,\"1375\":3}}],[\"i\",{\"1\":{\"35\":1,\"46\":1,\"94\":2,\"127\":2,\"129\":1,\"131\":2,\"132\":2,\"133\":1,\"134\":3,\"135\":4,\"136\":1,\"138\":1,\"139\":8,\"140\":1,\"141\":3,\"145\":8,\"146\":4,\"201\":1,\"271\":1,\"285\":28,\"286\":5,\"289\":2,\"337\":7,\"352\":9,\"353\":9,\"358\":2,\"360\":11,\"364\":21,\"377\":7,\"388\":4,\"420\":1,\"692\":6,\"724\":6,\"795\":1,\"896\":2,\"909\":1,\"922\":3,\"928\":27,\"932\":4,\"1020\":8,\"1034\":1,\"1084\":3,\"1085\":9,\"1104\":2,\"1105\":2,\"1167\":1,\"1285\":3,\"1286\":9,\"1302\":2,\"1303\":2,\"1355\":1}}],[\"i=1\",{\"1\":{\"35\":1}}],[\"its\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"itself\",{\"1\":{\"887\":1}}],[\"items\",{\"1\":{\"1431\":1}}],[\"itemdetail\",{\"1\":{\"795\":2}}],[\"itemprice\",{\"1\":{\"795\":2}}],[\"itemname\",{\"1\":{\"795\":2}}],[\"item=\",{\"1\":{\"724\":2,\"727\":3,\"787\":1}}],[\"item\",{\"1\":{\"336\":1,\"727\":10,\"787\":1,\"795\":12}}],[\"iterator<selectionkey>\",{\"1\":{\"1020\":1}}],[\"iterator\",{\"1\":{\"286\":67,\"1020\":6}}],[\"it\",{\"1\":{\"29\":2,\"112\":1,\"152\":3,\"856\":1,\"887\":1,\"1023\":2,\"1101\":3,\"1299\":3}}],[\"+printgc\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"+printgcdatestamps\",{\"1\":{\"942\":1}}],[\"+printgcdetails\",{\"1\":{\"942\":1,\"1151\":1,\"1342\":1}}],[\"+string\",{\"1\":{\"1086\":3,\"1287\":3}}],[\"+statementid\",{\"1\":{\"747\":2}}],[\"+n\",{\"1\":{\"1086\":3,\"1287\":3}}],[\"+null\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"+heapdumponoutofmemoryerror\",{\"1\":{\"942\":1}}],[\"+useconcmarksweepgc\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"+useparalleloldgc\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"+useparnewgc\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"+useg1gc\",{\"1\":{\"942\":2}}],[\"+uuid\",{\"1\":{\"876\":1}}],[\"++j\",{\"1\":{\"922\":1}}],[\"++size\",{\"1\":{\"922\":1,\"928\":1}}],[\"++\",{\"1\":{\"360\":1,\"377\":1}}],[\"+=\",{\"1\":{\"285\":1,\"388\":2,\"487\":1,\"488\":1}}],[\"+tree作为索引的效率\",{\"1\":{\"271\":1}}],[\"+tree作为索引的理论基础\",{\"1\":{\"271\":1}}],[\"+tree作为索引结构\",{\"1\":{\"271\":1}}],[\"+92\",{\"1\":{\"94\":1}}],[\"+\",{\"0\":{\"84\":1},\"1\":{\"35\":1,\"46\":1,\"195\":3,\"285\":8,\"286\":2,\"288\":6,\"289\":1,\"337\":1,\"339\":1,\"352\":3,\"353\":1,\"360\":1,\"364\":2,\"388\":4,\"487\":1,\"488\":1,\"573\":1,\"579\":1,\"664\":2,\"689\":12,\"692\":3,\"828\":2,\"830\":1,\"831\":1,\"837\":1,\"849\":1,\"876\":7,\"919\":1,\"928\":1,\"932\":2,\"936\":20,\"946\":1,\"984\":1,\"990\":1,\"1016\":4,\"1018\":3,\"1020\":3,\"1044\":7,\"1072\":4,\"1085\":2,\"1086\":2,\"1092\":5,\"1104\":5,\"1151\":3,\"1176\":1,\"1233\":1,\"1253\":7,\"1276\":4,\"1286\":2,\"1287\":2,\"1293\":5,\"1302\":5,\"1342\":3,\"1361\":1,\"1408\":1}}],[\"y和z\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"yonggen\",{\"1\":{\"940\":2}}],[\"you\",{\"1\":{\"526\":4}}],[\"your\",{\"1\":{\"506\":3,\"511\":1,\"1073\":1,\"1277\":1}}],[\"yao\",{\"1\":{\"919\":1}}],[\"yasm\",{\"1\":{\"125\":1}}],[\"y=\",{\"1\":{\"865\":25}}],[\"yyyy\",{\"1\":{\"800\":2,\"801\":2}}],[\"yiidian\",{\"1\":{\"703\":2,\"704\":2,\"706\":1,\"714\":1,\"716\":1}}],[\"yuv\",{\"1\":{\"145\":1}}],[\"yum\",{\"1\":{\"125\":1,\"852\":8}}],[\"yml增加以下配置项\",{\"1\":{\"885\":1}}],[\"yml\",{\"1\":{\"109\":1,\"406\":1,\"887\":3,\"1060\":1,\"1226\":2,\"1266\":1,\"1401\":2,\"1444\":1}}],[\"y\",{\"1\":{\"35\":2,\"140\":2,\"333\":1,\"339\":1,\"558\":2,\"705\":1,\"852\":1,\"1087\":4,\"1288\":4}}],[\"y^\",{\"1\":{\"35\":2}}],[\"=a\",{\"1\":{\"924\":2}}],[\"=1\",{\"1\":{\"801\":1}}],[\"=null\",{\"1\":{\"724\":1,\"727\":2,\"755\":6,\"763\":6,\"784\":1,\"785\":2,\"786\":8,\"800\":2,\"1099\":1,\"1297\":1}}],[\"=case\",{\"1\":{\"724\":1,\"725\":1,\"727\":1}}],[\"=或<>操作符\",{\"0\":{\"527\":1}}],[\"=>\",{\"1\":{\"487\":1,\"488\":1}}],[\"==>\",{\"1\":{\"648\":2,\"725\":2,\"789\":12,\"790\":2}}],[\"==============================test=============================================\",{\"1\":{\"388\":1}}],[\"==============================methods==========================================\",{\"1\":{\"388\":1}}],[\"==============================constructors=====================================\",{\"1\":{\"388\":1}}],[\"==============================fields===========================================\",{\"1\":{\"388\":1}}],[\"==\",{\"1\":{\"80\":1,\"83\":3,\"84\":2,\"267\":2,\"285\":8,\"286\":12,\"288\":2,\"289\":3,\"352\":1,\"353\":2,\"388\":2,\"487\":1,\"488\":1,\"624\":1,\"664\":1,\"829\":1,\"831\":3,\"922\":4,\"928\":6,\"932\":1,\"948\":2,\"952\":1,\"962\":1,\"964\":2,\"970\":1,\"1020\":1,\"1023\":6,\"1044\":1,\"1087\":1,\"1092\":1,\"1216\":2,\"1253\":1,\"1288\":1,\"1293\":1,\"1393\":2}}],[\"=\",{\"0\":{\"533\":1},\"1\":{\"35\":1,\"79\":1,\"80\":2,\"83\":2,\"84\":2,\"106\":1,\"134\":5,\"143\":6,\"157\":5,\"192\":1,\"194\":1,\"195\":2,\"267\":2,\"285\":25,\"286\":81,\"288\":17,\"289\":22,\"337\":19,\"339\":1,\"352\":26,\"353\":6,\"360\":11,\"364\":16,\"377\":15,\"387\":4,\"388\":33,\"487\":4,\"488\":4,\"495\":1,\"501\":3,\"505\":2,\"506\":2,\"511\":1,\"527\":1,\"532\":1,\"555\":1,\"556\":1,\"558\":1,\"571\":1,\"573\":8,\"577\":1,\"578\":1,\"579\":4,\"604\":1,\"648\":14,\"658\":1,\"689\":9,\"692\":14,\"727\":2,\"737\":13,\"744\":1,\"746\":3,\"747\":16,\"754\":1,\"755\":10,\"757\":8,\"759\":1,\"763\":20,\"766\":2,\"770\":2,\"779\":8,\"782\":2,\"784\":2,\"785\":3,\"786\":12,\"787\":1,\"789\":8,\"790\":4,\"793\":4,\"794\":2,\"795\":2,\"800\":3,\"827\":6,\"828\":11,\"829\":9,\"830\":11,\"831\":19,\"832\":2,\"849\":2,\"876\":12,\"919\":1,\"922\":21,\"924\":6,\"928\":54,\"932\":7,\"934\":7,\"936\":6,\"940\":1,\"944\":6,\"946\":9,\"948\":12,\"950\":2,\"952\":10,\"954\":3,\"958\":5,\"962\":3,\"964\":4,\"966\":7,\"982\":2,\"984\":3,\"988\":4,\"990\":7,\"992\":5,\"1004\":3,\"1008\":6,\"1010\":11,\"1016\":5,\"1018\":1,\"1020\":15,\"1022\":1,\"1023\":4,\"1044\":3,\"1071\":1,\"1084\":2,\"1085\":15,\"1086\":1,\"1087\":4,\"1092\":5,\"1093\":8,\"1099\":5,\"1104\":7,\"1105\":3,\"1107\":5,\"1163\":5,\"1174\":4,\"1175\":1,\"1176\":6,\"1177\":4,\"1192\":1,\"1216\":6,\"1253\":3,\"1275\":1,\"1285\":2,\"1286\":15,\"1287\":1,\"1288\":4,\"1293\":5,\"1294\":8,\"1297\":5,\"1302\":7,\"1303\":3,\"1305\":5,\"1351\":5,\"1359\":4,\"1360\":1,\"1361\":6,\"1362\":4,\"1375\":1,\"1393\":6,\"1431\":7}}],[\"rds\",{\"1\":{\"1444\":1}}],[\"rdb和aof\",{\"1\":{\"972\":1}}],[\"rdbsave\",{\"1\":{\"962\":1}}],[\"rdb\",{\"1\":{\"962\":6,\"964\":4,\"1201\":1,\"1381\":1}}],[\"rc\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"rf\",{\"1\":{\"852\":1}}],[\"rfc4122\",{\"1\":{\"385\":1}}],[\"rfc\",{\"1\":{\"385\":1}}],[\"rs\",{\"1\":{\"737\":9,\"1176\":3,\"1361\":3}}],[\"rsync\",{\"1\":{\"94\":1}}],[\"rpc\",{\"1\":{\"830\":1,\"1033\":2}}],[\"rpoplpush\",{\"1\":{\"604\":1,\"655\":2}}],[\"rpop\",{\"1\":{\"604\":1,\"655\":1}}],[\"rpushx\",{\"1\":{\"604\":1}}],[\"rpush\",{\"1\":{\"604\":5,\"655\":1}}],[\"ru\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"ruanyifeng\",{\"1\":{\"917\":1,\"919\":1}}],[\"rust学习教程\",{\"0\":{\"903\":1}}],[\"rust\",{\"0\":{\"902\":1},\"1\":{\"904\":5}}],[\"rule\",{\"1\":{\"887\":1}}],[\"rules\",{\"1\":{\"887\":4}}],[\"ruby\",{\"1\":{\"589\":1}}],[\"runwith\",{\"1\":{\"828\":2}}],[\"runnable\",{\"1\":{\"1100\":1,\"1104\":1,\"1298\":1,\"1302\":1}}],[\"runner\",{\"1\":{\"828\":1}}],[\"running\",{\"1\":{\"248\":1,\"1100\":2,\"1101\":2,\"1298\":2,\"1299\":2}}],[\"runtime<\",{\"1\":{\"812\":1}}],[\"runtime\",{\"1\":{\"688\":1,\"706\":1,\"944\":5,\"1092\":2,\"1143\":1,\"1293\":2,\"1334\":1}}],[\"runtimeexception\",{\"1\":{\"388\":1,\"829\":4}}],[\"runoob\",{\"1\":{\"605\":1,\"606\":1}}],[\"runs\",{\"1\":{\"152\":1}}],[\"run\",{\"1\":{\"116\":1,\"247\":1,\"251\":1,\"692\":2,\"855\":1,\"1059\":2,\"1098\":1,\"1101\":2,\"1104\":4,\"1105\":2,\"1107\":3,\"1265\":2,\"1296\":1,\"1299\":2,\"1302\":4,\"1303\":2,\"1305\":3}}],[\"rr隔离级别旨在防止幻读现象\",{\"1\":{\"575\":1}}],[\"rr\",{\"0\":{\"575\":1},\"1\":{\"1187\":1,\"1370\":1}}],[\"rwkc2lnarknn8dc0hrp58g\",{\"1\":{\"1184\":1,\"1367\":1}}],[\"rw\",{\"1\":{\"159\":1}}],[\"rwxr\",{\"1\":{\"159\":8}}],[\"rtmp\",{\"1\":{\"146\":5}}],[\"r用于限制输出\",{\"1\":{\"145\":1}}],[\"r与\",{\"1\":{\"145\":1}}],[\"raid56\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"raid6\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"raid\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"ratelimiter\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"ratio\",{\"1\":{\"790\":1}}],[\"rabbitmq\",{\"1\":{\"594\":1}}],[\"rank\",{\"1\":{\"1177\":2,\"1362\":2}}],[\"random\",{\"1\":{\"1105\":3,\"1303\":3}}],[\"randomaccess\",{\"1\":{\"946\":1}}],[\"randomutils\",{\"1\":{\"388\":2}}],[\"randomuuid\",{\"1\":{\"385\":1,\"876\":1,\"1008\":1}}],[\"range\",{\"1\":{\"448\":5}}],[\"rangecheck\",{\"1\":{\"285\":2,\"286\":3}}],[\"radixsort\",{\"1\":{\"377\":2}}],[\"radix\",{\"1\":{\"371\":1}}],[\"ram\",{\"1\":{\"273\":1}}],[\"race\",{\"1\":{\"152\":1}}],[\"raw\",{\"1\":{\"109\":1,\"1216\":1,\"1393\":1}}],[\"ray\",{\"0\":{\"61\":1},\"1\":{\"17\":1,\"60\":1}}],[\"robj\",{\"1\":{\"628\":1,\"635\":3}}],[\"rollover\",{\"1\":{\"1068\":2,\"1272\":2}}],[\"rollback\",{\"1\":{\"581\":1,\"770\":1,\"958\":1}}],[\"role\",{\"1\":{\"249\":1}}],[\"rowbounds\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"row\",{\"0\":{\"564\":1}}],[\"rocketmq\",{\"1\":{\"524\":1,\"1032\":1}}],[\"rocketmq快速入门教程\",{\"0\":{\"147\":1}}],[\"routing\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"routing=1\",{\"1\":{\"457\":1}}],[\"roundyuan\",{\"1\":{\"1104\":1,\"1105\":1,\"1302\":1,\"1303\":1}}],[\"round\",{\"1\":{\"340\":1}}],[\"room`\",{\"1\":{\"146\":1}}],[\"rootbeandefinition\",{\"1\":{\"952\":1}}],[\"roots\",{\"1\":{\"1150\":2,\"1341\":2}}],[\"roots开始递归的标记对象图\",{\"1\":{\"938\":1}}],[\"roots开始对堆中对象进行并发标记\",{\"1\":{\"936\":1,\"940\":1}}],[\"roots能直接关联的对象\",{\"1\":{\"936\":1,\"938\":1,\"940\":1}}],[\"root>\",{\"1\":{\"821\":1}}],[\"root\",{\"1\":{\"94\":2,\"106\":8,\"158\":1,\"159\":4,\"267\":2,\"435\":1,\"737\":1,\"743\":2,\"745\":1,\"864\":1,\"1176\":1,\"1361\":1}}],[\"rodert单排学习redis进阶\",{\"0\":{\"611\":1,\"612\":1,\"639\":1,\"640\":1}}],[\"rodert单排学习redis入门\",{\"0\":{\"585\":1,\"586\":1},\"1\":{\"613\":1,\"641\":1,\"647\":1}}],[\"rodert教你学mybatis\",{\"0\":{\"730\":1,\"731\":1},\"1\":{\"738\":1}}],[\"rodert教你学maven\",{\"0\":{\"697\":1,\"698\":1}}],[\"rodert教你学zookeeper\",{\"0\":{\"148\":1,\"149\":1}}],[\"rodert教你学ffmpeg实战这一篇就够了\",{\"0\":{\"119\":1,\"120\":1}}],[\"rodert\",{\"1\":{\"106\":1,\"112\":1,\"116\":1,\"209\":1,\"288\":1,\"289\":1,\"337\":3,\"352\":1,\"377\":2,\"641\":1,\"647\":1,\"681\":1,\"688\":2,\"689\":2,\"690\":1,\"812\":3,\"815\":2,\"818\":1,\"819\":1,\"825\":4,\"826\":6,\"827\":2,\"828\":10,\"829\":12,\"830\":23,\"831\":9,\"832\":1,\"844\":1,\"849\":2,\"856\":1,\"867\":1,\"878\":1,\"885\":1,\"889\":1,\"913\":3,\"922\":2,\"924\":2,\"926\":2,\"928\":2,\"930\":2,\"932\":2,\"934\":2,\"936\":2,\"938\":2,\"940\":2,\"942\":2,\"944\":2,\"946\":2,\"948\":2,\"950\":2,\"952\":2,\"954\":2,\"956\":2,\"958\":2,\"960\":2,\"962\":2,\"964\":2,\"966\":2,\"968\":2,\"970\":2,\"972\":2,\"974\":2,\"976\":2,\"978\":2,\"980\":2,\"982\":2,\"988\":2,\"990\":2,\"992\":2,\"994\":2,\"996\":2,\"998\":2,\"1000\":2,\"1002\":2,\"1004\":2,\"1006\":2,\"1008\":2,\"1010\":2,\"1012\":2,\"1016\":2,\"1018\":2,\"1020\":2,\"1023\":2,\"1030\":1,\"1062\":1,\"1068\":1,\"1070\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1268\":1,\"1272\":1,\"1274\":1,\"1302\":2,\"1303\":1,\"1305\":1,\"1444\":1}}],[\"rlimit\",{\"1\":{\"106\":2}}],[\"rmi\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"rmb\",{\"1\":{\"906\":1}}],[\"rm\",{\"1\":{\"90\":1,\"91\":2,\"852\":1,\"1444\":1}}],[\"review\",{\"1\":{\"1439\":1}}],[\"reentrantlock也可重入\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"reentrantlock也是独占锁\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"reentrantlock默认情况下也是非公平锁\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"reentrantlock\",{\"0\":{\"1106\":1,\"1304\":1},\"1\":{\"1022\":1,\"1105\":5,\"1303\":5}}],[\"rewriteappendonlyfile\",{\"1\":{\"962\":1}}],[\"rewrite的时候会阻塞客户端查询\",{\"1\":{\"962\":1}}],[\"remembered\",{\"1\":{\"940\":6}}],[\"remark\",{\"1\":{\"940\":1,\"1150\":1,\"1341\":1}}],[\"removeeldestentry\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"removeelem\",{\"1\":{\"284\":1,\"285\":2,\"286\":1}}],[\"removeelements\",{\"1\":{\"284\":1,\"285\":1,\"286\":1}}],[\"remove\",{\"1\":{\"852\":2,\"1020\":1,\"1216\":1,\"1393\":1}}],[\"remove及取交集并集和差集及更丰富的操作\",{\"1\":{\"589\":1}}],[\"removal\",{\"1\":{\"419\":1}}],[\"remote\",{\"1\":{\"94\":10,\"106\":1,\"589\":1,\"913\":1}}],[\"rejectedexecutionexception\",{\"1\":{\"926\":1}}],[\"regularly\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"registered\",{\"1\":{\"1216\":2,\"1393\":2}}],[\"register\",{\"1\":{\"1020\":2}}],[\"registry\",{\"1\":{\"852\":2,\"885\":1,\"1092\":2,\"1293\":2}}],[\"region\",{\"1\":{\"940\":2}}],[\"regarded\",{\"1\":{\"43\":1}}],[\"redo\",{\"1\":{\"1185\":1,\"1220\":1,\"1368\":1,\"1397\":1}}],[\"redlock算法通过在多个redis实例上获取锁\",{\"1\":{\"970\":1}}],[\"red\",{\"1\":{\"944\":2}}],[\"reducenumber\",{\"1\":{\"826\":2,\"827\":1,\"828\":1,\"830\":1}}],[\"redert肝一篇maven\",{\"1\":{\"698\":1}}],[\"redirect\",{\"1\":{\"104\":1,\"106\":2,\"831\":1}}],[\"redis实现分布式锁要注意什么\",{\"0\":{\"1206\":1,\"1386\":1}}],[\"redis部署分为单节点\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"redis篇\",{\"1\":{\"1041\":1}}],[\"redis支持两种持久化方式\",{\"1\":{\"972\":1}}],[\"redis支持多种压缩算法\",{\"1\":{\"972\":1}}],[\"redis内存优化\",{\"0\":{\"972\":1}}],[\"redis使用上如何做内存优化\",{\"0\":{\"1204\":1,\"1384\":1}}],[\"redis使用的是基于setnx命令的方式来实现分布式锁\",{\"1\":{\"970\":1}}],[\"redis使用crc16算法对键进行哈希计算\",{\"1\":{\"968\":1}}],[\"redis使用一种称为\",{\"1\":{\"968\":1}}],[\"redis使用场景\",{\"0\":{\"594\":1}}],[\"redis分布式锁\",{\"0\":{\"970\":1}}],[\"redis分布式锁要注意哪几点\",{\"0\":{\"664\":1}}],[\"redis分布式锁要点注意\",{\"0\":{\"663\":1}}],[\"redis分片集群会使用一种叫做\",{\"1\":{\"968\":1}}],[\"redis分片集群会自动进行重新分片\",{\"1\":{\"968\":1}}],[\"redis分片集群\",{\"0\":{\"968\":1}}],[\"redis主从架构是什么\",{\"1\":{\"964\":1}}],[\"redis主从架构\",{\"0\":{\"964\":1}}],[\"redisdb\",{\"1\":{\"962\":1}}],[\"redisdesktop\",{\"1\":{\"643\":1}}],[\"redis提供了aof重写机制\",{\"1\":{\"962\":1}}],[\"redis提供的哈希\",{\"1\":{\"594\":1}}],[\"redis重启时会重新执行aof文件中的命令来恢复数据\",{\"1\":{\"962\":1}}],[\"redis持久化有几种方式\",{\"0\":{\"1201\":1,\"1381\":1}}],[\"redis持久化\",{\"0\":{\"962\":1}}],[\"redis客户端\",{\"1\":{\"812\":1}}],[\"redis5\",{\"1\":{\"669\":1}}],[\"redis基础\",{\"0\":{\"960\":1}}],[\"redis基础数据结构\",{\"0\":{\"651\":1}}],[\"redis基本类型使用场景都懂了\",{\"0\":{\"652\":1}}],[\"redispool\",{\"1\":{\"648\":1}}],[\"redisutil\",{\"1\":{\"648\":2}}],[\"redis可视化工具\",{\"1\":{\"643\":1}}],[\"redis之白银一\",{\"1\":{\"640\":1}}],[\"redis之青铜\",{\"1\":{\"612\":1}}],[\"redisobject\",{\"1\":{\"635\":5}}],[\"redis的瓶颈最有可能是机器内存的大小或者网络带宽\",{\"1\":{\"1200\":1,\"1380\":1}}],[\"redis的rdb和aof双持久化方案\",{\"1\":{\"962\":1}}],[\"redis的持久化方案用的真的很巧妙\",{\"1\":{\"962\":1}}],[\"redis的优点很多\",{\"1\":{\"960\":1}}],[\"redis的对象\",{\"0\":{\"634\":1,\"635\":1}}],[\"redis的开发工作由vmware主持\",{\"1\":{\"589\":1}}],[\"redis中\",{\"1\":{\"621\":1}}],[\"redis中数据结构的对象\",{\"1\":{\"613\":1}}],[\"redis数据结构\",{\"0\":{\"617\":1}}],[\"redis数据结构解析\",{\"1\":{\"613\":1}}],[\"redis常用\",{\"0\":{\"608\":1}}],[\"redis>\",{\"1\":{\"604\":5,\"660\":6}}],[\"redis超时\",{\"1\":{\"603\":1}}],[\"redis就像一个可以持久化的memcached服务器\",{\"1\":{\"603\":1}}],[\"redis是串行执行命令\",{\"1\":{\"1206\":1,\"1386\":1}}],[\"redis是什么\",{\"0\":{\"1198\":1,\"1378\":1}}],[\"redis是一个高性能的内存数据库\",{\"1\":{\"972\":1}}],[\"redis是内存数据库\",{\"1\":{\"962\":1}}],[\"redis是非常优秀的缓存工具\",{\"1\":{\"601\":1}}],[\"redis是目前最热的缓存组件之一\",{\"1\":{\"587\":1}}],[\"redis哨兵\",{\"1\":{\"601\":1}}],[\"redis根目录下\",{\"1\":{\"597\":1}}],[\"redis列表结构\",{\"1\":{\"594\":1}}],[\"redis特性\",{\"0\":{\"590\":1}}],[\"redis入门\",{\"0\":{\"589\":1},\"1\":{\"586\":1}}],[\"redis版\",{\"0\":{\"341\":1}}],[\"redis\",{\"0\":{\"584\":1,\"602\":1,\"621\":1,\"622\":1,\"623\":1,\"625\":1,\"633\":1,\"642\":1,\"643\":1,\"644\":1,\"646\":1,\"648\":1,\"668\":1,\"1377\":1},\"1\":{\"342\":2,\"524\":1,\"587\":4,\"588\":1,\"589\":11,\"592\":4,\"593\":4,\"594\":8,\"597\":10,\"598\":4,\"600\":1,\"601\":3,\"602\":1,\"604\":5,\"605\":4,\"606\":4,\"607\":2,\"608\":2,\"613\":3,\"614\":5,\"615\":3,\"619\":6,\"622\":4,\"624\":6,\"626\":3,\"628\":3,\"629\":2,\"630\":1,\"632\":1,\"633\":2,\"635\":9,\"636\":5,\"641\":1,\"643\":2,\"647\":3,\"648\":1,\"652\":4,\"654\":2,\"655\":2,\"656\":1,\"658\":1,\"659\":2,\"660\":1,\"664\":3,\"671\":1,\"672\":2,\"674\":4,\"950\":2,\"960\":5,\"962\":9,\"964\":9,\"970\":6,\"1041\":1,\"1043\":4,\"1045\":2,\"1048\":3,\"1052\":1,\"1077\":1,\"1197\":3,\"1198\":1,\"1199\":1,\"1201\":3,\"1205\":1,\"1233\":3,\"1252\":4,\"1254\":2,\"1257\":3,\"1261\":1,\"1281\":1,\"1378\":1,\"1379\":1,\"1381\":3,\"1385\":1,\"1408\":3},\"2\":{\"72\":1,\"73\":1,\"345\":1,\"609\":1,\"610\":1,\"637\":1,\"638\":1,\"649\":1,\"650\":1,\"661\":1,\"662\":1,\"665\":1,\"666\":1,\"676\":1,\"677\":1,\"1209\":1}}],[\"ret\",{\"1\":{\"689\":4,\"1431\":3}}],[\"retention定义注解的生命周期\",{\"1\":{\"944\":1}}],[\"retentionpolicy\",{\"1\":{\"688\":1,\"944\":8,\"1092\":2,\"1293\":2}}],[\"retention\",{\"1\":{\"688\":1,\"944\":8,\"1092\":5,\"1293\":5}}],[\"returned\",{\"1\":{\"790\":1}}],[\"returning\",{\"1\":{\"689\":1,\"1217\":1,\"1394\":1}}],[\"returnresource\",{\"1\":{\"648\":1}}],[\"returnjedis\",{\"1\":{\"648\":1}}],[\"return\",{\"1\":{\"79\":1,\"80\":1,\"83\":1,\"84\":1,\"192\":1,\"267\":2,\"284\":9,\"285\":13,\"286\":15,\"288\":12,\"289\":6,\"337\":6,\"340\":2,\"352\":5,\"353\":2,\"364\":1,\"388\":11,\"648\":4,\"689\":2,\"747\":9,\"753\":2,\"754\":2,\"763\":4,\"770\":2,\"779\":4,\"780\":2,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"793\":1,\"794\":1,\"795\":1,\"826\":5,\"829\":4,\"830\":10,\"831\":7,\"832\":1,\"849\":1,\"924\":6,\"928\":6,\"932\":4,\"946\":1,\"954\":2,\"958\":1,\"964\":1,\"966\":2,\"970\":4,\"1004\":1,\"1008\":1,\"1016\":1,\"1018\":1,\"1022\":1,\"1023\":2,\"1044\":4,\"1085\":2,\"1092\":8,\"1101\":1,\"1216\":3,\"1253\":4,\"1286\":2,\"1293\":8,\"1299\":1,\"1393\":3,\"1431\":5}}],[\"reids\",{\"1\":{\"652\":1}}],[\"rehashing\",{\"1\":{\"624\":1}}],[\"rehashidx\",{\"1\":{\"624\":2,\"625\":4}}],[\"rehash\",{\"0\":{\"625\":1},\"1\":{\"624\":3,\"625\":7,\"626\":3,\"928\":2}}],[\"recently\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"receivemessage\",{\"1\":{\"986\":1}}],[\"received\",{\"1\":{\"984\":1,\"990\":1,\"1020\":1}}],[\"receive\",{\"1\":{\"964\":1}}],[\"recursions\",{\"1\":{\"1023\":2}}],[\"records`\",{\"1\":{\"982\":2}}],[\"records\",{\"1\":{\"824\":2,\"982\":7,\"984\":2,\"990\":2}}],[\"record\",{\"1\":{\"575\":1,\"984\":2,\"990\":2}}],[\"recipes\",{\"1\":{\"154\":1}}],[\"repeatappointexception\",{\"1\":{\"829\":4,\"830\":4,\"831\":2}}],[\"repeatable\",{\"1\":{\"575\":1,\"1187\":1,\"1220\":1,\"1370\":1,\"1397\":1}}],[\"repeat\",{\"1\":{\"829\":1,\"830\":2,\"831\":1}}],[\"repo\",{\"1\":{\"852\":2}}],[\"reporting\",{\"1\":{\"844\":2}}],[\"repo1\",{\"1\":{\"705\":1}}],[\"repository是本地仓库\",{\"1\":{\"702\":1}}],[\"repository\",{\"1\":{\"701\":1,\"702\":2,\"705\":1,\"944\":2}}],[\"repl\",{\"1\":{\"964\":1}}],[\"replstate\",{\"1\":{\"964\":1}}],[\"reply\",{\"1\":{\"602\":1}}],[\"replicas是怎么管理的\",{\"0\":{\"1160\":1,\"1348\":1}}],[\"replicas\",{\"1\":{\"1156\":3,\"1165\":1,\"1344\":3,\"1353\":1}}],[\"replicaofcommand\",{\"1\":{\"964\":2}}],[\"replication\",{\"1\":{\"601\":1,\"986\":1,\"1078\":2,\"1282\":2}}],[\"replica可以分担搜索请求\",{\"1\":{\"422\":1}}],[\"replica保证数据不丢失\",{\"1\":{\"422\":1}}],[\"replica承担三个任务\",{\"1\":{\"422\":1}}],[\"replica就是shard的数据拷贝\",{\"1\":{\"422\":1}}],[\"replica\",{\"0\":{\"422\":1},\"1\":{\"422\":5,\"980\":1,\"994\":1,\"1002\":1,\"1159\":1,\"1160\":2,\"1347\":1,\"1348\":2}}],[\"replaced\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"replacestaleentry\",{\"1\":{\"928\":1}}],[\"replaceall\",{\"1\":{\"876\":1}}],[\"replace\",{\"1\":{\"284\":3,\"285\":4,\"286\":4}}],[\"refused\",{\"1\":{\"964\":1}}],[\"refusing\",{\"1\":{\"388\":1}}],[\"ref\",{\"1\":{\"821\":1}}],[\"ref=\",{\"1\":{\"815\":1,\"818\":1,\"821\":1}}],[\"refid=\",{\"1\":{\"724\":1,\"782\":5}}],[\"reflect\",{\"1\":{\"689\":2,\"1093\":1,\"1294\":1}}],[\"refcount\",{\"1\":{\"635\":3}}],[\"refman\",{\"1\":{\"526\":1,\"527\":3,\"548\":1}}],[\"referring\",{\"1\":{\"504\":1}}],[\"references\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"reference\",{\"1\":{\"252\":1,\"419\":1,\"431\":1,\"457\":1,\"635\":1,\"1216\":2,\"1393\":2}}],[\"referer\",{\"1\":{\"106\":2,\"1137\":1,\"1330\":1}}],[\"refresh\",{\"1\":{\"457\":2,\"950\":2,\"1071\":1,\"1275\":1}}],[\"requires\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"required\",{\"1\":{\"849\":1,\"964\":1,\"1220\":1,\"1397\":1}}],[\"requirepass\",{\"1\":{\"673\":1}}],[\"require\",{\"1\":{\"487\":5,\"488\":6,\"1085\":1,\"1286\":1}}],[\"requests\",{\"1\":{\"885\":1}}],[\"requestparam\",{\"1\":{\"831\":1,\"849\":2}}],[\"requestmethod\",{\"1\":{\"831\":3}}],[\"requestmapping\",{\"1\":{\"819\":1,\"831\":5,\"832\":1,\"849\":2,\"876\":3,\"944\":2}}],[\"request\",{\"1\":{\"192\":1,\"201\":1,\"252\":1,\"876\":4,\"952\":1,\"956\":4,\"1072\":1,\"1092\":4,\"1127\":1,\"1137\":1,\"1215\":1,\"1276\":1,\"1293\":4,\"1320\":1,\"1330\":1,\"1392\":1,\"1431\":1}}],[\"req\",{\"1\":{\"192\":2,\"201\":2}}],[\"reserved\",{\"1\":{\"1023\":2}}],[\"reset\",{\"0\":{\"918\":1},\"1\":{\"918\":3}}],[\"resouces\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"resourceloader\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"resourceentityresolver\",{\"1\":{\"950\":1}}],[\"resource\",{\"1\":{\"746\":2,\"747\":2,\"757\":2,\"763\":2,\"766\":2,\"950\":1,\"1136\":1,\"1329\":1}}],[\"resource=\",{\"1\":{\"745\":1,\"755\":2,\"763\":3,\"766\":1,\"772\":5,\"782\":1}}],[\"resources\",{\"1\":{\"713\":4,\"746\":1,\"747\":2,\"757\":2,\"763\":2,\"809\":1,\"816\":1,\"821\":1,\"865\":1}}],[\"resolving\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"resolveviewname\",{\"1\":{\"956\":1}}],[\"resolvebeforeinstantiation\",{\"1\":{\"954\":1}}],[\"resize的过程中\",{\"1\":{\"922\":1}}],[\"resize的实现过程主要分为以下几步\",{\"1\":{\"922\":1}}],[\"resize\",{\"1\":{\"922\":1,\"948\":1}}],[\"responsible\",{\"1\":{\"1023\":2}}],[\"responsibility\",{\"1\":{\"152\":1}}],[\"responseentity\",{\"1\":{\"1431\":4}}],[\"responseentity<apiresponse<user>>\",{\"1\":{\"1431\":1}}],[\"responsestatus\",{\"1\":{\"1431\":7}}],[\"response\",{\"1\":{\"876\":4,\"956\":2,\"964\":1,\"1092\":6,\"1127\":1,\"1293\":6,\"1320\":1}}],[\"responsebody\",{\"1\":{\"831\":2}}],[\"responsebody等\",{\"1\":{\"819\":1}}],[\"resutltype无法帮助我们自动的去完成映射\",{\"1\":{\"797\":1}}],[\"resulting\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"results\",{\"1\":{\"1004\":3}}],[\"resultsethandler\",{\"1\":{\"770\":1}}],[\"resultset\",{\"1\":{\"737\":2,\"1176\":1,\"1361\":1}}],[\"result<>\",{\"1\":{\"831\":1}}],[\"result<appointexecution>\",{\"1\":{\"831\":2}}],[\"result<t>\",{\"1\":{\"830\":1}}],[\"resultmap的继承\",{\"0\":{\"796\":1}}],[\"resultmap>\",{\"1\":{\"793\":1,\"794\":1,\"795\":1,\"797\":1}}],[\"resultmap=\",{\"1\":{\"782\":2,\"793\":1,\"794\":1,\"795\":1}}],[\"resultmap\",{\"0\":{\"781\":1},\"1\":{\"763\":1,\"775\":1}}],[\"resulttype=\",{\"1\":{\"744\":1,\"755\":3,\"759\":1,\"763\":4,\"779\":7,\"780\":2,\"782\":2,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"793\":1,\"827\":3,\"958\":2,\"1175\":1,\"1360\":1}}],[\"resulttype\",{\"1\":{\"744\":1,\"755\":1,\"763\":1,\"775\":1,\"827\":1}}],[\"result++\",{\"1\":{\"285\":1,\"286\":6}}],[\"result\",{\"1\":{\"94\":2,\"192\":1,\"285\":8,\"286\":12,\"689\":2,\"829\":1,\"830\":4,\"831\":1,\"958\":2,\"1010\":1,\"1016\":2,\"1084\":1,\"1285\":1,\"1431\":1}}],[\"restcontroller\",{\"1\":{\"831\":1,\"849\":2,\"944\":1,\"1092\":2,\"1293\":2}}],[\"rest\",{\"1\":{\"412\":1,\"460\":1,\"1231\":1,\"1406\":1}}],[\"restful\",{\"1\":{\"400\":1,\"1027\":1}}],[\"restart\",{\"1\":{\"251\":1,\"852\":1}}],[\"res\",{\"1\":{\"353\":4}}],[\"re\",{\"1\":{\"146\":1}}],[\"relay\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"relativepath允许你选择一个不同的位置\",{\"1\":{\"715\":1}}],[\"relativepath\",{\"1\":{\"715\":1}}],[\"relativepath>\",{\"1\":{\"715\":1}}],[\"relations\",{\"1\":{\"457\":2}}],[\"reload\",{\"1\":{\"852\":1}}],[\"release<\",{\"1\":{\"709\":1,\"710\":1,\"715\":1,\"812\":1}}],[\"release\",{\"1\":{\"703\":1,\"932\":2,\"970\":1,\"1023\":1}}],[\"releaseshared\",{\"1\":{\"932\":1}}],[\"releases\",{\"1\":{\"125\":1,\"408\":1,\"412\":1,\"414\":1,\"597\":1,\"598\":1}}],[\"relieve\",{\"1\":{\"152\":1}}],[\"reliable\",{\"1\":{\"112\":1}}],[\"reactor线程模型的思想就是基于io复用和线程池的结合\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"reactor模型是什么\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"reactor\",{\"1\":{\"950\":1}}],[\"reash\",{\"1\":{\"625\":1}}],[\"rear+1\",{\"1\":{\"288\":1}}],[\"rear\",{\"1\":{\"288\":11,\"289\":7}}],[\"rear=maxsize\",{\"1\":{\"288\":1}}],[\"ready\",{\"1\":{\"1100\":2,\"1298\":2}}],[\"readobject\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"reader\",{\"1\":{\"766\":2,\"950\":2}}],[\"readdisk\",{\"1\":{\"267\":1}}],[\"readme\",{\"1\":{\"159\":1,\"911\":2}}],[\"read\",{\"1\":{\"106\":1,\"143\":2,\"572\":2,\"573\":1,\"575\":3,\"1020\":2,\"1187\":3,\"1220\":3,\"1370\":3,\"1397\":3}}],[\"real\",{\"1\":{\"106\":2}}],[\"r\",{\"1\":{\"35\":3,\"94\":2,\"106\":1,\"127\":1,\"141\":3,\"145\":3,\"159\":2,\"371\":2,\"372\":2,\"495\":1,\"924\":3,\"1107\":1,\"1305\":1}}],[\"right\",{\"1\":{\"35\":3,\"152\":1,\"364\":4}}],[\"lw\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"lw等分别代表什么\",{\"0\":{\"1157\":1,\"1345\":1}}],[\"lfu\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"lfence\",{\"1\":{\"924\":1}}],[\"lfd\",{\"1\":{\"898\":1}}],[\"lvm2\",{\"1\":{\"852\":1}}],[\"lt\",{\"1\":{\"800\":1}}],[\"ltrim\",{\"1\":{\"604\":1}}],[\"ltrim可用来限制列表的数量\",{\"1\":{\"594\":1}}],[\"lpop\",{\"1\":{\"604\":1,\"655\":1}}],[\"lpushx\",{\"1\":{\"604\":1}}],[\"lpush\",{\"1\":{\"604\":2,\"655\":1}}],[\"lpush可以在列表头部插入一个内容id作为关键字\",{\"1\":{\"594\":1}}],[\"lrem\",{\"1\":{\"604\":1}}],[\"lrange\",{\"1\":{\"604\":4,\"655\":2}}],[\"lrulinkedmap<string\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"lrulinkedmap<k\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"lrulinkedmap\",{\"1\":{\"1044\":2,\"1253\":2}}],[\"lru等其他知识点\",{\"1\":{\"636\":1}}],[\"lru\",{\"0\":{\"1044\":1,\"1253\":1},\"1\":{\"601\":1,\"635\":2,\"636\":1,\"1044\":1,\"1253\":1}}],[\"lru驱动事件\",{\"1\":{\"601\":1}}],[\"luxian\",{\"1\":{\"906\":1}}],[\"lua\",{\"1\":{\"601\":1}}],[\"lua脚本\",{\"1\":{\"601\":1}}],[\"lucene是一个开源的全文搜索引擎库\",{\"1\":{\"1000\":1}}],[\"lucene\",{\"1\":{\"400\":4,\"443\":2,\"450\":2,\"524\":1,\"1071\":3,\"1275\":3}}],[\"lucene™\",{\"1\":{\"400\":1}}],[\"lq\",{\"1\":{\"289\":8}}],[\"lmenezes\",{\"1\":{\"408\":1}}],[\"lmstudio\",{\"2\":{\"239\":1,\"240\":1}}],[\"lm\",{\"0\":{\"235\":1,\"238\":1},\"1\":{\"238\":1},\"2\":{\"236\":1,\"237\":1}}],[\"llen\",{\"1\":{\"604\":1}}],[\"llama3\",{\"1\":{\"247\":2,\"249\":2,\"251\":3},\"2\":{\"254\":1}}],[\"ll\",{\"1\":{\"159\":1}}],[\"ldconfig\",{\"1\":{\"125\":1}}],[\"ld\",{\"1\":{\"125\":1}}],[\"lifecycle\",{\"1\":{\"711\":3}}],[\"lifo\",{\"1\":{\"282\":1}}],[\"liawan\",{\"1\":{\"668\":1,\"1062\":1,\"1268\":1}}],[\"like\",{\"1\":{\"501\":1,\"511\":1,\"530\":2,\"532\":1,\"782\":2,\"784\":1,\"785\":1,\"786\":1,\"958\":1,\"1068\":1,\"1192\":1,\"1272\":1,\"1375\":1}}],[\"licensed\",{\"1\":{\"614\":1}}],[\"license\",{\"1\":{\"487\":1,\"488\":1,\"688\":1,\"689\":1,\"849\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1302\":2,\"1303\":1,\"1305\":1}}],[\"li\",{\"1\":{\"436\":3}}],[\"livereload\",{\"1\":{\"912\":1}}],[\"live\",{\"1\":{\"146\":5,\"1238\":1,\"1411\":1}}],[\"library\",{\"1\":{\"241\":1,\"251\":1,\"252\":1}}],[\"libfdk\",{\"1\":{\"145\":1}}],[\"libx264\",{\"1\":{\"135\":1,\"145\":1,\"146\":1}}],[\"libx265\",{\"1\":{\"135\":1}}],[\"lib\",{\"1\":{\"125\":1,\"701\":1,\"852\":1}}],[\"libavcodec里很多code都是从头开发的\",{\"1\":{\"122\":1}}],[\"list各实现类的序列化与反序列化实现\",{\"1\":{\"946\":1}}],[\"list各实现类在并发环境下的表现\",{\"1\":{\"946\":1}}],[\"listiterator与iterator的区别与使用场景\",{\"1\":{\"946\":1}}],[\"list迭代器\",{\"1\":{\"946\":1}}],[\"list子列表的实现原理与边界情况\",{\"1\":{\"946\":1}}],[\"list及其相关知识还有很多值得我继续学习与探索的地方\",{\"1\":{\"946\":1}}],[\"list接口表示一个有序集合\",{\"1\":{\"946\":1}}],[\"list和预留空间等手段减轻空间碎片问题\",{\"1\":{\"938\":1}}],[\"list维护小块空闲空间\",{\"1\":{\"938\":1}}],[\"list>\",{\"1\":{\"820\":2}}],[\"listnode\",{\"1\":{\"621\":8,\"622\":1}}],[\"lists\",{\"0\":{\"604\":1},\"1\":{\"593\":1,\"601\":1,\"604\":4,\"936\":1,\"940\":1}}],[\"list<string>\",{\"1\":{\"1008\":2}}],[\"list<document>\",{\"1\":{\"1004\":3}}],[\"list<topicpartition>\",{\"1\":{\"986\":1}}],[\"list<producerrecord<string\",{\"1\":{\"982\":1}}],[\"list<book>\",{\"1\":{\"826\":1,\"828\":1,\"830\":2,\"831\":1}}],[\"list<orderdetail>\",{\"1\":{\"794\":1}}],[\"list<user>\",{\"1\":{\"753\":1,\"754\":1,\"757\":1,\"763\":4,\"779\":2,\"784\":2,\"785\":2,\"786\":2,\"787\":2}}],[\"list<integer>\",{\"1\":{\"284\":1,\"285\":3,\"286\":2,\"353\":3}}],[\"list<\",{\"1\":{\"284\":1,\"285\":2,\"286\":2}}],[\"list<e>\",{\"1\":{\"284\":1,\"285\":1,\"286\":1,\"946\":1}}],[\"list\",{\"0\":{\"655\":1,\"946\":1,\"1114\":1,\"1309\":1},\"1\":{\"114\":1,\"145\":1,\"247\":1,\"284\":2,\"285\":9,\"286\":11,\"353\":8,\"589\":1,\"592\":1,\"619\":1,\"621\":3,\"622\":1,\"655\":4,\"724\":2,\"727\":4,\"753\":1,\"754\":1,\"757\":1,\"763\":1,\"794\":1,\"795\":1,\"797\":1,\"826\":1,\"828\":1,\"830\":2,\"831\":12,\"852\":1,\"866\":1,\"916\":1,\"946\":3,\"960\":1,\"1100\":1,\"1112\":1,\"1113\":2,\"1114\":1,\"1179\":2,\"1198\":1,\"1298\":1,\"1307\":1,\"1308\":2,\"1309\":1,\"1364\":2,\"1378\":1}}],[\"listeners\",{\"1\":{\"1230\":1,\"1405\":1}}],[\"listener\",{\"1\":{\"865\":2}}],[\"listening\",{\"1\":{\"106\":2}}],[\"listen\",{\"1\":{\"106\":4}}],[\"limit\",{\"1\":{\"106\":1,\"607\":2,\"826\":3,\"827\":2,\"1181\":1,\"1366\":1}}],[\"linenumber\",{\"1\":{\"800\":1}}],[\"linsert\",{\"1\":{\"604\":3}}],[\"lindex\",{\"1\":{\"604\":1}}],[\"linkedhashset\",{\"1\":{\"1112\":1,\"1307\":1}}],[\"linkedhashmap<k\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"linkedhashmap<>\",{\"1\":{\"948\":1}}],[\"linkedhashmap<string\",{\"1\":{\"948\":1}}],[\"linkedhashmap\",{\"1\":{\"922\":1,\"948\":1,\"1044\":2,\"1112\":1,\"1175\":1,\"1253\":2,\"1307\":1,\"1360\":1}}],[\"linked\",{\"1\":{\"604\":1}}],[\"linkedlist的底层是双向链表\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"linkedlist<>\",{\"1\":{\"946\":1}}],[\"linkedlist<integer>\",{\"1\":{\"946\":1}}],[\"linkedlist<e>\",{\"1\":{\"286\":1}}],[\"linkedlist\",{\"0\":{\"286\":1,\"1117\":1,\"1312\":1},\"1\":{\"286\":2,\"946\":1,\"1112\":1,\"1307\":1}}],[\"linkqueue<integer>\",{\"1\":{\"289\":2}}],[\"linkqueue<t>\",{\"1\":{\"289\":1}}],[\"linkqueue\",{\"1\":{\"289\":1}}],[\"linktr\",{\"1\":{\"2\":1}}],[\"linux中的pid\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"linux下docker安装\",{\"0\":{\"852\":1}}],[\"linux下redis安装\",{\"0\":{\"667\":1}}],[\"linux下\",{\"0\":{\"598\":1}}],[\"linux安装jdk\",{\"0\":{\"404\":1}}],[\"linux安装es\",{\"0\":{\"405\":1},\"1\":{\"394\":1}}],[\"linux安装\",{\"0\":{\"125\":1}}],[\"linux\",{\"0\":{\"88\":1,\"247\":1,\"1073\":1,\"1277\":1},\"1\":{\"90\":6,\"405\":2,\"591\":2,\"598\":1,\"852\":1}}],[\"lag\",{\"1\":{\"1156\":3,\"1344\":3}}],[\"later\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"latest\",{\"1\":{\"852\":3}}],[\"latch\",{\"1\":{\"932\":3}}],[\"label\",{\"1\":{\"887\":1,\"1059\":4,\"1265\":4}}],[\"lazy\",{\"1\":{\"440\":1,\"952\":1}}],[\"lazyloadingsingleton\",{\"1\":{\"80\":5}}],[\"lang\",{\"1\":{\"688\":1,\"689\":5,\"763\":1,\"904\":1,\"1023\":2,\"1092\":1,\"1093\":1,\"1142\":1,\"1149\":1,\"1293\":1,\"1294\":1,\"1333\":1,\"1340\":1}}],[\"language=\",{\"1\":{\"832\":1}}],[\"language\",{\"1\":{\"411\":1,\"837\":1,\"1177\":1,\"1362\":1}}],[\"lang3\",{\"1\":{\"388\":3}}],[\"langchain\",{\"0\":{\"229\":1,\"232\":1},\"1\":{\"232\":1},\"2\":{\"230\":1,\"231\":1,\"233\":1,\"234\":1}}],[\"lastest\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"lastname\",{\"1\":{\"432\":1,\"434\":3,\"436\":3,\"439\":1}}],[\"lasttimestamp\",{\"1\":{\"388\":9}}],[\"last\",{\"1\":{\"282\":1,\"436\":5,\"450\":2,\"451\":6,\"1157\":1,\"1345\":1}}],[\"layouts\",{\"1\":{\"144\":1}}],[\"largest\",{\"1\":{\"364\":8}}],[\"large\",{\"1\":{\"106\":1,\"922\":1}}],[\"looking\",{\"1\":{\"1239\":2,\"1412\":2}}],[\"look\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"loopback\",{\"1\":{\"591\":1}}],[\"loop++\",{\"1\":{\"286\":1}}],[\"loop\",{\"1\":{\"286\":1}}],[\"low\",{\"1\":{\"1085\":4,\"1157\":1,\"1286\":4,\"1345\":1}}],[\"lotail\",{\"1\":{\"922\":1}}],[\"lohead\",{\"1\":{\"922\":1}}],[\"lombok\",{\"1\":{\"689\":1,\"812\":1,\"825\":7,\"829\":1,\"830\":1}}],[\"loadbeandefinitions\",{\"1\":{\"950\":3}}],[\"loadclass\",{\"1\":{\"934\":1}}],[\"loadstore\",{\"1\":{\"924\":1}}],[\"loadload\",{\"1\":{\"924\":1}}],[\"load\",{\"1\":{\"625\":1,\"820\":1,\"887\":1,\"924\":4,\"928\":2,\"948\":1}}],[\"loading\",{\"1\":{\"440\":2,\"950\":2}}],[\"love\",{\"1\":{\"420\":1}}],[\"lock2\",{\"1\":{\"1105\":7,\"1303\":7}}],[\"lock1\",{\"1\":{\"1105\":7,\"1303\":7}}],[\"locked\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"lockobj\",{\"1\":{\"1100\":2,\"1298\":2}}],[\"lock函数中\",{\"1\":{\"970\":2}}],[\"lock`\",{\"1\":{\"577\":1}}],[\"locks\",{\"0\":{\"564\":1,\"565\":1,\"566\":1},\"1\":{\"558\":2,\"559\":2,\"561\":2,\"574\":1,\"575\":4,\"932\":1,\"1105\":2,\"1303\":2}}],[\"lock\",{\"1\":{\"406\":1,\"555\":2,\"558\":2,\"561\":1,\"572\":3,\"575\":5,\"577\":6,\"580\":2,\"664\":2,\"924\":3,\"932\":2,\"970\":14,\"988\":1,\"1022\":6,\"1023\":13,\"1105\":3,\"1106\":1,\"1193\":1,\"1206\":1,\"1244\":3,\"1303\":3,\"1304\":1,\"1376\":1,\"1386\":1,\"1417\":3},\"2\":{\"666\":1}}],[\"locateelements\",{\"1\":{\"284\":1,\"285\":2,\"286\":1}}],[\"locateelem\",{\"1\":{\"284\":1,\"285\":1,\"286\":1}}],[\"locations\",{\"1\":{\"1444\":2}}],[\"location=\",{\"1\":{\"815\":1}}],[\"location对url进行匹配\",{\"1\":{\"106\":1}}],[\"location\",{\"1\":{\"106\":17}}],[\"localcache\",{\"1\":{\"1045\":2,\"1254\":2}}],[\"locale\",{\"1\":{\"956\":2}}],[\"localhost\",{\"1\":{\"106\":1,\"109\":3,\"146\":1,\"249\":2,\"412\":1,\"413\":1,\"436\":3,\"462\":2,\"816\":1,\"824\":2,\"831\":1,\"866\":4,\"885\":1,\"887\":2,\"912\":1,\"984\":1,\"990\":1,\"1008\":1}}],[\"localhost是根据用户请求的url进行匹配\",{\"1\":{\"106\":1}}],[\"local\",{\"1\":{\"94\":5,\"106\":3,\"109\":1,\"125\":3,\"930\":1,\"944\":1}}],[\"long这几个类的valueof方法的实现是类似的\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"long\",{\"1\":{\"340\":5,\"387\":2,\"388\":30,\"439\":2,\"444\":1,\"448\":1,\"621\":1,\"624\":3,\"689\":3,\"725\":4,\"763\":2,\"790\":1,\"792\":1,\"793\":1,\"794\":1,\"825\":3,\"826\":6,\"827\":1,\"828\":6,\"829\":3,\"830\":8,\"831\":3,\"1085\":2,\"1100\":1,\"1101\":1,\"1286\":2,\"1298\":1,\"1299\":1,\"1431\":1}}],[\"logging\",{\"1\":{\"1444\":1}}],[\"loggerfactory\",{\"1\":{\"194\":2,\"830\":2,\"831\":2}}],[\"logger\",{\"1\":{\"194\":3,\"195\":5,\"821\":1,\"830\":4,\"831\":3}}],[\"log实现的\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"log中的语句\",{\"1\":{\"1186\":1,\"1369\":1}}],[\"log中\",{\"1\":{\"1186\":1,\"1369\":1}}],[\"logendoffset\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"logaround\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"logaspect\",{\"1\":{\"689\":1}}],[\"loglog\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"logrotate\",{\"1\":{\"852\":2}}],[\"loginrequired\",{\"1\":{\"1092\":8,\"1293\":8}}],[\"login\",{\"1\":{\"763\":3,\"779\":6,\"888\":1}}],[\"logindate\",{\"1\":{\"439\":1}}],[\"logpointcut\",{\"1\":{\"689\":6,\"1092\":3,\"1293\":3}}],[\"log2\",{\"1\":{\"364\":2}}],[\"logn\",{\"1\":{\"270\":2,\"495\":1,\"922\":1,\"1122\":1,\"1317\":1}}],[\"logback<\",{\"1\":{\"812\":1}}],[\"logback\",{\"0\":{\"194\":1},\"1\":{\"821\":3}}],[\"log4j12\",{\"1\":{\"708\":1}}],[\"log4j12<\",{\"1\":{\"708\":1,\"709\":1,\"715\":1}}],[\"log4j\",{\"0\":{\"194\":1}}],[\"log404\",{\"1\":{\"106\":1}}],[\"logopath\",{\"1\":{\"876\":3}}],[\"logo的宽和高\",{\"1\":{\"140\":1}}],[\"logo\",{\"1\":{\"139\":4,\"225\":1,\"876\":2}}],[\"logstartoffset\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"logstash\",{\"1\":{\"400\":1}}],[\"logs\",{\"1\":{\"106\":7,\"856\":1}}],[\"log\",{\"0\":{\"542\":1},\"1\":{\"35\":2,\"94\":8,\"106\":14,\"157\":1,\"192\":2,\"193\":2,\"195\":4,\"196\":1,\"197\":1,\"198\":4,\"200\":2,\"201\":4,\"264\":1,\"266\":3,\"270\":2,\"340\":4,\"348\":1,\"357\":2,\"503\":1,\"688\":2,\"689\":7,\"1185\":5,\"1220\":1,\"1368\":5,\"1397\":1,\"1444\":1},\"2\":{\"691\":1}}],[\"leo这两个都是指最后一条的下一条的位置而不是指最后一条的位置\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"leo\",{\"0\":{\"1157\":1,\"1345\":1},\"1\":{\"1157\":1,\"1161\":3,\"1163\":1,\"1345\":1,\"1349\":3,\"1351\":1}}],[\"lexicon\",{\"1\":{\"424\":1}}],[\"learner\",{\"1\":{\"1243\":2,\"1416\":2}}],[\"leading\",{\"1\":{\"1239\":2,\"1412\":2}}],[\"leader的选举\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"leader负责处理读写请求\",{\"1\":{\"986\":1}}],[\"leader挂后\",{\"1\":{\"166\":1}}],[\"leader与非leader服务器各司其职\",{\"1\":{\"166\":1}}],[\"leader选举是保证分布式数据一致性的关键所在\",{\"1\":{\"166\":1}}],[\"leader是干嘛用的\",{\"1\":{\"153\":1}}],[\"leader\",{\"0\":{\"1165\":1,\"1353\":1},\"1\":{\"112\":2,\"1159\":7,\"1160\":6,\"1163\":4,\"1164\":2,\"1165\":1,\"1166\":1,\"1239\":3,\"1242\":5,\"1243\":5,\"1347\":7,\"1348\":6,\"1351\":4,\"1352\":2,\"1353\":1,\"1354\":1,\"1412\":3,\"1415\":5,\"1416\":5}}],[\"least\",{\"1\":{\"374\":1,\"1044\":2,\"1253\":2}}],[\"lenght\",{\"1\":{\"632\":1}}],[\"length+1\",{\"1\":{\"353\":1}}],[\"length\",{\"1\":{\"106\":1,\"284\":1,\"285\":13,\"286\":3,\"337\":2,\"352\":8,\"353\":1,\"360\":4,\"364\":3,\"377\":1,\"511\":1,\"630\":1,\"922\":1,\"928\":6,\"948\":1,\"1085\":1,\"1286\":1}}],[\"len\",{\"1\":{\"337\":2,\"364\":12,\"619\":1,\"621\":1,\"928\":11,\"1020\":4}}],[\"level=\",{\"1\":{\"821\":1}}],[\"level\",{\"1\":{\"106\":1,\"152\":1,\"628\":2,\"994\":1}}],[\"less\",{\"1\":{\"90\":1,\"339\":1,\"388\":2}}],[\"left\",{\"1\":{\"35\":3,\"364\":4,\"793\":2,\"794\":2,\"795\":3}}],[\"lso\",{\"0\":{\"1157\":1,\"1345\":1},\"1\":{\"1157\":2,\"1345\":2}}],[\"lset\",{\"1\":{\"604\":1}}],[\"lsd\",{\"1\":{\"375\":4,\"377\":4}}],[\"lsd的排序方式由键值的最右边开始\",{\"1\":{\"374\":1}}],[\"ls\",{\"1\":{\"90\":1,\"91\":2,\"159\":3,\"1241\":1,\"1414\":1}}],[\"导出oom时的堆转储文件\",{\"1\":{\"942\":1}}],[\"导入和各种版本冲突\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"导入相关的库和类\",{\"1\":{\"1008\":1}}],[\"导入依赖\",{\"0\":{\"812\":1,\"862\":1}}],[\"导入文件\",{\"0\":{\"34\":1}}],[\"导致用户每次请求该数据都要去数据库中查询一遍\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"导致大量网络阻塞\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"导致不一致\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"导致读取老的\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"导致版本号更新并不完全正确\",{\"1\":{\"1018\":1}}],[\"导致性能下降比较严重\",{\"1\":{\"1018\":1}}],[\"导致的问题是\",{\"1\":{\"1018\":1}}],[\"导致系统难以演进\",{\"1\":{\"950\":1}}],[\"导致事务管理不生效\",{\"1\":{\"950\":1}}],[\"导致\",{\"1\":{\"950\":2,\"1048\":1,\"1165\":1,\"1257\":1,\"1353\":1}}],[\"导致依赖注入错误\",{\"1\":{\"950\":1}}],[\"导致控制层无法具体识别是哪个异常\",{\"1\":{\"830\":1}}],[\"导致整个系统崩溃\",{\"1\":{\"645\":1}}],[\"导致这些事务都无法继续执行\",{\"1\":{\"562\":1}}],[\"导致全表扫描\",{\"1\":{\"501\":1}}],[\"导致我们的日志信息不规整\",{\"1\":{\"196\":1}}],[\"导航栏\",{\"1\":{\"20\":1,\"23\":1}}],[\"此场景下zookeeper\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"此阶段清理删除掉标记阶段判断的已经死亡的对象\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"此内存区域的唯一目的就是存放对象实例\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"此为\",{\"1\":{\"950\":1}}],[\"此处的切点是注解的方式\",{\"1\":{\"689\":1}}],[\"此时事务\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"此时连接取消\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"此时连接建立\",{\"1\":{\"1134\":1,\"1327\":1}}],[\"此时处于就绪状态\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"此时对象还未初始化\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"此时只需一看源码便知究竟\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"此时会阻塞当前\",{\"1\":{\"962\":1}}],[\"此时会进入默认\",{\"1\":{\"918\":1}}],[\"此时工作区\",{\"1\":{\"916\":1}}],[\"此时我们从最后一个非叶子结点开始\",{\"1\":{\"364\":1}}],[\"此时末尾就为最大值\",{\"1\":{\"364\":1}}],[\"此时如果使用计数排序的话\",{\"1\":{\"361\":1}}],[\"此时有个key\",{\"1\":{\"333\":1,\"339\":1}}],[\"此时系统会向磁盘发出读盘信号\",{\"1\":{\"274\":1}}],[\"此时进行一次磁盘\",{\"1\":{\"267\":1}}],[\"此时\",{\"1\":{\"166\":1,\"364\":2,\"434\":1,\"1051\":1,\"1260\":1}}],[\"此时假定server1的zxid为123\",{\"1\":{\"166\":1}}],[\"此时便开始leader选举\",{\"1\":{\"166\":1}}],[\"此时便认为已经选出了leader\",{\"1\":{\"166\":1}}],[\"此时也不会影响leader\",{\"1\":{\"166\":1}}],[\"此时server2的myid最大\",{\"1\":{\"166\":1}}],[\"此时server1的投票为\",{\"1\":{\"166\":1}}],[\"此时两台机器可以相互通信\",{\"1\":{\"166\":1}}],[\"此选项仅在使用sendfile的时候使用\",{\"1\":{\"106\":1}}],[\"此选项允许或禁止使用socke的tcp\",{\"1\":{\"106\":1}}],[\"此文字有脚注^first\",{\"1\":{\"33\":1}}],[\"此外\",{\"1\":{\"3\":1,\"184\":1,\"511\":1,\"713\":1,\"926\":1,\"952\":1,\"968\":1,\"980\":3,\"992\":1,\"1016\":2,\"1022\":1}}],[\"脚注\",{\"0\":{\"33\":1}}],[\"提议者\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"提议者服务器只负责发送提交指令\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"提前演练\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"提前将对象注入到\",{\"1\":{\"954\":1}}],[\"提升读取性能\",{\"1\":{\"1043\":1,\"1252\":1}}],[\"提到的这些关键点imovativ析得很透彻\",{\"1\":{\"940\":1}}],[\"提到\",{\"1\":{\"919\":1}}],[\"提示用户登录\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"提示用户冲突发生\",{\"1\":{\"573\":1}}],[\"提示\",{\"1\":{\"826\":1}}],[\"提交之前先提交了\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"提交新的合并段到磁盘\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"提交操作\",{\"1\":{\"1018\":1}}],[\"提交\",{\"1\":{\"917\":3}}],[\"提交代码\",{\"1\":{\"915\":2}}],[\"提交成功\",{\"1\":{\"866\":1}}],[\"提交流程\",{\"1\":{\"866\":1}}],[\"提交事务\",{\"1\":{\"751\":1}}],[\"提交时检查版本号是否发生变化\",{\"1\":{\"569\":1}}],[\"提交一个比较大\",{\"1\":{\"106\":1}}],[\"提高\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"提高检索效率\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"提高检索性能\",{\"1\":{\"519\":1}}],[\"提高消费者的处理能力\",{\"1\":{\"982\":1}}],[\"提高开发效率\",{\"1\":{\"950\":1}}],[\"提高运用能力\",{\"1\":{\"946\":1}}],[\"提高效率\",{\"1\":{\"940\":1,\"982\":1}}],[\"提高自己的工程化水平与解决问题的能力\",{\"1\":{\"922\":1}}],[\"提高系统的安全性\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"提高系统的并发处理能力\",{\"1\":{\"984\":1}}],[\"提高系统吞吐量\",{\"1\":{\"950\":1}}],[\"提高系统灵活性\",{\"1\":{\"950\":1}}],[\"提高系统扩展性\",{\"1\":{\"950\":1}}],[\"提高系统扩展性和复用性\",{\"1\":{\"922\":1}}],[\"提高系统并发能力\",{\"0\":{\"547\":1}}],[\"提高查询性能\",{\"1\":{\"922\":1,\"1002\":1}}],[\"提高查询效率\",{\"1\":{\"499\":1}}],[\"提高性能和可扩展性\",{\"1\":{\"1004\":1}}],[\"提高性能\",{\"1\":{\"574\":1,\"922\":1,\"970\":1}}],[\"提高了redis集群高可用的特性\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"提高了redis的性能\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"提高了数据的写入和读取效率\",{\"1\":{\"980\":1}}],[\"提高了并发性\",{\"1\":{\"566\":1}}],[\"提高了并发性能\",{\"1\":{\"561\":1}}],[\"提高了系统的稳定性及可用性\",{\"1\":{\"518\":1}}],[\"提高了范围查询\",{\"1\":{\"264\":1}}],[\"提高集群的吞吐和性能\",{\"1\":{\"422\":1}}],[\"提出\",{\"1\":{\"357\":1}}],[\"提出的一个技巧\",{\"1\":{\"339\":1}}],[\"提问答疑\",{\"1\":{\"211\":1}}],[\"提问的智慧\",{\"1\":{\"10\":1}}],[\"提供一个\",{\"1\":{\"1444\":1}}],[\"提供一系列端点可以监控服务及应用\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"提供一些列\",{\"1\":{\"819\":1}}],[\"提供在监听器中注册bean的事件\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"提供对常用orm框架的管理和支持\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"提供映射标签支持字段关系映射\",{\"1\":{\"1173\":1,\"1358\":1}}],[\"提供视频+完善文档\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"提供出色的性能\",{\"1\":{\"980\":1}}],[\"提供两种持久化方案\",{\"1\":{\"962\":1}}],[\"提供事务管理\",{\"1\":{\"950\":1}}],[\"提供广泛的事务管理接口\",{\"1\":{\"950\":1}}],[\"提供\",{\"1\":{\"950\":1}}],[\"提供多种操作\",{\"1\":{\"895\":1}}],[\"提供高可用性\",{\"1\":{\"601\":1}}],[\"提供的插件接口\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"提供的首个近似聚合是cardinality\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"提供的别名机制使用非常广泛\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"提供的用来简化\",{\"1\":{\"844\":1}}],[\"提供的\",{\"1\":{\"594\":1}}],[\"提供的有序集合数据类构能实现各种复杂的排行榜应用\",{\"1\":{\"594\":1}}],[\"提供的功能包括\",{\"1\":{\"154\":1}}],[\"提供了aop\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"提供了两种持久化的方式\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"提供了9种动态sql标签\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"提供了副本机制\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"提供了选择器来实现多路复用\",{\"1\":{\"1020\":1}}],[\"提供了扩展点可以在\",{\"1\":{\"952\":1}}],[\"提供了\",{\"1\":{\"952\":2,\"1034\":2}}],[\"提供了在\",{\"1\":{\"950\":1}}],[\"提供了快速开发单个微服务的能力\",{\"1\":{\"950\":1}}],[\"提供了几种垃圾收集器\",{\"1\":{\"936\":1}}],[\"提供了发布\",{\"1\":{\"594\":1}}],[\"提供了键过期功能\",{\"1\":{\"594\":1}}],[\"提供了30多种常见语言的分词器\",{\"1\":{\"411\":1}}],[\"提供了分布式独享锁\",{\"1\":{\"154\":1}}],[\"提供java和c的接口\",{\"1\":{\"154\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"31\":1}}],[\"提取重复代码块\",{\"1\":{\"958\":1}}],[\"提取javapub讲坛\",{\"1\":{\"132\":1}}],[\"提取音频\",{\"0\":{\"132\":1,\"133\":1}}],[\"m3\",{\"1\":{\"992\":1}}],[\"m1\",{\"1\":{\"992\":1}}],[\"mbd\",{\"1\":{\"952\":6,\"954\":1}}],[\"mfence\",{\"1\":{\"924\":2}}],[\"mw08tjgs\",{\"1\":{\"864\":1}}],[\"mchange\",{\"1\":{\"815\":1}}],[\"mm\",{\"1\":{\"800\":4,\"801\":4,\"821\":1}}],[\"mmap\",{\"1\":{\"403\":1,\"1167\":1,\"1355\":1}}],[\"m2\",{\"1\":{\"701\":1,\"702\":1,\"705\":1,\"992\":1}}],[\"mget\",{\"1\":{\"603\":3}}],[\"mutex\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"mutual\",{\"1\":{\"562\":1,\"1106\":1,\"1304\":1}}],[\"multi\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"murmurhash2\",{\"1\":{\"626\":1}}],[\"must\",{\"1\":{\"526\":1}}],[\"muxers\",{\"1\":{\"144\":1}}],[\"mx\",{\"1\":{\"451\":2}}],[\"m++\",{\"1\":{\"377\":1}}],[\"m是bit数组长度\",{\"1\":{\"340\":1}}],[\"merge操作\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"merged\",{\"1\":{\"954\":1}}],[\"merge\",{\"1\":{\"915\":1,\"917\":1,\"919\":1}}],[\"meta\",{\"1\":{\"1092\":1,\"1228\":2,\"1232\":1,\"1293\":1,\"1403\":2,\"1407\":1}}],[\"metadata\",{\"1\":{\"820\":1,\"837\":1,\"1228\":1,\"1403\":1}}],[\"metrics\",{\"1\":{\"883\":1,\"885\":2,\"887\":3}}],[\"method指定静态方法名称\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"method等自定义的销毁方法\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"method等\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"methods\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"methodsignature\",{\"1\":{\"689\":3}}],[\"method=\",{\"1\":{\"952\":2}}],[\"methodname\",{\"1\":{\"689\":2,\"1092\":3,\"1293\":3}}],[\"method\",{\"1\":{\"106\":1,\"192\":2,\"688\":1,\"689\":4,\"770\":1,\"831\":3,\"934\":2,\"944\":4,\"952\":11,\"1010\":3,\"1016\":5,\"1033\":1,\"1092\":2,\"1101\":3,\"1142\":2,\"1293\":2,\"1299\":3,\"1333\":2}}],[\"method是使用的hash算法\",{\"1\":{\"106\":1}}],[\"message3\",{\"1\":{\"992\":1}}],[\"message2\",{\"1\":{\"992\":1}}],[\"message1\",{\"1\":{\"992\":1}}],[\"message\",{\"1\":{\"614\":1,\"829\":13,\"916\":1,\"984\":1,\"986\":4,\"990\":1,\"1020\":6,\"1167\":2,\"1355\":2,\"1431\":10}}],[\"messages两个维度\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"messages\",{\"1\":{\"249\":1}}],[\"member\",{\"1\":{\"606\":4,\"607\":6}}],[\"member2\",{\"1\":{\"606\":2,\"607\":1}}],[\"member1\",{\"1\":{\"606\":2,\"607\":1}}],[\"memcached\",{\"1\":{\"589\":3,\"1045\":1,\"1254\":1}}],[\"memorybuffer\",{\"1\":{\"1071\":2,\"1275\":2}}],[\"memory\",{\"1\":{\"406\":1,\"526\":2,\"614\":1,\"887\":1,\"889\":1,\"924\":7,\"1099\":7,\"1297\":7}}],[\"medcl\",{\"1\":{\"412\":1,\"413\":1}}],[\"medium\",{\"1\":{\"353\":1}}],[\"momery\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"momerybuffer\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"monitors\",{\"1\":{\"1101\":2,\"1299\":2}}],[\"monitorexit\",{\"1\":{\"1022\":2,\"1023\":5}}],[\"monitorenter\",{\"1\":{\"1022\":2,\"1023\":5}}],[\"money=2000\",{\"1\":{\"866\":1}}],[\"money\",{\"1\":{\"865\":2}}],[\"mongodb\",{\"1\":{\"588\":1}}],[\"mobile\",{\"1\":{\"432\":1,\"434\":3}}],[\"moved\",{\"1\":{\"388\":1}}],[\"most\",{\"1\":{\"353\":1,\"374\":1}}],[\"motivation\",{\"1\":{\"152\":1}}],[\"modifies\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"modify\",{\"1\":{\"954\":1}}],[\"modcount\",{\"1\":{\"946\":1,\"1119\":5,\"1314\":5}}],[\"modules>\",{\"1\":{\"716\":1}}],[\"module>\",{\"1\":{\"716\":3}}],[\"mode时\",{\"1\":{\"575\":1}}],[\"modeler\",{\"1\":{\"865\":2}}],[\"modeler=\",{\"1\":{\"865\":1}}],[\"modelandview\",{\"1\":{\"831\":9,\"832\":8,\"950\":2,\"956\":8,\"1092\":2,\"1293\":2}}],[\"modelversion>\",{\"1\":{\"715\":2,\"812\":1,\"844\":1}}],[\"model\",{\"1\":{\"152\":1,\"249\":2,\"698\":2,\"831\":8,\"865\":1,\"950\":1,\"956\":1}}],[\"mode\",{\"1\":{\"141\":1,\"555\":2,\"558\":2,\"673\":1}}],[\"mod\",{\"1\":{\"141\":1}}],[\"more\",{\"1\":{\"42\":1,\"90\":1}}],[\"m4v\",{\"1\":{\"136\":1}}],[\"myfield\",{\"1\":{\"1010\":2}}],[\"myfirstplugin\",{\"1\":{\"958\":2}}],[\"mymethod\",{\"1\":{\"1010\":2,\"1016\":5}}],[\"mymapper\",{\"0\":{\"744\":1},\"1\":{\"744\":1,\"745\":1,\"747\":2,\"755\":1,\"763\":1,\"772\":1}}],[\"myclass\",{\"1\":{\"944\":2,\"1010\":21}}],[\"myannotation\",{\"1\":{\"944\":4}}],[\"myanno\",{\"1\":{\"944\":4}}],[\"mylogaspect\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"mylog\",{\"1\":{\"1092\":4,\"1293\":4}}],[\"mylock\",{\"1\":{\"932\":3}}],[\"mylist\",{\"1\":{\"604\":8}}],[\"mydatabase\",{\"1\":{\"736\":3,\"737\":1,\"745\":1}}],[\"mybatisplus\",{\"1\":{\"1443\":1}}],[\"mybatis等\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"mybatis等定义的注解\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"mybatis的分页原理\",{\"0\":{\"1181\":1,\"1366\":1}}],[\"mybatis的工作原理\",{\"0\":{\"1179\":1,\"1364\":1}}],[\"mybatis的优点\",{\"0\":{\"1173\":1,\"1358\":1}}],[\"mybatis运行时会使用jdk动态代理为dao接口生成代理proxy对象\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"mybatis在处理\",{\"1\":{\"1174\":2,\"1359\":2}}],[\"mybatis可以使用xml或者注解来配置映射原生信息\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"mybatis是一个orm\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"mybatis会帮我们动态实现\",{\"1\":{\"827\":1}}],[\"mybatis已经为普通的\",{\"1\":{\"768\":1}}],[\"mybatis使用步骤总结\",{\"0\":{\"751\":1}}],[\"mybatistest\",{\"0\":{\"746\":1,\"747\":1},\"1\":{\"747\":2}}],[\"mybatis<\",{\"1\":{\"742\":1,\"812\":2}}],[\"mybatis整体架构\",{\"0\":{\"740\":1}}],[\"mybatis介绍\",{\"0\":{\"739\":1}}],[\"mybatissql批量更新\",{\"0\":{\"722\":1}}],[\"mybatis\",{\"0\":{\"719\":1,\"724\":1,\"743\":1,\"745\":1,\"765\":1,\"817\":1,\"958\":1,\"1171\":1,\"1177\":1,\"1356\":1,\"1362\":1},\"1\":{\"524\":1,\"722\":1,\"739\":2,\"743\":5,\"744\":4,\"745\":3,\"746\":1,\"747\":1,\"753\":1,\"754\":2,\"755\":9,\"757\":5,\"759\":2,\"762\":4,\"763\":13,\"765\":1,\"766\":2,\"768\":3,\"769\":1,\"770\":4,\"771\":1,\"772\":9,\"779\":7,\"780\":2,\"782\":4,\"784\":1,\"785\":1,\"786\":2,\"787\":1,\"789\":18,\"790\":7,\"793\":4,\"794\":3,\"795\":4,\"807\":2,\"812\":1,\"815\":5,\"817\":4,\"820\":1,\"826\":1,\"827\":6,\"958\":16,\"1171\":3,\"1176\":1,\"1177\":3,\"1178\":1,\"1179\":9,\"1180\":1,\"1181\":2,\"1361\":1,\"1362\":3,\"1363\":1,\"1364\":9,\"1365\":1,\"1366\":2,\"1442\":1,\"1443\":2,\"1444\":6},\"2\":{\"720\":1,\"721\":1,\"729\":1,\"802\":1,\"803\":1,\"1183\":1,\"1446\":1}}],[\"myinvocationhandler\",{\"1\":{\"1016\":7}}],[\"myinterfaceimpl\",{\"1\":{\"1016\":3}}],[\"myinterface\",{\"1\":{\"1016\":8}}],[\"myisam\",{\"1\":{\"511\":2,\"526\":2}}],[\"myid较大的服务器作为leader服务器\",{\"1\":{\"166\":1}}],[\"myid\",{\"1\":{\"166\":3}}],[\"my\",{\"1\":{\"288\":1,\"289\":1,\"388\":1,\"406\":1,\"436\":5,\"437\":3,\"456\":1,\"457\":7,\"577\":2,\"838\":1,\"839\":1,\"887\":1,\"984\":2,\"990\":2,\"998\":4}}],[\"mysql有哪几种log\",{\"0\":{\"1185\":1,\"1368\":1}}],[\"mysql常见面试题\",{\"1\":{\"1184\":1}}],[\"mysql``\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"mysql依赖\",{\"1\":{\"862\":1}}],[\"mysql5\",{\"1\":{\"808\":1}}],[\"mysql的复制原理以及流程\",{\"0\":{\"1186\":1,\"1369\":1}}],[\"mysql的配置参数\",{\"1\":{\"574\":1}}],[\"mysql的b树和b+树原理就说到这里了\",{\"1\":{\"275\":1}}],[\"mysql提供了lock\",{\"1\":{\"572\":1}}],[\"mysql不支持\",{\"1\":{\"542\":1}}],[\"mysql需要再次访问表中的数据行\",{\"1\":{\"504\":1}}],[\"mysql数据库几个基本的索引类型\",{\"0\":{\"1189\":1,\"1372\":1}}],[\"mysql数据库引擎在通过索引定位到数据行后\",{\"1\":{\"504\":1}}],[\"mysql数据导入elasticsearch搜索引擎\",{\"1\":{\"394\":1}}],[\"mysql回表查询是指在使用索引进行查询时\",{\"1\":{\"504\":1}}],[\"mysql可\",{\"1\":{\"501\":1}}],[\"mysql可以用主键的\",{\"1\":{\"383\":1}}],[\"mysql会按照索引中列的顺序从左到右进行匹配\",{\"1\":{\"498\":1}}],[\"mysql索引有哪些类型\",{\"0\":{\"495\":1}}],[\"mysql索引18连问\",{\"0\":{\"492\":1},\"1\":{\"492\":1}}],[\"mysql索引使用的数据结构\",{\"1\":{\"262\":1}}],[\"mysql\",{\"0\":{\"491\":1,\"511\":1,\"572\":1,\"574\":1,\"575\":1,\"1367\":1},\"1\":{\"441\":1,\"493\":1,\"495\":2,\"501\":2,\"506\":1,\"515\":1,\"524\":1,\"525\":1,\"526\":3,\"527\":5,\"528\":1,\"548\":1,\"558\":1,\"580\":1,\"737\":2,\"743\":4,\"745\":2,\"790\":1,\"816\":2,\"824\":2,\"844\":1,\"864\":2,\"884\":1,\"1043\":4,\"1060\":1,\"1062\":2,\"1184\":1,\"1191\":2,\"1193\":2,\"1252\":4,\"1266\":1,\"1268\":2,\"1374\":2,\"1376\":2,\"1444\":4},\"2\":{\"512\":1,\"513\":1,\"549\":1,\"550\":1,\"582\":1,\"583\":1,\"1196\":1}}],[\"mysql和elasticsearch区别\",{\"1\":{\"394\":1}}],[\"mysql为什么使用b\",{\"0\":{\"271\":1}}],[\"myvalue\",{\"1\":{\"115\":1}}],[\"mykey\",{\"1\":{\"115\":3,\"597\":2,\"603\":10}}],[\"myproject\",{\"1\":{\"94\":1}}],[\"michael\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"micrometer<\",{\"1\":{\"885\":1}}],[\"mission\",{\"1\":{\"942\":1}}],[\"mistral\",{\"1\":{\"245\":1}}],[\"mian\",{\"1\":{\"692\":1}}],[\"mi\",{\"1\":{\"660\":1,\"800\":2,\"801\":2}}],[\"millis\",{\"1\":{\"648\":2}}],[\"milliseconds\",{\"1\":{\"388\":1}}],[\"mit\",{\"1\":{\"487\":1,\"488\":1}}],[\"mirrors\",{\"1\":{\"157\":1,\"405\":2,\"671\":1,\"852\":2,\"888\":1,\"896\":2}}],[\"mixed\",{\"1\":{\"918\":2}}],[\"mix\",{\"1\":{\"106\":1}}],[\"mime\",{\"1\":{\"106\":1}}],[\"minute\",{\"1\":{\"887\":2}}],[\"minpoolsize\",{\"1\":{\"815\":1}}],[\"minimum\",{\"1\":{\"406\":1,\"832\":1,\"1070\":1,\"1074\":1,\"1274\":1,\"1278\":1}}],[\"minvalue\",{\"1\":{\"352\":5}}],[\"minrate\",{\"1\":{\"134\":2}}],[\"min\",{\"1\":{\"106\":4,\"607\":7,\"1073\":1,\"1085\":1,\"1277\":1,\"1286\":1}}],[\"mandatory\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"many\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"man\",{\"1\":{\"1087\":2,\"1288\":2}}],[\"management\",{\"1\":{\"885\":1}}],[\"managertaskhandler\",{\"1\":{\"865\":1}}],[\"manager=\",{\"1\":{\"818\":1}}],[\"manager比较喜欢\",{\"1\":{\"714\":1}}],[\"manager\",{\"0\":{\"643\":1},\"1\":{\"643\":1,\"852\":1}}],[\"markedobjects\",{\"1\":{\"938\":1}}],[\"mark\",{\"1\":{\"938\":2,\"940\":3,\"1150\":2,\"1341\":2}}],[\"markfromroots\",{\"1\":{\"936\":1}}],[\"mark数据\",{\"1\":{\"591\":1}}],[\"markdown\",{\"0\":{\"26\":1,\"27\":1,\"28\":1,\"29\":1},\"1\":{\"26\":2,\"27\":3,\"28\":1,\"29\":3,\"30\":2,\"31\":1,\"43\":3,\"44\":1,\"45\":2,\"46\":2,\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1022\":1},\"2\":{\"41\":1}}],[\"male\",{\"1\":{\"536\":1}}],[\"malformed\",{\"1\":{\"440\":1}}],[\"mattson在一篇有关探讨面向对象框架的文章中\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"mattson提出了ioc理论\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"match\",{\"1\":{\"434\":1,\"436\":1,\"605\":1,\"606\":1,\"607\":1,\"621\":1,\"998\":1}}],[\"math\",{\"1\":{\"340\":6,\"352\":2,\"364\":1,\"1085\":2,\"1286\":2}}],[\"master每执行一次数据变更的命令就会同步至slave节点\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"masterelection\",{\"1\":{\"1008\":1}}],[\"masterauth\",{\"1\":{\"964\":1}}],[\"masteruser\",{\"1\":{\"964\":1}}],[\"masterhost\",{\"1\":{\"964\":1}}],[\"master分支的末尾增加了一个提交f\",{\"1\":{\"917\":1}}],[\"master\",{\"0\":{\"1070\":1,\"1074\":2,\"1274\":1,\"1278\":2},\"1\":{\"406\":3,\"589\":1,\"592\":1,\"917\":4,\"964\":7,\"1070\":4,\"1074\":3,\"1205\":6,\"1237\":1,\"1244\":2,\"1274\":4,\"1278\":3,\"1385\":6,\"1410\":1,\"1417\":2}}],[\"maven首先从当前构建项目开始查找父项目的pom文件\",{\"1\":{\"715\":1}}],[\"maven继承\",{\"0\":{\"715\":1}}],[\"maven有三套相互独立的生命周期\",{\"1\":{\"711\":1}}],[\"maven生命周期就是为了对所有的构建过程进行抽象和统一\",{\"1\":{\"711\":1}}],[\"maven生命周期\",{\"0\":{\"711\":1}}],[\"maven不会在repository查找它\",{\"1\":{\"706\":1}}],[\"maven世界拥有大量构件\",{\"1\":{\"705\":1}}],[\"maven为什么使用坐标\",{\"1\":{\"705\":1}}],[\"maven坐标主要组成\",{\"1\":{\"705\":1}}],[\"maven2\",{\"1\":{\"705\":1}}],[\"maven本地仓库的默认位置\",{\"1\":{\"705\":1}}],[\"maven在某个统一的位置存储所有项目的共享的构件\",{\"1\":{\"705\":1}}],[\"maven项目的模板\",{\"1\":{\"703\":1,\"704\":1}}],[\"maven项目的目录结构遵守以下规范\",{\"1\":{\"702\":1}}],[\"maven项目目录\",{\"1\":{\"702\":1}}],[\"maven的插件机制是完全依赖maven的生命周期的\",{\"1\":{\"713\":1}}],[\"maven的本地仓库\",{\"1\":{\"705\":1}}],[\"maven的仓库有两大类\",{\"1\":{\"705\":1}}],[\"maven的默认本地仓库在\",{\"1\":{\"702\":1}}],[\"maven的功能\",{\"0\":{\"699\":1}}],[\"maven下载的jar包都会存储到此仓库中\",{\"1\":{\"701\":1}}],[\"maven可以指定jar的依赖范围\",{\"1\":{\"700\":1}}],[\"maven正是为了将开发人员从这些任务中解脱出来而诞生的一个项目管理工具\",{\"1\":{\"698\":1}}],[\"maven采用了一种被称之为project\",{\"1\":{\"698\":1}}],[\"maven翻译为\",{\"1\":{\"698\":1}}],[\"maven是跨平台的项目管理工具\",{\"1\":{\"699\":1}}],[\"maven是基于项目对象模型\",{\"1\":{\"698\":1}}],[\"maven是什么\",{\"1\":{\"698\":1}}],[\"maven\",{\"0\":{\"694\":1,\"839\":1,\"850\":1},\"1\":{\"401\":1,\"648\":1,\"698\":1,\"701\":2,\"702\":8,\"704\":1,\"705\":1,\"706\":2,\"714\":2,\"715\":8,\"716\":2,\"808\":1,\"811\":1,\"812\":6,\"837\":2,\"839\":1,\"844\":11,\"1225\":2,\"1232\":1,\"1400\":2,\"1407\":1},\"2\":{\"695\":1,\"696\":1,\"717\":1,\"718\":1}}],[\"map包括\",{\"1\":{\"1112\":1,\"1307\":1}}],[\"map在日常开发中用途广泛\",{\"1\":{\"948\":1}}],[\"map接口表示一个键值对集合\",{\"1\":{\"948\":1}}],[\"map这个接口的确非常重要且强大\",{\"1\":{\"948\":1}}],[\"map工具类\",{\"1\":{\"812\":1}}],[\"mapunderscoretocamelcase\",{\"1\":{\"767\":1,\"790\":1,\"817\":1}}],[\"mappedstatement维护了一条\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"mappedstatement\",{\"1\":{\"770\":1,\"1175\":2,\"1179\":2,\"1360\":2,\"1364\":2}}],[\"mapperlocations\",{\"1\":{\"815\":1}}],[\"mapper需要的xml文件\",{\"1\":{\"815\":1}}],[\"mapper文件示例代码\",{\"1\":{\"801\":1}}],[\"mapper配置\",{\"1\":{\"795\":1}}],[\"mapper映射\",{\"1\":{\"794\":1}}],[\"mapper中开启了也没用\",{\"1\":{\"790\":1}}],[\"mapper中namespace的定义本身是没有限制的\",{\"1\":{\"762\":1}}],[\"mapper接口中方法的输出参数类型必须和sql定义的resulttype一致\",{\"1\":{\"764\":1}}],[\"mapper接口中方法的输入参数类型必须和sql定义的parametertype一致\",{\"1\":{\"764\":1}}],[\"mapper接口的方法名必须和sql定义的id一致\",{\"1\":{\"764\":1}}],[\"mapper的namespace必须和mapper接口的全路径一致\",{\"1\":{\"764\":1}}],[\"mapperregistry\",{\"1\":{\"762\":3}}],[\"mapper具体的配置的时候\",{\"1\":{\"759\":1}}],[\"mapperscannerconfigurer\",{\"1\":{\"815\":1}}],[\"mappers>\",{\"1\":{\"745\":1,\"755\":1,\"763\":1,\"772\":3,\"782\":1}}],[\"mappers\",{\"0\":{\"772\":1},\"1\":{\"745\":1,\"755\":2,\"763\":3,\"772\":2}}],[\"mapper>\",{\"1\":{\"744\":1,\"755\":1,\"763\":1,\"782\":1,\"790\":1,\"793\":1,\"827\":2}}],[\"mapper\",{\"0\":{\"773\":1},\"1\":{\"744\":4,\"755\":4,\"761\":1,\"762\":1,\"763\":4,\"772\":3,\"782\":4,\"790\":2,\"809\":1,\"815\":2,\"827\":9,\"852\":1,\"958\":7,\"1175\":1,\"1178\":1,\"1360\":1,\"1363\":1,\"1444\":4}}],[\"mapping阶段充分结合各个字段的属性\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"mapping>\",{\"1\":{\"820\":2}}],[\"mappings\",{\"1\":{\"431\":1,\"432\":1,\"434\":1,\"436\":2,\"437\":1,\"440\":1,\"456\":1,\"457\":1,\"998\":1}}],[\"mapping\",{\"0\":{\"429\":1},\"1\":{\"428\":1,\"429\":5,\"431\":2,\"438\":1,\"439\":7,\"457\":1,\"487\":1,\"488\":1,\"761\":1,\"998\":1,\"1002\":1}}],[\"mapping详解\",{\"1\":{\"394\":1}}],[\"map<object\",{\"1\":{\"654\":1}}],[\"map<string\",{\"1\":{\"654\":1}}],[\"map是\",{\"1\":{\"615\":1}}],[\"maping设置\",{\"0\":{\"430\":1}}],[\"map\",{\"0\":{\"948\":1,\"1114\":1,\"1309\":1},\"1\":{\"353\":7,\"403\":2,\"615\":1,\"654\":1,\"948\":4,\"1044\":10,\"1112\":1,\"1114\":1,\"1179\":2,\"1253\":10,\"1307\":1,\"1309\":1,\"1364\":2}}],[\"may\",{\"1\":{\"159\":1,\"1085\":1,\"1286\":1}}],[\"make\",{\"1\":{\"125\":2,\"598\":1,\"672\":1}}],[\"machine\",{\"1\":{\"112\":1,\"374\":1}}],[\"machines\",{\"1\":{\"112\":1}}],[\"mac\",{\"1\":{\"108\":1,\"114\":1,\"122\":1,\"385\":1}}],[\"mainclass>\",{\"1\":{\"844\":1}}],[\"maintenance\",{\"1\":{\"152\":1}}],[\"main\",{\"1\":{\"106\":3,\"116\":1,\"251\":1,\"288\":1,\"289\":1,\"337\":1,\"352\":1,\"364\":1,\"377\":1,\"388\":1,\"681\":1,\"690\":1,\"692\":5,\"737\":1,\"747\":1,\"789\":24,\"790\":8,\"809\":1,\"839\":2,\"856\":1,\"913\":2,\"928\":1,\"932\":2,\"944\":2,\"984\":1,\"990\":1,\"1008\":1,\"1016\":3,\"1020\":1,\"1085\":2,\"1086\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1224\":1,\"1286\":2,\"1287\":1,\"1302\":2,\"1303\":1,\"1305\":1,\"1399\":1}}],[\"maxpoolsize\",{\"1\":{\"815\":1}}],[\"maxwaitmillis\",{\"1\":{\"648\":1}}],[\"maxwait\",{\"1\":{\"648\":1}}],[\"maxworkerid\",{\"1\":{\"388\":3}}],[\"maxtotal\",{\"1\":{\"648\":1}}],[\"maxactive\",{\"1\":{\"648\":1}}],[\"maxdatacenterid\",{\"1\":{\"388\":3}}],[\"maxvalue\",{\"1\":{\"352\":4}}],[\"maxsize++\",{\"1\":{\"289\":2}}],[\"maxsize\",{\"1\":{\"288\":13,\"289\":6}}],[\"maxrate就简单了\",{\"1\":{\"134\":1}}],[\"maxrate\",{\"1\":{\"134\":2}}],[\"max\",{\"1\":{\"106\":6,\"340\":1,\"360\":4,\"403\":2,\"607\":7,\"648\":6,\"982\":6,\"1085\":3,\"1156\":3,\"1286\":3,\"1344\":3}}],[\"max=65535\",{\"1\":{\"106\":1}}],[\"max指定缓存数量\",{\"1\":{\"106\":1}}],[\"maximum\",{\"1\":{\"106\":1,\"832\":1,\"948\":1,\"1085\":1,\"1286\":1}}],[\"m\",{\"1\":{\"94\":1,\"340\":2,\"371\":2,\"372\":2,\"377\":2,\"896\":1,\"913\":1,\"915\":1,\"918\":1,\"924\":2,\"944\":2}}],[\"mvnrepository\",{\"1\":{\"705\":1,\"812\":1,\"1444\":1}}],[\"mvn\",{\"1\":{\"702\":1,\"703\":3,\"704\":3,\"705\":9,\"711\":1,\"712\":4,\"850\":1}}],[\"mvc和spring有什么区别\",{\"0\":{\"1229\":1,\"1404\":1}}],[\"mvc模块为spring提供了一套轻量级的mvc实现\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"mvc=\",{\"1\":{\"819\":1}}],[\"mvcc\",{\"1\":{\"558\":1}}],[\"mvc\",{\"1\":{\"524\":1,\"807\":1,\"819\":4,\"832\":1,\"950\":6,\"956\":1,\"1211\":2,\"1388\":2}}],[\"mv\",{\"1\":{\"90\":1,\"91\":2}}],[\"mkdir\",{\"1\":{\"90\":1,\"91\":2,\"412\":1,\"413\":1}}],[\"mpeg4\",{\"1\":{\"135\":1}}],[\"mp4的第20s时间开始\",{\"1\":{\"141\":1}}],[\"mp4`\",{\"1\":{\"138\":1}}],[\"mp4音频到output\",{\"1\":{\"132\":1}}],[\"mp4文件转为ts\",{\"1\":{\"131\":1}}],[\"mp4\",{\"1\":{\"129\":4,\"131\":2,\"132\":2,\"133\":2,\"134\":6,\"135\":8,\"136\":1,\"138\":1,\"139\":8,\"140\":2,\"141\":3,\"143\":1,\"145\":1,\"146\":1}}],[\"mp\",{\"1\":{\"71\":1,\"147\":1,\"172\":1,\"832\":1,\"924\":2,\"1099\":1,\"1184\":1,\"1297\":1,\"1367\":1}}],[\"ms这个维度\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"ms和延迟条数replica\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"mset\",{\"1\":{\"603\":2}}],[\"msg\",{\"1\":{\"487\":5,\"488\":5,\"821\":1,\"1431\":3}}],[\"msd\",{\"1\":{\"375\":2}}],[\"ms\",{\"1\":{\"44\":1,\"266\":1,\"388\":1,\"648\":1,\"1100\":1,\"1166\":1,\"1298\":1,\"1354\":1}}],[\"md5\",{\"1\":{\"106\":1}}],[\"md\",{\"1\":{\"31\":1,\"911\":2}}],[\"pgving\",{\"1\":{\"1030\":1}}],[\"p3\",{\"1\":{\"992\":2}}],[\"p2\",{\"1\":{\"992\":2}}],[\"p2和p3\",{\"1\":{\"992\":1}}],[\"p1\",{\"1\":{\"992\":3}}],[\"p哥不想开新分支\",{\"1\":{\"916\":1}}],[\"p哥\",{\"1\":{\"916\":1}}],[\"pypi\",{\"1\":{\"896\":2}}],[\"pythonlibs\",{\"1\":{\"898\":1}}],[\"python3\",{\"1\":{\"896\":1,\"897\":2}}],[\"python安装cv2\",{\"0\":{\"894\":1}}],[\"python\",{\"0\":{\"893\":1,\"895\":1},\"1\":{\"232\":1,\"589\":1,\"896\":2,\"897\":1,\"898\":1},\"2\":{\"900\":1,\"901\":1}}],[\"pd24\",{\"1\":{\"832\":1}}],[\"pdf|xls|mp3|wma\",{\"1\":{\"106\":1}}],[\"pc\",{\"1\":{\"807\":1}}],[\"phase\",{\"1\":{\"712\":1,\"938\":1}}],[\"php$\",{\"1\":{\"106\":2}}],[\"php\",{\"1\":{\"106\":4,\"589\":1}}],[\"pfmerge\",{\"1\":{\"659\":2}}],[\"pfcount\",{\"1\":{\"659\":2}}],[\"pfadd\",{\"1\":{\"659\":2}}],[\"ptr\",{\"1\":{\"621\":3,\"635\":2}}],[\"px\",{\"1\":{\"450\":2,\"451\":2}}],[\"pb\",{\"1\":{\"400\":1}}],[\"p是误判率\",{\"1\":{\"340\":1}}],[\"pessimism\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"perpetualcache\",{\"1\":{\"1178\":2,\"1363\":2}}],[\"person\",{\"1\":{\"1176\":2,\"1219\":3,\"1361\":2,\"1396\":3}}],[\"persistent\",{\"1\":{\"852\":1,\"1244\":1,\"1417\":1}}],[\"persistenceexception\",{\"1\":{\"779\":1}}],[\"persistence\",{\"1\":{\"601\":1}}],[\"persist\",{\"1\":{\"603\":1}}],[\"periods\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"periodically\",{\"1\":{\"887\":1}}],[\"perl\",{\"1\":{\"589\":1}}],[\"performance\",{\"1\":{\"339\":1}}],[\"pem\",{\"1\":{\"106\":1}}],[\"pk规则如下\",{\"1\":{\"166\":1}}],[\"png\",{\"1\":{\"139\":4,\"819\":1}}],[\"p\",{\"1\":{\"110\":1,\"251\":2,\"289\":4,\"340\":2,\"597\":1,\"628\":1,\"633\":1,\"855\":1,\"916\":3,\"922\":1,\"924\":16,\"1068\":1,\"1078\":2,\"1088\":2,\"1105\":1,\"1272\":1,\"1282\":1,\"1289\":2,\"1303\":1}}],[\"pip3\",{\"1\":{\"896\":2}}],[\"pip\",{\"1\":{\"896\":4,\"898\":2}}],[\"pivot\",{\"1\":{\"604\":1}}],[\"pivotal\",{\"1\":{\"401\":1}}],[\"pinyin\",{\"1\":{\"411\":1,\"413\":3}}],[\"ping\",{\"1\":{\"90\":1,\"1205\":1,\"1385\":1}}],[\"pix\",{\"1\":{\"144\":1}}],[\"pick命令的参数\",{\"1\":{\"917\":1}}],[\"pick命令的作用\",{\"1\":{\"917\":1}}],[\"pick\",{\"0\":{\"917\":1},\"1\":{\"917\":13,\"919\":1}}],[\"pic\",{\"1\":{\"141\":2}}],[\"pid\",{\"1\":{\"106\":2}}],[\"pong其中节点没有回复且超过了一定时间\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"potentially\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"poll\",{\"1\":{\"982\":4,\"984\":1,\"990\":2}}],[\"pool\",{\"1\":{\"790\":1}}],[\"pooleddatasource\",{\"1\":{\"789\":3,\"790\":2}}],[\"pooled\",{\"1\":{\"743\":2,\"745\":1,\"766\":1,\"789\":3,\"790\":2}}],[\"pojo中的属性名字是username\",{\"1\":{\"759\":1}}],[\"pojo\",{\"1\":{\"747\":1,\"753\":1,\"754\":1,\"755\":5,\"757\":1,\"759\":1,\"763\":7,\"768\":3,\"779\":7,\"780\":2,\"784\":1,\"785\":1,\"786\":2,\"787\":1,\"793\":3,\"794\":3,\"795\":4,\"1179\":2,\"1219\":2,\"1364\":2,\"1396\":2}}],[\"pom\",{\"0\":{\"742\":1},\"1\":{\"648\":2,\"698\":2,\"705\":1,\"715\":5,\"756\":1,\"812\":3,\"839\":1,\"844\":8,\"885\":1,\"1232\":1,\"1407\":1}}],[\"point进行拦截\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"pointcut切点\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"pointcut表示这是一个切点\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"pointcut\",{\"1\":{\"689\":5,\"944\":1,\"1092\":1,\"1217\":1,\"1293\":1,\"1394\":1}}],[\"point\",{\"1\":{\"453\":1,\"1217\":3,\"1394\":3}}],[\"positions\",{\"1\":{\"433\":2,\"440\":3}}],[\"position\",{\"1\":{\"429\":1,\"433\":2,\"440\":1}}],[\"posthandle\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"postprocessafterinstantiation\",{\"1\":{\"954\":1}}],[\"postconstruct\",{\"1\":{\"952\":2}}],[\"postconstruct等实现依赖注入和初始化方法调用\",{\"1\":{\"944\":1}}],[\"postgresql\",{\"1\":{\"884\":1}}],[\"postmapper\",{\"1\":{\"772\":2}}],[\"posting\",{\"1\":{\"424\":1,\"1069\":1,\"1273\":1}}],[\"postinglist\",{\"1\":{\"424\":1}}],[\"posts\",{\"1\":{\"252\":1,\"664\":1}}],[\"post过来的数据记录到文件中用来做debug\",{\"1\":{\"106\":1}}],[\"post\",{\"1\":{\"104\":1,\"178\":3,\"663\":1,\"712\":2,\"713\":1,\"714\":1,\"831\":1,\"952\":1,\"954\":1,\"998\":1,\"1027\":1,\"1033\":1}}],[\"popdata\",{\"1\":{\"288\":2}}],[\"pop\",{\"1\":{\"282\":1,\"288\":3,\"289\":3,\"589\":1,\"916\":6}}],[\"portlet\",{\"1\":{\"950\":1}}],[\"port\",{\"1\":{\"106\":1,\"157\":1,\"406\":2,\"648\":2,\"864\":1,\"885\":1,\"1020\":4,\"1444\":1}}],[\"port=9215\",{\"1\":{\"94\":1}}],[\"portfolio\",{\"1\":{\"6\":1}}],[\"pull\",{\"1\":{\"919\":2,\"990\":1,\"1062\":2,\"1268\":2}}],[\"publish\",{\"1\":{\"593\":1}}],[\"public\",{\"1\":{\"45\":1,\"79\":3,\"80\":2,\"83\":2,\"84\":2,\"192\":1,\"193\":1,\"195\":2,\"196\":2,\"197\":1,\"198\":1,\"200\":1,\"201\":2,\"284\":1,\"285\":17,\"286\":16,\"288\":12,\"289\":12,\"337\":2,\"340\":2,\"352\":4,\"353\":1,\"360\":1,\"364\":3,\"377\":3,\"388\":5,\"487\":6,\"488\":6,\"648\":3,\"688\":1,\"689\":7,\"692\":6,\"737\":2,\"743\":1,\"744\":1,\"745\":1,\"747\":21,\"753\":6,\"754\":8,\"755\":1,\"757\":9,\"763\":19,\"770\":4,\"779\":4,\"782\":1,\"784\":1,\"785\":1,\"786\":3,\"787\":1,\"789\":3,\"790\":2,\"792\":1,\"793\":5,\"794\":3,\"795\":3,\"817\":1,\"825\":2,\"826\":2,\"827\":2,\"828\":8,\"829\":17,\"830\":11,\"831\":2,\"832\":1,\"849\":1,\"876\":3,\"924\":3,\"928\":2,\"932\":7,\"934\":13,\"936\":1,\"944\":7,\"946\":4,\"950\":1,\"956\":6,\"958\":3,\"966\":15,\"984\":2,\"986\":3,\"988\":4,\"990\":2,\"1004\":4,\"1008\":2,\"1016\":8,\"1018\":1,\"1020\":2,\"1022\":6,\"1023\":1,\"1044\":6,\"1085\":3,\"1086\":7,\"1091\":1,\"1092\":19,\"1104\":11,\"1105\":5,\"1107\":8,\"1253\":6,\"1286\":3,\"1287\":7,\"1292\":1,\"1293\":19,\"1302\":11,\"1303\":5,\"1305\":8,\"1431\":7}}],[\"pub\",{\"1\":{\"408\":1,\"425\":1}}],[\"put方法将键值对添加到表中\",{\"1\":{\"948\":1}}],[\"put\",{\"1\":{\"115\":1,\"178\":1,\"353\":2,\"431\":1,\"432\":1,\"434\":3,\"436\":2,\"437\":1,\"439\":2,\"457\":3,\"922\":2,\"936\":1,\"982\":2,\"984\":4,\"988\":1,\"990\":7,\"998\":1,\"1044\":7,\"1116\":1,\"1216\":1,\"1253\":7,\"1311\":1,\"1393\":1}}],[\"push\",{\"1\":{\"94\":1,\"282\":1,\"288\":5,\"289\":5,\"913\":1,\"915\":1,\"917\":1,\"990\":1}}],[\"plus这么好用\",{\"1\":{\"1442\":1}}],[\"plus\",{\"0\":{\"1442\":1},\"1\":{\"1442\":1,\"1443\":1,\"1444\":5},\"2\":{\"1446\":1}}],[\"plugin>\",{\"1\":{\"770\":1,\"812\":1,\"844\":2,\"958\":1}}],[\"plugin<\",{\"1\":{\"709\":1,\"710\":1,\"812\":1,\"844\":2}}],[\"plugin为准\",{\"1\":{\"709\":1}}],[\"plugins<\",{\"1\":{\"812\":1,\"844\":1}}],[\"plugins>\",{\"1\":{\"770\":1,\"812\":1,\"844\":1,\"958\":1}}],[\"plugins\",{\"0\":{\"770\":1},\"1\":{\"412\":3,\"413\":3,\"714\":1,\"884\":1}}],[\"plugin\",{\"1\":{\"31\":1,\"770\":2,\"844\":2}}],[\"platfromtransactionmanager\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"placeholder\",{\"1\":{\"815\":1}}],[\"plain\",{\"1\":{\"183\":1}}],[\"play\",{\"1\":{\"90\":1}}],[\"pswd\",{\"1\":{\"1176\":2,\"1361\":2}}],[\"ps\",{\"1\":{\"90\":1,\"94\":1,\"138\":1,\"1144\":1,\"1335\":1}}],[\"pwd\",{\"1\":{\"90\":1,\"91\":2,\"159\":1,\"602\":1,\"648\":2}}],[\"pragma\",{\"1\":{\"487\":1,\"488\":1}}],[\"prehandle\",{\"1\":{\"1092\":2,\"1293\":2}}],[\"preparing\",{\"1\":{\"725\":1,\"789\":6,\"790\":1}}],[\"preparestatement\",{\"1\":{\"737\":7,\"1176\":2,\"1361\":2}}],[\"preparedstatement\",{\"1\":{\"737\":3,\"769\":1,\"1176\":1,\"1179\":1,\"1361\":1,\"1364\":1}}],[\"prepare\",{\"1\":{\"713\":1,\"770\":1}}],[\"pre\",{\"1\":{\"712\":3,\"713\":1,\"714\":1}}],[\"preemption\",{\"1\":{\"562\":1}}],[\"pretty\",{\"1\":{\"436\":3}}],[\"previously\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"prev\",{\"1\":{\"286\":15,\"621\":1}}],[\"prefixoverrides\",{\"1\":{\"724\":2,\"787\":1}}],[\"prefix\",{\"1\":{\"724\":2,\"787\":1,\"819\":1}}],[\"prefix=\",{\"1\":{\"125\":1,\"724\":2,\"727\":3,\"755\":1,\"763\":1,\"786\":1}}],[\"preference\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"prefer\",{\"1\":{\"106\":1}}],[\"preloadsingleton\",{\"1\":{\"79\":5}}],[\"problemas\",{\"1\":{\"950\":1}}],[\"problems\",{\"1\":{\"526\":1}}],[\"product++\",{\"1\":{\"988\":1}}],[\"product\",{\"1\":{\"988\":2}}],[\"products\",{\"1\":{\"899\":1}}],[\"produce\",{\"1\":{\"988\":1}}],[\"producer<string\",{\"1\":{\"990\":1}}],[\"producerconfig\",{\"1\":{\"990\":3}}],[\"producerconsumer\",{\"1\":{\"988\":1}}],[\"producerprops\",{\"1\":{\"990\":5}}],[\"producer负责将消息发送到kafka集群\",{\"1\":{\"986\":1}}],[\"producer\",{\"1\":{\"982\":1,\"986\":1,\"990\":4,\"992\":6,\"1159\":3,\"1347\":3}}],[\"producerrecord<>\",{\"1\":{\"982\":3,\"990\":1}}],[\"producerrecord\",{\"1\":{\"982\":1}}],[\"produces\",{\"1\":{\"831\":1}}],[\"proposer\",{\"1\":{\"1243\":1,\"1246\":1,\"1416\":1,\"1419\":1}}],[\"proposal\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"propagation\",{\"1\":{\"1220\":7,\"1397\":7}}],[\"propagating\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"property\",{\"1\":{\"793\":1,\"794\":1,\"797\":1,\"815\":1,\"1085\":1,\"1286\":1}}],[\"property=\",{\"1\":{\"793\":3,\"794\":5,\"795\":7,\"797\":2}}],[\"properties类\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"properties配置的属性都是可外部配置且可动态替换的\",{\"1\":{\"766\":1}}],[\"properties属性读取外部资源\",{\"0\":{\"766\":1}}],[\"properties>\",{\"1\":{\"715\":1,\"743\":1,\"766\":1,\"812\":1,\"844\":1}}],[\"properties\",{\"0\":{\"816\":1},\"1\":{\"432\":1,\"434\":1,\"436\":2,\"437\":1,\"456\":1,\"457\":1,\"766\":7,\"770\":2,\"815\":1,\"816\":1,\"844\":1,\"984\":3,\"990\":5,\"998\":1,\"1226\":2,\"1401\":2}}],[\"props\",{\"1\":{\"766\":2,\"982\":2,\"984\":6}}],[\"projectlombok<\",{\"1\":{\"812\":1}}],[\"projectlombok\",{\"1\":{\"812\":1}}],[\"project>\",{\"1\":{\"715\":2,\"812\":1,\"844\":1}}],[\"project\",{\"1\":{\"698\":1,\"715\":1,\"716\":1,\"812\":1,\"837\":2,\"844\":2,\"1431\":1,\"1439\":1,\"1444\":1}}],[\"proceed\",{\"1\":{\"689\":1,\"770\":1,\"950\":1,\"958\":1,\"1092\":1,\"1293\":1}}],[\"proceedingjoinpoint\",{\"1\":{\"689\":3,\"1092\":1,\"1293\":1}}],[\"processors\",{\"1\":{\"954\":1}}],[\"processid=2501\",{\"1\":{\"866\":1}}],[\"processdiagram\",{\"1\":{\"866\":1}}],[\"processdef\",{\"1\":{\"865\":1}}],[\"processed\",{\"1\":{\"866\":1}}],[\"processes\",{\"1\":{\"106\":1,\"865\":1}}],[\"process>\",{\"1\":{\"865\":1}}],[\"processlist\",{\"1\":{\"581\":1}}],[\"process\",{\"1\":{\"106\":1,\"713\":6}}],[\"progress\",{\"1\":{\"624\":1}}],[\"programming\",{\"1\":{\"950\":1}}],[\"program\",{\"1\":{\"152\":1}}],[\"prot=8080\",{\"1\":{\"850\":1}}],[\"protostuff\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"protostuff<\",{\"1\":{\"812\":2}}],[\"prototype\",{\"1\":{\"952\":3,\"1215\":1,\"1392\":1}}],[\"protocols\",{\"1\":{\"144\":1}}],[\"protected\",{\"1\":{\"388\":2,\"673\":1,\"932\":3,\"950\":1,\"952\":2,\"1044\":1,\"1101\":1,\"1216\":1,\"1253\":1,\"1299\":1,\"1393\":1}}],[\"prompt\",{\"1\":{\"249\":1}}],[\"prometheus安装\",{\"0\":{\"887\":1}}],[\"prometheus安装包\",{\"1\":{\"886\":1}}],[\"prometheus<\",{\"1\":{\"885\":1}}],[\"prometheus\",{\"0\":{\"110\":1,\"883\":1},\"1\":{\"109\":12,\"883\":1,\"884\":1,\"885\":4,\"887\":6,\"889\":1},\"2\":{\"857\":1,\"858\":1,\"890\":1,\"891\":1}}],[\"prometheus+grafana\",{\"0\":{\"108\":1}}],[\"provide\",{\"1\":{\"950\":1}}],[\"provided\",{\"1\":{\"706\":1}}],[\"providers\",{\"1\":{\"159\":1}}],[\"provider\",{\"1\":{\"159\":2}}],[\"provides\",{\"1\":{\"112\":1}}],[\"prone\",{\"1\":{\"152\":1}}],[\"profiles等\",{\"1\":{\"942\":1}}],[\"profile\",{\"1\":{\"125\":2,\"145\":2,\"950\":1}}],[\"proxy\",{\"1\":{\"106\":22,\"954\":1,\"1016\":5}}],[\"price\",{\"1\":{\"795\":1}}],[\"pricing\",{\"1\":{\"643\":1}}],[\"privdata\",{\"1\":{\"624\":6}}],[\"private\",{\"1\":{\"79\":1,\"80\":2,\"83\":2,\"84\":2,\"194\":1,\"198\":1,\"285\":6,\"286\":7,\"288\":4,\"289\":4,\"337\":12,\"352\":3,\"364\":3,\"388\":17,\"648\":9,\"747\":9,\"790\":1,\"792\":5,\"793\":14,\"794\":11,\"795\":9,\"825\":7,\"828\":2,\"829\":7,\"830\":7,\"831\":5,\"924\":1,\"928\":13,\"932\":2,\"936\":1,\"938\":2,\"940\":1,\"946\":2,\"966\":4,\"986\":1,\"988\":3,\"990\":2,\"1004\":2,\"1008\":1,\"1016\":1,\"1018\":1,\"1020\":4,\"1022\":1,\"1023\":1,\"1044\":2,\"1085\":2,\"1104\":2,\"1105\":2,\"1253\":2,\"1286\":2,\"1302\":2,\"1303\":2,\"1431\":5}}],[\"primary\",{\"1\":{\"422\":3,\"436\":1,\"505\":1,\"507\":1,\"577\":1,\"726\":1,\"736\":1,\"792\":1,\"795\":3,\"824\":2,\"1071\":1,\"1078\":1,\"1275\":1,\"1282\":1,\"1444\":1}}],[\"primitives\",{\"1\":{\"152\":1}}],[\"printf\",{\"1\":{\"619\":2}}],[\"println\",{\"1\":{\"288\":3,\"289\":3,\"337\":5,\"352\":1,\"360\":1,\"364\":1,\"377\":1,\"388\":3,\"648\":2,\"689\":2,\"692\":3,\"737\":4,\"747\":2,\"757\":2,\"763\":5,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"789\":6,\"790\":2,\"793\":2,\"794\":2,\"795\":3,\"828\":6,\"830\":1,\"928\":2,\"932\":4,\"934\":2,\"944\":1,\"966\":1,\"984\":1,\"990\":1,\"1008\":2,\"1016\":3,\"1020\":3,\"1044\":1,\"1084\":2,\"1085\":2,\"1086\":5,\"1092\":4,\"1104\":9,\"1105\":4,\"1107\":3,\"1176\":1,\"1253\":1,\"1285\":2,\"1286\":2,\"1287\":5,\"1293\":4,\"1302\":9,\"1303\":4,\"1305\":3,\"1361\":1}}],[\"printstacktrace\",{\"0\":{\"196\":1},\"1\":{\"196\":3,\"648\":3,\"932\":1,\"988\":2,\"1092\":1,\"1104\":2,\"1105\":2,\"1107\":2,\"1293\":1,\"1302\":2,\"1303\":2,\"1305\":2}}],[\"print\",{\"1\":{\"94\":4,\"193\":1,\"195\":4,\"198\":2,\"201\":2,\"966\":5,\"1044\":2,\"1092\":1,\"1253\":2,\"1293\":1}}],[\"paxos做了一些优化\",{\"1\":{\"1246\":1,\"1419\":1}}],[\"paxos算法为基础\",{\"1\":{\"1246\":1,\"1419\":1}}],[\"paxos\",{\"0\":{\"1243\":1,\"1416\":1},\"1\":{\"1243\":5,\"1246\":2,\"1416\":5,\"1419\":2}}],[\"pagination\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"pagecontext\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"pageencoding=\",{\"1\":{\"832\":1}}],[\"pages\",{\"1\":{\"106\":1,\"911\":1,\"913\":2}}],[\"pagesize取得\",{\"1\":{\"106\":1}}],[\"pagesize\",{\"1\":{\"106\":2}}],[\"page\",{\"0\":{\"566\":1},\"1\":{\"43\":1,\"106\":3,\"272\":1,\"274\":1,\"561\":1,\"832\":2,\"1127\":1,\"1167\":2,\"1320\":1,\"1355\":2}}],[\"palermo\",{\"1\":{\"660\":5}}],[\"packaging>\",{\"1\":{\"715\":1,\"812\":1}}],[\"packaging\",{\"1\":{\"705\":1}}],[\"package=\",{\"1\":{\"818\":1,\"819\":1}}],[\"package\",{\"1\":{\"79\":1,\"80\":1,\"83\":1,\"84\":1,\"288\":1,\"289\":1,\"337\":1,\"352\":1,\"364\":1,\"377\":1,\"388\":1,\"688\":1,\"689\":2,\"705\":2,\"713\":2,\"825\":2,\"826\":2,\"828\":3,\"829\":5,\"830\":4,\"831\":1,\"849\":1,\"850\":1,\"876\":1,\"944\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1302\":2,\"1303\":1,\"1305\":1,\"1444\":1}}],[\"packed\",{\"1\":{\"506\":1}}],[\"payable\",{\"1\":{\"487\":2,\"488\":2}}],[\"patternlayoutencoder\",{\"1\":{\"821\":1}}],[\"pattern>\",{\"1\":{\"820\":2,\"821\":1}}],[\"pattern\",{\"1\":{\"605\":1,\"606\":1,\"607\":1}}],[\"patter\",{\"1\":{\"411\":1}}],[\"patch\",{\"1\":{\"178\":1}}],[\"pathvariable\",{\"1\":{\"819\":1,\"831\":2,\"1092\":1,\"1293\":1,\"1431\":1}}],[\"path\",{\"1\":{\"157\":2,\"887\":2,\"1023\":4}}],[\"path=$ffmpeg\",{\"1\":{\"125\":1}}],[\"path时数据的大小\",{\"1\":{\"106\":1}}],[\"path设置记录文件的目录\",{\"1\":{\"106\":1}}],[\"parnew\",{\"1\":{\"1151\":3,\"1342\":3}}],[\"parsing\",{\"1\":{\"1002\":1}}],[\"parallel\",{\"1\":{\"936\":2}}],[\"param注解呢\",{\"1\":{\"826\":1}}],[\"param>\",{\"1\":{\"820\":2}}],[\"param2\",{\"1\":{\"779\":3}}],[\"param1\",{\"1\":{\"779\":3}}],[\"parameter\",{\"1\":{\"779\":2,\"944\":1}}],[\"parameterize\",{\"1\":{\"770\":1}}],[\"parameterhandler\",{\"1\":{\"770\":1}}],[\"parametertype\",{\"1\":{\"763\":4,\"775\":1,\"776\":1,\"777\":1,\"778\":1,\"827\":1}}],[\"parametertype=\",{\"1\":{\"727\":1,\"755\":2,\"763\":3,\"786\":1,\"827\":1,\"1176\":1,\"1361\":1}}],[\"parameters\",{\"1\":{\"725\":1,\"779\":2,\"789\":6,\"790\":1}}],[\"params\",{\"1\":{\"106\":1}}],[\"param\",{\"1\":{\"106\":1,\"192\":1,\"284\":11,\"285\":6,\"286\":3,\"337\":1,\"352\":2,\"388\":3,\"648\":1,\"689\":3,\"753\":4,\"763\":10,\"779\":10,\"780\":4,\"784\":2,\"785\":4,\"786\":5,\"787\":2,\"793\":3,\"794\":2,\"795\":2,\"820\":2,\"826\":17,\"830\":3,\"1092\":2,\"1216\":2,\"1293\":2,\"1393\":2}}],[\"partation\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"part\",{\"1\":{\"506\":1}}],[\"partiton\",{\"1\":{\"1159\":1,\"1162\":1,\"1347\":1,\"1350\":1}}],[\"partitioner\",{\"1\":{\"1162\":1,\"1350\":1}}],[\"partition\",{\"0\":{\"1165\":1,\"1353\":1},\"1\":{\"980\":1,\"986\":1,\"992\":1,\"1078\":2,\"1159\":5,\"1165\":1,\"1166\":5,\"1167\":3,\"1240\":1,\"1282\":1,\"1347\":5,\"1353\":1,\"1354\":5,\"1355\":3,\"1413\":1}}],[\"partitions\",{\"1\":{\"112\":1,\"986\":1}}],[\"partial\",{\"1\":{\"35\":1}}],[\"partial^r\",{\"1\":{\"35\":1}}],[\"parent>\",{\"1\":{\"715\":1}}],[\"parent<\",{\"1\":{\"715\":1}}],[\"parent\",{\"1\":{\"457\":3}}],[\"password=\",{\"1\":{\"759\":1,\"789\":6,\"790\":2,\"816\":1}}],[\"password\",{\"1\":{\"602\":2,\"736\":3,\"737\":2,\"743\":4,\"745\":1,\"747\":5,\"755\":6,\"759\":2,\"763\":9,\"766\":4,\"779\":11,\"782\":2,\"786\":2,\"793\":1,\"815\":2,\"864\":2,\"1444\":1}}],[\"passwd\",{\"1\":{\"94\":1}}],[\"pass\",{\"1\":{\"106\":6,\"266\":1}}],[\"对实现不同应用间的相互隔离非常有帮助\",{\"1\":{\"1245\":1,\"1418\":1}}],[\"对运行时指标进行检查和监控\",{\"1\":{\"1231\":1,\"1406\":1}}],[\"对类进行方法级别的切面增强\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"对bean进行一些自定义的前置处理\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"对struts2的支持\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"对jdbc进行封装\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"对一定不存在的key进行过滤\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"对一个列表进行修剪\",{\"1\":{\"604\":1}}],[\"对查询结果为空的情况也进行缓存\",{\"1\":{\"1202\":1,\"1382\":1}}],[\"对查询进行优化\",{\"1\":{\"1192\":1,\"1375\":1}}],[\"对数据加上排他锁\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"对数据加上共享锁\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"对此\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"对某些行的内容作了更改\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"对结果集的解析过程\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"对已完成的事务而言\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"对未完成的事务而言\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"对静态变量和静态代码块执行初始化工作\",{\"1\":{\"1148\":1,\"1339\":1}}],[\"对静态资源处理\",{\"1\":{\"819\":1}}],[\"对称性\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"对所有可以成为\",{\"1\":{\"1070\":1,\"1274\":1}}],[\"对所有的计数累加\",{\"1\":{\"358\":1}}],[\"对缓存的负荷更小\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"对后续学习各种并发工具和框架\",{\"1\":{\"1018\":1}}],[\"对吧\",{\"1\":{\"1006\":1}}],[\"对吗\",{\"1\":{\"986\":1}}],[\"对kafka的性能有了深入的理解\",{\"1\":{\"980\":1}}],[\"对的\",{\"1\":{\"966\":1}}],[\"对构造器循环依赖\",{\"1\":{\"954\":1}}],[\"对代理循环依赖\",{\"1\":{\"954\":1}}],[\"对长连接使用主从\",{\"1\":{\"950\":1}}],[\"对非关键性计算使用异步处理\",{\"1\":{\"950\":1}}],[\"对频繁读取数据的接口使用缓存\",{\"1\":{\"950\":1}}],[\"对关系型数据库进行分库分表\",{\"1\":{\"950\":1}}],[\"对其设计与实现有深入理解\",{\"1\":{\"940\":1}}],[\"对其的理解也只是停留在理论的层面上\",{\"1\":{\"692\":1}}],[\"对超大对象特殊处理\",{\"1\":{\"940\":1}}],[\"对标记和筛选阶段误差产生的垃圾链进行清理\",{\"1\":{\"940\":1}}],[\"对标记和筛选阶段差异化技术产生的垃圾链进行清理\",{\"1\":{\"936\":1}}],[\"对内存进行复制然后清理\",{\"1\":{\"936\":1}}],[\"对整个堆进行垃圾回收\",{\"1\":{\"930\":1}}],[\"对整体项目有一个了解\",{\"1\":{\"98\":1}}],[\"对它的设计和实现有了比较深入的理解\",{\"1\":{\"922\":1}}],[\"对工作区的修改内容已经没有了\",{\"1\":{\"916\":1}}],[\"对mybatis有一定了解的\",{\"1\":{\"732\":1}}],[\"对maven的理解停留在能管理依赖\",{\"1\":{\"698\":1}}],[\"对日志描述的优化处理\",{\"1\":{\"689\":1}}],[\"对方法前后进行拦截\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"对方法名\",{\"1\":{\"689\":1}}],[\"对方法运行时间进行监控\",{\"1\":{\"689\":1}}],[\"对使用了自定义注解的方法进行aop切面处理\",{\"1\":{\"689\":1}}],[\"对设置到哈希表\",{\"1\":{\"605\":1}}],[\"对小型数据集使用\",{\"0\":{\"546\":1}}],[\"对象a获得依赖对象b的过程\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"对象a与对象b之间失去了直接联系\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"对象a依赖于对象b\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"对象与对象之间会彼此失去联系\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"对象与之对应\",{\"1\":{\"1023\":1}}],[\"对象粘合在一起发挥作用\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"对象之间复杂的依赖关系\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"对象之间耦合度过高的系统\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"对象之间的关系由容器来创建和维护\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"对象之间的关系本来是由我们开发者自己创建和维护的\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"对象之间的依赖关系已经降低到了最低程度\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"对象之间的依赖关系也越来越复杂\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"对象之间的耦合关系是无法避免的\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"对象进行分页\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"对象设置参数的过程\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"对象关系图如下\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"对象关系映射\",{\"1\":{\"1172\":1,\"1357\":1}}],[\"对象图导航语言\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"对象获得请求信息\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"对象指针偏移量\",{\"1\":{\"1023\":1}}],[\"对象指针\",{\"1\":{\"1023\":1}}],[\"对象头偏移量\",{\"1\":{\"1023\":1}}],[\"对象头\",{\"1\":{\"1023\":1}}],[\"对象头中的标记字被重新设计\",{\"1\":{\"1022\":1}}],[\"对象头中的标记字是\",{\"1\":{\"1022\":1}}],[\"对象或方法内部的状态能保证正确\",{\"1\":{\"988\":1}}],[\"对象并返回\",{\"1\":{\"958\":1}}],[\"对象负责填充\",{\"1\":{\"956\":1}}],[\"对象晋升到老年代时预留一定空间减少碎片\",{\"1\":{\"938\":1}}],[\"对象在eden出生\",{\"1\":{\"936\":1}}],[\"对象example引用为null\",{\"1\":{\"936\":1}}],[\"对象通过引用计数算法判断是否为垃圾\",{\"1\":{\"936\":1}}],[\"对象如何判断为\",{\"1\":{\"936\":1}}],[\"对象的方法将响应回传给客户端\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"对象的创建和销毁是非常频繁的操作\",{\"1\":{\"930\":1}}],[\"对象的创建和销毁\",{\"1\":{\"930\":1}}],[\"对象的空转时长\",{\"1\":{\"635\":1}}],[\"对象对应的变量值\",{\"1\":{\"928\":1}}],[\"对象中属性有\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"对象中查找当前\",{\"1\":{\"928\":1}}],[\"对象中存储了一个键值对\",{\"1\":{\"928\":1}}],[\"对象来存储每个线程的变量副本的\",{\"1\":{\"928\":1}}],[\"对象资源\",{\"1\":{\"648\":2}}],[\"对象会记录自己的最后一次被访问的时间\",{\"1\":{\"636\":1}}],[\"对象共享池指redis内部维护\",{\"1\":{\"1204\":1,\"1384\":1}}],[\"对象共享\",{\"1\":{\"635\":1}}],[\"对象结构\",{\"1\":{\"635\":1}}],[\"对象拷贝\",{\"1\":{\"524\":1}}],[\"对象作为独立的隐藏文档来存储\",{\"1\":{\"451\":1}}],[\"对象\",{\"1\":{\"451\":2,\"815\":1,\"928\":4,\"930\":1,\"932\":4,\"956\":3,\"958\":1,\"1010\":4,\"1023\":1,\"1128\":1,\"1133\":2,\"1179\":2,\"1321\":1,\"1326\":2,\"1364\":2}}],[\"对象类型\",{\"0\":{\"450\":1}}],[\"对象是\",{\"1\":{\"193\":1}}],[\"对快速高亮fast\",{\"1\":{\"440\":1}}],[\"对排序和聚合能提升较大性能\",{\"1\":{\"440\":1}}],[\"对排查故障造成感染\",{\"1\":{\"199\":1}}],[\"对not\",{\"1\":{\"440\":1}}],[\"对比可重复读\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"对比键的函数\",{\"1\":{\"624\":1}}],[\"对比\",{\"0\":{\"370\":1},\"1\":{\"1087\":1,\"1288\":1}}],[\"对树中的结点按从上至下\",{\"1\":{\"364\":1}}],[\"对应监控每一个redis实例\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"对应了操作系统上的一个文件夹\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"对应方法名\",{\"1\":{\"827\":1}}],[\"对应的\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"对应的值不为空\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"对应的栈帧会被弹出\",{\"1\":{\"930\":1}}],[\"对应的配置\",{\"1\":{\"844\":1}}],[\"对应的接口全名\",{\"1\":{\"827\":1}}],[\"对应的技术入门在\",{\"1\":{\"808\":1}}],[\"对应原userdao\",{\"1\":{\"763\":1}}],[\"对应数组下标的元素进行\",{\"1\":{\"359\":1}}],[\"对应位置\",{\"1\":{\"333\":1,\"339\":1}}],[\"对每一个桶中元素进行排序\",{\"1\":{\"351\":1}}],[\"对每个桶进行排序\",{\"1\":{\"348\":1,\"352\":1}}],[\"对每个桶中元素进行排序\",{\"1\":{\"348\":1}}],[\"对空无法出队\",{\"1\":{\"288\":1}}],[\"对故障排查意义不大\",{\"1\":{\"201\":1}}],[\"对低级别的日志输出\",{\"0\":{\"195\":1}}],[\"对于第二类\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"对于第一类\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"对于系统开发而言\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"对于面向对象设计及编程的基本思想\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"对于面试的同学\",{\"1\":{\"100\":1}}],[\"对于浏览量\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"对于到达服务器的客户机请求\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"对于成员变量来说\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"对于引用类型来说\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"对于基本类型来说\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"对于类\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"对于需要下车的人\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"对于需要保证唯一性的列\",{\"1\":{\"502\":1}}],[\"对于nio来说通过channel发起io操作请求后\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"对于没有分配到处理线程的连接就会被阻塞或者拒绝\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"对于任意非空引用x\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"对于任何引用x\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"对于任何引用x和y\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"对于任何非空引用x\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"对于读操作\",{\"1\":{\"1078\":1,\"1282\":1}}],[\"对于大数据量\",{\"0\":{\"1077\":1,\"1281\":1}}],[\"对于每一个搜索请求而言\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"对于宿主机来说\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"对于目标分片\",{\"1\":{\"1012\":1}}],[\"对于技术人员来说是一个必备的技能\",{\"1\":{\"1002\":1}}],[\"对于处理大数据和构建搜索引擎来说\",{\"1\":{\"998\":1}}],[\"对于刚入行的技术人员来说\",{\"1\":{\"978\":1}}],[\"对于自定义类型作为键\",{\"1\":{\"922\":1}}],[\"对于自增字段\",{\"1\":{\"575\":1}}],[\"对于线程安全的需求\",{\"1\":{\"922\":1}}],[\"对于这种情况\",{\"1\":{\"916\":1}}],[\"对于这些参数的描述主要基于笔者的理解\",{\"1\":{\"440\":1}}],[\"对于后端接口\",{\"1\":{\"829\":1}}],[\"对于传递性依赖\",{\"1\":{\"707\":1}}],[\"对于编译\",{\"1\":{\"706\":2}}],[\"对于下面操作\",{\"1\":{\"601\":1}}],[\"对于范围查询\",{\"1\":{\"575\":1}}],[\"对于索引项的查询\",{\"1\":{\"575\":1}}],[\"对于索引优化和原理理解都非常重要\",{\"1\":{\"262\":1}}],[\"对于一些设置了过期时间的\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"对于一次性事件\",{\"1\":{\"541\":1}}],[\"对于一个后端开发来说\",{\"1\":{\"90\":1}}],[\"对于连续的数值\",{\"1\":{\"529\":1}}],[\"对于慢查询我们一般通过如下思路解决\",{\"1\":{\"525\":1}}],[\"对于列的值分布进行分析\",{\"1\":{\"510\":1}}],[\"对于经常更新的字段\",{\"1\":{\"508\":1}}],[\"对于经常出现在查询条件中的列\",{\"1\":{\"502\":1}}],[\"对于频繁执行的复杂查询\",{\"1\":{\"504\":1}}],[\"对于只读或几乎只读的表\",{\"1\":{\"502\":1}}],[\"对于数据量小的表\",{\"1\":{\"502\":1}}],[\"对于数据量较大的表\",{\"1\":{\"502\":1}}],[\"对于数据量的大小评估\",{\"1\":{\"499\":1}}],[\"对于复合索引\",{\"1\":{\"498\":1,\"501\":1}}],[\"对于浮点数\",{\"1\":{\"444\":1}}],[\"对于初学者可以对\",{\"1\":{\"411\":1,\"428\":1,\"460\":1}}],[\"对于初始化或leader宕机时\",{\"1\":{\"166\":1}}],[\"对于出现频率不同的数字集合\",{\"1\":{\"353\":1}}],[\"对于桶中元素的排序\",{\"1\":{\"348\":1}}],[\"对于现在大趋势分布式架构\",{\"1\":{\"342\":1}}],[\"对于普通队列的\",{\"1\":{\"288\":1}}],[\"对于普通应用\",{\"1\":{\"106\":1}}],[\"对于普通应用设为\",{\"1\":{\"106\":1}}],[\"对于server1\",{\"1\":{\"166\":1}}],[\"对于server1而言\",{\"1\":{\"166\":1}}],[\"对于server2而言\",{\"1\":{\"166\":1}}],[\"对于软件系统的某些类\",{\"1\":{\"77\":1}}],[\"对于\",{\"1\":{\"45\":1,\"195\":1,\"511\":3,\"924\":2,\"1091\":1,\"1292\":1}}],[\"对\",{\"0\":{\"1073\":1,\"1277\":1},\"1\":{\"30\":1,\"106\":1,\"352\":2,\"364\":1,\"603\":1,\"613\":1,\"647\":1,\"707\":3,\"807\":1,\"940\":1,\"950\":1,\"952\":2,\"954\":1,\"956\":2,\"1179\":1,\"1364\":1}}],[\"为空或者为\",{\"1\":{\"1431\":1}}],[\"为何不用\",{\"1\":{\"1431\":1}}],[\"为每一个bean提供一个实例\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"为每个session创建一个实例\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"为每个\",{\"1\":{\"28\":1}}],[\"为3\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"为4\",{\"1\":{\"1161\":1,\"1349\":1}}],[\"为保证集群中的某个节点发生故障时\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"为对象的属性赋值\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"为对象分配空间\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"为目的对它们进行重排序\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"为后续的指令建立基础映像\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"为异步非阻塞\",{\"1\":{\"1034\":1}}],[\"为类添加额外的功能\",{\"1\":{\"1016\":2}}],[\"为啥泛型类不能有静态方法\",{\"1\":{\"966\":1}}],[\"为多个小\",{\"1\":{\"954\":1}}],[\"为下面几条jvm指令\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"为下次gc做准备\",{\"1\":{\"940\":1}}],[\"为下一次gc做准备\",{\"1\":{\"938\":1}}],[\"为解决这个问题\",{\"1\":{\"938\":1}}],[\"为事务做准备\",{\"1\":{\"829\":1}}],[\"为dao接口方法提供sql语句配置\",{\"1\":{\"827\":1}}],[\"为客户端模式\",{\"1\":{\"692\":1}}],[\"为单位的数组\",{\"1\":{\"658\":1}}],[\"为哈希表\",{\"1\":{\"605\":2}}],[\"为已存在的列表添加值\",{\"1\":{\"604\":1}}],[\"为一个long型\",{\"1\":{\"388\":1}}],[\"为一页\",{\"1\":{\"269\":1}}],[\"为堆数\",{\"1\":{\"371\":1,\"372\":1}}],[\"为所采取的基数\",{\"1\":{\"371\":1,\"372\":1}}],[\"为所有叶子结点增加了一个链指针\",{\"1\":{\"269\":1}}],[\"为1\",{\"1\":{\"342\":1}}],[\"为止\",{\"1\":{\"267\":1}}],[\"为\",{\"1\":{\"267\":1,\"270\":4,\"443\":1,\"451\":2,\"457\":3,\"625\":1,\"1078\":3,\"1084\":1,\"1161\":1,\"1162\":1,\"1179\":1,\"1282\":3,\"1285\":1,\"1349\":1,\"1350\":1,\"1364\":1}}],[\"为底数很大的\",{\"1\":{\"266\":1}}],[\"为例\",{\"0\":{\"247\":1},\"1\":{\"251\":1,\"375\":1,\"525\":1,\"1444\":1}}],[\"为用户提供数据节点的监听注册服务\",{\"1\":{\"167\":1}}],[\"为用户提供数据的注册和查询服务\",{\"1\":{\"167\":1}}],[\"为什么redis是单线程的\",{\"0\":{\"1200\":1,\"1380\":1}}],[\"为什么这么快\",{\"0\":{\"1167\":1,\"1355\":1}}],[\"为什么红黑树转换回链表的阈值不是7而是6呢\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"为什么不直接用key的hashcode\",{\"0\":{\"1121\":1,\"1316\":1}}],[\"为什么计算key的hash时要把hashcode的高16位与低16位进行异或\",{\"0\":{\"1121\":1,\"1316\":1}}],[\"为什么重写equals还要重写hashcode\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"为什么呢\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"为什么我在主线程\",{\"1\":{\"692\":1}}],[\"为什么使用maven\",{\"0\":{\"700\":1}}],[\"为什么使用redis\",{\"1\":{\"613\":1}}],[\"为什么使用单例模式\",{\"0\":{\"77\":1}}],[\"为什么大字段io效率低\",{\"1\":{\"516\":1}}],[\"为什么要使用双亲委派模型\",{\"0\":{\"1149\":1,\"1340\":1},\"1\":{\"1149\":1,\"1340\":1}}],[\"为什么要使用缓存\",{\"0\":{\"616\":1}}],[\"为什么要把链表转为红黑树\",{\"0\":{\"1122\":1,\"1317\":1}}],[\"为什么要有不同的作用域\",{\"1\":{\"952\":1}}],[\"为什么要进行两倍扩容\",{\"1\":{\"922\":1}}],[\"为什么要进行依赖管理\",{\"1\":{\"699\":1}}],[\"为什么要选择数组和链表这两种数据结构呢\",{\"1\":{\"922\":1}}],[\"为什么要写\",{\"1\":{\"920\":1}}],[\"为什么要在数据库中加锁\",{\"0\":{\"553\":1}}],[\"为什么要用缓存\",{\"0\":{\"1043\":1,\"1252\":1}}],[\"为什么要用redis\",{\"0\":{\"615\":1}}],[\"为什么要用\",{\"0\":{\"503\":1,\"1032\":1,\"1224\":1,\"1399\":1}}],[\"为什么要用zookeeper\",{\"0\":{\"153\":1}}],[\"为什么要三次握手\",{\"1\":{\"104\":1}}],[\"为什么\",{\"0\":{\"500\":1,\"1123\":1,\"1318\":1},\"1\":{\"104\":1}}],[\"为了进一步的查询优化\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"为了不影响集群正常的性能\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"为了实现扩展性\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"为了实现这一点\",{\"1\":{\"274\":1}}],[\"为了能够在这种极端情况下仍保证较为高效的查询效率\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"为了让hashcode的高16位能够参与到按位与操作中\",{\"1\":{\"1121\":1,\"1316\":1}}],[\"为了让哈希表的\",{\"1\":{\"625\":1}}],[\"为了反序列化一个对象\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"为了控制容器中进程对资源的访问\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"为了控制我们的执行顺序\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"为了支持各种协议和处理数据的方式\",{\"1\":{\"1034\":1}}],[\"为了优化\",{\"1\":{\"1022\":1}}],[\"为了解决对象之间的耦合度过高的问题\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"为了解决该问题就出现了分区再分配\",{\"1\":{\"1164\":1,\"1352\":1}}],[\"为了解决这个问题\",{\"1\":{\"996\":1,\"1071\":1,\"1275\":1}}],[\"为了解决线程并发的问题\",{\"1\":{\"692\":1}}],[\"为了使用接口动态代理\",{\"1\":{\"763\":1}}],[\"为了使桶排序更加高效\",{\"1\":{\"348\":1}}],[\"为了提高内存分配的效率\",{\"1\":{\"930\":1}}],[\"为了提高垃圾回收的效率\",{\"1\":{\"930\":1}}],[\"为了提高程序的性能\",{\"1\":{\"930\":1}}],[\"为了提高查询效率\",{\"1\":{\"525\":1}}],[\"为了提供性能而做的优化\",{\"1\":{\"692\":1}}],[\"为了代码简洁易懂就不加了\",{\"1\":{\"689\":1}}],[\"为了防止幻读\",{\"1\":{\"575\":1}}],[\"为了缓和系统表的资源\",{\"0\":{\"542\":1}}],[\"为了快速开发\",{\"1\":{\"525\":1}}],[\"为了避免应用出现单点故障\",{\"1\":{\"664\":1}}],[\"为了避免io争抢并减少锁表的几率\",{\"1\":{\"516\":1}}],[\"为了避免线程的上下文切换消耗大量时间\",{\"1\":{\"82\":1}}],[\"为了用户有参与感\",{\"1\":{\"483\":1}}],[\"为了系统后续处理方便\",{\"1\":{\"425\":1}}],[\"为了估算出k和m的值\",{\"1\":{\"339\":1}}],[\"为了便于操作\",{\"1\":{\"289\":1}}],[\"为了达到这个目的\",{\"1\":{\"274\":1}}],[\"为了读取这个扇区的数据\",{\"1\":{\"274\":1}}],[\"为了简单起见\",{\"1\":{\"274\":1}}],[\"为了增加\",{\"1\":{\"269\":1}}],[\"为了更快\",{\"1\":{\"266\":1}}],[\"为了打印一行日志\",{\"1\":{\"193\":1}}],[\"为了保证数据实时效\",{\"1\":{\"594\":1}}],[\"为了保证效率\",{\"1\":{\"589\":1}}],[\"为了保证高可移植性和编解码质量\",{\"1\":{\"122\":1}}],[\"为了保留系统运行关键指标\",{\"1\":{\"191\":1}}],[\"为了丰富文档写作\",{\"1\":{\"30\":1}}],[\"语句执行中\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"语句的\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"语句的所有方法\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"语句实现物理分页\",{\"1\":{\"958\":1}}],[\"语句才会添加\",{\"1\":{\"958\":1}}],[\"语句\",{\"1\":{\"958\":1,\"1179\":2,\"1364\":2}}],[\"语句本身\",{\"1\":{\"958\":1}}],[\"语句中的\",{\"1\":{\"556\":1}}],[\"语句都是以实现功能为主\",{\"1\":{\"525\":1}}],[\"语句优化\",{\"1\":{\"525\":1}}],[\"语句在执行查询时\",{\"1\":{\"497\":1}}],[\"语句产生的字符串记录的是堆栈信息\",{\"1\":{\"196\":1}}],[\"语言是支持多线程的\",{\"1\":{\"692\":1}}],[\"语言编写\",{\"1\":{\"648\":1}}],[\"语言并不具备自动的内存回收功能\",{\"1\":{\"635\":1}}],[\"语言传统的字符串表示\",{\"1\":{\"619\":1}}],[\"语言\",{\"1\":{\"251\":1,\"377\":1}}],[\"语法\",{\"0\":{\"35\":1},\"1\":{\"31\":1,\"46\":1,\"106\":3,\"140\":1,\"654\":1,\"727\":1,\"1177\":1,\"1362\":1}}],[\"语法进行了扩展\",{\"1\":{\"30\":1}}],[\"语法扩展\",{\"1\":{\"29\":1}}],[\"语雀\",{\"1\":{\"2\":1}}],[\"请谈一谈\",{\"0\":{\"1119\":1,\"1314\":1}}],[\"请谈谈你对\",{\"0\":{\"511\":1}}],[\"请说一下java容器集合的分类\",{\"0\":{\"1112\":1,\"1307\":1}}],[\"请说说有哪些缓存算法\",{\"0\":{\"1044\":1,\"1253\":1}}],[\"请随时提问\",{\"1\":{\"984\":1}}],[\"请开始你的表演\",{\"1\":{\"970\":1}}],[\"请问你叫什么名字\",{\"1\":{\"956\":1}}],[\"请问你对jvm内存模型有了解吗\",{\"1\":{\"930\":1}}],[\"请问你对\",{\"1\":{\"928\":1,\"1010\":1}}],[\"请问你对线程池有什么了解\",{\"1\":{\"926\":1}}],[\"请王哥考考我\",{\"1\":{\"954\":1}}],[\"请注意这里说的是\",{\"1\":{\"711\":1}}],[\"请看代码\",{\"1\":{\"692\":1}}],[\"请求直接落到数据库上\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"请求最终将到达顶层的启动类加载器\",{\"1\":{\"1149\":1,\"1340\":1}}],[\"请求管道化\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"请求对象不会变\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"请求对象\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"请求处理\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"请求到\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"请求会被转发到\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"请求发现缓存不存在后\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"请求时从\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"请求等等\",{\"1\":{\"1033\":1}}],[\"请求\",{\"1\":{\"1033\":1,\"1048\":1,\"1072\":1,\"1128\":2,\"1257\":1,\"1276\":1,\"1321\":2}}],[\"请求的整个过程\",{\"1\":{\"1027\":1}}],[\"请求的方法名\",{\"1\":{\"689\":1}}],[\"请求映射到\",{\"1\":{\"956\":1}}],[\"请求都会创建一个\",{\"1\":{\"952\":1}}],[\"请求相应参数等信息\",{\"1\":{\"179\":1}}],[\"请求参数错误\",{\"1\":{\"1431\":1}}],[\"请求参数\",{\"1\":{\"179\":1}}],[\"请求方式\",{\"1\":{\"1027\":1}}],[\"请求方式常用的有如下几种\",{\"1\":{\"178\":1}}],[\"请求方式规范\",{\"0\":{\"178\":1}}],[\"请求和应答时间长度\",{\"1\":{\"157\":1}}],[\"请求backup机器\",{\"1\":{\"106\":1}}],[\"请求有哪些区别\",{\"1\":{\"104\":1}}],[\"请点一个免费的\",{\"1\":{\"49\":1}}],[\"请使用绝对链接\",{\"1\":{\"45\":1}}],[\"请阅读\",{\"1\":{\"28\":1,\"30\":1}}],[\"请先阅读\",{\"1\":{\"27\":1}}],[\"是要做一个用户相关的系统\",{\"1\":{\"1439\":1}}],[\"是多台\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"是ioc的核心\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"是软件工程永远追求的目标之一\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"是拼接符\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"是字符串替换\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"是字符串且格式为日期格式\",{\"1\":{\"439\":1}}],[\"是占位符\",{\"1\":{\"1174\":1,\"1359\":1}}],[\"是按\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"是怎么选举的\",{\"0\":{\"1165\":1,\"1353\":1}}],[\"是其它编程语言交互的接口\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"是各个线程共享的内存区域\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"是浏览器对\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"是在\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"是在线程工作内存当中获取\",{\"1\":{\"692\":1}}],[\"是服务器内部的处理\",{\"1\":{\"1132\":1,\"1325\":1}}],[\"是sun公司提供的一套规范\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"是遗留类\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"是遗留的线程安全\",{\"1\":{\"988\":1}}],[\"是同步的\",{\"1\":{\"1115\":1,\"1310\":1}}],[\"是判断两个变量或实例所指向的内存空间的值是不是相同\",{\"1\":{\"1087\":2,\"1288\":2}}],[\"是判断两个变量或实例是不是指向同一个内存空间\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"是完全可行的\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"是通过hash值与数组长度减一的值进行按位与操作的\",{\"1\":{\"1121\":1,\"1316\":1}}],[\"是通过\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"是通过哈希表实现的\",{\"1\":{\"606\":1}}],[\"是docker的管理工具\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"是轻量级的沙盒\",{\"1\":{\"1058\":1,\"1264\":1}}],[\"是比较麻烦的\",{\"1\":{\"1052\":1,\"1261\":1}}],[\"是真实存在对应的值的\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"是真的吗\",{\"1\":{\"954\":1}}],[\"是实现java并发编程的基础工具之一\",{\"1\":{\"1018\":1}}],[\"是java并发编程的基础之一\",{\"1\":{\"1018\":1}}],[\"是java程序员用得最频繁的集合之一\",{\"1\":{\"922\":1}}],[\"是最小的数据单元\",{\"1\":{\"1002\":1}}],[\"是最基础的锁类型\",{\"1\":{\"555\":1}}],[\"是线程安全的\",{\"1\":{\"988\":1,\"1089\":1,\"1115\":1,\"1290\":1,\"1310\":1}}],[\"是吗\",{\"1\":{\"970\":1,\"986\":1,\"994\":1,\"996\":1}}],[\"是我最喜欢的\",{\"1\":{\"960\":1}}],[\"是我最喜欢且熟练使用的持久层框架之一\",{\"1\":{\"958\":1}}],[\"是我们比较先想到的方法\",{\"1\":{\"385\":1}}],[\"是我们在数据量较小的系统中经常使用的\",{\"1\":{\"383\":1}}],[\"是如何实现\",{\"0\":{\"1070\":1,\"1274\":1}}],[\"是如何解决循环依赖问题的呢\",{\"1\":{\"954\":1}}],[\"是如何调用这些方法的\",{\"1\":{\"952\":1}}],[\"是如何工作的\",{\"1\":{\"950\":1}}],[\"是基于内存的数据库\",{\"1\":{\"960\":1}}],[\"是基于\",{\"1\":{\"950\":1,\"956\":1}}],[\"是不是有点懵\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"是不是太武断了\",{\"1\":{\"940\":1}}],[\"是不是很开心~\",{\"1\":{\"830\":1}}],[\"是的\",{\"1\":{\"934\":1,\"938\":2,\"940\":1,\"962\":1,\"970\":1,\"978\":2,\"980\":1,\"982\":1,\"986\":2,\"988\":1,\"994\":1,\"996\":2,\"1000\":1,\"1010\":1,\"1012\":1,\"1018\":1,\"1022\":1}}],[\"是默认的拒绝策略\",{\"1\":{\"926\":1}}],[\"是hashmap的线程安全替代方案\",{\"1\":{\"922\":1}}],[\"是hadoop和hbase的重要组件\",{\"1\":{\"154\":1}}],[\"是当前推荐的线程安全\",{\"1\":{\"922\":1}}],[\"是非常强大的一个功能\",{\"1\":{\"958\":1}}],[\"是非常重要且非常实用的一个命令\",{\"1\":{\"917\":1}}],[\"是非线程安全的\",{\"1\":{\"922\":1,\"1115\":1,\"1310\":1}}],[\"是映射中的键值\",{\"1\":{\"922\":1}}],[\"是用来构建分布式一致性状态机系统\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"是用来编译源代码的\",{\"1\":{\"844\":1}}],[\"是用来创建文件的命令\",{\"1\":{\"91\":1}}],[\"是项目开发中最常修改的地方\",{\"1\":{\"844\":1}}],[\"是项目中用到的一些属性\",{\"1\":{\"844\":1}}],[\"是参数类型\",{\"1\":{\"827\":1}}],[\"是返回值类型\",{\"1\":{\"827\":1}}],[\"是因为该方法有两个或以上的参数\",{\"1\":{\"826\":1}}],[\"是因为词频信息在搜索结果排序时\",{\"1\":{\"425\":1}}],[\"是进行字符串拼接\",{\"1\":{\"779\":1}}],[\"是负责执行低层映射语句的内部对象\",{\"1\":{\"770\":1}}],[\"是传递依赖\",{\"1\":{\"707\":1}}],[\"是第一条指令\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"是第一直接依赖\",{\"1\":{\"707\":1}}],[\"是第二直接依赖\",{\"1\":{\"707\":1}}],[\"是单线程应用\",{\"1\":{\"664\":1}}],[\"是区分大小写的\",{\"1\":{\"652\":1}}],[\"是什么\",{\"0\":{\"1158\":1,\"1346\":1},\"1\":{\"614\":1}}],[\"是简单的字符串列表\",{\"1\":{\"604\":1}}],[\"是批量操作\",{\"1\":{\"603\":1}}],[\"是运行\",{\"1\":{\"591\":1}}],[\"是british\",{\"1\":{\"589\":1}}],[\"是redis\",{\"1\":{\"589\":1}}],[\"是mysql数据库中innodb存储引擎特有的一种锁机制\",{\"1\":{\"559\":1}}],[\"是根据表中数据来进行查询优化的\",{\"0\":{\"536\":1}}],[\"是数据库使用中最长遇见的问题\",{\"1\":{\"501\":1}}],[\"是性能瓶颈\",{\"1\":{\"499\":1}}],[\"是可以通过我们插入的文档自动生成索引\",{\"1\":{\"438\":1}}],[\"是elasticsearch\",{\"1\":{\"429\":1}}],[\"是整个\",{\"1\":{\"428\":1}}],[\"是整个搜索的核心\",{\"1\":{\"424\":1}}],[\"是由艾兹格\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"是由c语言编写的\",{\"1\":{\"619\":1}}],[\"是由\",{\"1\":{\"401\":1,\"920\":1}}],[\"是由高位数为基底开始进行分配\",{\"1\":{\"375\":1}}],[\"是与名为\",{\"1\":{\"400\":1}}],[\"是1970年由布隆提出的\",{\"1\":{\"332\":1}}],[\"是聚合在一起的\",{\"1\":{\"267\":1}}],[\"是一款优秀的持久层框架\",{\"1\":{\"958\":1}}],[\"是一款高性能\",{\"1\":{\"940\":1}}],[\"是一款比较经典的低停顿收集器\",{\"1\":{\"938\":1}}],[\"是一种错误检测机制\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"是一种以空间换时间的做法\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"是一种流行的开源软件平台\",{\"1\":{\"1057\":1,\"1263\":1}}],[\"是一种非常\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"是一种标记\",{\"1\":{\"938\":1}}],[\"是一种并发标记清除算法\",{\"1\":{\"938\":1}}],[\"是一种特殊的远程仓库\",{\"1\":{\"705\":1}}],[\"是一种基数估算算法\",{\"1\":{\"659\":1}}],[\"是一种数据库完整性约束\",{\"1\":{\"560\":1}}],[\"是一个基于观察者模式设计的分布式服务管理框架\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"是一个基于内存的\",{\"1\":{\"1198\":1,\"1378\":1}}],[\"是一个模板方法\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"是一个有序的队列\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"是一个分布式的流式处理平台\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"是一个w3c标准\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"是一个包装类\",{\"1\":{\"1113\":1,\"1308\":1}}],[\"是一个避免死锁\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"是一个同步的辅助类\",{\"1\":{\"1104\":2,\"1302\":2}}],[\"是一个实现线程安全的方式\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"是一个用来定义和运行复杂应用的docker工具\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"是一个文本文件\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"是一个异步的\",{\"1\":{\"1031\":1}}],[\"是一个强大的分布式消息系统\",{\"1\":{\"982\":1}}],[\"是一个水果啊\",{\"1\":{\"966\":1}}],[\"是一个计数器\",{\"1\":{\"932\":1,\"1104\":1,\"1302\":1}}],[\"是一个简单直接的替代方案\",{\"1\":{\"922\":1}}],[\"是一个散列映射表\",{\"1\":{\"922\":1}}],[\"是一个以对话形式讲解知识点的文章合集\",{\"1\":{\"920\":1}}],[\"是一个比较优秀的工具\",{\"1\":{\"884\":1}}],[\"是一个快速开发框架\",{\"1\":{\"836\":1}}],[\"是一个采用纯java编写的开源项目管理工具\",{\"1\":{\"698\":1}}],[\"是一个类似于\",{\"1\":{\"654\":1}}],[\"是一个高性能的key\",{\"1\":{\"589\":1}}],[\"是一个\",{\"1\":{\"589\":1,\"605\":1,\"928\":1}}],[\"是一个自增字段\",{\"1\":{\"559\":1}}],[\"是一个好的选择\",{\"0\":{\"535\":1},\"1\":{\"1192\":1,\"1375\":1}}],[\"是一个开源框架\",{\"1\":{\"950\":1}}],[\"是一个开源\",{\"1\":{\"601\":1}}],[\"是一个开源的分布式协调服务\",{\"1\":{\"1237\":1,\"1410\":1}}],[\"是一个开源的dashboard展示工具\",{\"1\":{\"884\":1}}],[\"是一个开源的系统监控和告警的工具包\",{\"1\":{\"883\":1}}],[\"是一个开源的\",{\"1\":{\"614\":1}}],[\"是一个开源的使用ansi\",{\"1\":{\"589\":1}}],[\"是一个开源的搜索引擎\",{\"1\":{\"400\":1}}],[\"是一个开源大语言模型工具\",{\"1\":{\"245\":1}}],[\"是一个排序算法\",{\"1\":{\"348\":1}}],[\"是一个集合接口\",{\"1\":{\"1113\":1,\"1308\":1}}],[\"是一个集合\",{\"1\":{\"333\":1,\"339\":1}}],[\"是一棵自平衡的搜索树\",{\"1\":{\"266\":1}}],[\"是一定要看的\",{\"1\":{\"100\":1}}],[\"是使用门面模式的日志框架\",{\"1\":{\"194\":1}}],[\"是google的chubby一个开源的实现\",{\"1\":{\"154\":1}}],[\"是video的缩写\",{\"1\":{\"145\":1}}],[\"是指某个极度\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"是指缓存由于某些原因无法提供服务\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"是指查询一个一定不存在的数据\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"是指向下一个节点的指针\",{\"1\":{\"922\":1}}],[\"是指利用堆这种数据结构所设计的一种排序算法\",{\"1\":{\"364\":1}}],[\"是指当前server编号\",{\"1\":{\"166\":1}}],[\"是指当前服务器数据越新\",{\"1\":{\"166\":1}}],[\"是指每隔几帧输出一帧\",{\"1\":{\"141\":1}}],[\"是指\",{\"1\":{\"141\":1}}],[\"是独立的一个开源代码\",{\"1\":{\"135\":1}}],[\"是视频容器转换\",{\"1\":{\"131\":1}}],[\"是否相等\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"是否允许元素重复\",{\"1\":{\"1114\":1,\"1309\":1}}],[\"是否超过了该资源剩余的总量\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"是否能转换成右边的class类型\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"是否能手写一下\",{\"0\":{\"1044\":1,\"1253\":1}}],[\"是否需要存储等\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"是否需要检索\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"是否存在\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"是否存在时\",{\"1\":{\"333\":1,\"339\":1}}],[\"是否成功标志\",{\"1\":{\"830\":1}}],[\"是否喜欢的文章\",{\"1\":{\"653\":1}}],[\"是否提前进行\",{\"1\":{\"648\":1}}],[\"是否是大字段的原则拆分为多个表\",{\"1\":{\"520\":1}}],[\"是否单独设置此字段的是否存储而从\",{\"1\":{\"440\":1}}],[\"是否准确\",{\"1\":{\"176\":1}}],[\"是否来自looking状态的服务器\",{\"1\":{\"166\":1}}],[\"是否在http\",{\"1\":{\"106\":1}}],[\"是否调用sendfile\",{\"1\":{\"106\":1}}],[\"是\",{\"1\":{\"28\":1,\"145\":4,\"263\":1,\"264\":1,\"450\":1,\"457\":1,\"501\":1,\"506\":1,\"597\":1,\"606\":1,\"615\":1,\"630\":1,\"633\":1,\"827\":1,\"844\":3,\"922\":1,\"950\":1,\"956\":1,\"1020\":1,\"1022\":1,\"1084\":1,\"1133\":3,\"1177\":1,\"1231\":1,\"1238\":1,\"1285\":1,\"1326\":3,\"1362\":1,\"1406\":1,\"1411\":1}}],[\"文中大多是以实际面试中遇到的情况编写\",{\"1\":{\"920\":1}}],[\"文末还会提供无剪辑版的完整搭建视频\",{\"1\":{\"906\":1}}],[\"文末源码\",{\"1\":{\"847\":1}}],[\"文本检索\",{\"1\":{\"1006\":1}}],[\"文本执行使用\",{\"1\":{\"591\":1}}],[\"文本类型\",{\"1\":{\"440\":1}}],[\"文章点赞打赏截图\",{\"1\":{\"653\":1}}],[\"文章结构由简到难\",{\"1\":{\"525\":1}}],[\"文章标题列表\",{\"1\":{\"23\":1}}],[\"文档并没有真\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"文档3\",{\"1\":{\"1006\":1}}],[\"文档2\",{\"1\":{\"1006\":1}}],[\"文档1\",{\"1\":{\"1006\":1}}],[\"文档就是具体的记录\",{\"1\":{\"998\":1}}],[\"文档的根元素\",{\"1\":{\"844\":1}}],[\"文档及统计数据自动生成\",{\"1\":{\"714\":1}}],[\"文档中并不属于同一个\",{\"1\":{\"451\":1}}],[\"文档中\",{\"1\":{\"451\":1}}],[\"文档中同样存在布尔类型\",{\"1\":{\"446\":1}}],[\"文档扁平化\",{\"1\":{\"450\":1}}],[\"文档号+词频+位置+偏移量\",{\"1\":{\"440\":1}}],[\"文档号+词频+位置\",{\"1\":{\"440\":1}}],[\"文档号+词频\",{\"1\":{\"440\":1}}],[\"文档频率信息\",{\"1\":{\"425\":2}}],[\"文档矩阵\",{\"1\":{\"424\":1}}],[\"文档类似于关系型数据库中表内的一行记录\",{\"1\":{\"420\":1}}],[\"文档\",{\"1\":{\"420\":1,\"998\":1,\"1002\":1,\"1072\":1,\"1276\":1}}],[\"文件下执行测试案例\",{\"1\":{\"1444\":1}}],[\"文件追加数据更完整\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"文件可以加载多个映射文件\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"文件句柄和一个数据文件句柄\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"文件句柄和内存\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"文件句柄的开销\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"文件的正确性\",{\"1\":{\"1148\":1,\"1339\":1}}],[\"文件的内容都可以\",{\"1\":{\"602\":1}}],[\"文件然后装载入内存中\",{\"1\":{\"1148\":1,\"1339\":1}}],[\"文件中设置的<load\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"文件中被标记为删除的文档将不会被写入\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"文件中被标记为删除\",{\"1\":{\"1076\":2,\"1280\":2}}],[\"文件中使用的示例\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"文件中\",{\"1\":{\"1059\":1,\"1133\":1,\"1265\":1,\"1326\":1}}],[\"文件中对应的值来替换\",{\"1\":{\"766\":1}}],[\"文件后载入\",{\"1\":{\"964\":1}}],[\"文件发送给从服务器\",{\"1\":{\"964\":1}}],[\"文件并获得数据集\",{\"1\":{\"964\":1}}],[\"文件并发送给从服务器\",{\"1\":{\"964\":1}}],[\"文件创建完成之前是不能处理其他客户端发送的任何命令请求\",{\"1\":{\"962\":1}}],[\"文件准备\",{\"0\":{\"851\":1}}],[\"文件其他位置的属性值\",{\"1\":{\"844\":1}}],[\"文件了\",{\"1\":{\"820\":1}}],[\"文件夹里新建logback\",{\"1\":{\"821\":1}}],[\"文件夹里新建\",{\"1\":{\"818\":1,\"819\":1}}],[\"文件夹里新建一个\",{\"1\":{\"816\":1}}],[\"文件夹的图片\",{\"1\":{\"45\":1}}],[\"文件没有分离\",{\"1\":{\"772\":1}}],[\"文件最后添加一行\",{\"1\":{\"403\":1}}],[\"文件系统\",{\"1\":{\"272\":1}}],[\"文件系统中一个文件大小只有1个字节\",{\"1\":{\"272\":1}}],[\"文件太大\",{\"1\":{\"134\":1}}],[\"文件扩展名与文件类型映射表\",{\"1\":{\"106\":1}}],[\"文件描述符在cache中总是打开状态\",{\"1\":{\"106\":1}}],[\"文件授权\",{\"1\":{\"94\":1}}],[\"文件\",{\"1\":{\"94\":1,\"648\":1,\"816\":1,\"818\":1,\"819\":1,\"821\":1,\"1076\":1,\"1280\":1}}],[\"文件搜索\",{\"1\":{\"90\":1}}],[\"文件权限\",{\"1\":{\"90\":1}}],[\"文件压缩\",{\"1\":{\"90\":1}}],[\"文件查看\",{\"1\":{\"90\":1}}],[\"文件操作\",{\"0\":{\"91\":1},\"1\":{\"90\":1,\"1020\":1}}],[\"文件放置在一起使用相对路径进行引用\",{\"1\":{\"45\":1}}],[\"文件生成页面\",{\"1\":{\"26\":1}}],[\"v的值变为了其他值\",{\"1\":{\"1018\":1}}],[\"v的确为a\",{\"1\":{\"1018\":1}}],[\"v在jdk9后g1成为了更好的选择\",{\"1\":{\"938\":1}}],[\"v>>\",{\"1\":{\"1044\":2,\"1253\":2}}],[\"v>\",{\"1\":{\"922\":8,\"948\":2,\"988\":1,\"1044\":2,\"1253\":2}}],[\"vt线程在运行的时候会把\",{\"1\":{\"692\":1}}],[\"vt\",{\"1\":{\"692\":24}}],[\"v6\",{\"1\":{\"664\":1}}],[\"vert\",{\"1\":{\"950\":1}}],[\"verify\",{\"1\":{\"713\":1}}],[\"version=\",{\"1\":{\"743\":1,\"744\":1,\"745\":1,\"755\":1,\"763\":1,\"782\":1,\"812\":1,\"815\":1,\"817\":1,\"818\":1,\"819\":1,\"820\":1,\"821\":1,\"827\":2,\"844\":1,\"865\":1}}],[\"version等\",{\"1\":{\"715\":1}}],[\"version简称为gav\",{\"1\":{\"705\":1}}],[\"version>2\",{\"1\":{\"844\":1}}],[\"version>1\",{\"1\":{\"715\":1,\"844\":1}}],[\"version>4\",{\"1\":{\"715\":2,\"812\":1}}],[\"version>\",{\"1\":{\"648\":1,\"708\":2,\"709\":4,\"710\":2,\"715\":12,\"735\":1,\"742\":1,\"756\":1,\"812\":25,\"844\":6,\"862\":2,\"874\":2,\"1444\":1}}],[\"version\",{\"1\":{\"106\":1,\"115\":1,\"144\":2,\"436\":1,\"573\":5,\"579\":4,\"688\":1,\"689\":1,\"692\":2,\"702\":2,\"705\":1,\"715\":6,\"812\":8,\"824\":2,\"844\":2,\"849\":1,\"852\":1,\"1060\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1191\":7,\"1266\":1,\"1302\":2,\"1303\":1,\"1305\":1,\"1374\":7,\"1431\":1}}],[\"vector可以指定扩容的大小\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"vector的性能是不如arraylist的\",{\"1\":{\"1118\":1,\"1313\":1}}],[\"vector<>\",{\"1\":{\"946\":1}}],[\"vector<integer>\",{\"1\":{\"946\":1}}],[\"vector\",{\"1\":{\"440\":2,\"946\":1,\"1112\":1,\"1307\":1}}],[\"v7\",{\"1\":{\"412\":1,\"413\":1}}],[\"vmstructs\",{\"1\":{\"1023\":1}}],[\"vmsymbols\",{\"1\":{\"1023\":2}}],[\"vmware在资助着\",{\"1\":{\"589\":1}}],[\"vm\",{\"1\":{\"403\":1}}],[\"vd\",{\"1\":{\"251\":1}}],[\"vs\",{\"1\":{\"238\":1,\"370\":2}}],[\"vsync\",{\"1\":{\"141\":1}}],[\"v0\",{\"1\":{\"232\":1,\"408\":1,\"460\":1}}],[\"void\",{\"1\":{\"193\":1,\"195\":2,\"196\":2,\"197\":1,\"198\":2,\"200\":1,\"201\":2,\"284\":4,\"285\":7,\"286\":5,\"288\":2,\"289\":4,\"337\":2,\"352\":1,\"360\":1,\"364\":4,\"377\":2,\"388\":1,\"621\":7,\"624\":19,\"635\":1,\"648\":1,\"689\":6,\"692\":4,\"737\":1,\"747\":10,\"753\":3,\"754\":3,\"757\":6,\"763\":11,\"770\":1,\"784\":1,\"785\":1,\"786\":3,\"787\":1,\"789\":3,\"790\":1,\"793\":2,\"794\":1,\"795\":1,\"828\":5,\"830\":1,\"876\":2,\"924\":11,\"928\":6,\"932\":4,\"934\":1,\"936\":2,\"938\":2,\"940\":5,\"944\":2,\"948\":1,\"950\":2,\"952\":1,\"962\":2,\"964\":1,\"966\":8,\"984\":1,\"986\":2,\"988\":2,\"990\":1,\"1004\":1,\"1008\":1,\"1016\":3,\"1020\":2,\"1022\":4,\"1023\":2,\"1044\":2,\"1085\":1,\"1086\":6,\"1092\":5,\"1100\":1,\"1104\":6,\"1105\":4,\"1107\":4,\"1253\":2,\"1286\":1,\"1287\":6,\"1293\":5,\"1298\":1,\"1302\":6,\"1303\":4,\"1305\":4}}],[\"volatile有两大特性\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"volatile不保证原子性\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"volatile关键字方式\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"volatile关键字修饰的变量看到的随时是自己的最新值\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"volatile关键字的作用\",{\"0\":{\"692\":1,\"1099\":1,\"1297\":1}}],[\"volatileexample\",{\"1\":{\"924\":2}}],[\"volatile写\",{\"1\":{\"692\":1}}],[\"volatiletest\",{\"1\":{\"692\":9}}],[\"volatile\",{\"0\":{\"84\":1,\"924\":1},\"1\":{\"84\":2,\"636\":1,\"692\":10,\"920\":1,\"924\":41,\"1018\":1,\"1022\":4,\"1023\":19,\"1099\":1,\"1297\":1},\"2\":{\"693\":1}}],[\"v1\",{\"1\":{\"181\":1}}],[\"v2\",{\"1\":{\"145\":3,\"181\":1,\"182\":1,\"815\":1}}],[\"v表示存储jpeg的图像质量\",{\"1\":{\"141\":1}}],[\"vf\",{\"1\":{\"138\":1,\"140\":2,\"141\":1}}],[\"v时\",{\"1\":{\"134\":1}}],[\"v\",{\"1\":{\"134\":5,\"135\":2,\"141\":2,\"143\":4,\"145\":3,\"146\":2,\"251\":1,\"462\":1,\"624\":1,\"916\":1,\"928\":2,\"948\":1,\"1018\":1,\"1044\":2,\"1253\":2}}],[\"vcodec\",{\"1\":{\"127\":1,\"129\":1,\"133\":1,\"135\":2,\"136\":1,\"145\":1}}],[\"vn\",{\"1\":{\"127\":1,\"132\":2}}],[\"v3\",{\"1\":{\"116\":1,\"1238\":1,\"1245\":1,\"1411\":1,\"1418\":1}}],[\"visible\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"visibility\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"visit\",{\"1\":{\"913\":1}}],[\"visitor\",{\"1\":{\"3\":1}}],[\"visualizer\",{\"1\":{\"861\":1}}],[\"viewname\",{\"1\":{\"956\":1}}],[\"viewresolver\",{\"1\":{\"950\":1,\"956\":8}}],[\"viewport\",{\"1\":{\"832\":1}}],[\"viewclass\",{\"1\":{\"819\":1}}],[\"view\",{\"1\":{\"819\":2,\"950\":3,\"956\":10}}],[\"video\",{\"1\":{\"134\":1,\"251\":1,\"860\":1,\"878\":1,\"1439\":1}}],[\"video的就是\",{\"1\":{\"134\":1}}],[\"vim编辑器\",{\"1\":{\"918\":1}}],[\"vim\",{\"1\":{\"125\":1,\"403\":1,\"852\":1}}],[\"virtual\",{\"1\":{\"106\":1}}],[\"variable\",{\"1\":{\"944\":1,\"1101\":4,\"1299\":4}}],[\"var\",{\"1\":{\"852\":1}}],[\"varchar\",{\"0\":{\"539\":1},\"1\":{\"501\":2,\"505\":2,\"507\":1,\"577\":1,\"726\":2,\"736\":3,\"792\":1,\"795\":3,\"824\":1,\"1444\":2}}],[\"vary\",{\"1\":{\"106\":1}}],[\"valdestructor\",{\"1\":{\"624\":1}}],[\"valdup\",{\"1\":{\"624\":1}}],[\"val\",{\"1\":{\"337\":4,\"624\":1}}],[\"validate\",{\"1\":{\"648\":1,\"713\":1}}],[\"valid\",{\"1\":{\"106\":3}}],[\"valueof\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"value3\",{\"1\":{\"982\":1}}],[\"value又是什么作用\",{\"1\":{\"960\":1}}],[\"value呢\",{\"1\":{\"960\":1}}],[\"value>\",{\"1\":{\"820\":1}}],[\"value>classpath\",{\"1\":{\"820\":1}}],[\"value=\",{\"1\":{\"743\":12,\"745\":4,\"766\":6,\"767\":1,\"770\":1,\"790\":2,\"815\":14,\"817\":3,\"819\":4,\"958\":1,\"1219\":6,\"1396\":6}}],[\"value2\",{\"1\":{\"604\":2,\"605\":1,\"982\":1}}],[\"value存储的不足\",{\"1\":{\"589\":1}}],[\"value数据库\",{\"1\":{\"589\":2}}],[\"value1\",{\"1\":{\"559\":1,\"579\":1,\"604\":2,\"605\":1,\"982\":1}}],[\"values\",{\"1\":{\"440\":2,\"526\":1,\"559\":1,\"577\":1,\"726\":1,\"736\":2,\"755\":1,\"763\":1,\"795\":5,\"824\":4,\"827\":1,\"829\":1,\"1444\":5}}],[\"value\",{\"0\":{\"434\":1},\"1\":{\"106\":1,\"112\":1,\"352\":10,\"377\":3,\"434\":4,\"440\":2,\"555\":1,\"571\":3,\"573\":2,\"578\":1,\"589\":2,\"592\":2,\"603\":2,\"604\":8,\"605\":5,\"615\":1,\"621\":1,\"653\":1,\"654\":1,\"664\":1,\"688\":1,\"763\":1,\"779\":1,\"831\":4,\"832\":1,\"876\":2,\"922\":7,\"924\":12,\"928\":11,\"944\":1,\"948\":2,\"960\":7,\"970\":4,\"984\":2,\"988\":1,\"990\":3,\"1018\":1,\"1044\":2,\"1049\":3,\"1085\":3,\"1116\":3,\"1175\":1,\"1176\":1,\"1198\":1,\"1206\":1,\"1253\":2,\"1258\":3,\"1286\":3,\"1311\":3,\"1360\":1,\"1361\":1,\"1378\":1,\"1386\":1}}],[\"vue\",{\"1\":{\"46\":2,\"1062\":1,\"1268\":1}}],[\"vuepress\",{\"0\":{\"30\":1},\"1\":{\"26\":2,\"28\":2,\"29\":1,\"30\":2,\"31\":1,\"45\":1}}],[\"展示如何增加\",{\"1\":{\"982\":1}}],[\"展示如何增加分区数\",{\"1\":{\"982\":1}}],[\"展示如何使用批量发送消息\",{\"1\":{\"982\":1}}],[\"展示如何调整\",{\"1\":{\"982\":1}}],[\"展示\",{\"0\":{\"26\":1}}],[\"中名字为\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"中都包含一个\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"中原本就有的\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"中会用到它\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"中执行增强逻辑\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"中用悲观锁务必要确定走了索引\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"中用于多线程编程的工具类\",{\"1\":{\"932\":1}}],[\"中查询\",{\"1\":{\"1188\":1,\"1371\":1}}],[\"中查询时传入的参数对象为\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"中继日志也是二进制日志\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"中继日志\",{\"1\":{\"1185\":2,\"1368\":2}}],[\"中任意定义接口\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"中加载\",{\"1\":{\"1179\":1,\"1364\":1}}],[\"中恢复元数据时每个\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"中读取每一个\",{\"1\":{\"1166\":1,\"1354\":1}}],[\"中只有leader\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"中同步数据\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"中断正常执行的逻辑\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"中实现的\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"中指定一组键值对\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"中存储对应的\",{\"1\":{\"1047\":1,\"1256\":1}}],[\"中有哪些状态码\",{\"1\":{\"1027\":1}}],[\"中有哪些锁\",{\"0\":{\"554\":1}}],[\"中与\",{\"1\":{\"1023\":2}}],[\"中内置的同步机制\",{\"1\":{\"1022\":1}}],[\"中多次调用同一个\",{\"1\":{\"958\":1}}],[\"中非常重要的一个组件\",{\"1\":{\"958\":1}}],[\"中对应的占位符\",{\"1\":{\"958\":1}}],[\"中对应字段的\",{\"1\":{\"443\":1}}],[\"中提供的一种更加灵活的同步机制\",{\"1\":{\"1022\":1}}],[\"中提供\",{\"1\":{\"954\":1}}],[\"中提到的已排序集合\",{\"1\":{\"351\":1}}],[\"中配置\",{\"1\":{\"952\":2}}],[\"中配置了\",{\"1\":{\"952\":1}}],[\"中配置的属性值注入到\",{\"1\":{\"952\":1}}],[\"中配置接口的全路径\",{\"1\":{\"762\":1}}],[\"中通过\",{\"1\":{\"844\":1}}],[\"中通过class路径\",{\"1\":{\"772\":1}}],[\"中填写的是方法的参数\",{\"1\":{\"827\":1}}],[\"中去关闭二级缓存\",{\"1\":{\"790\":1}}],[\"中央仓库的地址\",{\"1\":{\"705\":1}}],[\"中央仓库\",{\"1\":{\"705\":2}}],[\"中默认的用户库\",{\"1\":{\"701\":1}}],[\"中取值\",{\"1\":{\"692\":1}}],[\"中获取目标对象完成依赖注入\",{\"1\":{\"954\":1}}],[\"中获取已经提前实例化的对象\",{\"1\":{\"954\":1}}],[\"中获取\",{\"1\":{\"692\":1}}],[\"中叫做\",{\"1\":{\"658\":1}}],[\"中启用了此方法\",{\"1\":{\"648\":1}}],[\"中当我们创建一个键值对时\",{\"1\":{\"635\":1}}],[\"中没有其他应用\",{\"1\":{\"629\":1}}],[\"中一种典型且常用的数据构\",{\"1\":{\"621\":1}}],[\"中一种术语\",{\"1\":{\"429\":1}}],[\"中每个\",{\"1\":{\"605\":1}}],[\"中文意思是比较与交换\",{\"1\":{\"1018\":1}}],[\"中文基础知识\",{\"1\":{\"904\":1}}],[\"中文官网\",{\"1\":{\"587\":1}}],[\"中文参考文档\",{\"1\":{\"252\":1}}],[\"中包含元数据的特殊数据库\",{\"1\":{\"506\":1}}],[\"中最基本的索引类型\",{\"1\":{\"495\":1}}],[\"中日期可以为以下形式\",{\"1\":{\"445\":1}}],[\"中field定义选择\",{\"1\":{\"440\":1}}],[\"中建立\",{\"1\":{\"375\":1}}],[\"中6最大\",{\"1\":{\"364\":1}}],[\"中9元素最大\",{\"1\":{\"364\":1}}],[\"中\",{\"0\":{\"1104\":1,\"1106\":1,\"1302\":1,\"1304\":1},\"1\":{\"270\":1,\"342\":1,\"371\":1,\"375\":1,\"387\":2,\"605\":2,\"606\":3,\"607\":2,\"635\":1,\"648\":1,\"654\":1,\"659\":1,\"688\":2,\"706\":1,\"917\":1,\"924\":1,\"950\":1,\"952\":1,\"954\":1,\"980\":1,\"1018\":1,\"1022\":4,\"1023\":1,\"1043\":1,\"1048\":2,\"1050\":2,\"1059\":1,\"1071\":1,\"1252\":1,\"1257\":2,\"1259\":2,\"1265\":1,\"1275\":1}}],[\"中增加\",{\"1\":{\"125\":1}}],[\"中创建仪表板\",{\"1\":{\"109\":1}}],[\"中使用\",{\"1\":{\"46\":1}}],[\"中的代理过滤器实现\",{\"1\":{\"1233\":1,\"1408\":1}}],[\"中的starter到底是什么\",{\"0\":{\"1232\":1,\"1407\":1}}],[\"中的监视器是什么\",{\"0\":{\"1231\":1,\"1406\":1}}],[\"中的所有\",{\"1\":{\"1178\":1,\"1363\":1}}],[\"中的所有副本都成功写入消息后才能收到服务端的响应\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"中的对象为\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"中的数据行的行锁\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"中的数据又是按照一个一个的\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"中的数据写入到磁盘中时\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"中的副本才有资格晋升为\",{\"1\":{\"1160\":1,\"1348\":1}}],[\"中的文档是不可变的\",{\"1\":{\"1076\":1,\"1280\":1}}],[\"中的节点\",{\"0\":{\"1074\":1,\"1278\":1}}],[\"中的指令自动构建镜像\",{\"1\":{\"1059\":1,\"1265\":1}}],[\"中的指定字段的浮点数值加上增量\",{\"1\":{\"605\":1}}],[\"中的指定字段的整数值加上增量\",{\"1\":{\"605\":1}}],[\"中的一个关键字\",{\"1\":{\"1022\":1}}],[\"中的一个概念\",{\"1\":{\"624\":1}}],[\"中的某个方法名\",{\"1\":{\"952\":2}}],[\"中的信息实例化\",{\"1\":{\"952\":1}}],[\"中的独占模式来实现线程的等待和唤醒\",{\"1\":{\"932\":1}}],[\"中的共享模式来实现线程的等待和唤醒\",{\"1\":{\"932\":1}}],[\"中的类\",{\"1\":{\"928\":1}}],[\"中的名称空间是类的接口的全路径\",{\"1\":{\"772\":1}}],[\"中的内容\",{\"1\":{\"724\":1}}],[\"中的clean就是上面的clean\",{\"1\":{\"712\":1}}],[\"中的字典使用哈希表作为底层实现\",{\"1\":{\"626\":1}}],[\"中的字典由\",{\"1\":{\"624\":1}}],[\"中的字段\",{\"1\":{\"605\":1}}],[\"中的字段类型\",{\"1\":{\"441\":1}}],[\"中的锁升级是什么\",{\"0\":{\"574\":1}}],[\"中的倒排索引到内存中\",{\"1\":{\"440\":1}}],[\"中的待排序集合是同一个集合\",{\"1\":{\"351\":1}}],[\"中的第一个\",{\"1\":{\"43\":1}}],[\"中的\",{\"1\":{\"30\":1,\"654\":1,\"656\":1,\"827\":1,\"924\":3,\"932\":2,\"956\":1,\"1016\":1,\"1022\":1,\"1167\":1,\"1355\":1}}],[\"中很重要的一个概念\",{\"1\":{\"28\":1}}],[\"中自定义它们\",{\"1\":{\"23\":1}}],[\"中设置一个参数时\",{\"1\":{\"769\":1}}],[\"中设置了\",{\"1\":{\"692\":1}}],[\"中设置了vt\",{\"1\":{\"692\":1}}],[\"中设置页面信息\",{\"1\":{\"44\":1}}],[\"中设置页面标题\",{\"1\":{\"43\":1}}],[\"中设置\",{\"1\":{\"6\":1}}],[\"夜间模式按钮\",{\"1\":{\"23\":1}}],[\"主缓存更新时需要同步更新备份缓存\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"主缓存失效后从数据库加载最新值\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"主缓存\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"主\",{\"0\":{\"1176\":1,\"1361\":1},\"1\":{\"1186\":1,\"1369\":1}}],[\"主副本\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"主shard或副本shard\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"主节点负责协调整个集群的工作\",{\"1\":{\"1004\":1}}],[\"主节点负责处理写操作\",{\"1\":{\"968\":1}}],[\"主服务器将\",{\"1\":{\"964\":1}}],[\"主服务器接收到\",{\"1\":{\"964\":1}}],[\"主服务器继续接收写命令\",{\"1\":{\"964\":1}}],[\"主服务器执行\",{\"1\":{\"964\":1}}],[\"主服务器的数据可以在从服务器中备份\",{\"1\":{\"964\":1}}],[\"主服务器处理写请求\",{\"1\":{\"964\":1}}],[\"主进程加载新aof\",{\"1\":{\"962\":1}}],[\"主进程fork一个子进程\",{\"1\":{\"962\":1}}],[\"主进程仍然处理客户端请求\",{\"1\":{\"962\":1}}],[\"主内存\",{\"1\":{\"692\":4}}],[\"主线程将\",{\"1\":{\"692\":1}}],[\"主线程结束\",{\"1\":{\"692\":1}}],[\"主线程暂停2秒结束以后将\",{\"1\":{\"692\":1}}],[\"主从之间同步分为全量或增量\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"主从部署\",{\"1\":{\"1205\":2,\"1385\":2}}],[\"主从复制\",{\"1\":{\"968\":1}}],[\"主从复制得以顺利进行\",{\"1\":{\"964\":1}}],[\"主从复制的同步实现\",{\"1\":{\"964\":1}}],[\"主从复制的同步工作是在\",{\"1\":{\"964\":1}}],[\"主从复制的同步工作是如何实现的\",{\"1\":{\"964\":1}}],[\"主从复制的工作流程如下\",{\"1\":{\"964\":1}}],[\"主从复制的工作流程是怎样的\",{\"1\":{\"964\":1}}],[\"主从服务器保持数据一致\",{\"1\":{\"964\":1}}],[\"主从架构就是将一台\",{\"1\":{\"964\":1}}],[\"主从\",{\"1\":{\"589\":1}}],[\"主键id\",{\"1\":{\"1444\":1}}],[\"主键冲突\",{\"1\":{\"827\":1}}],[\"主键对应的pojo属性名\",{\"1\":{\"763\":1,\"776\":1}}],[\"主键可以被其他表作为外键\",{\"1\":{\"496\":1}}],[\"主键索引不可以\",{\"1\":{\"496\":1}}],[\"主键索引和唯一索引有什么区别\",{\"0\":{\"496\":1}}],[\"主键索引是一种特殊的唯一索引\",{\"1\":{\"495\":1}}],[\"主键索引\",{\"1\":{\"495\":1,\"1189\":1,\"1372\":1}}],[\"主主数据库同步\",{\"1\":{\"383\":1}}],[\"主存和磁盘以页为单位交换数据\",{\"1\":{\"274\":1}}],[\"主存存取的时间仅与存取次数呈线性关系\",{\"1\":{\"273\":1}}],[\"主存存取原理\",{\"0\":{\"273\":1}}],[\"主存读取两个总线的内容\",{\"1\":{\"273\":1}}],[\"主存读到地址信号后\",{\"1\":{\"273\":1}}],[\"主存的存取过程如下\",{\"1\":{\"273\":1}}],[\"主存是一系列的存储单元组成的矩阵\",{\"1\":{\"273\":1}}],[\"主页\",{\"1\":{\"209\":1}}],[\"主体是一个select\",{\"1\":{\"141\":1}}],[\"主题\",{\"1\":{\"986\":1}}],[\"主题扩展了更多\",{\"1\":{\"31\":1}}],[\"主题扩展\",{\"0\":{\"31\":1}}],[\"主题也带有以下元素\",{\"1\":{\"23\":1}}],[\"主要创建了配置环境\",{\"1\":{\"1230\":1,\"1405\":1}}],[\"主要功能体现于三点\",{\"1\":{\"1158\":1,\"1346\":1}}],[\"主要功能与配置演示\",{\"0\":{\"18\":1}}],[\"主要分为以下几个阶段\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"主要是用来做web开发\",{\"1\":{\"1229\":1,\"1404\":1}}],[\"主要是通过二级缓存和三级缓存来解决的\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"主要是设置注解的生命周期\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"主要是当字段遇到\",{\"1\":{\"434\":1}}],[\"主要指的是\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"主要区别在于泛型类的类型参数可以用在整个类的方法和属性上\",{\"1\":{\"966\":1}}],[\"主要的工作流程是\",{\"1\":{\"964\":1}}],[\"主要的源码在rewriteappendonlyfile方法中\",{\"1\":{\"962\":1}}],[\"主要有两种情况\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"主要有两个\",{\"1\":{\"936\":1}}],[\"主要有以下几种方式可以避免\",{\"1\":{\"954\":1}}],[\"主要有三种场景\",{\"1\":{\"954\":1}}],[\"主要通过\",{\"1\":{\"950\":1,\"954\":1}}],[\"主要流程是\",{\"1\":{\"950\":1}}],[\"主要工作流程是\",{\"1\":{\"950\":1}}],[\"主要包括\",{\"1\":{\"948\":1}}],[\"主要为了第2步做准备\",{\"1\":{\"936\":1}}],[\"主要为了裂变\",{\"1\":{\"483\":1}}],[\"主要以场景化的方式\",{\"1\":{\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"934\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1023\":1}}],[\"主要已通过和\",{\"1\":{\"919\":1}}],[\"主要服务于基于java平台的项目构建\",{\"1\":{\"699\":1}}],[\"主要内容有\",{\"1\":{\"613\":1}}],[\"主要用来创建ioc容器\",{\"1\":{\"1229\":1,\"1404\":1}}],[\"主要用来做\",{\"1\":{\"1033\":1}}],[\"主要用来做父子查询\",{\"1\":{\"457\":1}}],[\"主要用于实现非阻塞算法\",{\"1\":{\"1018\":1}}],[\"主要用于暂停线程指定时间\",{\"1\":{\"988\":1}}],[\"主要用于存放类信息\",{\"1\":{\"930\":1}}],[\"主要用于业务解耦\",{\"1\":{\"594\":1}}],[\"主要对创建索引和搜索做讲解\",{\"1\":{\"460\":1}}],[\"主要参数\",{\"1\":{\"127\":1}}],[\"主要从\",{\"1\":{\"26\":1}}],[\"t4njraxo75r1e4jlevo\",{\"1\":{\"1444\":1}}],[\"t3\",{\"0\":{\"1107\":1,\"1305\":1},\"1\":{\"1107\":1,\"1305\":1}}],[\"tls\",{\"1\":{\"1032\":1}}],[\"t可以替换为任何类型\",{\"1\":{\"966\":1}}],[\"t>\",{\"1\":{\"966\":4}}],[\"t>表示从t类型到其子类型之间的某种类型\",{\"1\":{\"966\":1}}],[\"t>分别代表什么含义\",{\"1\":{\"966\":1}}],[\"t2\",{\"0\":{\"1107\":1,\"1305\":1},\"1\":{\"934\":1,\"1107\":1,\"1305\":1}}],[\"tx\",{\"1\":{\"818\":4}}],[\"tx=\",{\"1\":{\"818\":1}}],[\"tx<\",{\"1\":{\"812\":1}}],[\"txt\",{\"1\":{\"94\":4,\"159\":1,\"385\":1}}],[\"t1\",{\"0\":{\"1107\":1,\"1305\":1},\"1\":{\"801\":3,\"934\":1,\"1107\":1,\"1305\":1}}],[\"ttime\",{\"1\":{\"800\":2,\"801\":2}}],[\"ttl\",{\"1\":{\"603\":2,\"1238\":9,\"1411\":9}}],[\"tb\",{\"1\":{\"736\":4,\"737\":1,\"744\":2,\"755\":7,\"759\":1,\"763\":7,\"772\":1,\"779\":5,\"780\":2,\"782\":4,\"784\":1,\"785\":1,\"786\":2,\"787\":1,\"789\":6,\"790\":1,\"792\":1,\"793\":4,\"794\":3,\"795\":12}}],[\"tm\",{\"1\":{\"692\":2}}],[\"tmpfile\",{\"1\":{\"962\":4}}],[\"tmp\",{\"1\":{\"352\":3}}],[\"t整数\",{\"1\":{\"624\":2}}],[\"tporadowski\",{\"1\":{\"597\":1}}],[\"tuser\",{\"1\":{\"755\":11,\"759\":11}}],[\"ture\",{\"1\":{\"440\":1}}],[\"tuna\",{\"1\":{\"157\":1}}],[\"tgz\",{\"1\":{\"408\":2}}],[\"twepoch\",{\"1\":{\"388\":2}}],[\"twitter\",{\"1\":{\"386\":2,\"388\":1}}],[\"tsinghua\",{\"1\":{\"157\":1}}],[\"ts\",{\"1\":{\"131\":1}}],[\"trim>\",{\"1\":{\"724\":2,\"727\":3,\"755\":1,\"763\":1,\"786\":1}}],[\"trim\",{\"1\":{\"604\":1,\"724\":1,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"876\":1,\"1177\":1,\"1362\":1}}],[\"truncate都表示删除\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"truncate\",{\"0\":{\"543\":1},\"1\":{\"541\":1,\"1190\":2,\"1373\":2}}],[\"true\",{\"1\":{\"6\":2,\"145\":1,\"284\":1,\"288\":5,\"289\":2,\"337\":4,\"406\":5,\"431\":2,\"432\":1,\"436\":1,\"439\":1,\"440\":1,\"446\":1,\"487\":1,\"488\":2,\"648\":2,\"692\":8,\"763\":2,\"767\":1,\"790\":1,\"793\":2,\"794\":3,\"795\":4,\"797\":2,\"817\":4,\"820\":1,\"821\":1,\"829\":1,\"831\":1,\"864\":3,\"865\":1,\"876\":1,\"885\":3,\"924\":3,\"932\":2,\"946\":1,\"970\":2,\"984\":1,\"988\":1,\"1008\":1,\"1020\":1,\"1044\":2,\"1070\":1,\"1084\":1,\"1085\":1,\"1092\":2,\"1105\":2,\"1176\":2,\"1238\":1,\"1253\":2,\"1274\":1,\"1285\":1,\"1286\":1,\"1293\":2,\"1303\":2,\"1361\":2,\"1411\":1,\"1431\":2}}],[\"translog\",{\"1\":{\"1071\":6,\"1275\":6}}],[\"transient\",{\"1\":{\"946\":1,\"988\":2}}],[\"transactiontemplate\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"transactional注解的方式\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"transactional\",{\"1\":{\"830\":2}}],[\"transactionmanager\",{\"1\":{\"818\":2}}],[\"transactions\",{\"1\":{\"601\":1}}],[\"transaction\",{\"1\":{\"555\":1,\"556\":2,\"558\":2,\"559\":1,\"571\":1,\"573\":2,\"789\":3,\"790\":2,\"818\":2,\"830\":1}}],[\"transfer\",{\"1\":{\"487\":2,\"488\":2,\"824\":1}}],[\"transport\",{\"1\":{\"406\":2}}],[\"trace\",{\"1\":{\"195\":2,\"201\":1}}],[\"traceid\",{\"1\":{\"192\":1}}],[\"trac\",{\"1\":{\"122\":1}}],[\"trylock\",{\"1\":{\"1105\":6,\"1303\":6}}],[\"tryrelease\",{\"1\":{\"932\":2}}],[\"tryacquire\",{\"1\":{\"932\":2}}],[\"try\",{\"1\":{\"196\":2,\"197\":1,\"285\":1,\"388\":1,\"614\":1,\"648\":3,\"689\":1,\"737\":1,\"747\":1,\"830\":1,\"831\":1,\"876\":2,\"932\":1,\"952\":2,\"988\":2,\"1023\":1,\"1092\":1,\"1104\":2,\"1105\":6,\"1107\":2,\"1293\":1,\"1302\":2,\"1303\":6,\"1305\":2,\"1431\":1}}],[\"treeset\",{\"1\":{\"1112\":1,\"1307\":1}}],[\"treemap<>\",{\"1\":{\"948\":1}}],[\"treemap<string\",{\"1\":{\"948\":1}}],[\"treemap\",{\"1\":{\"922\":1,\"948\":1,\"1112\":1,\"1307\":1}}],[\"treenode<k\",{\"1\":{\"922\":1}}],[\"treenode\",{\"1\":{\"922\":1}}],[\"treeifybin\",{\"1\":{\"922\":1}}],[\"treeify\",{\"1\":{\"922\":1}}],[\"tree索引适合范围查询和排序操作\",{\"1\":{\"510\":1}}],[\"tree\",{\"0\":{\"271\":1},\"1\":{\"152\":1,\"495\":1,\"681\":1,\"690\":1,\"856\":1}}],[\"typeparams\",{\"1\":{\"1010\":1}}],[\"typevariable<\",{\"1\":{\"1010\":1}}],[\"typelanguage=\",{\"1\":{\"865\":1}}],[\"type>\",{\"1\":{\"844\":1}}],[\"typehandlers\",{\"0\":{\"769\":1}}],[\"typealiasespackage\",{\"1\":{\"815\":1}}],[\"typealiases>\",{\"1\":{\"768\":2}}],[\"typealiases\",{\"0\":{\"768\":1}}],[\"type=datasource\",{\"1\":{\"884\":1}}],[\"type=\",{\"1\":{\"743\":4,\"745\":2,\"766\":1,\"768\":2,\"770\":1,\"793\":1,\"794\":1,\"795\":1,\"797\":1,\"865\":6}}],[\"typedef\",{\"1\":{\"621\":2,\"624\":4,\"628\":1,\"630\":1,\"635\":3}}],[\"type\",{\"0\":{\"419\":1},\"1\":{\"106\":1,\"419\":1,\"429\":3,\"432\":3,\"434\":3,\"436\":11,\"437\":2,\"440\":2,\"443\":1,\"456\":1,\"457\":1,\"506\":1,\"602\":1,\"603\":3,\"624\":1,\"635\":2,\"762\":1,\"768\":1,\"797\":1,\"821\":1,\"824\":1,\"944\":1,\"962\":2,\"998\":4,\"1002\":1,\"1010\":1,\"1444\":1}}],[\"types\",{\"1\":{\"106\":2,\"419\":1}}],[\"tinyint\",{\"1\":{\"536\":1,\"726\":2}}],[\"tilnextmillis\",{\"1\":{\"388\":2}}],[\"tirestay\",{\"1\":{\"251\":1}}],[\"ticktime\",{\"1\":{\"157\":1}}],[\"ticktime这个时间是作为zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔\",{\"1\":{\"157\":1}}],[\"tips\",{\"1\":{\"106\":1}}],[\"timeunit\",{\"1\":{\"1105\":3,\"1303\":3}}],[\"timed\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"timeseries\",{\"1\":{\"887\":1}}],[\"timestamp\",{\"1\":{\"388\":11,\"824\":3,\"998\":2,\"1191\":1,\"1374\":1}}],[\"timestampleftshift\",{\"1\":{\"388\":2}}],[\"time`\",{\"1\":{\"824\":3}}],[\"timegen\",{\"1\":{\"388\":4}}],[\"time\",{\"1\":{\"106\":1,\"603\":1,\"664\":1,\"689\":4,\"817\":2,\"827\":1,\"885\":1,\"942\":1,\"1156\":2,\"1238\":1,\"1344\":2,\"1411\":1,\"1431\":1}}],[\"timeout\",{\"1\":{\"106\":8,\"604\":3,\"648\":2,\"887\":1,\"970\":2}}],[\"title>\",{\"1\":{\"832\":1}}],[\"title1\",{\"1\":{\"727\":1}}],[\"title的值为new\",{\"1\":{\"727\":1}}],[\"title\",{\"1\":{\"43\":3,\"420\":1,\"507\":3,\"727\":7,\"958\":5,\"998\":2,\"1431\":1}}],[\"threshold\",{\"1\":{\"922\":3,\"928\":5,\"948\":1}}],[\"threadc\",{\"1\":{\"1107\":6,\"1305\":6}}],[\"threadnum\",{\"1\":{\"1104\":3,\"1302\":3}}],[\"threadb\",{\"1\":{\"1104\":3,\"1107\":13,\"1302\":3,\"1305\":13}}],[\"threada\",{\"1\":{\"1104\":3,\"1107\":11,\"1302\":3,\"1305\":11}}],[\"threadprimitivedeprecation\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"threadpoolexecutor\",{\"1\":{\"926\":2}}],[\"threads\",{\"1\":{\"932\":4,\"1101\":1,\"1299\":1}}],[\"thread2\",{\"1\":{\"928\":3,\"1105\":2,\"1303\":2}}],[\"thread1\",{\"1\":{\"928\":3,\"1105\":2,\"1303\":2}}],[\"threadlocal类\",{\"1\":{\"1103\":1,\"1301\":1}}],[\"threadlocal方式的线程通信\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"threadlocal方式\",{\"1\":{\"1102\":1,\"1300\":1}}],[\"threadlocalhashcode\",{\"1\":{\"928\":4}}],[\"threadlocalmap\",{\"1\":{\"928\":5,\"1103\":1,\"1301\":1}}],[\"threadlocal<\",{\"1\":{\"928\":6}}],[\"threadlocal<>\",{\"1\":{\"928\":1}}],[\"threadlocal<string>\",{\"1\":{\"928\":1}}],[\"threadlocaldemo\",{\"1\":{\"928\":1}}],[\"threadlocal\",{\"0\":{\"928\":1},\"1\":{\"928\":24,\"1103\":2,\"1301\":2}}],[\"threadfactory\",{\"1\":{\"926\":1}}],[\"threaddump\",{\"1\":{\"885\":1}}],[\"thread\",{\"1\":{\"692\":5,\"821\":1,\"876\":2,\"928\":4,\"930\":1,\"932\":5,\"1008\":1,\"1023\":5,\"1101\":7,\"1103\":1,\"1104\":28,\"1105\":2,\"1107\":7,\"1299\":7,\"1301\":1,\"1302\":28,\"1303\":2,\"1305\":7}}],[\"throwing\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"throwable\",{\"1\":{\"689\":2,\"770\":1,\"829\":3,\"958\":1,\"1016\":1,\"1092\":3,\"1293\":3}}],[\"throw\",{\"1\":{\"285\":3,\"286\":2,\"388\":3,\"830\":4,\"952\":2,\"1023\":2}}],[\"throwss\",{\"1\":{\"689\":1}}],[\"throws\",{\"1\":{\"285\":4,\"286\":2,\"352\":4,\"364\":2,\"689\":2,\"692\":2,\"737\":1,\"747\":1,\"757\":6,\"763\":1,\"770\":1,\"785\":1,\"786\":1,\"787\":1,\"793\":2,\"794\":1,\"795\":1,\"828\":5,\"830\":1,\"876\":2,\"932\":1,\"950\":2,\"956\":5,\"958\":1,\"1016\":1,\"1020\":2,\"1044\":1,\"1092\":4,\"1105\":1,\"1253\":1,\"1293\":4,\"1303\":1}}],[\"than\",{\"1\":{\"388\":4}}],[\"that\",{\"1\":{\"106\":1,\"112\":2,\"152\":1,\"526\":1,\"1085\":1,\"1101\":4,\"1286\":1,\"1299\":4}}],[\"this\",{\"1\":{\"106\":1,\"285\":1,\"286\":1,\"288\":10,\"289\":8,\"337\":1,\"388\":2,\"457\":2,\"487\":1,\"488\":1,\"747\":9,\"754\":6,\"757\":9,\"763\":8,\"770\":1,\"784\":1,\"785\":1,\"786\":2,\"787\":1,\"789\":6,\"790\":1,\"829\":9,\"830\":5,\"831\":1,\"887\":1,\"922\":1,\"924\":1,\"946\":3,\"950\":4,\"966\":2,\"1004\":2,\"1016\":1,\"1022\":2,\"1023\":1,\"1044\":1,\"1072\":1,\"1101\":3,\"1104\":3,\"1107\":2,\"1216\":6,\"1253\":1,\"1276\":1,\"1299\":3,\"1302\":3,\"1305\":2,\"1393\":6,\"1431\":6}}],[\"these\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"them\",{\"1\":{\"887\":1,\"936\":1}}],[\"then\",{\"1\":{\"724\":1,\"725\":2,\"727\":8,\"950\":1,\"1072\":1,\"1276\":1}}],[\"there\",{\"1\":{\"604\":2}}],[\"they\",{\"1\":{\"152\":1}}],[\"the\",{\"1\":{\"43\":1,\"106\":4,\"112\":1,\"152\":3,\"353\":1,\"411\":1,\"437\":2,\"504\":1,\"526\":2,\"762\":1,\"821\":1,\"887\":5,\"936\":1,\"938\":2,\"940\":1,\"950\":4,\"954\":2,\"964\":1,\"1101\":11,\"1150\":2,\"1216\":5,\"1299\":11,\"1341\":2,\"1393\":5}}],[\"tcp和udp的区别\",{\"0\":{\"1135\":1,\"1328\":1},\"1\":{\"1027\":1}}],[\"tcp\",{\"1\":{\"104\":3,\"106\":3,\"406\":1,\"1032\":1,\"1135\":3,\"1328\":3}}],[\"tformalexpression\",{\"1\":{\"865\":6}}],[\"tf\",{\"1\":{\"94\":2,\"425\":1,\"1069\":1,\"1273\":1}}],[\"technotes\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"tencentcdb\",{\"1\":{\"864\":1}}],[\"territory\",{\"1\":{\"589\":1}}],[\"terminated\",{\"1\":{\"926\":1,\"1100\":1,\"1298\":1}}],[\"term+偏移量\",{\"1\":{\"440\":1}}],[\"term+位置+偏移量\",{\"1\":{\"440\":1}}],[\"term+位置\",{\"1\":{\"440\":1}}],[\"term存储\",{\"1\":{\"440\":1}}],[\"term\",{\"1\":{\"433\":5,\"436\":2,\"440\":1,\"1069\":1,\"1273\":1}}],[\"test5\",{\"1\":{\"1444\":1}}],[\"test4\",{\"1\":{\"1444\":1}}],[\"test3\",{\"1\":{\"1444\":1}}],[\"test2\",{\"1\":{\"1444\":1}}],[\"test1\",{\"1\":{\"1107\":1,\"1305\":1,\"1444\":1}}],[\"test就是告诉测试运行器哪些是测试方法\",{\"1\":{\"944\":1}}],[\"testappoint\",{\"1\":{\"830\":1}}],[\"testinsertappointment\",{\"1\":{\"828\":1}}],[\"testinsertuser\",{\"1\":{\"763\":1}}],[\"testreducenumber\",{\"1\":{\"828\":1}}],[\"testquerybykeywithbook\",{\"1\":{\"828\":1}}],[\"testquerybyid\",{\"1\":{\"828\":2}}],[\"testqueryall\",{\"1\":{\"828\":1}}],[\"testqueryuserlist\",{\"1\":{\"784\":1}}],[\"testqueryuserall\",{\"1\":{\"763\":1}}],[\"testqueryuserbyid\",{\"1\":{\"763\":1,\"789\":3}}],[\"testqueryuserbytablename\",{\"1\":{\"763\":1}}],[\"test<\",{\"1\":{\"812\":1,\"844\":1}}],[\"testcache\",{\"1\":{\"790\":1}}],[\"test参考if\",{\"1\":{\"787\":1}}],[\"testognl表达式或者简单java代码\",{\"1\":{\"787\":1}}],[\"testdeleteuserbyid\",{\"1\":{\"763\":1}}],[\"testupdateuser\",{\"1\":{\"763\":1,\"786\":1}}],[\"testlogin\",{\"1\":{\"763\":1}}],[\"test=\",{\"1\":{\"724\":1,\"727\":2,\"755\":6,\"763\":6,\"784\":1,\"785\":2,\"786\":8,\"800\":2,\"958\":1}}],[\"test\",{\"1\":{\"360\":1,\"377\":1,\"432\":1,\"439\":3,\"648\":2,\"705\":3,\"706\":1,\"713\":10,\"725\":1,\"726\":2,\"743\":2,\"745\":2,\"747\":1,\"756\":1,\"757\":6,\"762\":1,\"763\":8,\"784\":1,\"785\":1,\"786\":2,\"787\":1,\"789\":3,\"790\":1,\"793\":2,\"794\":1,\"795\":1,\"800\":2,\"812\":1,\"828\":10,\"830\":2,\"831\":3,\"832\":6,\"854\":2,\"855\":2,\"934\":12,\"1044\":1,\"1104\":3,\"1105\":1,\"1107\":1,\"1253\":1,\"1302\":3,\"1303\":1,\"1305\":1,\"1444\":7}}],[\"testname\",{\"1\":{\"94\":1}}],[\"templates\",{\"1\":{\"876\":2}}],[\"temp\",{\"1\":{\"106\":3,\"364\":2,\"377\":3,\"913\":4}}],[\"text\",{\"1\":{\"183\":2,\"432\":3,\"433\":1,\"434\":2,\"436\":5,\"437\":7,\"439\":5,\"440\":1,\"443\":5,\"457\":2,\"495\":1,\"507\":1,\"747\":1,\"819\":1,\"832\":1,\"998\":2}}],[\"textjson\",{\"1\":{\"94\":3}}],[\"tex\",{\"0\":{\"35\":1}}],[\"t\",{\"0\":{\"540\":1},\"1\":{\"94\":5,\"129\":2,\"140\":2,\"141\":1,\"212\":1,\"288\":6,\"289\":4,\"388\":2,\"501\":3,\"526\":2,\"528\":3,\"529\":2,\"530\":2,\"531\":2,\"532\":2,\"577\":2,\"624\":2,\"630\":6,\"830\":2,\"854\":1,\"934\":1,\"964\":1,\"966\":14,\"1023\":19,\"1044\":2,\"1090\":2,\"1181\":2,\"1253\":2,\"1291\":2,\"1366\":2,\"1431\":2}}],[\"tair\",{\"1\":{\"1045\":1,\"1254\":1}}],[\"tail=100\",{\"1\":{\"856\":1}}],[\"tail\",{\"1\":{\"90\":1,\"94\":2,\"621\":1}}],[\"ta来了\",{\"1\":{\"917\":1}}],[\"taskthread\",{\"1\":{\"1104\":3,\"1302\":3}}],[\"taskid=2507\",{\"1\":{\"866\":1}}],[\"task\",{\"1\":{\"866\":1,\"1244\":3,\"1417\":3}}],[\"tasklistener>\",{\"1\":{\"865\":2}}],[\"tasklistener\",{\"1\":{\"865\":2}}],[\"taskuser\",{\"1\":{\"865\":1}}],[\"tab\",{\"1\":{\"922\":1,\"928\":12}}],[\"table结果筛选回收区域\",{\"1\":{\"940\":1}}],[\"tablename\",{\"1\":{\"724\":1,\"763\":4,\"779\":8}}],[\"table2\",{\"1\":{\"572\":1}}],[\"table1\",{\"1\":{\"572\":1}}],[\"tables进行优化\",{\"1\":{\"940\":1}}],[\"tables进行概括性标记\",{\"1\":{\"940\":1}}],[\"tables外\",{\"1\":{\"940\":1}}],[\"tables实现了分代回收和空间整合\",{\"1\":{\"940\":1}}],[\"tables是g1高效率回收的关键\",{\"1\":{\"940\":1}}],[\"tables都是g1用来管理堆和处理垃圾回收的重要数据结构\",{\"1\":{\"940\":1}}],[\"tables语句来显式地锁定一个或多个表\",{\"1\":{\"572\":1}}],[\"tables语句显式地对表加锁和解锁\",{\"1\":{\"565\":1}}],[\"tables和unlock\",{\"1\":{\"565\":1}}],[\"tables\",{\"1\":{\"506\":1,\"511\":3,\"561\":2,\"572\":3,\"940\":4}}],[\"table\",{\"0\":{\"542\":2,\"543\":2,\"565\":1},\"1\":{\"504\":1,\"505\":1,\"506\":6,\"507\":3,\"511\":15,\"541\":3,\"542\":5,\"555\":2,\"556\":2,\"558\":2,\"559\":1,\"561\":2,\"571\":1,\"572\":2,\"573\":4,\"574\":1,\"577\":1,\"578\":1,\"579\":1,\"624\":1,\"726\":1,\"736\":2,\"792\":1,\"795\":3,\"817\":1,\"824\":6,\"922\":4,\"928\":13,\"948\":3,\"988\":1,\"1444\":1}}],[\"tabulation\",{\"1\":{\"374\":1}}],[\"tag\",{\"1\":{\"412\":1,\"1062\":1,\"1268\":1}}],[\"target表示这个注解可以修饰那些地方\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"target有\",{\"1\":{\"944\":1}}],[\"target定义可以用于什么地方\",{\"1\":{\"944\":1}}],[\"targets\",{\"1\":{\"887\":2}}],[\"targetref=\",{\"1\":{\"865\":8}}],[\"targetnamespace=\",{\"1\":{\"865\":1}}],[\"target>\",{\"1\":{\"812\":1,\"844\":1}}],[\"target\",{\"1\":{\"284\":2,\"285\":3,\"286\":3,\"688\":1,\"770\":2,\"824\":2,\"944\":2,\"954\":1,\"1016\":9,\"1092\":4,\"1101\":3,\"1217\":2,\"1293\":4,\"1299\":3,\"1394\":2}}],[\"tar\",{\"1\":{\"90\":1,\"94\":5,\"125\":3,\"157\":3,\"405\":3,\"408\":1,\"598\":3,\"672\":2}}],[\"tolerance\",{\"1\":{\"1078\":2,\"1240\":1,\"1282\":1,\"1413\":1}}],[\"tolerate\",{\"1\":{\"112\":1}}],[\"tool用\",{\"1\":{\"944\":1}}],[\"tosting\",{\"1\":{\"825\":2}}],[\"tostring方法等\",{\"1\":{\"1086\":1,\"1287\":1}}],[\"tostring方法\",{\"1\":{\"825\":2,\"829\":1}}],[\"tostring\",{\"1\":{\"195\":1,\"352\":1,\"360\":1,\"364\":1,\"377\":1,\"385\":1,\"689\":1,\"825\":4,\"876\":1,\"1008\":1,\"1092\":1,\"1293\":1}}],[\"tomat\",{\"1\":{\"1225\":1,\"1400\":1}}],[\"tom\",{\"1\":{\"723\":1,\"726\":1}}],[\"tomcat\",{\"1\":{\"94\":1,\"832\":1,\"1033\":1,\"1136\":1,\"1329\":1}}],[\"token\",{\"1\":{\"594\":1,\"1137\":1,\"1330\":1}}],[\"tokens\",{\"1\":{\"487\":1,\"488\":1}}],[\"to的目标字段不出现在\",{\"1\":{\"436\":1}}],[\"to将字段数值拷贝到目标字段\",{\"1\":{\"436\":1}}],[\"to所代替\",{\"1\":{\"436\":1}}],[\"toarray\",{\"1\":{\"284\":1,\"285\":2,\"286\":2}}],[\"totalprice\",{\"1\":{\"794\":1,\"795\":1}}],[\"totalsupply\",{\"1\":{\"487\":7,\"488\":7}}],[\"totalclaimed\",{\"1\":{\"487\":5,\"488\":5}}],[\"total\",{\"1\":{\"159\":1,\"648\":2,\"789\":5,\"790\":1,\"795\":1}}],[\"to\",{\"0\":{\"436\":1},\"1\":{\"106\":4,\"112\":2,\"152\":7,\"157\":2,\"388\":1,\"436\":5,\"440\":1,\"504\":1,\"602\":1,\"762\":1,\"790\":1,\"800\":2,\"801\":2,\"887\":7,\"940\":2,\"950\":1,\"954\":2,\"964\":1,\"1023\":1,\"1073\":1,\"1085\":2,\"1101\":5,\"1216\":2,\"1238\":1,\"1277\":1,\"1286\":2,\"1299\":5,\"1393\":2,\"1411\":1}}],[\"todo\",{\"0\":{\"104\":1,\"172\":1,\"1014\":1},\"1\":{\"172\":1,\"232\":1,\"238\":1,\"251\":1,\"664\":1}}],[\"topic分\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"topic的主题中\",{\"1\":{\"990\":1}}],[\"topic是消息的类别\",{\"1\":{\"986\":1}}],[\"topicpartition\",{\"1\":{\"984\":1}}],[\"topic\",{\"1\":{\"980\":1,\"982\":5,\"984\":1,\"986\":1,\"990\":4,\"1159\":5,\"1167\":1,\"1347\":5,\"1355\":1}}],[\"topkfrequent\",{\"1\":{\"353\":1}}],[\"top\",{\"1\":{\"90\":2,\"282\":1,\"353\":1,\"1023\":2}}],[\"touch\",{\"1\":{\"90\":1,\"91\":2}}],[\"tocodepoints\",{\"1\":{\"388\":2}}],[\"toc\",{\"1\":{\"23\":1,\"76\":1,\"108\":1,\"120\":1,\"149\":1,\"261\":1,\"277\":1,\"328\":1,\"346\":1,\"356\":1,\"368\":1,\"380\":1,\"394\":1,\"397\":1,\"428\":1,\"460\":1,\"481\":1,\"515\":1,\"525\":1,\"586\":1,\"612\":1,\"640\":1,\"681\":1,\"698\":1,\"722\":1,\"731\":1,\"807\":1,\"847\":1,\"859\":1,\"871\":1,\"881\":1,\"895\":1,\"914\":1,\"1026\":1,\"1030\":1,\"1041\":1,\"1056\":1,\"1067\":1,\"1083\":1,\"1097\":1,\"1111\":1,\"1126\":1,\"1141\":1,\"1155\":1,\"1171\":1,\"1184\":1,\"1197\":1,\"1210\":1,\"1223\":1,\"1236\":1,\"1249\":1}}],[\"页签\",{\"1\":{\"913\":1}}],[\"页锁适用于需要较高并发的场景\",{\"1\":{\"567\":1}}],[\"页锁和表锁的冲突较少\",{\"1\":{\"567\":1}}],[\"页锁次之\",{\"1\":{\"567\":1}}],[\"页锁可以用于控制对表中特定数据页的访问\",{\"1\":{\"566\":1}}],[\"页锁可能导致较少的锁冲突\",{\"1\":{\"566\":1}}],[\"页锁允许多个事务同时访问不同的数据页\",{\"1\":{\"566\":1}}],[\"页锁允许多个事务同时访问不同的页\",{\"1\":{\"561\":1}}],[\"页锁通常由数据库管理系统自动管理\",{\"1\":{\"561\":1,\"566\":1}}],[\"页锁锁定的是数据页\",{\"1\":{\"561\":1}}],[\"页锁是锁定数据库中的一个数据页\",{\"1\":{\"566\":1}}],[\"页锁是锁定数据库中的一个\",{\"1\":{\"561\":1}}],[\"页锁\",{\"0\":{\"561\":1,\"566\":1},\"1\":{\"561\":2,\"567\":1}}],[\"页是数据库存储单位\",{\"1\":{\"516\":1}}],[\"页是计算机管理存储器的逻辑块\",{\"1\":{\"274\":1}}],[\"页的目录\",{\"1\":{\"500\":1}}],[\"页得大小通常为4k\",{\"1\":{\"274\":1}}],[\"页\",{\"1\":{\"272\":1,\"500\":1,\"561\":1,\"1072\":1,\"1276\":1}}],[\"页面锁有什么区别\",{\"0\":{\"563\":1}}],[\"页面都会被转换为一个\",{\"1\":{\"46\":1}}],[\"页面内容\",{\"0\":{\"45\":1}}],[\"页面标题\",{\"0\":{\"43\":1},\"1\":{\"43\":1}}],[\"页面配置\",{\"0\":{\"42\":1},\"1\":{\"44\":1},\"2\":{\"48\":1}}],[\"页面引入配置\",{\"1\":{\"28\":1}}],[\"页面信息\",{\"0\":{\"44\":1},\"1\":{\"20\":1}}],[\"页脚\",{\"1\":{\"20\":1,\"23\":1}}],[\"贡献者\",{\"1\":{\"20\":1,\"23\":1}}],[\"侧边栏\",{\"1\":{\"20\":1,\"23\":1}}],[\"你帮我安排一下\",{\"1\":{\"1439\":1}}],[\"你们redis使用哪种部署方式\",{\"0\":{\"1205\":1,\"1385\":1}}],[\"你们产品自己去协调去\",{\"1\":{\"153\":1}}],[\"你访问的资源需要登录\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"你正在访问sourcec资源\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"你正在访问sourceb资源\",{\"1\":{\"1092\":2,\"1293\":2}}],[\"你正在访问sourcea资源\",{\"1\":{\"1092\":2,\"1293\":2}}],[\"你是怎么使用的\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"你是怎么怎么使用的\",{\"1\":{\"76\":1}}],[\"你一定经常能见到类似这种写法\",{\"1\":{\"1090\":1,\"1291\":1}}],[\"你一定不陌生\",{\"1\":{\"559\":1}}],[\"你已进入候补名单\",{\"1\":{\"1023\":1}}],[\"你已经掌握了jvm调优的基础知识和日常工具\",{\"1\":{\"942\":1}}],[\"你已经运用了自己网站\",{\"1\":{\"912\":1}}],[\"你给我看这\",{\"1\":{\"1022\":1,\"1023\":1}}],[\"你给出的这些方法都很实用\",{\"1\":{\"982\":1}}],[\"你准备好聊一聊elasticsearch索引文档的底层过程了吗\",{\"1\":{\"1012\":1}}],[\"你不仅解释得很清楚\",{\"1\":{\"1004\":1}}],[\"你不知道是苹果还是香蕉\",{\"1\":{\"966\":1}}],[\"你刚刚创建了一个名为\",{\"1\":{\"998\":1}}],[\"你用代码很好地解释了kafka的工作原理\",{\"1\":{\"992\":1}}],[\"你用过\",{\"1\":{\"932\":1}}],[\"你真的写了一段kafka\",{\"1\":{\"986\":1}}],[\"你真是个elasticsearch小能手\",{\"1\":{\"998\":1}}],[\"你真是个天才\",{\"1\":{\"984\":1}}],[\"你真是一个有趣的候选人\",{\"1\":{\"926\":1}}],[\"你真是一个线程池的专家啊\",{\"1\":{\"926\":1}}],[\"你还有其他的建议吗\",{\"1\":{\"972\":1}}],[\"你都理解得非常透彻\",{\"1\":{\"964\":1}}],[\"你解释得很详细\",{\"1\":{\"964\":1}}],[\"你解释的很透彻\",{\"1\":{\"956\":1}}],[\"你通过详细的说明和示意图\",{\"1\":{\"956\":1}}],[\"你觉得kafka和传统消息系统相比\",{\"1\":{\"992\":1}}],[\"你觉得还可以在哪些方面加深对\",{\"1\":{\"952\":1}}],[\"你觉查询起来还会方便吗\",{\"1\":{\"500\":1}}],[\"你之前提到也有些不太理解的地方\",{\"1\":{\"948\":1}}],[\"你理解得比较透彻\",{\"1\":{\"948\":1}}],[\"你在哪些场景使用redis\",{\"0\":{\"1199\":1,\"1379\":1}}],[\"你在高并发系统设计方面有很强的理解力和丰富经验\",{\"1\":{\"950\":1}}],[\"你在list及相关接口的理解上一定会有大的提高\",{\"1\":{\"946\":1}}],[\"你在代码使用了那些设计模式\",{\"1\":{\"76\":1}}],[\"你先等一下\",{\"1\":{\"938\":1}}],[\"你这种围绕一个场景作解释的方式很形象\",{\"1\":{\"934\":1}}],[\"你这个朋友我知道是谁了\",{\"1\":{\"98\":1}}],[\"你会有什么疑惑或者过程\",{\"1\":{\"934\":1}}],[\"你会发现一切如此简单\",{\"1\":{\"121\":1}}],[\"你了解什么\",{\"1\":{\"1018\":1}}],[\"你了解java的类加载过程吗\",{\"1\":{\"934\":1}}],[\"你了解pomxml吗\",{\"0\":{\"844\":1}}],[\"你说的很详细\",{\"1\":{\"1018\":1}}],[\"你说的很具体\",{\"1\":{\"950\":1}}],[\"你说的很全面和深入\",{\"1\":{\"922\":1}}],[\"你说的真是五花八门\",{\"1\":{\"950\":1}}],[\"你说得很好\",{\"1\":{\"926\":1}}],[\"你说得不错\",{\"1\":{\"926\":1}}],[\"你好呀\",{\"1\":{\"1443\":1}}],[\"你好\",{\"1\":{\"926\":2,\"928\":1,\"930\":1,\"972\":1,\"1010\":1,\"1020\":1,\"1022\":1}}],[\"你回答的很好\",{\"1\":{\"924\":1}}],[\"你认为kafka有哪些缺点呢\",{\"1\":{\"978\":1}}],[\"你认为\",{\"1\":{\"924\":1}}],[\"你能够给我讲讲\",{\"1\":{\"1022\":2}}],[\"你能够准确定位自己尚未完全掌握的知识点\",{\"1\":{\"946\":1}}],[\"你能告诉我如何避免\",{\"1\":{\"1022\":1}}],[\"你能告诉我\",{\"1\":{\"1022\":4}}],[\"你能举个例子来说明\",{\"1\":{\"1022\":1}}],[\"你能详细解释一下选主的过程吗\",{\"1\":{\"1008\":1}}],[\"你能给我讲讲它的作用吗\",{\"1\":{\"1022\":1}}],[\"你能给我展示一下选主过程的源码示例吗\",{\"1\":{\"1008\":1}}],[\"你能给我举个例子来说明kafka的工作原理吗\",{\"1\":{\"992\":1}}],[\"你能给我举个例子来说明kafka的性能吗\",{\"1\":{\"980\":1}}],[\"你能给我一些指导吗\",{\"1\":{\"974\":1}}],[\"你能不能不那么书呆子\",{\"1\":{\"966\":1}}],[\"你能否简单介绍一下jvm内存模型的优化策略\",{\"1\":{\"930\":1}}],[\"你能否举一个例子来说明\",{\"1\":{\"924\":1}}],[\"你能具体说明一下\",{\"1\":{\"924\":1}}],[\"你能解释一下代码中的关键部分吗\",{\"1\":{\"990\":1}}],[\"你能解释一下\",{\"1\":{\"924\":1,\"1022\":1}}],[\"你也提出了很好的问题\",{\"1\":{\"922\":1}}],[\"你也可以创建并引入你自己的组件\",{\"1\":{\"46\":1}}],[\"你继续加深对各种设计模式的理解和运用\",{\"1\":{\"922\":1}}],[\"你的经验很丰富\",{\"1\":{\"1022\":1}}],[\"你的问题很棒\",{\"1\":{\"1008\":1}}],[\"你的源码示例非常清晰\",{\"1\":{\"1008\":1}}],[\"你的比喻真是越来越有意思了\",{\"1\":{\"976\":1}}],[\"你的解释让我受益匪浅\",{\"1\":{\"966\":1}}],[\"你的解释简直让人眼前一亮\",{\"1\":{\"966\":1}}],[\"你的解释很到位\",{\"1\":{\"950\":1}}],[\"你的java基础会更加牢固\",{\"1\":{\"948\":1}}],[\"你的理解已经趋于准确和清晰\",{\"1\":{\"940\":1}}],[\"你的理解和应用已经相当不错了\",{\"1\":{\"922\":1}}],[\"你的谢意我心领了\",{\"1\":{\"934\":1}}],[\"你的回答非常详细\",{\"1\":{\"984\":1}}],[\"你的回答非常出色\",{\"1\":{\"980\":1}}],[\"你的回答很全面\",{\"1\":{\"1023\":1}}],[\"你的回答很全面和到位\",{\"1\":{\"934\":1}}],[\"你的回答很详细\",{\"1\":{\"1022\":2}}],[\"你的回答很清晰\",{\"1\":{\"1022\":1}}],[\"你的回答很不错\",{\"1\":{\"1022\":1}}],[\"你的回答很棒\",{\"1\":{\"976\":1}}],[\"你的回答已经很全面和深入\",{\"1\":{\"952\":1}}],[\"你的回答真是太棒了\",{\"1\":{\"926\":1}}],[\"你的态度很好\",{\"1\":{\"922\":1}}],[\"你的项目已经可以打包\",{\"1\":{\"702\":1}}],[\"你对锁机制的理解已经深入到能够在实践中运用并解决遇到的问题的地步\",{\"1\":{\"1018\":1}}],[\"你对动态代理的了解很深入\",{\"1\":{\"1016\":1}}],[\"你对反射和动态代理的了解很深入\",{\"1\":{\"1016\":1}}],[\"你对elasticsearch集群架构\",{\"1\":{\"1004\":1}}],[\"你对elasticsearch的架构设计有很好的理解\",{\"1\":{\"1002\":1}}],[\"你对elasticsearch的理解非常透彻\",{\"1\":{\"998\":1}}],[\"你对elasticsearch和lucene的理解非常透彻\",{\"1\":{\"1000\":1}}],[\"你对elasticsearch和lucene的解释非常清晰\",{\"1\":{\"1000\":1}}],[\"你对elasticsearch有了解吗\",{\"1\":{\"998\":1}}],[\"你对kafka和传统消息系统的区别有很清晰的认识\",{\"1\":{\"992\":1}}],[\"你对kafka的push和pull模式的理解非常到位\",{\"1\":{\"990\":1}}],[\"你对kafka的push和pull模式有很好的理解\",{\"1\":{\"990\":1}}],[\"你对kafka的理解非常出色\",{\"1\":{\"992\":1}}],[\"你对kafka的理解真是深入透彻\",{\"1\":{\"984\":1}}],[\"你对kafka的理解很深入\",{\"1\":{\"976\":1}}],[\"你对kafka的理解很透彻\",{\"1\":{\"974\":1}}],[\"你对kafka的性能有了很好的理解\",{\"1\":{\"980\":1}}],[\"你对kafka的性能优化有什么建议吗\",{\"1\":{\"980\":1}}],[\"你对kafka的了解非常全面\",{\"1\":{\"974\":1}}],[\"你对kafka有了解吗\",{\"1\":{\"974\":1,\"976\":1,\"980\":1}}],[\"你对此有什么了解吗\",{\"1\":{\"972\":1}}],[\"你对分布式锁的理解非常全面\",{\"1\":{\"970\":1}}],[\"你对redis分布式锁的了解令人印象深刻\",{\"1\":{\"970\":1}}],[\"你对redis分片集群的理解非常全面\",{\"1\":{\"968\":1}}],[\"你对redis分片集群的理解非常透彻\",{\"1\":{\"968\":1}}],[\"你对这个概念了解多少呢\",{\"1\":{\"1006\":1}}],[\"你对这个话题有了解吗\",{\"1\":{\"1008\":1}}],[\"你对这个话题有什么了解吗\",{\"1\":{\"1002\":1}}],[\"你对这个话题了解多少\",{\"1\":{\"968\":1}}],[\"你对这些有了解吗\",{\"1\":{\"1004\":1}}],[\"你对这些知识已经有一定理解\",{\"1\":{\"946\":1}}],[\"你对这两个技术有了解吗\",{\"1\":{\"1000\":1}}],[\"你对它的理解很深入\",{\"1\":{\"958\":1}}],[\"你对它的理解已经相当深刻了\",{\"1\":{\"922\":1}}],[\"你对map及其实现类一定有比较深入的理解和认知\",{\"1\":{\"948\":1}}],[\"你对map有比较扎实的认知基础\",{\"1\":{\"948\":1}}],[\"你对list还有哪些不太理解的地方\",{\"1\":{\"946\":1}}],[\"你对g1的理解已经相当深入全面\",{\"1\":{\"940\":1}}],[\"你对cms收集器的理解已经相当透彻\",{\"1\":{\"938\":1}}],[\"你对类的生命周期及其与类初始化的关系理解很透彻\",{\"1\":{\"934\":1}}],[\"你对java类加载机制有很深入的理解\",{\"1\":{\"934\":1}}],[\"你对jvm内存模型的了解非常深入\",{\"1\":{\"930\":2}}],[\"你对\",{\"1\":{\"924\":1,\"928\":1,\"950\":1,\"952\":1,\"956\":1,\"958\":1,\"1010\":2,\"1022\":1}}],[\"你对自己的提高有清醒的认识\",{\"1\":{\"922\":1}}],[\"你快点处理一下\",{\"1\":{\"916\":1}}],[\"你可能需要安装\",{\"1\":{\"899\":1}}],[\"你可以通过用\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"20\":1}}],[\"你可以这样使用\",{\"1\":{\"1022\":2}}],[\"你可以将这些日志数据发送到一个主题\",{\"1\":{\"980\":1}}],[\"你可以将图片和\",{\"1\":{\"45\":1}}],[\"你可以找到各种有用的注释和解释\",{\"1\":{\"974\":1}}],[\"你可以把消息当作咖啡订单\",{\"1\":{\"974\":1}}],[\"你可以根据你的需求选择适合的方式\",{\"1\":{\"972\":1}}],[\"你可以使用一个引入来使bean实现\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"你可以使用\",{\"1\":{\"1022\":1}}],[\"你可以使用kafka来构建一个实时的数据管道\",{\"1\":{\"974\":1}}],[\"你可以使用相对于类路径的资源引用\",{\"1\":{\"772\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"26\":1}}],[\"你可以添加一个元素到列表的头部\",{\"1\":{\"604\":1}}],[\"你可以直接翻到对应的页码\",{\"1\":{\"1006\":1}}],[\"你可以直接发送到我的邮箱\",{\"1\":{\"211\":1}}],[\"你可以直接看最后一个案例\",{\"1\":{\"78\":1}}],[\"你可以访问\",{\"1\":{\"209\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"45\":1}}],[\"你可以在官方的github仓库上找到\",{\"1\":{\"974\":1}}],[\"你可以在\",{\"1\":{\"43\":1,\"44\":1}}],[\"你可以在主题选项和页面的\",{\"1\":{\"23\":1}}],[\"你怎么处理的\",{\"0\":{\"581\":1}}],[\"你遇到过死锁吗\",{\"0\":{\"581\":1}}],[\"你应如何优化这个字段的索引以提高排序操作的性能\",{\"0\":{\"509\":1}}],[\"你应该在页面\",{\"1\":{\"6\":1}}],[\"你有实战经验\",{\"1\":{\"1199\":1,\"1379\":1}}],[\"你有一个应用程序需要处理大量的日志数据\",{\"1\":{\"980\":1}}],[\"你有一个箱子\",{\"1\":{\"966\":1}}],[\"你有哪些学习计划\",{\"1\":{\"942\":1}}],[\"你有什么建议来优化redis分布式锁的性能吗\",{\"1\":{\"970\":1}}],[\"你有什么问题想要提问吗\",{\"1\":{\"922\":1}}],[\"你有什么想看的可以催更\",{\"1\":{\"150\":1}}],[\"你有没有使用过\",{\"1\":{\"1022\":1}}],[\"你有没有想过这样一些问题\",{\"1\":{\"872\":1}}],[\"你有没有想过这样一件事\",{\"1\":{\"871\":1,\"872\":1}}],[\"你有没有这样疑问\",{\"1\":{\"347\":1}}],[\"你知道分片和副本是什么吗\",{\"1\":{\"1012\":1}}],[\"你知道搜索引擎是怎么找到相关结果的吗\",{\"1\":{\"1006\":1}}],[\"你知道kafka的ack机制是用来做什么的吗\",{\"1\":{\"994\":1}}],[\"你知道kafka消息系统是如何工作的吗\",{\"1\":{\"990\":1}}],[\"你知道kafka有哪些优点吗\",{\"1\":{\"978\":1}}],[\"你知道吗\",{\"1\":{\"976\":3,\"982\":1}}],[\"你知道redis是如何实现分布式锁的吗\",{\"1\":{\"970\":1}}],[\"你知道\",{\"1\":{\"249\":2,\"1027\":1}}],[\"你将获得以下特权\",{\"1\":{\"211\":1}}],[\"你就可以在\",{\"1\":{\"109\":1}}],[\"你需要创建并编写\",{\"1\":{\"26\":1}}],[\"fyuvwrd8iixffikodcect8ipnof\",{\"1\":{\"1422\":1}}],[\"fd\",{\"1\":{\"962\":2}}],[\"fdk\",{\"1\":{\"145\":1}}],[\"fn\",{\"1\":{\"832\":1}}],[\"f2fa3\",{\"1\":{\"766\":1}}],[\"f26c\",{\"1\":{\"178\":1}}],[\"feishu\",{\"1\":{\"1422\":1}}],[\"fence\",{\"1\":{\"924\":1}}],[\"fetch\",{\"0\":{\"919\":1},\"1\":{\"919\":2,\"982\":2,\"1072\":2,\"1276\":2}}],[\"feature\",{\"1\":{\"915\":2,\"917\":3}}],[\"female\",{\"1\":{\"536\":1}}],[\"feb\",{\"1\":{\"159\":8}}],[\"ft\",{\"1\":{\"507\":1}}],[\"func\",{\"1\":{\"936\":1}}],[\"function\",{\"1\":{\"487\":2,\"488\":2}}],[\"fulltext\",{\"1\":{\"507\":2}}],[\"full\",{\"1\":{\"436\":5,\"495\":1}}],[\"fullname\",{\"1\":{\"436\":2}}],[\"fubing2\",{\"1\":{\"434\":1}}],[\"fubing\",{\"1\":{\"434\":1}}],[\"flip\",{\"1\":{\"1020\":1}}],[\"flush\",{\"1\":{\"876\":2,\"1071\":3,\"1178\":1,\"1275\":3,\"1363\":1}}],[\"flushstatements\",{\"1\":{\"770\":1}}],[\"flase\",{\"1\":{\"864\":1}}],[\"flag=true\",{\"1\":{\"692\":1}}],[\"flag\",{\"1\":{\"692\":21,\"924\":16}}],[\"flow2\",{\"1\":{\"865\":3}}],[\"flow1\",{\"1\":{\"865\":3}}],[\"flowable=\",{\"1\":{\"865\":1}}],[\"flowable2\",{\"1\":{\"863\":1,\"864\":1}}],[\"flowable<\",{\"1\":{\"862\":1}}],[\"flowable工作流依赖\",{\"1\":{\"862\":1}}],[\"flowable\",{\"1\":{\"861\":1,\"864\":1,\"865\":8,\"867\":1},\"2\":{\"868\":1,\"869\":1}}],[\"float的valueof方法的实现是类似的\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"float\",{\"1\":{\"444\":4,\"448\":1,\"795\":1,\"928\":1,\"948\":1}}],[\"floor\",{\"1\":{\"352\":2,\"364\":1}}],[\"flv`\",{\"1\":{\"146\":1}}],[\"flv\",{\"1\":{\"145\":1,\"146\":3}}],[\"fmts\",{\"1\":{\"144\":2}}],[\"fmpeg\",{\"1\":{\"138\":1}}],[\"ffprobe\",{\"1\":{\"143\":1}}],[\"ffmpg控制码率有3种选择\",{\"1\":{\"134\":1}}],[\"ffmpeg会从input\",{\"1\":{\"141\":1}}],[\"ffmpeg会通知缩放滤镜在输出时保持原始的宽高比\",{\"1\":{\"138\":1}}],[\"ffmpeg自己也有编码器\",{\"1\":{\"135\":1}}],[\"ffmpeg编码时可以调用它\",{\"1\":{\"135\":1}}],[\"ffmpeg官方wiki比较建议\",{\"1\":{\"134\":1}}],[\"ffmpeg的使用方式\",{\"1\":{\"127\":1}}],[\"ffmpeg在linux平台下开发\",{\"1\":{\"122\":1}}],[\"ffmpeg是一套可以用来记录\",{\"1\":{\"122\":1}}],[\"ffmpeg\",{\"1\":{\"122\":1,\"125\":8,\"127\":1,\"129\":1,\"131\":2,\"132\":2,\"133\":1,\"134\":3,\"135\":4,\"136\":1,\"139\":4,\"140\":1,\"141\":3,\"144\":1,\"145\":5,\"146\":4}}],[\"ffmpeg有多强大\",{\"1\":{\"121\":1}}],[\"ff\",{\"1\":{\"122\":1}}],[\"fsync将创建一个新的提交点\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"fssl\",{\"1\":{\"109\":1,\"247\":1}}],[\"fs=\",{\"1\":{\"94\":1}}],[\"fashion\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"fastjson\",{\"1\":{\"844\":2}}],[\"fasterxml\",{\"1\":{\"812\":1}}],[\"fast\",{\"0\":{\"546\":1,\"1119\":1,\"1314\":1},\"1\":{\"122\":1,\"1023\":2,\"1119\":4,\"1314\":4}}],[\"fastcgi\",{\"1\":{\"106\":5}}],[\"factories\",{\"1\":{\"1228\":2,\"1232\":1,\"1403\":2,\"1407\":1}}],[\"factory\",{\"1\":{\"766\":2,\"828\":2,\"830\":2,\"831\":1}}],[\"factor\",{\"1\":{\"625\":1,\"928\":2,\"948\":1}}],[\"false\",{\"1\":{\"284\":1,\"288\":3,\"289\":1,\"337\":1,\"406\":2,\"431\":3,\"432\":2,\"439\":1,\"440\":4,\"446\":1,\"447\":1,\"692\":3,\"790\":1,\"815\":1,\"831\":1,\"832\":1,\"849\":1,\"864\":1,\"865\":1,\"924\":1,\"932\":1,\"970\":2,\"988\":2,\"1008\":1,\"1020\":2,\"1044\":1,\"1085\":1,\"1092\":1,\"1253\":1,\"1286\":1,\"1293\":1}}],[\"fanggateway\",{\"1\":{\"1104\":1,\"1105\":1,\"1302\":1,\"1303\":1}}],[\"fan\",{\"1\":{\"252\":1}}],[\"familiar\",{\"1\":{\"152\":1}}],[\"failed\",{\"1\":{\"196\":1}}],[\"failure\",{\"1\":{\"112\":1}}],[\"fail\",{\"0\":{\"1119\":2,\"1314\":2},\"1\":{\"106\":1,\"1119\":6,\"1314\":6}}],[\"fails次失败后\",{\"1\":{\"106\":1}}],[\"fails\",{\"1\":{\"106\":1}}],[\"fair\",{\"1\":{\"106\":2}}],[\"following\",{\"1\":{\"1239\":2,\"1412\":2}}],[\"follower是有状态的\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"follower\",{\"1\":{\"1159\":3,\"1160\":3,\"1163\":1,\"1239\":1,\"1242\":1,\"1243\":2,\"1347\":3,\"1348\":3,\"1351\":1,\"1412\":1,\"1415\":1,\"1416\":2}}],[\"follower从leader同步数据有一些延迟\",{\"1\":{\"1156\":1,\"1344\":1}}],[\"folder\",{\"1\":{\"94\":2,\"913\":1}}],[\"foxes\",{\"1\":{\"437\":2}}],[\"found\",{\"1\":{\"436\":1,\"779\":2,\"1216\":1,\"1393\":1,\"1431\":3,\"1447\":1}}],[\"forbidden\",{\"1\":{\"1431\":1}}],[\"forgery\",{\"1\":{\"1137\":1,\"1330\":1}}],[\"for=pc\",{\"1\":{\"1030\":1}}],[\"fork\",{\"1\":{\"962\":1}}],[\"forname\",{\"1\":{\"737\":1,\"1093\":1,\"1294\":1}}],[\"foreach\",{\"0\":{\"787\":1},\"1\":{\"787\":1,\"1177\":1,\"1362\":1}}],[\"foreach>\",{\"1\":{\"724\":2,\"727\":3,\"787\":1}}],[\"foreign\",{\"1\":{\"560\":1,\"824\":1}}],[\"foreground|stop|restart|status|upgrade|print\",{\"1\":{\"158\":1}}],[\"for获取用户真实ip\",{\"1\":{\"106\":1}}],[\"formats\",{\"1\":{\"144\":1}}],[\"format\",{\"1\":{\"106\":1,\"388\":3,\"440\":1}}],[\"for信息\",{\"1\":{\"106\":1}}],[\"for用以记录客户端的ip地址\",{\"1\":{\"106\":1}}],[\"for\",{\"0\":{\"571\":1},\"1\":{\"106\":6,\"152\":4,\"285\":7,\"286\":2,\"289\":1,\"337\":4,\"352\":5,\"353\":3,\"360\":4,\"364\":2,\"377\":3,\"388\":4,\"555\":2,\"556\":3,\"558\":1,\"564\":1,\"570\":1,\"571\":1,\"573\":1,\"575\":1,\"578\":1,\"757\":1,\"763\":2,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"824\":2,\"828\":1,\"829\":1,\"922\":2,\"928\":4,\"932\":2,\"936\":1,\"938\":2,\"940\":1,\"950\":2,\"984\":1,\"990\":1,\"1004\":1,\"1008\":1,\"1020\":1,\"1044\":2,\"1073\":1,\"1085\":1,\"1092\":1,\"1101\":2,\"1104\":1,\"1105\":1,\"1191\":5,\"1216\":2,\"1253\":2,\"1277\":1,\"1286\":1,\"1293\":1,\"1299\":2,\"1302\":1,\"1303\":1,\"1374\":5,\"1393\":2}}],[\"forwarded\",{\"1\":{\"106\":8}}],[\"forward\",{\"0\":{\"546\":1},\"1\":{\"104\":1,\"122\":1,\"628\":1,\"831\":1}}],[\"food\",{\"1\":{\"966\":1}}],[\"food等\",{\"1\":{\"966\":1}}],[\"foo\",{\"0\":{\"17\":1,\"58\":1},\"1\":{\"59\":1,\"602\":1,\"660\":1}}],[\"f\",{\"1\":{\"94\":3,\"127\":1,\"136\":1,\"141\":2,\"145\":7,\"146\":4,\"854\":1,\"856\":1,\"917\":4,\"1062\":1,\"1068\":1,\"1268\":1,\"1272\":1}}],[\"fightfightfight\",{\"1\":{\"917\":1,\"919\":1}}],[\"fieldtype\",{\"1\":{\"1010\":1}}],[\"field2\",{\"1\":{\"605\":3}}],[\"field1\",{\"1\":{\"605\":3}}],[\"fielddata\",{\"1\":{\"440\":3}}],[\"fields\",{\"1\":{\"437\":1,\"440\":1}}],[\"field\",{\"1\":{\"436\":2,\"437\":2,\"440\":1,\"457\":4,\"602\":1,\"605\":10,\"654\":1,\"944\":1,\"1010\":3}}],[\"fifo\",{\"1\":{\"282\":1,\"1044\":1,\"1244\":1,\"1253\":1,\"1417\":1}}],[\"finish\",{\"1\":{\"487\":2,\"488\":2}}],[\"finished\",{\"1\":{\"487\":2,\"488\":2,\"932\":4}}],[\"final修饰一个成员变量\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"final修饰一个局部变量\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"final修饰一个方法\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"final修饰一个类\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"final类中的所有成员方法都会被隐式地指定为final方法\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"final关键字有四个常见用法\",{\"1\":{\"1091\":1,\"1292\":1}}],[\"finalname>\",{\"1\":{\"812\":1}}],[\"final增强\",{\"1\":{\"689\":1}}],[\"finally\",{\"1\":{\"689\":1,\"737\":1,\"747\":1,\"876\":2,\"1105\":4,\"1303\":4}}],[\"final\",{\"0\":{\"1091\":1,\"1292\":1},\"1\":{\"194\":1,\"337\":2,\"352\":1,\"388\":10,\"648\":1,\"790\":1,\"922\":1,\"928\":3,\"932\":1,\"934\":2,\"946\":1,\"948\":3,\"952\":2,\"988\":2,\"990\":2,\"1018\":1,\"1020\":3,\"1085\":3,\"1089\":1,\"1091\":10,\"1286\":3,\"1290\":1,\"1292\":10,\"1431\":2}}],[\"findsmallestnode\",{\"1\":{\"1008\":2}}],[\"findactiveblogwithtitlelike\",{\"1\":{\"958\":1}}],[\"finding\",{\"1\":{\"934\":1}}],[\"find\",{\"1\":{\"90\":1,\"94\":1}}],[\"filltask\",{\"1\":{\"865\":7}}],[\"filterregistrationbean\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"filterregions\",{\"1\":{\"940\":1}}],[\"filtered\",{\"1\":{\"940\":2}}],[\"filters\",{\"1\":{\"144\":1}}],[\"filter\",{\"1\":{\"139\":4,\"332\":1,\"339\":1,\"343\":1,\"406\":1,\"1133\":4,\"1326\":4}}],[\"fileinputstream\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"file>\",{\"1\":{\"820\":1}}],[\"file>index\",{\"1\":{\"820\":1}}],[\"file=\",{\"1\":{\"109\":1}}],[\"filesystem\",{\"1\":{\"1071\":5,\"1275\":5}}],[\"files\",{\"1\":{\"106\":1,\"887\":1}}],[\"fileall\",{\"1\":{\"94\":1}}],[\"file2\",{\"1\":{\"94\":1}}],[\"file1\",{\"1\":{\"94\":1}}],[\"filename\",{\"1\":{\"94\":2,\"106\":1,\"962\":1}}],[\"file\",{\"1\":{\"90\":1,\"94\":8,\"106\":16,\"134\":1,\"152\":1,\"424\":1,\"772\":1,\"820\":2,\"824\":1,\"876\":3,\"962\":2,\"1201\":1,\"1381\":1}}],[\"firstunstableoffset\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"firstname\",{\"1\":{\"432\":1,\"434\":3,\"436\":3,\"439\":1}}],[\"first\",{\"1\":{\"43\":1,\"282\":1,\"287\":2,\"436\":5,\"450\":2,\"451\":6,\"604\":2,\"887\":1,\"1044\":2,\"1253\":2}}],[\"friend\",{\"1\":{\"1023\":1}}],[\"fruit\",{\"1\":{\"966\":2}}],[\"fruit>\",{\"1\":{\"966\":3}}],[\"frequency\",{\"1\":{\"1069\":1,\"1273\":1}}],[\"frequencies\",{\"1\":{\"433\":3}}],[\"frequently\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"frequent\",{\"1\":{\"353\":2}}],[\"freqs\",{\"1\":{\"433\":1,\"440\":1}}],[\"freenext\",{\"1\":{\"1023\":2}}],[\"freeclient\",{\"1\":{\"964\":1}}],[\"freememory\",{\"1\":{\"938\":1}}],[\"free\",{\"1\":{\"90\":1,\"511\":3,\"619\":1,\"620\":1,\"621\":1}}],[\"front++\",{\"1\":{\"288\":1}}],[\"front+1\",{\"1\":{\"288\":1}}],[\"front\",{\"1\":{\"288\":14,\"289\":9}}],[\"frontmatter\",{\"1\":{\"6\":1,\"20\":1,\"23\":1,\"28\":4,\"43\":1,\"44\":1}}],[\"from\",{\"0\":{\"540\":1},\"1\":{\"152\":1,\"501\":3,\"505\":1,\"506\":2,\"511\":1,\"526\":2,\"528\":3,\"529\":2,\"530\":2,\"531\":2,\"532\":2,\"535\":4,\"542\":2,\"555\":2,\"556\":2,\"558\":2,\"571\":1,\"573\":2,\"577\":1,\"578\":1,\"580\":1,\"737\":1,\"744\":1,\"755\":4,\"759\":1,\"763\":5,\"772\":1,\"779\":8,\"780\":2,\"782\":4,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"789\":5,\"790\":1,\"793\":2,\"794\":1,\"795\":1,\"800\":2,\"827\":3,\"850\":1,\"887\":1,\"928\":2,\"940\":2,\"958\":2,\"964\":1,\"1059\":3,\"1072\":7,\"1101\":1,\"1174\":4,\"1175\":1,\"1181\":3,\"1265\":3,\"1276\":7,\"1299\":1,\"1359\":4,\"1360\":1,\"1366\":3}}],[\"frame\",{\"1\":{\"1142\":1,\"1333\":1}}],[\"frameworkservlet\",{\"1\":{\"956\":1}}],[\"framework\",{\"1\":{\"956\":1}}],[\"framerate\",{\"1\":{\"145\":3,\"146\":1}}],[\"framerate作用相同\",{\"1\":{\"145\":1}}],[\"frames\",{\"1\":{\"143\":4}}],[\"frac\",{\"1\":{\"35\":4}}],[\"通道用于进行数据的读写操作\",{\"1\":{\"1020\":1}}],[\"通道可以支持双向数据传输\",{\"1\":{\"1020\":1}}],[\"通道\",{\"1\":{\"1020\":2}}],[\"通配符模式\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"通配符可以更广泛的匹配不同的\",{\"1\":{\"966\":1}}],[\"通配符只能在读操作场景使用\",{\"1\":{\"966\":1}}],[\"通配符有些微的区别\",{\"1\":{\"966\":1}}],[\"通知等待的队列\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"通知有各种类型\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"通知需为此作为响应的broker\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"通知机制\",{\"1\":{\"1102\":2,\"1300\":2}}],[\"通知或中断\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"通知生产者生产产品\",{\"1\":{\"988\":1}}],[\"通知消费者消费产品\",{\"1\":{\"988\":1}}],[\"通知\",{\"1\":{\"593\":1,\"1216\":1,\"1217\":1,\"1237\":1,\"1244\":1,\"1393\":1,\"1394\":1,\"1410\":1,\"1417\":1}}],[\"通俗点说\",{\"1\":{\"165\":1}}],[\"通常可以为有效期增加随机值或者统一规划有效期\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"通常来讲在数据库上的悲观锁需要数据库本身提供支持\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"通常所说的\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"通常针对数据更新\",{\"1\":{\"1188\":2,\"1371\":2}}],[\"通常要伴随拷贝数组的操作\",{\"1\":{\"1117\":1,\"1312\":1}}],[\"通常由多个容器组成\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"通常在像泛型方法的定义中\",{\"1\":{\"966\":1}}],[\"通常在方法的参数列表上加上一个注释\",{\"1\":{\"779\":1}}],[\"通常在on子句中指定\",{\"1\":{\"502\":1}}],[\"通常把dao的包叫做mapper\",{\"1\":{\"772\":1}}],[\"通常首字母大写\",{\"1\":{\"768\":1}}],[\"通常会用于\",{\"1\":{\"659\":1}}],[\"通常我们按以下原则进行垂直拆分\",{\"1\":{\"516\":1}}],[\"通常\",{\"1\":{\"510\":1}}],[\"通常使用较少\",{\"1\":{\"495\":1}}],[\"通常被使用在高亮字段\",{\"1\":{\"440\":1}}],[\"通常用来距离查询\",{\"1\":{\"440\":1}}],[\"通常用于删除数据\",{\"1\":{\"178\":1}}],[\"通常用于修改部分数据\",{\"1\":{\"178\":1}}],[\"通常用于更新数据\",{\"1\":{\"178\":1}}],[\"通常用于查询数据\",{\"1\":{\"178\":1}}],[\"通常用在新增\",{\"1\":{\"178\":1}}],[\"通常是消息的key\",{\"1\":{\"996\":1}}],[\"通常是object类型\",{\"1\":{\"966\":1}}],[\"通常是\",{\"1\":{\"109\":1}}],[\"通常情况下这部分应答中包含一个小的应答头\",{\"1\":{\"106\":1}}],[\"通常web服务器放在反向代理的后面\",{\"1\":{\"106\":1}}],[\"通过状态码可以知道当前程序哪里出了问题\",{\"1\":{\"1431\":1}}],[\"通过观察\",{\"1\":{\"1431\":1}}],[\"通过对通用性的技术学习\",{\"1\":{\"1429\":1}}],[\"通过选举产生一个领导者\",{\"1\":{\"1246\":1,\"1419\":1}}],[\"通过设置\",{\"1\":{\"1245\":1,\"1418\":1}}],[\"通过各种组件的协调配合\",{\"1\":{\"1229\":1,\"1404\":1}}],[\"通过启动类的\",{\"1\":{\"1224\":1,\"1399\":1}}],[\"通过启用压缩\",{\"1\":{\"972\":1}}],[\"通过自动配置方式简化\",{\"1\":{\"1224\":1,\"1399\":1}}],[\"通过自动的垃圾回收机制回收这些垃圾对象所占的内存\",{\"1\":{\"936\":1}}],[\"通过构造方法进行依赖注入时产生的循环依赖问题\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"通过动态代理\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"通过getsingleton方法从singletonobjects中获取bean\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"通过aware类型的接口\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"通过前后的对比\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"通过xml里面写sql来绑定\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"通过注解绑定\",{\"1\":{\"1180\":1,\"1365\":1}}],[\"通过表达式可以迭代出整个对象的结构图\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"通过副本\",{\"1\":{\"1163\":1,\"1351\":1}}],[\"通过多路复用器selector来轮询注册在其上的channel\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"通过后台的异步线程\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"通过限制\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"通过限定垃圾产生速率\",{\"1\":{\"940\":1}}],[\"通过搭建缓存的高可用\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"通过该对象可以获取其他对象\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"通过该接口的\",{\"1\":{\"1034\":1}}],[\"通过该文件maven可以管理项目的整个声明周期\",{\"1\":{\"698\":1}}],[\"通过上面俩条我们知道\",{\"1\":{\"1087\":1,\"1288\":1}}],[\"通过上述实践\",{\"1\":{\"1018\":1}}],[\"通过上次校验\",{\"1\":{\"286\":1}}],[\"通过幂等性的机制\",{\"1\":{\"996\":1}}],[\"通过将topic分成多个分区\",{\"1\":{\"986\":1}}],[\"通过将获取锁和设置过期时间的操作合并为一个原子操作\",{\"1\":{\"970\":1}}],[\"通过合理地设置分区数和副本数\",{\"1\":{\"984\":1}}],[\"通过拦截执行的\",{\"1\":{\"958\":1}}],[\"通过工厂方法或构造器实例化\",{\"1\":{\"950\":1}}],[\"通过事件监听器监听事件\",{\"1\":{\"950\":1}}],[\"通过预置切点在不修改源代码的情况下增加新功能\",{\"1\":{\"950\":1}}],[\"通过ensurecapacityinternal\",{\"1\":{\"946\":1}}],[\"通过压力测试找出系统瓶颈\",{\"1\":{\"942\":1}}],[\"通过回收产生的空闲区的合并整理\",{\"1\":{\"940\":1}}],[\"通过统计与分析\",{\"1\":{\"940\":1}}],[\"通过颜色标记法管理标记过程\",{\"1\":{\"940\":1}}],[\"通过card\",{\"1\":{\"940\":1}}],[\"通过remembered\",{\"1\":{\"940\":2}}],[\"通过最终标记修正并发阶段的\",{\"1\":{\"938\":1}}],[\"通过垃圾收集器进行自动回收\",{\"1\":{\"936\":1}}],[\"通过引用计数算法判断对象是否可达\",{\"1\":{\"936\":1}}],[\"通过我们的交流\",{\"1\":{\"922\":1}}],[\"通过数组和链表组合\",{\"1\":{\"922\":1}}],[\"通过数据库事务的隔离级别隐式地实现锁定\",{\"1\":{\"570\":1}}],[\"通过链表解决冲突\",{\"1\":{\"922\":1}}],[\"通过真实案例编写\",{\"1\":{\"920\":1}}],[\"通过http协议传输\",{\"1\":{\"883\":1}}],[\"通过maven依赖的继承方式\",{\"1\":{\"836\":1}}],[\"通过maping\",{\"1\":{\"438\":1}}],[\"通过左上角引入\",{\"1\":{\"832\":1}}],[\"通过主键查询预约图书记录\",{\"1\":{\"826\":1}}],[\"通过id查询单本图书\",{\"1\":{\"826\":1}}],[\"通过方法参数传递的属性具有最高优先级\",{\"1\":{\"766\":1}}],[\"通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"通过setter方法进行依赖注入且是在多例\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"通过sqlsession操作数据库\",{\"1\":{\"751\":1}}],[\"通过sqlsessionfactory创建sqlsession对象\",{\"1\":{\"751\":1}}],[\"通过slf4j1\",{\"1\":{\"709\":1}}],[\"通过一个配置文件来管理多个docker容器\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"通过一个后台的异步线程进行缓存的构建\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"通过一个行地址和一个列地址可以唯一定位到一个存储单元\",{\"1\":{\"273\":1}}],[\"通过一片\",{\"1\":{\"632\":1}}],[\"通过为链表设置不同的类型特定函数\",{\"1\":{\"622\":1}}],[\"通过分析文档内容\",{\"1\":{\"1012\":1}}],[\"通过分代和分片回收\",{\"1\":{\"940\":1}}],[\"通过分数返回有序集合指定区间内的成员\",{\"1\":{\"607\":1}}],[\"通过分词后\",{\"1\":{\"425\":1}}],[\"通过字典区间返回有序集合的成员\",{\"1\":{\"607\":1}}],[\"通过索引\",{\"1\":{\"607\":1}}],[\"通过索引区间返回有序集合指定区间内的成员\",{\"1\":{\"607\":1}}],[\"通过索引设置列表元素的值\",{\"1\":{\"604\":1}}],[\"通过索引获取列表中的元素\",{\"1\":{\"604\":1}}],[\"通过在服务器端记录信息确定用户身份\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"通过在客户端记录信息确定用户身份\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"通过在尾部添加节点\",{\"1\":{\"922\":1}}],[\"通过在事务开始时锁定需要修改的数据行\",{\"1\":{\"573\":1}}],[\"通过在数据表中添加一个版本号或时间戳字段来实现\",{\"1\":{\"573\":1}}],[\"通过锁定机制预防冲突\",{\"1\":{\"570\":1}}],[\"通过这种分区分段的设计\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"通过这种数据库拆分的方法来解决数据库的性能问题\",{\"1\":{\"515\":1}}],[\"通过这样的方式\",{\"1\":{\"1049\":1,\"1258\":1}}],[\"通过这个流程\",{\"1\":{\"950\":1}}],[\"通过这个图可以知道\",{\"1\":{\"555\":1}}],[\"通过这一机制\",{\"1\":{\"635\":1}}],[\"通过名字\",{\"1\":{\"555\":1}}],[\"通过垂直分表性能得到了一定程度的提升\",{\"1\":{\"517\":1}}],[\"通过提升服务器硬件能力来提高数据处理能力\",{\"1\":{\"515\":1}}],[\"通过执行以下语句\",{\"1\":{\"619\":1}}],[\"通过执行\",{\"1\":{\"511\":1}}],[\"通过建立索引可以加快排序和分组的处理速度\",{\"1\":{\"502\":1}}],[\"通过哈希算法将被索引的列的值存储到一个固定长度的桶\",{\"1\":{\"499\":1}}],[\"通过地理类型的字段\",{\"1\":{\"453\":1}}],[\"通过倒排索引\",{\"1\":{\"424\":1}}],[\"通过修改vm\",{\"1\":{\"403\":1}}],[\"通过隐藏\",{\"1\":{\"400\":1}}],[\"通过计数排序特性分析题目\",{\"1\":{\"359\":1}}],[\"通过三次hash计算\",{\"1\":{\"333\":1,\"339\":1}}],[\"通过日志可以快速排查定位异常\",{\"1\":{\"200\":1}}],[\"通过入参\",{\"1\":{\"179\":1}}],[\"通过接口名就可以了解个大概\",{\"1\":{\"179\":1}}],[\"通过用户id查询用户信息\",{\"1\":{\"177\":1}}],[\"通过ls\",{\"1\":{\"159\":1}}],[\"通过zkcli\",{\"1\":{\"159\":1}}],[\"通过$remote\",{\"1\":{\"106\":1}}],[\"通过\",{\"1\":{\"28\":1,\"31\":1,\"436\":1,\"659\":1,\"692\":1,\"701\":1,\"832\":1,\"856\":1,\"865\":4,\"950\":1,\"1018\":1,\"1033\":1,\"1049\":1,\"1068\":1,\"1133\":1,\"1159\":1,\"1167\":1,\"1177\":2,\"1179\":1,\"1230\":1,\"1244\":1,\"1258\":1,\"1272\":1,\"1326\":1,\"1347\":1,\"1355\":1,\"1362\":2,\"1364\":1,\"1405\":1,\"1417\":1}}],[\"通过公众号可以获得站长联系方式\",{\"1\":{\"3\":1}}],[\"通向成功的高效学习法\",{\"1\":{\"10\":1}}],[\"华商崛起\",{\"1\":{\"10\":1}}],[\"华尔街之狼\",{\"1\":{\"10\":1}}],[\"知道为什么学它至关重要\",{\"1\":{\"153\":1}}],[\"知识点\",{\"1\":{\"101\":1}}],[\"知识星球\",{\"1\":{\"49\":1}}],[\"知识是人类进步的阶梯\",{\"1\":{\"9\":1}}],[\"知乎\",{\"1\":{\"2\":1,\"492\":1}}],[\"黄山版\",{\"1\":{\"7\":1}}],[\"阿里巴巴开发手册\",{\"1\":{\"7\":1}}],[\"阿里云栖社区\",{\"1\":{\"2\":1}}],[\"和大量的就业岗位\",{\"1\":{\"1439\":1}}],[\"和分布式锁服务中的控制时序场景基本原理一致\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"和分区容忍性\",{\"1\":{\"1078\":2,\"1282\":1}}],[\"和选\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"和过半写成功策略外\",{\"1\":{\"1239\":1,\"1412\":1}}],[\"和文件追加\",{\"1\":{\"1201\":1,\"1381\":1}}],[\"和上面的\",{\"1\":{\"1191\":1,\"1374\":1}}],[\"和设置的分页参数\",{\"1\":{\"1181\":1,\"1366\":1}}],[\"和若干个\",{\"1\":{\"1159\":1,\"1347\":1}}],[\"和一个\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"和运行中\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"和class类的newinstance方法很像\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"和cas\",{\"1\":{\"1018\":1}}],[\"和排序值给协调节点\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"和排它锁\",{\"1\":{\"555\":1}}],[\"和虚拟机有什么不同\",{\"0\":{\"1058\":1,\"1264\":1}}],[\"和更新\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"和缓存击穿不同的是\",{\"1\":{\"1203\":1,\"1383\":1}}],[\"和缓存的操作\",{\"1\":{\"1050\":1,\"1259\":1}}],[\"和缓存\",{\"1\":{\"1049\":2,\"1258\":2}}],[\"和出站事件流的\",{\"1\":{\"1034\":1}}],[\"和字节编解码器\",{\"1\":{\"1020\":1}}],[\"和新值\",{\"1\":{\"1018\":1}}],[\"和映射\",{\"1\":{\"998\":1}}],[\"和副本\",{\"1\":{\"986\":1}}],[\"和bitmap相比\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"和broker\",{\"1\":{\"986\":1}}],[\"和b+树是\",{\"1\":{\"262\":1}}],[\"和无边界的\",{\"1\":{\"966\":1}}],[\"和内存资源给应用\",{\"1\":{\"950\":1}}],[\"和框架\",{\"1\":{\"950\":1}}],[\"和filesystemxmlapplicationcontext\",{\"1\":{\"950\":1}}],[\"和高可扩展系统的理解很透彻\",{\"1\":{\"950\":1}}],[\"和arraylist类似\",{\"1\":{\"946\":1}}],[\"和类加载息息相关的其他类\",{\"1\":{\"934\":1}}],[\"和loading\",{\"1\":{\"934\":1}}],[\"和git\",{\"1\":{\"916\":1}}],[\"和set\",{\"0\":{\"786\":1}}],[\"和server\",{\"1\":{\"106\":1}}],[\"和$\",{\"0\":{\"779\":1,\"1174\":1,\"1359\":1}}],[\"和需要对应的mapper\",{\"1\":{\"762\":1}}],[\"和有序集合\",{\"1\":{\"619\":1}}],[\"和集合\",{\"1\":{\"607\":1}}],[\"和自动\",{\"1\":{\"601\":1}}],[\"和不同级别的\",{\"1\":{\"601\":1}}],[\"和hashmap类似\",{\"1\":{\"948\":1}}],[\"和hash\",{\"1\":{\"589\":1,\"1198\":1,\"1378\":1}}],[\"和意向排他锁\",{\"1\":{\"575\":1}}],[\"和数据一致性的场景\",{\"1\":{\"553\":1}}],[\"和数据中心id\",{\"1\":{\"387\":1}}],[\"和嵌套类型\",{\"1\":{\"449\":1}}],[\"和步骤\",{\"1\":{\"351\":1}}],[\"和k个hash函数\",{\"1\":{\"339\":1}}],[\"和n个hash函数\",{\"1\":{\"333\":1}}],[\"和领接表表示法\",{\"0\":{\"319\":1}}],[\"和51~\",{\"1\":{\"263\":1}}],[\"和前面工作进程配合起来用\",{\"1\":{\"106\":1}}],[\"和\",{\"0\":{\"529\":1,\"1104\":1,\"1106\":1,\"1113\":1,\"1115\":1,\"1117\":1,\"1119\":1,\"1243\":1,\"1302\":1,\"1304\":1,\"1308\":1,\"1310\":1,\"1312\":1,\"1314\":1,\"1416\":1},\"1\":{\"6\":1,\"27\":1,\"44\":1,\"101\":1,\"104\":4,\"109\":1,\"178\":1,\"267\":1,\"270\":2,\"342\":1,\"387\":3,\"424\":1,\"433\":3,\"436\":3,\"443\":1,\"445\":1,\"451\":2,\"505\":1,\"506\":1,\"535\":1,\"558\":1,\"589\":1,\"598\":1,\"601\":1,\"603\":3,\"605\":1,\"625\":1,\"628\":1,\"629\":1,\"635\":1,\"648\":1,\"656\":1,\"692\":2,\"766\":2,\"772\":2,\"775\":1,\"807\":1,\"824\":1,\"825\":1,\"826\":1,\"827\":2,\"828\":1,\"844\":1,\"916\":1,\"917\":1,\"918\":1,\"922\":2,\"926\":2,\"928\":1,\"932\":5,\"940\":1,\"944\":1,\"952\":1,\"956\":3,\"960\":1,\"962\":2,\"966\":1,\"988\":1,\"1022\":2,\"1027\":2,\"1041\":1,\"1071\":2,\"1072\":1,\"1079\":1,\"1085\":1,\"1087\":1,\"1092\":1,\"1112\":1,\"1119\":1,\"1128\":1,\"1131\":1,\"1150\":1,\"1151\":1,\"1177\":1,\"1192\":1,\"1217\":1,\"1220\":1,\"1275\":2,\"1276\":1,\"1283\":1,\"1286\":1,\"1288\":1,\"1293\":1,\"1307\":1,\"1314\":1,\"1321\":1,\"1324\":1,\"1341\":1,\"1342\":1,\"1362\":1,\"1375\":1,\"1394\":1,\"1397\":1,\"1431\":1,\"1444\":1}}],[\"介绍文档\",{\"0\":{\"1425\":1,\"1434\":1},\"1\":{\"1426\":1,\"1431\":1,\"1435\":1,\"1439\":1,\"1443\":1}}],[\"介绍截图\",{\"1\":{\"739\":1}}],[\"介绍一下zab协议\",{\"0\":{\"1242\":1,\"1415\":1}}],[\"介绍一下你们的个性化搜索方案\",{\"0\":{\"1079\":1,\"1283\":1}}],[\"介绍一下\",{\"0\":{\"1128\":1,\"1321\":1},\"1\":{\"329\":1}}],[\"介绍\",{\"0\":{\"6\":1,\"27\":1,\"53\":1,\"59\":1,\"223\":1,\"339\":1,\"342\":1,\"399\":1,\"601\":1},\"1\":{\"27\":1,\"28\":1,\"394\":1,\"587\":1}}],[\"档案主页\",{\"0\":{\"5\":1,\"222\":1},\"1\":{\"6\":1}}],[\"qr\",{\"1\":{\"878\":1}}],[\"qrcodeutil1\",{\"1\":{\"876\":3}}],[\"qrcodecontroller1\",{\"1\":{\"876\":2}}],[\"qos\",{\"1\":{\"812\":1,\"821\":2}}],[\"q1234\",{\"1\":{\"602\":1}}],[\"q=fullname\",{\"1\":{\"436\":1}}],[\"q=javapub\",{\"1\":{\"4\":3}}],[\"qnode<integer>\",{\"1\":{\"289\":4}}],[\"qnode<t>\",{\"1\":{\"289\":11}}],[\"qnode\",{\"1\":{\"289\":2}}],[\"qzphzgrpbjpvcgvuihnlc2ftzq==\",{\"1\":{\"183\":1}}],[\"quorum\",{\"1\":{\"1078\":2,\"1282\":2}}],[\"quartz\",{\"1\":{\"950\":1}}],[\"question\",{\"1\":{\"457\":4}}],[\"queue的方式更高效\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"queue作为list的子接口\",{\"1\":{\"946\":1}}],[\"queue接口\",{\"1\":{\"946\":1}}],[\"queue\",{\"1\":{\"288\":8,\"289\":1}}],[\"query方法中调用的execute\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"querybykeywithbook\",{\"1\":{\"826\":1,\"827\":1,\"828\":1,\"830\":1}}],[\"querybyid\",{\"1\":{\"177\":2,\"181\":2,\"826\":2,\"827\":1,\"828\":1,\"830\":1}}],[\"queryall\",{\"1\":{\"826\":1,\"827\":1,\"828\":1,\"830\":1}}],[\"queryorderwithuseranddetailitembyordernumber\",{\"1\":{\"795\":4}}],[\"queryorderwithuseranddetailbyordernumber\",{\"1\":{\"794\":4}}],[\"queryorderwithuserbyordernumber\",{\"1\":{\"793\":4}}],[\"queryorderuserbyordernumber\",{\"1\":{\"793\":4}}],[\"querying\",{\"1\":{\"779\":1}}],[\"queryuserlistbyids\",{\"1\":{\"787\":4}}],[\"queryuserlistbynameandage\",{\"1\":{\"786\":4}}],[\"queryuserlistbynameorage\",{\"1\":{\"785\":4}}],[\"queryuserlistbyname2\",{\"1\":{\"780\":2}}],[\"queryuserlistbyname1\",{\"1\":{\"780\":2}}],[\"queryuserlist\",{\"1\":{\"784\":3}}],[\"queryuserslikeusername\",{\"1\":{\"782\":2}}],[\"queryuserbytablename\",{\"1\":{\"763\":3,\"779\":5}}],[\"queryuserbyid\",{\"1\":{\"753\":1,\"754\":2,\"755\":2,\"757\":2,\"759\":1,\"763\":3,\"782\":2,\"789\":21,\"790\":5}}],[\"queryuserall\",{\"1\":{\"753\":1,\"754\":2,\"755\":1,\"757\":2,\"763\":3}}],[\"query\",{\"1\":{\"434\":1,\"436\":2,\"770\":2,\"998\":1,\"1002\":1,\"1072\":2,\"1185\":1,\"1276\":2,\"1368\":1}}],[\"query=javapub\",{\"1\":{\"4\":1}}],[\"quickstart\",{\"1\":{\"703\":2}}],[\"quick\",{\"0\":{\"156\":1,\"741\":1},\"1\":{\"437\":2}}],[\"q\",{\"1\":{\"141\":3}}],[\"qw\",{\"1\":{\"94\":1}}],[\"qq推荐可能认识的人\",{\"1\":{\"656\":1}}],[\"qq\",{\"1\":{\"71\":1,\"147\":1,\"172\":1,\"211\":1,\"232\":1,\"251\":1,\"275\":1,\"394\":1,\"675\":1,\"728\":1,\"832\":1,\"1099\":1,\"1184\":1,\"1297\":1,\"1367\":1}}],[\"搜索执行阶段过程分俩个部分\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"搜索的过程\",{\"0\":{\"1072\":1,\"1276\":1}}],[\"搜索性能会越低\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"搜索镜像\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"搜索非常简单\",{\"1\":{\"998\":1}}],[\"搜索和分析海量数据\",{\"1\":{\"998\":1}}],[\"搜索效率越高\",{\"1\":{\"444\":1}}],[\"搜索时用standard用来完成自动提示功能\",{\"1\":{\"440\":1}}],[\"搜索引擎会根据关键词在网页中进行匹配\",{\"1\":{\"1006\":1}}],[\"搜索引擎中最重要的一部分之一\",{\"1\":{\"428\":1}}],[\"搜索引擎收录直达\",{\"0\":{\"4\":1}}],[\"搜索结果分页处理\",{\"1\":{\"394\":1}}],[\"搜索结果优化排序和耗时处理\",{\"1\":{\"394\":1}}],[\"搜索结果集展示\",{\"1\":{\"394\":1}}],[\"搜索关键词高亮\",{\"1\":{\"394\":1}}],[\"搜索排序和高亮关键字\",{\"1\":{\"394\":1}}],[\"搜索有可能在非叶子结点结束\",{\"1\":{\"265\":1}}],[\"搜索也就更快了\",{\"1\":{\"266\":1}}],[\"搜索也就更快\",{\"1\":{\"263\":1}}],[\"搜索可能在非叶子节点结束\",{\"1\":{\"263\":1}}],[\"搜索\",{\"0\":{\"475\":1},\"1\":{\"223\":1,\"920\":1}}],[\"搜索微信号\",{\"1\":{\"214\":1}}],[\"搜狗收录\",{\"1\":{\"4\":1}}],[\"b之间的循环依赖强制其中一个bean在完全初始化之前被注入另一个bean\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"b线程同时对该集合进行增删元素操作\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"bgsave\",{\"1\":{\"962\":3,\"964\":6,\"1205\":1,\"1385\":1}}],[\"bbs\",{\"1\":{\"950\":1}}],[\"bv17f421q73r\",{\"1\":{\"1439\":1}}],[\"bv1cw411w7rk\",{\"1\":{\"878\":1}}],[\"bv1fa411j7q5\",{\"1\":{\"860\":1}}],[\"bj\",{\"1\":{\"864\":1}}],[\"bpmnedge>\",{\"1\":{\"865\":8}}],[\"bpmnedge\",{\"1\":{\"865\":16}}],[\"bpmnelement=\",{\"1\":{\"865\":15}}],[\"bpmnshape>\",{\"1\":{\"865\":6}}],[\"bpmnshape\",{\"1\":{\"865\":12}}],[\"bpmnplane>\",{\"1\":{\"865\":1}}],[\"bpmnplane\",{\"1\":{\"865\":2}}],[\"bpmndi\",{\"1\":{\"865\":16}}],[\"bpmndiagram>\",{\"1\":{\"865\":1}}],[\"bpmndiagram\",{\"1\":{\"865\":2}}],[\"bpmndi=\",{\"1\":{\"865\":1}}],[\"bpmn20\",{\"1\":{\"865\":1}}],[\"bpmn\",{\"1\":{\"861\":1,\"865\":3}}],[\"bpmn绘图可视化工具\",{\"1\":{\"861\":1}}],[\"b项目中自动传递依赖于log4j\",{\"1\":{\"708\":1}}],[\"b和a\",{\"1\":{\"498\":1}}],[\"bm25\",{\"1\":{\"440\":1}}],[\"b+tree\",{\"0\":{\"271\":1},\"1\":{\"495\":1}}],[\"b+\",{\"0\":{\"268\":1,\"499\":1,\"503\":1},\"1\":{\"499\":4}}],[\"b+树在数据库索引中提供了更稳定的查询性能\",{\"1\":{\"503\":1}}],[\"b+树在索引删除和插入操作时\",{\"1\":{\"499\":1}}],[\"b+树通过减少节点分裂和合并的次数\",{\"1\":{\"503\":1}}],[\"b+树通过多层索引结构\",{\"1\":{\"503\":1}}],[\"b+树也能保持较高的查询效率\",{\"1\":{\"503\":1}}],[\"b+树擅长范围查询和排序操作\",{\"1\":{\"499\":1}}],[\"b+树索引的节点是有序存储的\",{\"1\":{\"499\":1}}],[\"b+树索引使用平衡树\",{\"1\":{\"499\":1}}],[\"b+树索引\",{\"1\":{\"499\":1}}],[\"b+树白话详解\",{\"1\":{\"499\":1}}],[\"b+树是最常用的索引类型\",{\"1\":{\"495\":1}}],[\"b+树是b\",{\"1\":{\"269\":1}}],[\"b+树是b树的一种变种\",{\"1\":{\"264\":1}}],[\"b+树可以很好的利用局部性原理\",{\"1\":{\"270\":1}}],[\"b+树可以增加了区间访问性\",{\"1\":{\"264\":1}}],[\"b+树叶节点两两相连可大大增加区间访问性\",{\"1\":{\"270\":1}}],[\"b+树查询节点\",{\"1\":{\"270\":1}}],[\"b+树内节点不存储数据\",{\"1\":{\"270\":1}}],[\"b+树概述\",{\"0\":{\"269\":1}}],[\"b+树的非叶子节点仅用于索引\",{\"1\":{\"503\":1}}],[\"b+树的有序链表结构使得它在执行范围查询和排序操作时非常高效\",{\"1\":{\"503\":1}}],[\"b+树的设计更适合减少磁盘访问次数\",{\"1\":{\"503\":1}}],[\"b+树的叶子节点包含了所有数据记录\",{\"1\":{\"503\":1}}],[\"b+树的查询时间复杂度仍然是对数级别\",{\"1\":{\"503\":1}}],[\"b+树的基本概念\",{\"0\":{\"316\":1}}],[\"b+树的示意图如下\",{\"1\":{\"264\":1}}],[\"b+树的神秘面纱揭开\",{\"1\":{\"262\":1}}],[\"b+树更适合外部存储\",{\"1\":{\"264\":1,\"270\":1}}],[\"b+树\",{\"0\":{\"264\":1},\"1\":{\"266\":1,\"269\":1,\"270\":1},\"2\":{\"276\":1}}],[\"btreesearch\",{\"1\":{\"267\":2}}],[\"b树和b+树的区别\",{\"1\":{\"1184\":1,\"1367\":1}}],[\"b树和b+树区别\",{\"0\":{\"261\":1}}],[\"b树的由于每个节点都有key和data\",{\"1\":{\"270\":1}}],[\"b树的每个节点\",{\"1\":{\"266\":1}}],[\"b树的每个节点可以存储多个数据\",{\"1\":{\"263\":1}}],[\"b树把每个节点都给了一点的范围区间\",{\"1\":{\"266\":1}}],[\"b树由来\",{\"1\":{\"266\":1}}],[\"b树深入\",{\"0\":{\"266\":1}}],[\"b树可以分为四个区间\",{\"1\":{\"263\":1}}],[\"b树中每个节点都存放着索引和数据\",{\"1\":{\"263\":1}}],[\"b树\",{\"0\":{\"263\":1,\"265\":1},\"1\":{\"262\":1,\"263\":1,\"264\":1},\"2\":{\"276\":1}}],[\"blue\",{\"1\":{\"944\":2}}],[\"blpop\",{\"1\":{\"604\":1}}],[\"blob等大字段拆分出来放在附表中\",{\"1\":{\"516\":1}}],[\"bloom\",{\"1\":{\"332\":1,\"339\":1,\"343\":1}}],[\"bloomfiltersimple\",{\"1\":{\"337\":8}}],[\"bloomfilter\",{\"0\":{\"328\":1},\"1\":{\"1047\":4,\"1256\":4}}],[\"blocked\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"block\",{\"1\":{\"266\":2,\"270\":2,\"1107\":2,\"1305\":2}}],[\"blogmapper\",{\"1\":{\"772\":2}}],[\"blog\",{\"1\":{\"232\":1,\"238\":1,\"251\":2,\"275\":1,\"388\":2,\"394\":3,\"425\":1,\"520\":1,\"675\":1,\"688\":1,\"689\":1,\"849\":1,\"917\":2,\"919\":3,\"958\":2,\"1030\":1,\"1073\":1,\"1092\":1,\"1093\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1219\":1,\"1277\":1,\"1293\":1,\"1294\":1,\"1302\":2,\"1303\":1,\"1305\":1,\"1396\":1}}],[\"blf1a6cp\",{\"1\":{\"71\":1}}],[\"b4fe3684d20e97fa311ca213c8dc7ea9\",{\"1\":{\"182\":1}}],[\"b530\",{\"1\":{\"177\":1}}],[\"b696\",{\"1\":{\"177\":1}}],[\"b是这个服务器的ip地址\",{\"1\":{\"157\":1}}],[\"bounds>\",{\"1\":{\"865\":6}}],[\"bounds\",{\"1\":{\"865\":6}}],[\"bosspassflow\",{\"1\":{\"865\":3}}],[\"bossnotpassflow\",{\"1\":{\"865\":3}}],[\"bosstaskhandler\",{\"1\":{\"865\":1}}],[\"bosstask\",{\"1\":{\"865\":6}}],[\"board\",{\"1\":{\"657\":3}}],[\"borrow\",{\"1\":{\"648\":2}}],[\"box2\",{\"1\":{\"966\":2}}],[\"box1\",{\"1\":{\"966\":2}}],[\"box<object>\",{\"1\":{\"966\":1}}],[\"box<orange>\",{\"1\":{\"966\":1}}],[\"box<\",{\"1\":{\"966\":6}}],[\"box<>\",{\"1\":{\"966\":1}}],[\"box<apple>\",{\"1\":{\"966\":4}}],[\"box<t>\",{\"1\":{\"966\":3}}],[\"box\",{\"1\":{\"591\":1,\"966\":10}}],[\"bool\",{\"1\":{\"487\":1,\"488\":1}}],[\"boolean\",{\"1\":{\"284\":1,\"285\":1,\"286\":1,\"288\":3,\"289\":1,\"337\":5,\"439\":1,\"536\":1,\"648\":1,\"692\":2,\"830\":3,\"924\":2,\"932\":3,\"940\":1,\"946\":1,\"956\":2,\"988\":1,\"1044\":1,\"1084\":2,\"1092\":2,\"1216\":1,\"1253\":1,\"1285\":2,\"1293\":2,\"1393\":1}}],[\"boostrap\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"boost\",{\"1\":{\"440\":2}}],[\"boot3\",{\"1\":{\"1444\":1}}],[\"boot的核心注解是什么\",{\"0\":{\"1227\":1,\"1402\":1}}],[\"boot<\",{\"1\":{\"687\":1,\"844\":4,\"862\":1,\"885\":2,\"1092\":1,\"1293\":1}}],[\"bootstrap\",{\"1\":{\"406\":2,\"934\":2,\"984\":1,\"990\":5,\"1034\":1,\"1226\":2,\"1401\":2}}],[\"boot\",{\"0\":{\"1224\":1,\"1225\":1,\"1226\":1,\"1399\":1,\"1400\":1,\"1401\":1},\"1\":{\"401\":5,\"524\":1,\"681\":1,\"687\":1,\"690\":1,\"701\":1,\"837\":4,\"844\":11,\"856\":1,\"862\":2,\"885\":2,\"889\":1,\"950\":2,\"1092\":1,\"1225\":1,\"1232\":8,\"1293\":1,\"1400\":1,\"1407\":8}}],[\"bookcontroller\",{\"1\":{\"831\":2,\"832\":2}}],[\"bookserviceimpltest\",{\"1\":{\"830\":2}}],[\"bookserviceimpl\",{\"1\":{\"830\":3}}],[\"bookservice\",{\"1\":{\"830\":9,\"831\":7}}],[\"books\",{\"1\":{\"828\":2,\"1004\":1}}],[\"bookdaotest\",{\"1\":{\"828\":3}}],[\"bookdao\",{\"1\":{\"826\":4,\"827\":3,\"828\":6,\"830\":6}}],[\"bookid\",{\"1\":{\"825\":2,\"826\":8,\"827\":4,\"828\":8,\"829\":7,\"830\":16,\"831\":13}}],[\"book\",{\"1\":{\"193\":4,\"824\":3,\"825\":5,\"826\":3,\"827\":21,\"828\":7,\"830\":4,\"831\":11,\"832\":3,\"904\":1}}],[\"bottom\",{\"1\":{\"282\":1}}],[\"both\",{\"1\":{\"152\":1}}],[\"body>\",{\"1\":{\"832\":1}}],[\"body\",{\"1\":{\"106\":6,\"1431\":2}}],[\"bsd\",{\"1\":{\"614\":1}}],[\"bsd许可\",{\"1\":{\"601\":1}}],[\"bsfs\",{\"1\":{\"144\":1}}],[\"bsafe\",{\"1\":{\"94\":1}}],[\"bz2\",{\"1\":{\"125\":2}}],[\"bio放一块比较\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"bio\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"biggod222\",{\"1\":{\"763\":1,\"789\":6,\"790\":2}}],[\"bigint\",{\"1\":{\"726\":1,\"824\":3,\"1444\":1}}],[\"birthday=\",{\"1\":{\"759\":1,\"789\":6,\"790\":2}}],[\"birthday\",{\"1\":{\"736\":3,\"737\":1,\"747\":5,\"755\":6,\"759\":2,\"763\":4,\"782\":2,\"786\":2,\"793\":1}}],[\"bits\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"bitset\",{\"1\":{\"337\":8,\"658\":1}}],[\"bitmap标识哪些用户活跃\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"bitmaps\",{\"1\":{\"601\":1}}],[\"bitmap索引适合低基数\",{\"1\":{\"510\":1}}],[\"bitmap\",{\"0\":{\"658\":1},\"1\":{\"505\":3,\"658\":8,\"1077\":2,\"1198\":1,\"1199\":1,\"1281\":2,\"1378\":1,\"1379\":1}}],[\"bitcount\",{\"1\":{\"342\":1,\"658\":1}}],[\"bit\",{\"1\":{\"134\":2,\"342\":2,\"387\":2,\"658\":10}}],[\"biterate\",{\"1\":{\"134\":2}}],[\"bitrate的缩写\",{\"1\":{\"145\":1}}],[\"bitrate\",{\"1\":{\"134\":1}}],[\"bilibili\",{\"1\":{\"112\":1,\"251\":1,\"860\":1,\"871\":1,\"878\":1,\"889\":1,\"1439\":1}}],[\"binlog线程\",{\"1\":{\"1186\":1,\"1369\":1}}],[\"binlog\",{\"1\":{\"1185\":1,\"1186\":1,\"1368\":1,\"1369\":1}}],[\"bincount\",{\"1\":{\"922\":1}}],[\"bindingexception\",{\"1\":{\"762\":1,\"779\":2}}],[\"binding\",{\"1\":{\"762\":2,\"779\":2}}],[\"bindings\",{\"1\":{\"152\":1}}],[\"bind\",{\"1\":{\"673\":1,\"831\":1,\"849\":3,\"876\":1,\"1020\":1,\"1177\":1,\"1362\":1}}],[\"binary\",{\"1\":{\"447\":1}}],[\"binarysearch\",{\"1\":{\"267\":1}}],[\"bin\",{\"1\":{\"109\":1,\"125\":1,\"158\":2,\"159\":3,\"371\":1,\"407\":1,\"408\":1,\"701\":2,\"702\":2,\"856\":1}}],[\"bingo\",{\"1\":{\"1006\":1}}],[\"bing\",{\"1\":{\"4\":1}}],[\"brain\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"branch\",{\"1\":{\"94\":1,\"913\":1,\"915\":2}}],[\"break\",{\"1\":{\"922\":1,\"1008\":1,\"1105\":2,\"1303\":2}}],[\"brew\",{\"1\":{\"109\":3,\"114\":5}}],[\"broadcast\",{\"1\":{\"1020\":2,\"1243\":1,\"1416\":1}}],[\"brokenbarrierexception\",{\"1\":{\"932\":2}}],[\"broker会将消息发送给consumer\",{\"1\":{\"986\":1}}],[\"broker会接收并存储消息\",{\"1\":{\"986\":1}}],[\"broker的源码\",{\"1\":{\"986\":2}}],[\"broker\",{\"1\":{\"614\":1,\"1159\":8,\"1164\":5,\"1166\":7,\"1167\":1,\"1347\":8,\"1352\":5,\"1354\":7,\"1355\":1}}],[\"brown\",{\"1\":{\"437\":2}}],[\"brpoplpush\",{\"1\":{\"604\":1}}],[\"brpop\",{\"1\":{\"604\":1}}],[\"build>\",{\"1\":{\"812\":1,\"844\":1}}],[\"builder\",{\"1\":{\"772\":6}}],[\"buildmaxheap\",{\"1\":{\"364\":2}}],[\"building\",{\"1\":{\"339\":1}}],[\"build\",{\"1\":{\"152\":1,\"746\":1,\"747\":1,\"757\":1,\"763\":1,\"766\":3,\"812\":2,\"844\":2,\"854\":1,\"944\":1,\"1059\":1,\"1060\":1,\"1265\":1,\"1266\":1}}],[\"buf\",{\"1\":{\"619\":3}}],[\"bufsize\",{\"1\":{\"134\":4}}],[\"buffers缓冲区\",{\"1\":{\"106\":1}}],[\"buffers中指定的一个缓冲区的大小\",{\"1\":{\"106\":1}}],[\"buffers\",{\"1\":{\"106\":5}}],[\"buffers来读取\",{\"1\":{\"106\":1}}],[\"buffer\",{\"1\":{\"106\":8,\"930\":1,\"1020\":9,\"1071\":1,\"1275\":1}}],[\"busy\",{\"1\":{\"106\":1}}],[\"bucketindex\",{\"1\":{\"948\":3}}],[\"bucketcount\",{\"1\":{\"352\":2}}],[\"buckets\",{\"1\":{\"352\":4}}],[\"bucketsize\",{\"1\":{\"352\":3}}],[\"bucketsort\",{\"1\":{\"352\":7}}],[\"bucket\",{\"0\":{\"348\":1},\"1\":{\"106\":5,\"348\":1,\"352\":5,\"371\":1,\"499\":1,\"1116\":1,\"1311\":1}}],[\"bug修复提交后\",{\"1\":{\"916\":1}}],[\"bug修复手册\",{\"0\":{\"70\":1}}],[\"bugfix\",{\"2\":{\"72\":1,\"73\":1}}],[\"by或distinct操作中使用的列\",{\"1\":{\"502\":1}}],[\"bytebuffer\",{\"1\":{\"1020\":5}}],[\"byte\",{\"1\":{\"266\":1,\"444\":1,\"658\":1,\"1085\":1,\"1286\":1}}],[\"bytes`\",{\"1\":{\"982\":2}}],[\"bytes\",{\"1\":{\"106\":2,\"887\":1,\"889\":1,\"982\":2}}],[\"by\",{\"1\":{\"106\":1,\"112\":1,\"158\":1,\"502\":1,\"821\":1,\"827\":1,\"904\":1,\"1023\":2,\"1085\":1,\"1101\":2,\"1192\":1,\"1286\":1,\"1299\":2,\"1375\":1}}],[\"b\",{\"0\":{\"267\":1,\"270\":1,\"316\":1},\"1\":{\"94\":1,\"127\":1,\"134\":5,\"145\":3,\"263\":2,\"265\":1,\"266\":5,\"267\":1,\"269\":1,\"270\":3,\"288\":2,\"364\":2,\"388\":2,\"498\":2,\"510\":1,\"535\":2,\"603\":2,\"604\":2,\"635\":1,\"707\":4,\"827\":5,\"913\":1,\"915\":1,\"917\":7,\"924\":1,\"934\":2,\"936\":4,\"952\":2,\"966\":7,\"1018\":2,\"1068\":1,\"1088\":1,\"1104\":14,\"1188\":2,\"1212\":2,\"1214\":2,\"1218\":1,\"1220\":1,\"1272\":1,\"1289\":1,\"1302\":14,\"1371\":2,\"1389\":2,\"1391\":2,\"1395\":1,\"1397\":1,\"1439\":1}}],[\"behavior\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"behind\",{\"1\":{\"152\":1}}],[\"become\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"beancurrentlyincreationexception\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"beancreationexception\",{\"1\":{\"952\":1}}],[\"beanfacotry加载后\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"beanfactroy采用的是延迟加载形式来注入bean的\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"beanfactory通常以编程的方式被创建\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"beanfactory需要手动注册\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"beanfactory是spring里面最底层的接口\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"beanfactory和applicationcontext都支持beanpostprocessor\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"beanfactory和applicationcontext是spring的两大核心接口\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"beanfactory和applicationcontext有什么区别\",{\"0\":{\"1218\":1,\"1395\":1}}],[\"beanfactory接口是spring\",{\"1\":{\"1213\":1,\"1390\":1}}],[\"beanfactorypostprocessor的使用\",{\"1\":{\"1218\":1,\"1395\":1}}],[\"beanfactorypostprocessor\",{\"1\":{\"952\":2}}],[\"beanfactory\",{\"1\":{\"950\":6,\"954\":2}}],[\"bean会随之消失\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"bean会失效并被垃圾回收器回收\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"bean就成功创建了\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"bean实例创建出来后\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"bean属性填充\",{\"1\":{\"1214\":2,\"1391\":2}}],[\"beanb\",{\"1\":{\"954\":8}}],[\"beana\",{\"1\":{\"954\":8}}],[\"beanpostprocessors\",{\"1\":{\"954\":1}}],[\"beanpostprocessor\",{\"1\":{\"952\":2}}],[\"beanname\",{\"1\":{\"952\":3,\"954\":2,\"1216\":8,\"1393\":8}}],[\"beandefinitionstoreexception\",{\"1\":{\"952\":1}}],[\"beandefinition\",{\"1\":{\"952\":7}}],[\"beandefinitionreader\",{\"1\":{\"950\":6}}],[\"bean\",{\"0\":{\"1214\":1,\"1215\":1,\"1391\":1,\"1392\":1},\"1\":{\"950\":17,\"952\":62,\"954\":21,\"1214\":1,\"1216\":1,\"1219\":1,\"1230\":1,\"1391\":1,\"1393\":1,\"1396\":1,\"1405\":1}}],[\"bean>\",{\"1\":{\"815\":3,\"818\":1,\"819\":1,\"952\":1,\"1219\":2,\"1396\":2}}],[\"beansexception\",{\"1\":{\"950\":2}}],[\"beans>\",{\"1\":{\"815\":1,\"818\":1,\"819\":1}}],[\"beans\",{\"1\":{\"815\":4,\"818\":4,\"819\":4,\"828\":2,\"830\":2,\"831\":1,\"950\":1}}],[\"beans<\",{\"1\":{\"709\":1,\"710\":1,\"715\":1,\"812\":1}}],[\"begintime\",{\"1\":{\"689\":2}}],[\"before内存模型中\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"before等注解搭配使用\",{\"1\":{\"944\":1}}],[\"beforeexecute\",{\"1\":{\"926\":1}}],[\"before\",{\"1\":{\"604\":1,\"689\":2,\"757\":2,\"763\":2,\"944\":1,\"1016\":1,\"1217\":1,\"1394\":1}}],[\"before|after\",{\"1\":{\"604\":1}}],[\"better\",{\"1\":{\"339\":1}}],[\"between\",{\"1\":{\"141\":1,\"529\":2,\"556\":1,\"558\":2}}],[\"bellard发起\",{\"1\":{\"122\":1}}],[\"be\",{\"1\":{\"43\":1,\"106\":1,\"112\":1,\"152\":1,\"388\":2,\"1085\":2,\"1101\":2,\"1216\":1,\"1286\":2,\"1299\":2,\"1393\":1}}],[\"baomidou<\",{\"1\":{\"1444\":1}}],[\"bad\",{\"1\":{\"1431\":1}}],[\"ballot\",{\"1\":{\"1243\":1,\"1416\":1}}],[\"balance\",{\"1\":{\"263\":1,\"487\":1,\"488\":1}}],[\"banker\",{\"1\":{\"1105\":1,\"1303\":1}}],[\"batch\",{\"1\":{\"770\":1}}],[\"battle\",{\"1\":{\"192\":1}}],[\"baijiahao\",{\"1\":{\"1030\":1}}],[\"baike\",{\"1\":{\"336\":1}}],[\"baidu\",{\"1\":{\"4\":1,\"336\":1,\"1030\":1}}],[\"basetest\",{\"1\":{\"828\":7,\"830\":2}}],[\"base\",{\"1\":{\"818\":1,\"819\":1}}],[\"basepackage\",{\"1\":{\"815\":1}}],[\"base64\",{\"1\":{\"442\":1,\"447\":1}}],[\"based\",{\"1\":{\"106\":1}}],[\"basiclock\",{\"1\":{\"1023\":2}}],[\"basic\",{\"1\":{\"106\":2,\"183\":1}}],[\"bash\",{\"1\":{\"94\":1,\"109\":1,\"856\":1}}],[\"backward\",{\"1\":{\"628\":1}}],[\"backwards\",{\"1\":{\"388\":1}}],[\"backup\",{\"1\":{\"106\":2}}],[\"backend\",{\"1\":{\"106\":2,\"251\":1,\"1060\":1,\"1266\":1}}],[\"bakend\",{\"1\":{\"106\":4}}],[\"baz\",{\"0\":{\"55\":1},\"1\":{\"16\":1,\"54\":1}}],[\"barrier\",{\"1\":{\"932\":2,\"1104\":8,\"1302\":8}}],[\"bar\",{\"0\":{\"16\":1,\"52\":1},\"1\":{\"53\":1,\"660\":1}}],[\"wfr=spider\",{\"1\":{\"1030\":1}}],[\"wonderful\",{\"1\":{\"940\":1,\"946\":1,\"948\":1}}],[\"word2vec\",{\"1\":{\"1079\":3,\"1283\":3}}],[\"wordcloud\",{\"1\":{\"898\":1}}],[\"world\",{\"1\":{\"604\":3,\"936\":1,\"938\":2,\"940\":1,\"944\":3,\"1150\":2,\"1341\":2}}],[\"working\",{\"1\":{\"932\":6}}],[\"workid\",{\"1\":{\"387\":1}}],[\"workeridshift\",{\"1\":{\"388\":2}}],[\"workeridbits\",{\"1\":{\"388\":4}}],[\"workerid\",{\"1\":{\"387\":2,\"388\":9}}],[\"worker\",{\"1\":{\"106\":4}}],[\"w3\",{\"1\":{\"715\":2,\"812\":1,\"815\":1,\"818\":1,\"819\":1,\"820\":1,\"844\":1,\"865\":3}}],[\"wx\",{\"1\":{\"524\":1,\"920\":1}}],[\"whl\",{\"1\":{\"898\":1}}],[\"whether\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"when>\",{\"1\":{\"785\":2}}],[\"when\",{\"0\":{\"785\":1},\"1\":{\"724\":1,\"725\":2,\"727\":9,\"787\":2,\"1177\":1,\"1362\":1}}],[\"where>\",{\"1\":{\"786\":1}}],[\"where\",{\"0\":{\"526\":1,\"527\":1,\"528\":1,\"531\":1,\"533\":1,\"786\":1},\"1\":{\"498\":1,\"501\":4,\"505\":1,\"506\":1,\"511\":1,\"526\":2,\"528\":3,\"529\":2,\"530\":2,\"531\":2,\"532\":2,\"535\":3,\"555\":3,\"556\":2,\"558\":3,\"571\":1,\"573\":4,\"577\":1,\"578\":1,\"579\":1,\"724\":1,\"725\":1,\"727\":2,\"737\":1,\"744\":1,\"755\":4,\"759\":1,\"763\":4,\"779\":4,\"780\":2,\"782\":4,\"784\":1,\"785\":1,\"786\":1,\"787\":2,\"789\":6,\"790\":1,\"793\":2,\"794\":1,\"795\":1,\"800\":2,\"827\":3,\"958\":2,\"1174\":4,\"1175\":1,\"1177\":1,\"1192\":6,\"1359\":4,\"1360\":1,\"1362\":1,\"1375\":6}}],[\"whitespace\",{\"1\":{\"411\":1}}],[\"while\",{\"1\":{\"286\":11,\"289\":1,\"352\":1,\"377\":1,\"388\":1,\"692\":8,\"737\":1,\"922\":1,\"924\":2,\"928\":2,\"984\":1,\"988\":2,\"1008\":1,\"1018\":1,\"1020\":2,\"1105\":2,\"1303\":2}}],[\"wu\",{\"1\":{\"450\":2,\"451\":6}}],[\"w+\",{\"1\":{\"411\":1}}],[\"wd1w8octswpb0mdykfzbiq\",{\"1\":{\"172\":1}}],[\"wd=javapub\",{\"1\":{\"4\":1}}],[\"wronly|o\",{\"1\":{\"962\":1}}],[\"wrap\",{\"1\":{\"770\":1,\"1020\":1}}],[\"wrappers\",{\"1\":{\"143\":2}}],[\"wrappers=1\",{\"1\":{\"143\":1}}],[\"writer\",{\"1\":{\"143\":1}}],[\"write\",{\"1\":{\"106\":1,\"561\":1,\"572\":2,\"962\":1,\"1020\":1}}],[\"w\",{\"1\":{\"139\":2,\"140\":2,\"333\":1,\"339\":1}}],[\"wget\",{\"1\":{\"125\":1,\"157\":1,\"405\":1,\"408\":1,\"412\":1,\"413\":1,\"598\":1}}],[\"wang\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"wangshiyu\",{\"1\":{\"288\":1,\"289\":1,\"337\":1,\"352\":1,\"825\":2,\"826\":2,\"828\":3,\"829\":5,\"830\":4,\"831\":1,\"849\":2}}],[\"watch无\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"watermark\",{\"1\":{\"1157\":2,\"1161\":1,\"1345\":2,\"1349\":1}}],[\"war\",{\"1\":{\"705\":1,\"1225\":1,\"1400\":1}}],[\"warn\",{\"1\":{\"106\":1,\"191\":2,\"195\":1}}],[\"waiters\",{\"1\":{\"1023\":2}}],[\"waiting\",{\"1\":{\"964\":1,\"1100\":2,\"1298\":2}}],[\"waitset\",{\"1\":{\"1023\":2}}],[\"waits\",{\"1\":{\"580\":1,\"1101\":1,\"1299\":1}}],[\"waits表来查看死锁信息\",{\"1\":{\"580\":1}}],[\"wait\",{\"1\":{\"562\":2,\"648\":2,\"934\":1,\"964\":1,\"988\":13,\"1100\":5,\"1101\":1,\"1298\":5,\"1299\":1}}],[\"wav\",{\"1\":{\"145\":1}}],[\"waypoint>\",{\"1\":{\"865\":19}}],[\"waypoint\",{\"1\":{\"865\":19}}],[\"way\",{\"1\":{\"112\":1}}],[\"win32openssl\",{\"1\":{\"899\":1}}],[\"win\",{\"1\":{\"898\":1}}],[\"windows下\",{\"0\":{\"597\":1}}],[\"windows安装\",{\"0\":{\"124\":1}}],[\"windows\",{\"1\":{\"77\":1,\"597\":1,\"598\":1}}],[\"width=\",{\"1\":{\"865\":6}}],[\"width=device\",{\"1\":{\"832\":1}}],[\"width\",{\"1\":{\"832\":1}}],[\"wikipedia\",{\"1\":{\"343\":1}}],[\"wiki\",{\"1\":{\"122\":1,\"343\":1,\"1422\":1}}],[\"withscores\",{\"1\":{\"607\":4}}],[\"with\",{\"1\":{\"90\":1,\"106\":1,\"440\":3,\"526\":1,\"950\":2,\"964\":1,\"1101\":1,\"1299\":1}}],[\"will\",{\"1\":{\"43\":1}}],[\"weaving\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"weakexample\",{\"1\":{\"936\":1}}],[\"weakreference<>\",{\"1\":{\"936\":1}}],[\"weakreference<example>\",{\"1\":{\"936\":1}}],[\"weakreference<threadlocal<\",{\"1\":{\"928\":1}}],[\"weakhashmap\",{\"1\":{\"922\":1,\"948\":1}}],[\"were\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"welcome\",{\"1\":{\"820\":2,\"831\":1,\"832\":1,\"849\":1}}],[\"weight为weight越大\",{\"1\":{\"106\":1}}],[\"weight和访问比率成正比\",{\"1\":{\"106\":1}}],[\"weight\",{\"1\":{\"106\":1}}],[\"weight=10\",{\"1\":{\"106\":2}}],[\"weight=2\",{\"1\":{\"106\":2}}],[\"weight=3\",{\"1\":{\"106\":2}}],[\"weight参数表示权值\",{\"1\":{\"106\":1}}],[\"weight是权重\",{\"1\":{\"106\":1}}],[\"weixin\",{\"1\":{\"71\":1,\"147\":1,\"172\":1,\"520\":1,\"832\":1,\"1099\":1,\"1184\":1,\"1297\":1,\"1367\":1}}],[\"web服务器对它进行一下三个操作\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"web服务器接收到请求之后\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"web应用的配置对象\",{\"1\":{\"1127\":1,\"1320\":1}}],[\"web项目\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"web项目模板\",{\"1\":{\"704\":1}}],[\"webmvcconfigurer\",{\"1\":{\"1092\":2,\"1136\":1,\"1293\":2,\"1329\":1}}],[\"webmvc<\",{\"1\":{\"812\":1}}],[\"web层\",{\"0\":{\"831\":1}}],[\"web<\",{\"1\":{\"812\":3,\"862\":1,\"885\":1}}],[\"webapp\",{\"1\":{\"704\":2,\"809\":1,\"820\":1}}],[\"websites\",{\"1\":{\"655\":2}}],[\"website\",{\"1\":{\"388\":1,\"659\":4}}],[\"webui\",{\"1\":{\"251\":7,\"252\":3}}],[\"web001\",{\"1\":{\"106\":1}}],[\"web\",{\"0\":{\"819\":1,\"820\":1},\"1\":{\"4\":1,\"94\":1,\"223\":1,\"499\":1,\"811\":1,\"812\":2,\"815\":1,\"819\":6,\"820\":6,\"828\":1,\"831\":5,\"832\":1,\"849\":3,\"876\":3,\"885\":2,\"950\":5,\"956\":1,\"1128\":1,\"1211\":1,\"1321\":1,\"1388\":1,\"1444\":1}}],[\"www4\",{\"1\":{\"4\":1}}],[\"www\",{\"1\":{\"4\":4,\"106\":2,\"136\":1,\"238\":1,\"251\":1,\"385\":1,\"419\":1,\"431\":1,\"435\":1,\"457\":1,\"587\":1,\"605\":1,\"606\":1,\"628\":1,\"633\":1,\"706\":1,\"714\":1,\"715\":2,\"716\":1,\"739\":1,\"812\":1,\"815\":7,\"818\":10,\"819\":10,\"820\":1,\"844\":1,\"860\":1,\"865\":8,\"878\":1,\"898\":1,\"917\":1,\"919\":2,\"1068\":1,\"1072\":1,\"1073\":1,\"1088\":2,\"1212\":1,\"1272\":1,\"1276\":1,\"1277\":1,\"1289\":2,\"1389\":1,\"1439\":1}}],[\"s1cwut9wvusrmyw\",{\"1\":{\"1099\":1,\"1297\":1}}],[\"sb\",{\"1\":{\"1092\":3,\"1293\":3}}],[\"sz\",{\"1\":{\"928\":2}}],[\"sfence\",{\"1\":{\"924\":1}}],[\"skip>\",{\"1\":{\"844\":1}}],[\"skip=true\",{\"1\":{\"705\":1}}],[\"s64\",{\"1\":{\"624\":1}}],[\"sds是\",{\"1\":{\"620\":1}}],[\"sds可以\",{\"1\":{\"620\":1}}],[\"sds不会发生溢出的问题\",{\"1\":{\"620\":1}}],[\"sdshdr数据结构中用len属性记录了字符串的长度\",{\"1\":{\"620\":1}}],[\"sdshdr\",{\"1\":{\"619\":2}}],[\"sds\",{\"1\":{\"619\":10,\"620\":1,\"658\":1}}],[\"sds简单动态字符串好处\",{\"0\":{\"620\":1}}],[\"sds简单动态字符串\",{\"0\":{\"618\":1,\"619\":1},\"1\":{\"613\":1}}],[\"sdiffstore\",{\"1\":{\"606\":1}}],[\"sdiff\",{\"1\":{\"606\":1}}],[\"srem\",{\"1\":{\"606\":1}}],[\"srandmember\",{\"1\":{\"606\":1}}],[\"src\",{\"1\":{\"154\":1}}],[\"smallestnode\",{\"1\":{\"1008\":6}}],[\"smartinstantiationawarebeanpostprocessor\",{\"1\":{\"954\":1}}],[\"sm1234<\",{\"1\":{\"715\":3}}],[\"smove\",{\"1\":{\"606\":1}}],[\"smembers\",{\"1\":{\"606\":1}}],[\"smith\",{\"1\":{\"436\":2}}],[\"safe机制更像是一种对\",{\"1\":{\"1119\":1,\"1314\":1}}],[\"safe\",{\"0\":{\"1119\":1,\"1314\":1},\"1\":{\"1119\":2,\"1314\":2}}],[\"safepoint\",{\"1\":{\"940\":1}}],[\"sanduzxcvbnm\",{\"1\":{\"1068\":1,\"1272\":1}}],[\"sayhello\",{\"1\":{\"944\":2}}],[\"satisfiy小对象分配\",{\"1\":{\"938\":1}}],[\"save\",{\"1\":{\"916\":2,\"962\":3}}],[\"savelog\",{\"1\":{\"689\":2}}],[\"saxparseexception\",{\"1\":{\"800\":1}}],[\"sax\",{\"1\":{\"800\":1}}],[\"saparator\",{\"1\":{\"787\":1}}],[\"sadd\",{\"1\":{\"606\":1}}],[\"same\",{\"1\":{\"339\":1}}],[\"sample\",{\"1\":{\"144\":1,\"157\":1}}],[\"slot\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"slow\",{\"1\":{\"1023\":2,\"1185\":1,\"1368\":1}}],[\"slproweb\",{\"1\":{\"899\":1}}],[\"sleep方法属于thread类中方法\",{\"1\":{\"1100\":1,\"1298\":1}}],[\"sleep方法和wait方法有什么区别\",{\"0\":{\"1100\":1,\"1298\":1}}],[\"sleep\",{\"1\":{\"692\":3,\"988\":8,\"1008\":1,\"1100\":2,\"1104\":2,\"1105\":2,\"1298\":2,\"1302\":2,\"1303\":2}}],[\"slave节点接收到写入命令后将master发送过来的文件加载并写入\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"slave\",{\"1\":{\"589\":1,\"592\":1,\"1186\":1,\"1205\":3,\"1369\":1,\"1385\":3}}],[\"slf4j<\",{\"1\":{\"708\":1,\"709\":1,\"715\":1}}],[\"slf4j\",{\"0\":{\"194\":1},\"1\":{\"194\":3,\"689\":3,\"715\":2,\"830\":2,\"831\":2}}],[\"snippet\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"snapshot<\",{\"1\":{\"708\":1,\"715\":3,\"812\":1,\"844\":1}}],[\"snapshot\",{\"1\":{\"575\":1,\"703\":3,\"704\":2}}],[\"snowflakeid\",{\"1\":{\"388\":1}}],[\"snowflakeidworker\",{\"1\":{\"388\":5}}],[\"snowflake每秒能够产生26万id左右\",{\"1\":{\"388\":1}}],[\"snowflake的优点是\",{\"1\":{\"388\":1}}],[\"snowflake的结构如下\",{\"1\":{\"388\":1}}],[\"snowflake<br>\",{\"1\":{\"388\":1}}],[\"snowflake可以保证\",{\"1\":{\"387\":1}}],[\"snowflake算法生成id的结果是一个64bit大小的整数\",{\"1\":{\"387\":1}}],[\"snowflake\",{\"0\":{\"386\":1},\"1\":{\"387\":2}}],[\"s锁\",{\"1\":{\"555\":1,\"575\":1}}],[\"swing程序中\",{\"1\":{\"1133\":1,\"1326\":1}}],[\"swing\",{\"1\":{\"1018\":1}}],[\"switch\",{\"1\":{\"200\":1}}],[\"sweep\",{\"1\":{\"938\":2,\"1150\":1,\"1341\":1}}],[\"sweep算法\",{\"1\":{\"936\":1}}],[\"swap的缩写\",{\"1\":{\"1018\":1}}],[\"swap\",{\"1\":{\"364\":3}}],[\"sql优化方式\",{\"0\":{\"1192\":1,\"1375\":1}}],[\"sql中的drop\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"sql执行线程\",{\"1\":{\"1186\":1,\"1369\":1}}],[\"sql>\",{\"1\":{\"782\":3}}],[\"sql片段也可以定义在单独的\",{\"1\":{\"782\":1}}],[\"sql片段\",{\"0\":{\"782\":1}}],[\"sqlsession\",{\"1\":{\"747\":8,\"754\":12,\"757\":8,\"763\":4,\"789\":3,\"790\":4,\"958\":7,\"1179\":2,\"1364\":2}}],[\"sqlsessionfactorybeanname\",{\"1\":{\"815\":1}}],[\"sqlsessionfactorybean\",{\"1\":{\"815\":1}}],[\"sqlsessionfactorybuilder\",{\"1\":{\"746\":1,\"747\":2,\"757\":2,\"763\":2,\"766\":3,\"958\":1}}],[\"sqlsessionfactory\",{\"1\":{\"746\":2,\"747\":5,\"757\":4,\"763\":4,\"766\":2,\"771\":1,\"790\":1,\"815\":3,\"958\":2,\"1179\":1,\"1364\":1}}],[\"sql语句中某个参数进行占位的时候\",{\"1\":{\"779\":1}}],[\"sql语句动态生成的时候\",{\"1\":{\"779\":1}}],[\"sql语句查询结果集的封装类型\",{\"1\":{\"744\":1,\"755\":1,\"763\":1}}],[\"sql语句\",{\"1\":{\"744\":1,\"755\":1,\"763\":1,\"1444\":1}}],[\"sql结构体\",{\"1\":{\"726\":1}}],[\"sql篇\",{\"0\":{\"525\":1}}],[\"sql\",{\"0\":{\"536\":2,\"572\":1,\"588\":1,\"824\":1,\"1177\":2,\"1362\":2},\"1\":{\"501\":2,\"525\":3,\"571\":1,\"737\":6,\"772\":1,\"815\":1,\"864\":1,\"958\":13,\"1174\":2,\"1175\":1,\"1176\":1,\"1177\":6,\"1179\":5,\"1359\":2,\"1360\":1,\"1361\":1,\"1362\":6,\"1364\":5,\"1444\":3}}],[\"sqqueue<character>\",{\"1\":{\"288\":2}}],[\"sqqueue<t>\",{\"1\":{\"288\":1}}],[\"sqqueue\",{\"1\":{\"288\":1}}],[\"squid2\",{\"1\":{\"106\":1}}],[\"squid1\",{\"1\":{\"106\":1}}],[\"sss\",{\"1\":{\"821\":1}}],[\"ssm实例\",{\"0\":{\"823\":1}}],[\"ssm1\",{\"1\":{\"816\":1,\"824\":1}}],[\"ssm\",{\"1\":{\"807\":1,\"822\":1,\"824\":1,\"832\":2},\"2\":{\"833\":1}}],[\"ssh\",{\"1\":{\"716\":1}}],[\"sscan\",{\"1\":{\"606\":1}}],[\"ss\",{\"1\":{\"127\":1,\"129\":2,\"141\":1,\"800\":2,\"801\":2,\"821\":1}}],[\"ssl\",{\"1\":{\"106\":8,\"406\":1,\"852\":1,\"1032\":1}}],[\"spider\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"spinearly\",{\"1\":{\"1023\":2}}],[\"spinduration\",{\"1\":{\"1023\":2}}],[\"spinclock\",{\"1\":{\"1023\":2}}],[\"spinfreq\",{\"1\":{\"1023\":2}}],[\"sping\",{\"1\":{\"832\":1}}],[\"split\",{\"1\":{\"922\":1,\"1165\":1,\"1353\":1}}],[\"specs\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"spec\",{\"1\":{\"865\":4}}],[\"specifies\",{\"1\":{\"106\":1}}],[\"span\",{\"1\":{\"628\":1}}],[\"space\",{\"1\":{\"112\":1,\"871\":1,\"889\":1}}],[\"spop\",{\"1\":{\"606\":1}}],[\"spdx\",{\"1\":{\"487\":1,\"488\":1}}],[\"springapplicationadminjmxautoconfiguration\",{\"1\":{\"1232\":1,\"1407\":1}}],[\"springcloud\",{\"1\":{\"1226\":1,\"1401\":1}}],[\"spring如何处理这些事务的行为\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"spring如何解决循环依赖问题\",{\"0\":{\"1219\":1,\"1396\":1}}],[\"spring的事务传播机制\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"spring的applicationcontext中配置所有的datasource\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"spring的aop中\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"spring支持编程式事务管理和声明式事务管理两种方式\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"spring会在事务开始时\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"spring会检测该对象是否实现了xxxaware接口\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"spring只提供统一事务管理接口\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"spring是无法提供事务功能的\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"spring是针对bean的生命周期进行管理的轻量级容器\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"spring事务的传播机制说的是\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"spring事务的种类\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"spring事务的本质其实就是数据库对事务的支持\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"spring事务的实现方式和实现原理\",{\"0\":{\"1220\":1,\"1397\":1}}],[\"spring提前暴露的bean实例的引用在第三级缓存中进行存储\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"spring提供对jdbc的支持\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"spring在单例模式下的setter方法依赖注入引起的循环依赖问题\",{\"1\":{\"1219\":1,\"1396\":1}}],[\"spring允许引入新的接口\",{\"1\":{\"1217\":1,\"1394\":1}}],[\"spring实现aop功能的原理就是代理模式\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"spring用的是双重判断加锁的单例模式\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"spring器中的bean可以分为5个范围\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"spring中的隔离级别\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"spring中的beanfactory就是简单工厂模式的体现\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"spring中的bean的生命周期主要包含四个阶段\",{\"1\":{\"1214\":1,\"1391\":1}}],[\"spring中观察者模式一般用在listener的实现\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"spring中都应用了哪些设计模式\",{\"0\":{\"1216\":1,\"1393\":1}}],[\"spring中超级常用的注解有\",{\"1\":{\"944\":1}}],[\"spring有七大功能模块\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"spring循环依赖\",{\"0\":{\"954\":1}}],[\"springbean生命周期\",{\"0\":{\"952\":1}}],[\"springboot数据库信息配置\",{\"1\":{\"1444\":1}}],[\"springboot3\",{\"1\":{\"1444\":1}}],[\"springboot如何整合mybatis\",{\"1\":{\"1442\":1}}],[\"springboot整合mybatis\",{\"0\":{\"1442\":1}}],[\"springboot启动时都做了什么\",{\"0\":{\"1230\":1,\"1405\":1}}],[\"springboot启动的时候加载主配置类\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"springboot就能够在底层默认其配置\",{\"1\":{\"1229\":1,\"1404\":1}}],[\"springboot更像是一个管家\",{\"1\":{\"1229\":1,\"1404\":1}}],[\"springbootconfiguration\",{\"1\":{\"1227\":1,\"1402\":1}}],[\"springboot+vue\",{\"1\":{\"1062\":1,\"1268\":1}}],[\"springbootapplication\",{\"1\":{\"944\":1,\"1227\":1,\"1402\":1}}],[\"springbootannotation\",{\"1\":{\"686\":1,\"688\":1,\"689\":3}}],[\"springboot中常用的注解有\",{\"1\":{\"944\":1}}],[\"springboot中常见的注解也说一下\",{\"1\":{\"944\":1}}],[\"springboot的ip和端口号\",{\"1\":{\"887\":1}}],[\"springboot的pom\",{\"0\":{\"843\":1}}],[\"springboot加速初始化\",{\"1\":{\"885\":1}}],[\"springboot工程初始化\",{\"0\":{\"885\":1}}],[\"springbootqr\",{\"1\":{\"876\":2}}],[\"springboot生成二维码的正确姿势\",{\"0\":{\"870\":1,\"871\":1}}],[\"springbootdocker\",{\"1\":{\"849\":1}}],[\"springboot2\",{\"0\":{\"394\":1,\"397\":1,\"411\":1,\"428\":1,\"460\":1,\"847\":1,\"881\":1},\"1\":{\"411\":2,\"428\":2,\"460\":2,\"881\":1,\"885\":1}}],[\"springboot\",{\"0\":{\"399\":1,\"401\":1,\"834\":1,\"850\":1,\"873\":1,\"1223\":1,\"1229\":1,\"1231\":1,\"1232\":1,\"1398\":1,\"1404\":1,\"1406\":1,\"1407\":1},\"1\":{\"394\":1,\"681\":1,\"690\":1,\"836\":2,\"844\":4,\"856\":1,\"867\":1,\"878\":1,\"885\":1,\"1030\":1,\"1223\":3,\"1225\":1,\"1226\":2,\"1229\":1,\"1230\":2,\"1231\":2,\"1400\":1,\"1401\":2,\"1404\":1,\"1405\":2,\"1406\":2,\"1443\":1,\"1444\":2},\"2\":{\"392\":1,\"393\":1,\"395\":1,\"396\":1,\"409\":1,\"410\":1,\"426\":1,\"427\":1,\"458\":1,\"459\":1,\"476\":1,\"477\":1,\"841\":1,\"842\":1,\"845\":1,\"846\":1,\"857\":1,\"858\":1,\"868\":1,\"869\":1,\"879\":1,\"880\":1,\"890\":1,\"891\":1,\"1235\":1,\"1446\":1}}],[\"springbootes\",{\"1\":{\"377\":1}}],[\"spring基础\",{\"0\":{\"950\":1}}],[\"springmv\",{\"1\":{\"1443\":1}}],[\"springmvc请求处理流程\",{\"1\":{\"956\":1}}],[\"springmvc\",{\"0\":{\"956\":1},\"1\":{\"820\":1,\"956\":11,\"1229\":1,\"1404\":1}}],[\"springmetrics\",{\"1\":{\"885\":2}}],[\"spring配置文件\",{\"1\":{\"828\":1}}],[\"springjunit4classrunner\",{\"1\":{\"828\":2}}],[\"spring核心\",{\"1\":{\"812\":1}}],[\"spring<\",{\"1\":{\"812\":1}}],[\"springframework<\",{\"1\":{\"709\":1,\"710\":2,\"715\":3,\"812\":8}}],[\"springframework\",{\"1\":{\"687\":1,\"689\":1,\"815\":6,\"818\":10,\"819\":11,\"820\":1,\"828\":4,\"830\":4,\"831\":4,\"844\":4,\"849\":3,\"862\":1,\"876\":2,\"885\":2,\"1092\":1,\"1232\":2,\"1293\":1,\"1407\":2}}],[\"spring\",{\"0\":{\"804\":1,\"815\":1,\"818\":1,\"819\":1,\"1211\":2,\"1212\":1,\"1214\":1,\"1215\":1,\"1217\":1,\"1224\":1,\"1225\":1,\"1226\":1,\"1227\":1,\"1229\":1,\"1387\":1,\"1388\":2,\"1389\":1,\"1391\":1,\"1392\":1,\"1394\":1,\"1399\":1,\"1400\":1,\"1401\":1,\"1402\":1,\"1404\":1},\"1\":{\"401\":6,\"524\":4,\"681\":1,\"690\":1,\"709\":2,\"710\":1,\"715\":5,\"772\":1,\"807\":3,\"812\":13,\"815\":4,\"818\":6,\"819\":5,\"820\":6,\"827\":1,\"828\":5,\"837\":5,\"838\":1,\"844\":6,\"856\":1,\"862\":1,\"864\":1,\"889\":1,\"950\":29,\"952\":26,\"954\":16,\"956\":1,\"1092\":2,\"1133\":8,\"1210\":2,\"1214\":1,\"1216\":1,\"1224\":1,\"1225\":1,\"1227\":1,\"1228\":2,\"1229\":1,\"1232\":10,\"1233\":3,\"1293\":2,\"1326\":8,\"1391\":1,\"1393\":1,\"1399\":1,\"1400\":1,\"1402\":1,\"1403\":2,\"1404\":1,\"1407\":10,\"1408\":3,\"1431\":1,\"1443\":1,\"1444\":2},\"2\":{\"805\":1,\"806\":1,\"833\":1,\"1222\":1}}],[\"shanghai\",{\"1\":{\"1444\":1}}],[\"shape\",{\"1\":{\"454\":1}}],[\"sharing\",{\"1\":{\"1136\":1,\"1329\":1}}],[\"share\",{\"1\":{\"555\":2,\"558\":2,\"575\":1}}],[\"shared\",{\"1\":{\"106\":1,\"125\":1,\"575\":1}}],[\"shards\",{\"1\":{\"1071\":1,\"1072\":1,\"1275\":1,\"1276\":1}}],[\"shardid\",{\"1\":{\"1004\":4}}],[\"shard故障或者node宕机时\",{\"1\":{\"422\":1}}],[\"shard\",{\"0\":{\"421\":1},\"1\":{\"422\":10,\"1002\":1,\"1004\":2,\"1071\":1,\"1275\":1}}],[\"should\",{\"1\":{\"1101\":4,\"1216\":1,\"1299\":4,\"1393\":1}}],[\"shoshana\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"short\",{\"1\":{\"444\":1,\"982\":1,\"1085\":1,\"1286\":1}}],[\"show\",{\"1\":{\"140\":2,\"143\":2,\"506\":2,\"511\":1,\"581\":2,\"916\":5}}],[\"sh连接客户端\",{\"1\":{\"159\":1}}],[\"shtml\",{\"1\":{\"136\":1}}],[\"sh\",{\"1\":{\"109\":1,\"158\":4,\"159\":5,\"247\":2,\"852\":1}}],[\"stmt\",{\"1\":{\"1176\":4,\"1361\":4}}],[\"stw\",{\"1\":{\"940\":2}}],[\"step\",{\"1\":{\"885\":1}}],[\"stereotype\",{\"1\":{\"689\":1,\"830\":1,\"876\":1}}],[\"stdoutimpl\",{\"1\":{\"1444\":1}}],[\"stdout\",{\"1\":{\"821\":2,\"1444\":1}}],[\"stdio\",{\"1\":{\"619\":1}}],[\"student\",{\"1\":{\"827\":3,\"1177\":6,\"1181\":2,\"1219\":3,\"1362\":6,\"1366\":2,\"1396\":3}}],[\"studentid=1234567890\",{\"1\":{\"831\":1}}],[\"studentid\",{\"1\":{\"825\":1,\"826\":6,\"827\":2,\"828\":4,\"830\":7,\"831\":6}}],[\"studio\",{\"0\":{\"235\":1,\"238\":1},\"1\":{\"238\":1},\"2\":{\"236\":1,\"237\":1}}],[\"stub\",{\"1\":{\"106\":1,\"1107\":1,\"1305\":1}}],[\"styled\",{\"1\":{\"152\":1}}],[\"storage\",{\"1\":{\"526\":1,\"1073\":1,\"1277\":1}}],[\"storeload\",{\"1\":{\"924\":1}}],[\"storestore\",{\"1\":{\"924\":1}}],[\"store\",{\"1\":{\"112\":2,\"440\":2,\"447\":1,\"614\":1,\"924\":4}}],[\"stopping\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"stope\",{\"1\":{\"692\":4}}],[\"stop\",{\"1\":{\"114\":1,\"411\":1,\"604\":2,\"607\":3,\"936\":1,\"1101\":5,\"1150\":2,\"1299\":5,\"1341\":2}}],[\"strongrefs\",{\"1\":{\"936\":1,\"938\":1,\"940\":1}}],[\"strongly\",{\"1\":{\"112\":1}}],[\"strs如果子类可以随意加载\",{\"1\":{\"934\":1}}],[\"struts\",{\"1\":{\"950\":1}}],[\"struts<\",{\"1\":{\"709\":1,\"710\":1}}],[\"struct\",{\"1\":{\"619\":1,\"621\":4,\"624\":5,\"628\":4,\"630\":1,\"635\":3}}],[\"structure\",{\"1\":{\"152\":1,\"614\":1,\"824\":2}}],[\"strict\",{\"1\":{\"431\":2}}],[\"string是immutable类的典型实现\",{\"1\":{\"1089\":1,\"1290\":1}}],[\"stringbuilder就是解决string的这个性能问题\",{\"1\":{\"1089\":1,\"1290\":1}}],[\"stringbuilder\",{\"0\":{\"1089\":1,\"1290\":1},\"1\":{\"1092\":2,\"1293\":2}}],[\"stringbuffer\",{\"0\":{\"1089\":1,\"1290\":1},\"1\":{\"1089\":3,\"1290\":3}}],[\"string>\",{\"1\":{\"984\":3,\"990\":4}}],[\"string>>\",{\"1\":{\"982\":1}}],[\"stringdeserializer\",{\"1\":{\"984\":2,\"990\":3}}],[\"stringserializer\",{\"1\":{\"990\":3}}],[\"strings\",{\"0\":{\"603\":1},\"1\":{\"593\":1,\"601\":1}}],[\"stringutils\",{\"1\":{\"388\":3,\"952\":1}}],[\"string\",{\"0\":{\"653\":1,\"1089\":1,\"1290\":1},\"1\":{\"192\":2,\"195\":1,\"198\":2,\"288\":1,\"289\":1,\"337\":10,\"352\":1,\"364\":1,\"377\":1,\"388\":5,\"443\":1,\"603\":1,\"605\":1,\"606\":1,\"607\":1,\"619\":2,\"648\":2,\"653\":1,\"658\":1,\"688\":1,\"689\":2,\"692\":2,\"737\":5,\"746\":1,\"747\":20,\"753\":2,\"754\":2,\"757\":1,\"763\":5,\"779\":6,\"780\":2,\"784\":1,\"785\":1,\"786\":1,\"787\":2,\"789\":7,\"790\":1,\"792\":1,\"793\":6,\"794\":2,\"795\":3,\"825\":1,\"829\":10,\"830\":2,\"831\":2,\"849\":2,\"876\":4,\"928\":1,\"932\":2,\"934\":1,\"944\":3,\"952\":4,\"956\":1,\"960\":1,\"984\":1,\"988\":3,\"990\":3,\"992\":3,\"1004\":3,\"1008\":6,\"1010\":3,\"1016\":1,\"1020\":5,\"1085\":1,\"1086\":10,\"1092\":7,\"1104\":2,\"1105\":1,\"1107\":1,\"1176\":1,\"1216\":1,\"1228\":1,\"1286\":1,\"1287\":10,\"1293\":7,\"1302\":2,\"1303\":1,\"1305\":1,\"1361\":1,\"1393\":1,\"1403\":1,\"1431\":4}}],[\"streaming\",{\"1\":{\"252\":1}}],[\"streamname\",{\"1\":{\"146\":1}}],[\"streamname`\",{\"1\":{\"146\":1}}],[\"stream=nb\",{\"1\":{\"143\":1}}],[\"streams\",{\"1\":{\"143\":2,\"1198\":1,\"1378\":1}}],[\"stream\",{\"1\":{\"106\":1,\"143\":1,\"876\":12}}],[\"stable\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"staleslot\",{\"1\":{\"928\":4}}],[\"stash命令\",{\"1\":{\"916\":1}}],[\"stash列表中的信息进行删除\",{\"1\":{\"916\":1}}],[\"stash翻译\",{\"1\":{\"916\":1}}],[\"stash\",{\"0\":{\"916\":1},\"1\":{\"916\":33}}],[\"standard\",{\"1\":{\"411\":1}}],[\"stacks\",{\"1\":{\"1142\":2,\"1333\":2}}],[\"stack<>\",{\"1\":{\"946\":1}}],[\"stack<integer>\",{\"1\":{\"946\":1}}],[\"stack\",{\"1\":{\"400\":2,\"946\":2,\"1023\":2,\"1101\":1,\"1112\":1,\"1142\":1,\"1299\":1,\"1307\":1,\"1333\":1}}],[\"stateenum\",{\"1\":{\"829\":6}}],[\"stateof\",{\"1\":{\"829\":1}}],[\"stateinfo\",{\"1\":{\"829\":8}}],[\"state\",{\"1\":{\"829\":11,\"932\":2,\"958\":1,\"1101\":1,\"1216\":1,\"1299\":1,\"1393\":1}}],[\"statement时候\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"statementhandler\",{\"1\":{\"770\":1}}],[\"statement的parametertype必须和mapper接口方法的参数类型一致\",{\"1\":{\"763\":1}}],[\"statement的resulttype必须和mapper接口方法的返回类型一致\",{\"1\":{\"763\":1}}],[\"statement\",{\"1\":{\"527\":1,\"744\":1,\"755\":1,\"761\":1,\"763\":1,\"958\":2,\"1216\":1,\"1393\":1}}],[\"statistics\",{\"1\":{\"506\":2}}],[\"static\",{\"1\":{\"79\":2,\"80\":2,\"83\":2,\"84\":2,\"106\":1,\"194\":1,\"288\":1,\"289\":1,\"337\":8,\"340\":2,\"352\":2,\"364\":1,\"377\":2,\"388\":6,\"648\":12,\"692\":2,\"737\":1,\"747\":1,\"790\":1,\"829\":1,\"887\":2,\"928\":6,\"932\":3,\"934\":4,\"946\":1,\"948\":3,\"966\":1,\"984\":1,\"990\":3,\"1008\":2,\"1016\":1,\"1020\":5,\"1023\":19,\"1085\":6,\"1086\":1,\"1100\":1,\"1104\":3,\"1105\":4,\"1107\":1,\"1286\":6,\"1287\":1,\"1298\":1,\"1302\":3,\"1303\":4,\"1305\":1}}],[\"status`\",{\"1\":{\"726\":1}}],[\"status为1\",{\"1\":{\"724\":1}}],[\"status为0\",{\"1\":{\"724\":1}}],[\"status命令\",{\"1\":{\"511\":1}}],[\"status\",{\"1\":{\"94\":1,\"106\":1,\"158\":1,\"511\":1,\"581\":1,\"724\":1,\"725\":1,\"794\":1,\"795\":2,\"801\":4,\"916\":3,\"1431\":9}}],[\"star\",{\"1\":{\"49\":2,\"1431\":1,\"1439\":1,\"1444\":1}}],[\"start>\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"starttls\",{\"1\":{\"1032\":1}}],[\"starttime\",{\"1\":{\"388\":2}}],[\"startup>\",{\"1\":{\"820\":1}}],[\"startup>1<\",{\"1\":{\"820\":1}}],[\"startdatetime\",{\"1\":{\"800\":2,\"801\":1}}],[\"startevent>\",{\"1\":{\"865\":1}}],[\"started\",{\"1\":{\"739\":1,\"1020\":1}}],[\"starter<\",{\"1\":{\"844\":1,\"862\":1,\"1444\":1}}],[\"starter\",{\"1\":{\"687\":1,\"844\":1,\"862\":1,\"885\":2,\"1092\":1,\"1232\":8,\"1293\":1,\"1407\":8}}],[\"start|start\",{\"1\":{\"158\":1}}],[\"start\",{\"0\":{\"156\":1,\"741\":1,\"1098\":1,\"1296\":1},\"1\":{\"1\":1,\"109\":1,\"114\":1,\"158\":1,\"192\":1,\"555\":1,\"556\":2,\"558\":2,\"559\":1,\"571\":1,\"573\":2,\"604\":2,\"607\":3,\"692\":3,\"800\":3,\"837\":2,\"838\":1,\"865\":4,\"873\":1,\"885\":1,\"928\":2,\"932\":2,\"952\":2,\"964\":1,\"1104\":3,\"1105\":2,\"1107\":3,\"1302\":3,\"1303\":2,\"1305\":3}}],[\"sistem\",{\"1\":{\"950\":1}}],[\"sismember\",{\"1\":{\"606\":1}}],[\"site生命周期包含如下4个阶段\",{\"1\":{\"714\":1}}],[\"site生命周期\",{\"0\":{\"714\":1}}],[\"site\",{\"1\":{\"711\":2,\"714\":4,\"913\":1,\"1137\":1,\"1330\":1}}],[\"sicily\",{\"1\":{\"660\":5}}],[\"signature\",{\"1\":{\"689\":3,\"770\":1}}],[\"sign\",{\"1\":{\"658\":3}}],[\"significant\",{\"1\":{\"374\":2}}],[\"singapore\",{\"1\":{\"1444\":1}}],[\"singletonfactories\",{\"1\":{\"1216\":2,\"1393\":2}}],[\"singletonfactory\",{\"1\":{\"1216\":3,\"1393\":3}}],[\"singletonobjects\",{\"1\":{\"1216\":2,\"1393\":2}}],[\"singletonobject\",{\"1\":{\"1216\":8,\"1393\":8}}],[\"singletons\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"singletonlist\",{\"1\":{\"984\":1}}],[\"singleton\",{\"1\":{\"84\":6,\"952\":3,\"954\":1,\"982\":1,\"990\":1,\"1099\":1,\"1215\":1,\"1216\":3,\"1297\":1,\"1392\":1,\"1393\":3}}],[\"sinterstore\",{\"1\":{\"606\":1}}],[\"sinter\",{\"1\":{\"606\":1}}],[\"simply\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"simpledateformat\",{\"1\":{\"747\":1}}],[\"simple\",{\"1\":{\"152\":1,\"411\":1,\"619\":1,\"896\":2}}],[\"similarity\",{\"1\":{\"440\":1}}],[\"size是10\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"size增加\",{\"1\":{\"922\":1}}],[\"sizemask\",{\"1\":{\"624\":1}}],[\"size++\",{\"1\":{\"285\":2,\"286\":2,\"946\":1,\"948\":1}}],[\"size设置\",{\"1\":{\"106\":1}}],[\"size这个buffer来读取header值\",{\"1\":{\"106\":1}}],[\"size的提示\",{\"1\":{\"106\":1}}],[\"size等于一路处理器缓存的大小\",{\"1\":{\"106\":1}}],[\"size总是等于hash表的大小\",{\"1\":{\"106\":1}}],[\"size所控制的\",{\"1\":{\"106\":1}}],[\"size\",{\"1\":{\"106\":11,\"134\":1,\"285\":19,\"286\":8,\"337\":3,\"353\":1,\"624\":2,\"928\":5,\"946\":2,\"1020\":2,\"1044\":1,\"1072\":7,\"1085\":1,\"1253\":1,\"1276\":7,\"1286\":1}}],[\"size该值必须设置为\",{\"1\":{\"106\":1}}],[\"size超过4k的情况\",{\"1\":{\"106\":1}}],[\"scheme\",{\"1\":{\"887\":1}}],[\"schemalocation=\",{\"1\":{\"715\":2,\"812\":1,\"815\":1,\"818\":1,\"819\":1,\"820\":1,\"844\":1}}],[\"schema数据库中的innodb\",{\"1\":{\"580\":1}}],[\"schema\",{\"1\":{\"79\":1,\"80\":1,\"83\":1,\"84\":1,\"429\":1,\"506\":5,\"511\":5,\"580\":1,\"815\":6,\"818\":9,\"819\":9,\"864\":2,\"1444\":1}}],[\"scoring\",{\"1\":{\"1002\":1}}],[\"score2\",{\"1\":{\"607\":1}}],[\"score1\",{\"1\":{\"607\":1}}],[\"score\",{\"1\":{\"607\":1,\"628\":1,\"657\":1,\"1177\":3,\"1362\":3}}],[\"scope=\",{\"1\":{\"952\":2}}],[\"scope\",{\"1\":{\"952\":1}}],[\"scope>\",{\"1\":{\"715\":2,\"812\":2,\"844\":2,\"1444\":1}}],[\"scm\",{\"1\":{\"705\":1}}],[\"scalable=no\",{\"1\":{\"832\":1}}],[\"scale\",{\"1\":{\"922\":1,\"1073\":1,\"1277\":1}}],[\"scale=1\",{\"1\":{\"832\":3}}],[\"scale=960\",{\"1\":{\"138\":1}}],[\"scaled\",{\"1\":{\"444\":2}}],[\"scan\",{\"1\":{\"818\":1,\"819\":1}}],[\"scard\",{\"1\":{\"606\":1}}],[\"scroll\",{\"1\":{\"1072\":2,\"1276\":2}}],[\"scraped\",{\"1\":{\"887\":1}}],[\"scrape\",{\"1\":{\"887\":6}}],[\"scratch\",{\"1\":{\"152\":1}}],[\"scripting\",{\"1\":{\"601\":1}}],[\"script\",{\"1\":{\"106\":2}}],[\"scripts$fastcgi\",{\"1\":{\"106\":1}}],[\"scripts\",{\"1\":{\"106\":2}}],[\"scp\",{\"1\":{\"94\":1}}],[\"survivor\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"survivorratio=8\",{\"1\":{\"1151\":1,\"1342\":1}}],[\"survivor区1和survivor区2三个部分\",{\"1\":{\"930\":1}}],[\"supported\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"supports\",{\"1\":{\"956\":2,\"1220\":1,\"1397\":1}}],[\"support\",{\"1\":{\"940\":1}}],[\"super\",{\"1\":{\"829\":6,\"928\":1,\"966\":2}}],[\"succ\",{\"1\":{\"1023\":2}}],[\"success\",{\"1\":{\"829\":1,\"830\":8,\"1431\":5}}],[\"such\",{\"1\":{\"152\":1}}],[\"suffixoverrides\",{\"1\":{\"724\":2,\"787\":1}}],[\"suffixoverrides=\",{\"1\":{\"724\":1,\"727\":1,\"755\":1,\"763\":1,\"786\":1}}],[\"suffix\",{\"1\":{\"724\":2,\"787\":1,\"819\":1}}],[\"suffix=\",{\"1\":{\"724\":1,\"727\":2}}],[\"sunionstore\",{\"1\":{\"606\":1}}],[\"sunion\",{\"1\":{\"606\":1}}],[\"sunke\",{\"1\":{\"436\":3}}],[\"subclass\",{\"1\":{\"950\":1}}],[\"sublist\",{\"1\":{\"946\":1}}],[\"subscribe\",{\"1\":{\"593\":1,\"984\":1,\"990\":1}}],[\"substring\",{\"1\":{\"532\":1}}],[\"sub\",{\"1\":{\"198\":1,\"506\":1}}],[\"sudo\",{\"1\":{\"94\":1}}],[\"summary\",{\"1\":{\"883\":1}}],[\"sums\",{\"1\":{\"388\":6}}],[\"sum\",{\"1\":{\"35\":1}}],[\"semaphore\",{\"1\":{\"1107\":1,\"1305\":1}}],[\"se8\",{\"1\":{\"1084\":1,\"1285\":1}}],[\"segement中\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"segement\",{\"1\":{\"1071\":1,\"1275\":1}}],[\"segment中\",{\"1\":{\"1190\":1,\"1373\":1}}],[\"segment\",{\"1\":{\"440\":1,\"1167\":2,\"1355\":2}}],[\"selinux\",{\"1\":{\"852\":2}}],[\"selectimports\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"selectionkey\",{\"1\":{\"1020\":5}}],[\"selectauthorlinkedhashmap\",{\"1\":{\"1175\":1,\"1360\":1}}],[\"selectedkeys\",{\"1\":{\"1020\":1}}],[\"selector\",{\"1\":{\"1020\":13}}],[\"selectone\",{\"1\":{\"747\":2,\"754\":1}}],[\"selectgarbagecollectioncandidates\",{\"1\":{\"940\":1}}],[\"select中的几个属性说明\",{\"1\":{\"775\":1}}],[\"selectlist\",{\"1\":{\"754\":1}}],[\"select>\",{\"1\":{\"744\":1,\"755\":3,\"759\":1,\"763\":4,\"779\":7,\"780\":2,\"782\":4,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"793\":2,\"794\":1,\"795\":1,\"827\":3,\"958\":2,\"1175\":1,\"1360\":1}}],[\"selectuser\",{\"1\":{\"744\":1,\"747\":2,\"958\":3}}],[\"select\",{\"0\":{\"537\":1,\"540\":1,\"542\":1,\"571\":1,\"775\":1},\"1\":{\"143\":2,\"178\":1,\"501\":3,\"505\":1,\"506\":1,\"511\":1,\"526\":2,\"527\":1,\"528\":3,\"529\":2,\"530\":2,\"531\":2,\"532\":2,\"535\":4,\"542\":2,\"555\":4,\"556\":3,\"558\":3,\"571\":1,\"573\":2,\"578\":1,\"580\":1,\"737\":1,\"744\":1,\"755\":3,\"759\":1,\"763\":4,\"772\":2,\"775\":1,\"779\":8,\"780\":2,\"782\":4,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"789\":5,\"790\":1,\"793\":2,\"794\":1,\"795\":1,\"800\":2,\"827\":4,\"958\":2,\"1020\":1,\"1174\":4,\"1175\":1,\"1180\":1,\"1181\":3,\"1191\":6,\"1359\":4,\"1360\":1,\"1365\":1,\"1366\":3,\"1374\":6}}],[\"select=between\",{\"1\":{\"141\":1}}],[\"secureclassloader\",{\"1\":{\"934\":2}}],[\"security\",{\"1\":{\"406\":2}}],[\"second\",{\"1\":{\"887\":1}}],[\"seconds\",{\"1\":{\"887\":2,\"960\":2,\"1206\":1,\"1386\":1}}],[\"seckill\",{\"1\":{\"831\":1}}],[\"serializer\",{\"1\":{\"990\":2}}],[\"serialization\",{\"1\":{\"948\":1,\"984\":2,\"990\":2}}],[\"serializable\",{\"1\":{\"790\":1,\"946\":1,\"1187\":1,\"1220\":1,\"1370\":1,\"1397\":1}}],[\"serial\",{\"1\":{\"936\":1,\"1151\":2,\"1342\":2}}],[\"serialversionuid\",{\"1\":{\"790\":1}}],[\"serve\",{\"1\":{\"912\":2}}],[\"servertimezone=asia\",{\"1\":{\"1444\":1}}],[\"serverbootstrap\",{\"1\":{\"1034\":1}}],[\"serverchannel\",{\"1\":{\"1020\":4}}],[\"serversocketchannel\",{\"1\":{\"1020\":5}}],[\"servers\",{\"1\":{\"984\":1,\"990\":5}}],[\"serverlog\",{\"1\":{\"964\":1}}],[\"server中的用法\",{\"1\":{\"542\":1}}],[\"server3的zxid为122\",{\"1\":{\"166\":1}}],[\"server3三台服务器\",{\"1\":{\"166\":1}}],[\"server语句中不能写入weight等其他的参数\",{\"1\":{\"106\":1}}],[\"server2而言\",{\"1\":{\"166\":1}}],[\"server2的投票为\",{\"1\":{\"166\":1}}],[\"server2\",{\"1\":{\"106\":1,\"166\":1}}],[\"server1将会成为leader\",{\"1\":{\"166\":1}}],[\"server1和server3都会投自己\",{\"1\":{\"166\":1}}],[\"server1和server2都会将自己作为leader服务器来进行投票\",{\"1\":{\"166\":1}}],[\"server1\",{\"1\":{\"106\":1}}],[\"server\",{\"0\":{\"1239\":1,\"1412\":1},\"1\":{\"106\":31,\"146\":4,\"157\":2,\"159\":1,\"589\":1,\"597\":1,\"674\":2,\"692\":1,\"824\":4,\"850\":1,\"864\":1,\"885\":2,\"962\":3,\"964\":8,\"1020\":1,\"1431\":1,\"1444\":1}}],[\"servlet再负责响应用户的请求\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"servlet需要在web\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"servlet独立地处理静态表示逻辑与动态业务逻辑\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"servlet本身是个java类\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"servlet和jsp的区别和联系\",{\"0\":{\"1129\":1,\"1322\":1}}],[\"servletconfig\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"servlet的生命周期就是从servlet出现到消亡\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"servlet是运行在服务器端\",{\"1\":{\"1128\":1,\"1321\":1}}],[\"servletoutputstream\",{\"1\":{\"876\":3}}],[\"servlet>\",{\"1\":{\"820\":1}}],[\"servlet<\",{\"1\":{\"812\":1}}],[\"servlet\",{\"0\":{\"1128\":1,\"1321\":1},\"1\":{\"812\":2,\"819\":3,\"820\":5,\"831\":1,\"876\":3,\"1128\":7,\"1133\":5,\"1225\":1,\"1321\":7,\"1326\":5,\"1400\":1}}],[\"service\",{\"0\":{\"818\":1,\"830\":1},\"1\":{\"152\":2,\"159\":2,\"815\":1,\"818\":4,\"820\":1,\"828\":1,\"830\":8,\"831\":1,\"944\":3,\"1128\":3,\"1133\":1,\"1321\":3,\"1326\":1,\"1444\":2}}],[\"services\",{\"1\":{\"109\":1,\"114\":3,\"152\":3,\"1060\":1,\"1266\":1}}],[\"separator\",{\"1\":{\"876\":2}}],[\"separator=\",{\"1\":{\"724\":1,\"727\":1,\"787\":1}}],[\"separate\",{\"1\":{\"624\":1}}],[\"sex=1\",{\"1\":{\"784\":1,\"785\":1,\"789\":6,\"790\":2}}],[\"sex=0\",{\"1\":{\"759\":1}}],[\"sex\",{\"1\":{\"536\":2,\"736\":3,\"747\":5,\"755\":6,\"759\":2,\"763\":4,\"782\":2,\"786\":2,\"793\":1}}],[\"seesion\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"seelec\",{\"1\":{\"497\":1}}],[\"seed\",{\"1\":{\"337\":5,\"406\":1}}],[\"seeds\",{\"1\":{\"337\":3}}],[\"sequential\",{\"1\":{\"1008\":2,\"1244\":2,\"1417\":2}}],[\"sequenceflow>\",{\"1\":{\"865\":8}}],[\"sequencemask\",{\"1\":{\"388\":2}}],[\"sequencebits\",{\"1\":{\"388\":5}}],[\"sequence\",{\"1\":{\"383\":1,\"388\":6,\"996\":1}}],[\"seq\",{\"1\":{\"436\":1,\"506\":1}}],[\"seward\",{\"1\":{\"357\":1}}],[\"session中\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"session中属性值\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"session和portlet应用相关\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"session和cookie的区别和联系\",{\"0\":{\"1131\":1,\"1324\":1}}],[\"session过期后\",{\"1\":{\"1215\":1,\"1392\":1}}],[\"session会在一定时间内保存在服务器上\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"session数据放在服务器上\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"session的唯一标识需要存放在客户端\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"sessionid\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"session\",{\"0\":{\"1233\":1,\"1408\":1},\"1\":{\"106\":2,\"594\":4,\"664\":1,\"747\":3,\"754\":1,\"757\":3,\"762\":2,\"763\":3,\"952\":2,\"958\":1,\"1027\":1,\"1127\":1,\"1131\":3,\"1178\":3,\"1215\":2,\"1233\":10,\"1320\":1,\"1324\":3,\"1363\":3,\"1392\":2,\"1408\":10}}],[\"sendmessage\",{\"1\":{\"986\":1}}],[\"sender\",{\"1\":{\"487\":5,\"488\":5,\"1020\":2}}],[\"send\",{\"1\":{\"106\":1,\"964\":1,\"982\":1,\"990\":2,\"992\":3}}],[\"sendfile\",{\"1\":{\"106\":2,\"1167\":1,\"1355\":1}}],[\"sendfile指令指定\",{\"1\":{\"106\":1}}],[\"sendfile指令指定nginx是否调用sendfile函数来输出文件\",{\"1\":{\"106\":1}}],[\"sentinel\",{\"1\":{\"601\":1,\"960\":1,\"1048\":2,\"1205\":2,\"1257\":2,\"1385\":2}}],[\"sent\",{\"1\":{\"106\":2}}],[\"sed\",{\"1\":{\"94\":3}}],[\"setcontenttype\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"setcreated\",{\"1\":{\"747\":1}}],[\"setresourceloader\",{\"1\":{\"950\":1}}],[\"setex\",{\"1\":{\"960\":2}}],[\"setexclusiveownerthread\",{\"1\":{\"932\":2}}],[\"setentityresolver\",{\"1\":{\"950\":1}}],[\"setentry\",{\"1\":{\"928\":1}}],[\"setenvironment\",{\"1\":{\"950\":1}}],[\"setflag\",{\"1\":{\"924\":3}}],[\"setviewname\",{\"1\":{\"831\":1,\"832\":1}}],[\"setproperties\",{\"1\":{\"770\":1}}],[\"setparameters\",{\"1\":{\"770\":1}}],[\"setpassword\",{\"1\":{\"747\":1,\"757\":2,\"763\":2,\"786\":1}}],[\"setup\",{\"1\":{\"757\":1,\"762\":1,\"763\":1}}],[\"setupdated\",{\"1\":{\"747\":1}}],[\"setusername\",{\"1\":{\"747\":1,\"757\":2,\"763\":2,\"786\":1}}],[\"setbirthday\",{\"1\":{\"747\":1,\"757\":2,\"763\":2,\"786\":1}}],[\"setbit\",{\"1\":{\"658\":1}}],[\"setage\",{\"1\":{\"747\":1,\"757\":1,\"763\":1}}],[\"setname\",{\"1\":{\"747\":1,\"757\":2,\"763\":2,\"786\":1,\"789\":1}}],[\"setnx\",{\"1\":{\"664\":5,\"960\":4,\"970\":1}}],[\"setid\",{\"1\":{\"747\":1,\"757\":1,\"763\":1,\"786\":1,\"789\":1}}],[\"setlong\",{\"1\":{\"737\":1}}],[\"setthreshold\",{\"1\":{\"928\":2}}],[\"setter\",{\"1\":{\"825\":4,\"954\":5}}],[\"settestonborrow\",{\"1\":{\"648\":1}}],[\"setting\",{\"1\":{\"702\":1}}],[\"settings>\",{\"1\":{\"767\":1,\"790\":1,\"817\":1}}],[\"settings设置\",{\"0\":{\"767\":1}}],[\"settings\",{\"1\":{\"701\":1,\"702\":1,\"913\":1}}],[\"setmaxidle\",{\"1\":{\"648\":1}}],[\"setmaxtotal\",{\"1\":{\"648\":1}}],[\"setmaxwaitmillis\",{\"1\":{\"648\":1}}],[\"setmaxwait\",{\"1\":{\"648\":1}}],[\"setmaxactive\",{\"1\":{\"648\":1}}],[\"set会失败\",{\"1\":{\"603\":1}}],[\"setstring\",{\"1\":{\"1176\":1,\"1361\":1}}],[\"setstate\",{\"1\":{\"932\":1}}],[\"sets记录精细的引用信息\",{\"1\":{\"940\":1}}],[\"sets维护的引用链过于精细\",{\"1\":{\"940\":1}}],[\"sets要做的工作\",{\"1\":{\"940\":1}}],[\"sets和card\",{\"1\":{\"940\":5}}],[\"sets实现空间整合\",{\"1\":{\"940\":1}}],[\"setsex\",{\"1\":{\"747\":1,\"757\":2,\"763\":2,\"786\":1}}],[\"sets\",{\"1\":{\"593\":2,\"601\":2,\"606\":1,\"940\":3}}],[\"setdata\",{\"1\":{\"289\":1}}],[\"set\",{\"0\":{\"606\":1,\"607\":1,\"656\":1,\"1114\":1,\"1309\":1},\"1\":{\"94\":1,\"106\":6,\"152\":1,\"337\":1,\"555\":1,\"573\":2,\"579\":1,\"589\":2,\"592\":1,\"597\":1,\"603\":7,\"606\":1,\"619\":2,\"630\":1,\"653\":1,\"657\":1,\"724\":1,\"725\":1,\"727\":2,\"755\":1,\"763\":1,\"786\":1,\"787\":1,\"789\":1,\"824\":1,\"825\":2,\"827\":1,\"887\":2,\"928\":5,\"954\":1,\"960\":7,\"966\":5,\"1112\":1,\"1113\":1,\"1114\":1,\"1177\":1,\"1198\":2,\"1204\":1,\"1206\":1,\"1241\":1,\"1307\":1,\"1308\":1,\"1309\":1,\"1362\":1,\"1378\":2,\"1384\":1,\"1386\":1,\"1414\":1}}],[\"search\",{\"1\":{\"4\":2,\"434\":1,\"436\":2,\"437\":1,\"440\":2,\"998\":1,\"1002\":1,\"1004\":1,\"1062\":1,\"1067\":1,\"1072\":2,\"1217\":1,\"1268\":1,\"1276\":2,\"1394\":1}}],[\"synonym\",{\"1\":{\"414\":1}}],[\"syncwithmaster\",{\"1\":{\"964\":1}}],[\"sync\",{\"1\":{\"932\":7,\"964\":4,\"1078\":1,\"1156\":2,\"1165\":1,\"1282\":1,\"1344\":2,\"1353\":1}}],[\"synclimit\",{\"1\":{\"157\":1}}],[\"synclimit这个配置项标识leader与follower之间发送消息\",{\"1\":{\"157\":1}}],[\"synchronize\",{\"1\":{\"1100\":2,\"1298\":2}}],[\"synchronized可重入\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"synchronized是独占锁\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"synchronized的锁是非公平锁\",{\"1\":{\"1106\":1,\"1304\":1}}],[\"synchronizedmap\",{\"1\":{\"988\":1}}],[\"synchronized\",{\"0\":{\"1022\":1,\"1106\":1,\"1304\":1},\"1\":{\"82\":2,\"83\":2,\"84\":3,\"388\":2,\"648\":2,\"692\":4,\"920\":1,\"924\":1,\"988\":3,\"1022\":41,\"1023\":3,\"1106\":1,\"1216\":1,\"1304\":1,\"1393\":1}}],[\"synchronization\",{\"1\":{\"152\":1}}],[\"sysdate\",{\"1\":{\"736\":4}}],[\"sysctl\",{\"1\":{\"403\":1}}],[\"systemctl\",{\"1\":{\"852\":2}}],[\"systemutils\",{\"1\":{\"388\":2}}],[\"systems\",{\"1\":{\"152\":1}}],[\"system\",{\"1\":{\"112\":1,\"285\":3,\"288\":3,\"289\":3,\"337\":5,\"352\":1,\"360\":1,\"364\":1,\"377\":1,\"388\":7,\"406\":1,\"648\":2,\"689\":4,\"692\":3,\"706\":1,\"737\":4,\"747\":2,\"757\":2,\"763\":5,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"789\":6,\"790\":2,\"793\":2,\"794\":2,\"795\":3,\"828\":6,\"830\":1,\"928\":2,\"932\":4,\"934\":2,\"944\":1,\"966\":1,\"984\":1,\"990\":1,\"1008\":2,\"1016\":3,\"1020\":3,\"1044\":3,\"1084\":2,\"1085\":2,\"1086\":5,\"1092\":4,\"1104\":9,\"1105\":4,\"1107\":3,\"1176\":1,\"1253\":3,\"1285\":2,\"1286\":2,\"1287\":5,\"1293\":4,\"1302\":9,\"1303\":4,\"1305\":3,\"1361\":1}}],[\"sychronizedsingleton\",{\"1\":{\"83\":6}}],[\"sychronized\",{\"0\":{\"83\":1,\"84\":1}}],[\"socket\",{\"1\":{\"1020\":1,\"1167\":1,\"1355\":1}}],[\"socketchannel\",{\"1\":{\"1020\":8}}],[\"soldity\",{\"2\":{\"479\":1,\"480\":1,\"489\":1,\"490\":1}}],[\"solidity\",{\"0\":{\"478\":1},\"1\":{\"481\":1,\"487\":1,\"488\":3}}],[\"solution\",{\"1\":{\"353\":1}}],[\"someproperty\",{\"1\":{\"770\":1,\"958\":1}}],[\"somevalue\",{\"1\":{\"603\":2}}],[\"some\",{\"1\":{\"571\":3,\"578\":3,\"579\":3,\"603\":3,\"1101\":1,\"1299\":1}}],[\"something\",{\"1\":{\"193\":1,\"198\":2,\"201\":2,\"664\":1,\"924\":2}}],[\"somename\",{\"1\":{\"106\":2}}],[\"sourcename\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"sourcec\",{\"1\":{\"1092\":2,\"1293\":2}}],[\"sourceb\",{\"1\":{\"1092\":5,\"1293\":5}}],[\"sourceb资源\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"sourceaccessinterceptor\",{\"1\":{\"1092\":2,\"1293\":2}}],[\"sourcea\",{\"1\":{\"1092\":4,\"1293\":4}}],[\"sourcearray\",{\"1\":{\"352\":6,\"364\":3}}],[\"sourceref=\",{\"1\":{\"865\":8}}],[\"source>\",{\"1\":{\"812\":1,\"844\":1}}],[\"sourceencoding>\",{\"1\":{\"812\":1,\"844\":1}}],[\"sourceencoding>utf\",{\"1\":{\"812\":1,\"844\":1}}],[\"sourcekey\",{\"1\":{\"659\":2}}],[\"source字段中分离\",{\"1\":{\"440\":1}}],[\"source中\",{\"1\":{\"436\":1}}],[\"source和\",{\"1\":{\"394\":1}}],[\"source=f2a0231e07e27f42fa11f05024479cb8\",{\"1\":{\"251\":1}}],[\"source\",{\"1\":{\"109\":1,\"125\":1,\"152\":1,\"436\":2,\"604\":2,\"606\":2,\"614\":1,\"655\":1,\"824\":4,\"944\":2,\"1072\":1,\"1092\":2,\"1276\":1,\"1293\":2}}],[\"sources\",{\"1\":{\"109\":1,\"713\":4}}],[\"soft\",{\"1\":{\"94\":2,\"158\":1,\"159\":1,\"918\":2}}],[\"sortedset\",{\"0\":{\"657\":1}}],[\"sorted\",{\"0\":{\"607\":1},\"1\":{\"589\":1,\"601\":1,\"619\":1,\"960\":1,\"1198\":1,\"1378\":1}}],[\"sortedarray\",{\"1\":{\"360\":3}}],[\"sortjavapub\",{\"1\":{\"360\":1}}],[\"sort\",{\"0\":{\"348\":1,\"357\":1},\"1\":{\"94\":1,\"348\":1,\"352\":6,\"364\":4,\"371\":4,\"377\":2,\"1113\":1,\"1308\":1}}],[\"sogou\",{\"1\":{\"4\":1}}],[\"so\",{\"1\":{\"4\":1,\"125\":1,\"342\":1}}],[\"s\",{\"1\":{\"4\":2,\"71\":1,\"94\":1,\"106\":2,\"127\":2,\"146\":1,\"147\":1,\"172\":1,\"198\":5,\"288\":1,\"555\":1,\"591\":2,\"593\":2,\"619\":3,\"832\":1,\"887\":1,\"950\":1,\"960\":2,\"966\":2,\"1030\":1,\"1085\":1,\"1099\":1,\"1105\":1,\"1167\":1,\"1184\":1,\"1286\":1,\"1297\":1,\"1303\":1,\"1355\":1,\"1367\":1}}],[\"hw\",{\"1\":{\"1157\":3,\"1161\":3,\"1163\":1,\"1166\":1,\"1345\":3,\"1349\":3,\"1351\":1,\"1354\":1}}],[\"hll\",{\"1\":{\"1077\":1,\"1281\":1}}],[\"hlen\",{\"1\":{\"605\":1}}],[\"hystrix\",{\"1\":{\"1048\":1,\"1257\":1}}],[\"hyperloglog计数\",{\"1\":{\"1077\":2,\"1281\":2}}],[\"hyperloglog\",{\"0\":{\"659\":1},\"1\":{\"659\":11,\"1077\":4,\"1198\":1,\"1281\":4,\"1378\":1}}],[\"hyperloglogs\",{\"1\":{\"601\":1}}],[\"href=\",{\"1\":{\"832\":1}}],[\"hh\",{\"1\":{\"821\":1}}],[\"hh24\",{\"1\":{\"800\":2,\"801\":2}}],[\"hj\",{\"1\":{\"736\":1,\"763\":1}}],[\"h>\",{\"1\":{\"620\":1}}],[\"hscan\",{\"1\":{\"605\":1}}],[\"hsetnx\",{\"1\":{\"605\":1}}],[\"hset\",{\"1\":{\"605\":1,\"654\":1}}],[\"hvals\",{\"1\":{\"605\":1}}],[\"hmset\",{\"1\":{\"605\":1}}],[\"hmget\",{\"1\":{\"605\":1}}],[\"hgetall\",{\"1\":{\"605\":1}}],[\"hget\",{\"1\":{\"605\":1}}],[\"hguisu\",{\"1\":{\"425\":1}}],[\"hdel\",{\"1\":{\"605\":1}}],[\"hbase\",{\"1\":{\"588\":1}}],[\"hihead\",{\"1\":{\"922\":1}}],[\"histogram\",{\"1\":{\"883\":1}}],[\"hitail\",{\"1\":{\"922\":1}}],[\"hit\",{\"1\":{\"790\":1}}],[\"hincrbyfloat\",{\"1\":{\"605\":1}}],[\"hincrby\",{\"1\":{\"605\":1}}],[\"hibernate\",{\"1\":{\"524\":1,\"950\":2,\"1211\":1,\"1388\":1}}],[\"highlighting\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"highlighter能提升性能\",{\"1\":{\"440\":1}}],[\"higher\",{\"1\":{\"152\":1}}],[\"high\",{\"1\":{\"106\":1,\"601\":1,\"1085\":5,\"1157\":1,\"1161\":1,\"1286\":5,\"1345\":1,\"1349\":1}}],[\"humongous\",{\"1\":{\"940\":1}}],[\"hunternet\",{\"1\":{\"628\":1,\"633\":1}}],[\"hu\",{\"1\":{\"451\":2}}],[\"huaweicloud\",{\"1\":{\"405\":2,\"671\":1,\"888\":1}}],[\"huwangyun\",{\"1\":{\"238\":1}}],[\"herd\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"here\",{\"1\":{\"887\":1,\"1085\":1,\"1286\":1}}],[\"hexists\",{\"1\":{\"605\":1}}],[\"held\",{\"1\":{\"1023\":3}}],[\"hellocontroller\",{\"1\":{\"849\":1}}],[\"helloworld\",{\"1\":{\"832\":1}}],[\"helloword\",{\"1\":{\"812\":2}}],[\"hello\",{\"1\":{\"603\":1,\"604\":2,\"849\":3,\"928\":2,\"944\":2,\"990\":1,\"998\":1,\"1010\":1}}],[\"help\",{\"1\":{\"286\":1}}],[\"height=\",{\"1\":{\"865\":6}}],[\"heigh\",{\"1\":{\"439\":1}}],[\"he\",{\"1\":{\"145\":3}}],[\"heapregion\",{\"1\":{\"940\":2}}],[\"heapdump\",{\"1\":{\"885\":1}}],[\"heapify\",{\"1\":{\"364\":4}}],[\"heapsort\",{\"1\":{\"364\":6}}],[\"health\",{\"1\":{\"116\":1,\"462\":1,\"885\":1}}],[\"head~2\",{\"1\":{\"918\":1}}],[\"head~1\",{\"1\":{\"918\":1}}],[\"head^的意思是上一个版本\",{\"1\":{\"918\":1}}],[\"head^\",{\"1\":{\"918\":3}}],[\"head>\",{\"1\":{\"832\":1}}],[\"heading\",{\"1\":{\"663\":1}}],[\"headers\",{\"1\":{\"406\":1}}],[\"header中添加vary\",{\"1\":{\"106\":1}}],[\"header\",{\"1\":{\"106\":13,\"1023\":7}}],[\"head\",{\"1\":{\"90\":1,\"94\":1,\"109\":1,\"286\":13,\"621\":1}}],[\"h\",{\"1\":{\"139\":4,\"140\":2,\"357\":1,\"436\":3,\"597\":1,\"619\":2,\"621\":1,\"624\":2,\"628\":2,\"831\":1,\"928\":6,\"1085\":3,\"1105\":1,\"1286\":3,\"1303\":1}}],[\"h264stream`\",{\"1\":{\"146\":1}}],[\"h264\",{\"1\":{\"135\":1,\"136\":1}}],[\"h2o\",{\"1\":{\"38\":1}}],[\"haicoder\",{\"1\":{\"1193\":1,\"1376\":1}}],[\"haiyang\",{\"1\":{\"865\":2}}],[\"handle\",{\"1\":{\"956\":2}}],[\"handlermethod\",{\"1\":{\"1092\":4,\"1293\":4}}],[\"handlermapping\",{\"1\":{\"950\":2,\"956\":11}}],[\"handler主要用来处理各种事件\",{\"1\":{\"1034\":1}}],[\"handlerinterceptor\",{\"1\":{\"956\":3,\"1092\":2,\"1293\":2}}],[\"handlerexecutionchain\",{\"1\":{\"956\":5}}],[\"handleresultsets\",{\"1\":{\"770\":1}}],[\"handleradapter\",{\"1\":{\"950\":2,\"956\":10}}],[\"handler\",{\"1\":{\"819\":1,\"950\":4,\"956\":20,\"1016\":2,\"1092\":5,\"1293\":5}}],[\"handleoutputparameters\",{\"1\":{\"770\":1}}],[\"handles\",{\"1\":{\"112\":1}}],[\"hadoop\",{\"1\":{\"588\":2}}],[\"half\",{\"1\":{\"444\":1}}],[\"harold\",{\"1\":{\"357\":1}}],[\"hard\",{\"1\":{\"152\":1,\"918\":1}}],[\"have\",{\"1\":{\"337\":3,\"526\":1,\"932\":4}}],[\"hasnext\",{\"1\":{\"1020\":1}}],[\"haslength\",{\"1\":{\"952\":1}}],[\"has\",{\"1\":{\"152\":1,\"1101\":1,\"1299\":1}}],[\"hashtable<>\",{\"1\":{\"948\":1}}],[\"hashtable<string\",{\"1\":{\"948\":1}}],[\"hashtable\",{\"0\":{\"1115\":1,\"1310\":1},\"1\":{\"922\":4,\"948\":1,\"988\":2,\"1112\":1,\"1115\":8,\"1307\":1,\"1310\":8}}],[\"hashset\",{\"1\":{\"656\":1,\"659\":1,\"1087\":1,\"1112\":1,\"1288\":1,\"1307\":1}}],[\"hashfunction\",{\"1\":{\"624\":1}}],[\"hash索引适合等值查询\",{\"1\":{\"510\":1}}],[\"hash索引的效率可能会下降\",{\"1\":{\"499\":1}}],[\"hashmap选择把链表转换为红黑树\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"hashmap是怎样确定key存放在数组的哪个位置的\",{\"0\":{\"1120\":1,\"1315\":1}}],[\"hashmap是非线程安全的\",{\"1\":{\"922\":2}}],[\"hashmap底层采用数组+链表实现\",{\"1\":{\"948\":1}}],[\"hashmap<>\",{\"1\":{\"948\":1}}],[\"hashmap<string\",{\"1\":{\"948\":1}}],[\"hashmap<integer\",{\"1\":{\"353\":1}}],[\"hashmap还是最为常用和推荐的\",{\"1\":{\"922\":1}}],[\"hashmap确实是我常用的数据结构之一\",{\"1\":{\"922\":1}}],[\"hashmap作为一个高频使用的数据结构\",{\"1\":{\"922\":1}}],[\"hashmap不支持排序\",{\"1\":{\"922\":1}}],[\"hashmap采用拉链法解决冲突\",{\"1\":{\"922\":1}}],[\"hashmap也存在一定的缺点\",{\"1\":{\"922\":1}}],[\"hashmap有很高的空间利用率\",{\"1\":{\"922\":1}}],[\"hashmap支持null键和null值\",{\"1\":{\"922\":1}}],[\"hashmap通过扩容和链表转红黑树\",{\"1\":{\"922\":1}}],[\"hashmap通过数组实现快速查找\",{\"1\":{\"922\":1}}],[\"hashmap的源码解析得不错\",{\"1\":{\"948\":1}}],[\"hashmap的源码实现还有很多精妙的地方\",{\"1\":{\"948\":1}}],[\"hashmap的源码实现较复杂\",{\"1\":{\"948\":1}}],[\"hashmap的线程安全版本\",{\"1\":{\"922\":1}}],[\"hashmap的主要缺点在于\",{\"1\":{\"922\":1}}],[\"hashmap的主要优势有\",{\"1\":{\"922\":1}}],[\"hashmap的初始容量和扩容机制的设计不当\",{\"1\":{\"922\":1}}],[\"hashmap的性能会很差\",{\"1\":{\"922\":1}}],[\"hashmap的遍历也是o\",{\"1\":{\"922\":1}}],[\"hashmap的迭代顺序是未定义的\",{\"1\":{\"922\":1}}],[\"hashmap的优势在于\",{\"1\":{\"922\":1}}],[\"hashmap的实现是非常巧妙的\",{\"1\":{\"922\":1}}],[\"hashmap的扩容机制就是在put时\",{\"1\":{\"922\":1}}],[\"hashmap\",{\"0\":{\"922\":1,\"1115\":1,\"1116\":1,\"1123\":1,\"1310\":1,\"1311\":1,\"1318\":1},\"1\":{\"353\":1,\"920\":1,\"922\":11,\"948\":1,\"988\":10,\"1112\":1,\"1115\":5,\"1116\":3,\"1123\":1,\"1178\":2,\"1307\":1,\"1310\":5,\"1311\":3,\"1318\":1,\"1363\":2}}],[\"hashing\",{\"1\":{\"339\":1}}],[\"hashcode\",{\"1\":{\"337\":2,\"922\":1,\"1086\":1,\"1087\":2,\"1116\":1,\"1287\":1,\"1288\":2,\"1311\":1}}],[\"hashes\",{\"1\":{\"337\":4,\"593\":1,\"601\":1,\"605\":1}}],[\"hash参考百度百科\",{\"1\":{\"336\":1}}],[\"hash函数对\",{\"1\":{\"336\":1}}],[\"hash\",{\"0\":{\"499\":1,\"605\":1,\"654\":1},\"1\":{\"106\":11,\"336\":1,\"337\":11,\"495\":1,\"499\":4,\"592\":1,\"605\":3,\"619\":1,\"654\":2,\"922\":12,\"948\":4,\"960\":1,\"1071\":1,\"1116\":7,\"1123\":1,\"1162\":1,\"1204\":1,\"1275\":1,\"1311\":7,\"1318\":1,\"1350\":1,\"1384\":1}}],[\"htpasswd文件的内容可以用apache提供的htpasswd工具来产生\",{\"1\":{\"106\":1}}],[\"ht\",{\"1\":{\"106\":1,\"624\":5,\"625\":7}}],[\"htaccess\",{\"1\":{\"106\":1}}],[\"htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|\",{\"1\":{\"106\":1}}],[\"htm\",{\"1\":{\"106\":4}}],[\"html内容的任何变动会自动编译装入到服务程序\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"html内容与java内容也可放在单独文件中\",{\"1\":{\"1129\":1,\"1322\":1}}],[\"html文件在工作区进行修改\",{\"1\":{\"916\":1}}],[\"html>\",{\"1\":{\"832\":2}}],[\"html\",{\"1\":{\"106\":13,\"152\":1,\"183\":1,\"394\":1,\"419\":1,\"431\":1,\"435\":1,\"457\":1,\"526\":1,\"527\":3,\"548\":1,\"605\":1,\"606\":1,\"628\":1,\"633\":1,\"706\":1,\"714\":1,\"716\":1,\"739\":1,\"819\":1,\"832\":1,\"899\":1,\"904\":1,\"911\":1,\"917\":1,\"919\":2,\"1068\":1,\"1072\":1,\"1084\":2,\"1088\":2,\"1101\":1,\"1130\":1,\"1193\":1,\"1212\":1,\"1272\":1,\"1276\":1,\"1285\":2,\"1289\":2,\"1299\":1,\"1323\":1,\"1376\":1,\"1389\":1}}],[\"http状态码\",{\"1\":{\"1431\":1}}],[\"httpurl\",{\"1\":{\"1231\":1,\"1406\":1}}],[\"http2\",{\"1\":{\"1138\":1,\"1331\":1}}],[\"http1\",{\"0\":{\"1138\":1,\"1331\":1},\"1\":{\"1138\":2,\"1331\":2}}],[\"http协议中有那些请求方式\",{\"1\":{\"1027\":1}}],[\"httptrace\",{\"1\":{\"885\":1}}],[\"http请求或者剥离到事务方法外部\",{\"1\":{\"830\":1}}],[\"http\",{\"0\":{\"1026\":1,\"1027\":1},\"1\":{\"104\":1,\"106\":9,\"109\":3,\"125\":1,\"136\":1,\"177\":1,\"248\":1,\"249\":2,\"251\":1,\"406\":4,\"407\":1,\"412\":1,\"413\":1,\"462\":2,\"587\":1,\"598\":1,\"614\":1,\"668\":1,\"690\":2,\"698\":1,\"701\":1,\"705\":2,\"706\":1,\"714\":1,\"715\":8,\"716\":1,\"739\":1,\"743\":1,\"744\":1,\"745\":1,\"755\":1,\"763\":1,\"782\":1,\"812\":4,\"815\":7,\"817\":1,\"818\":10,\"819\":10,\"820\":4,\"827\":2,\"844\":3,\"865\":10,\"866\":4,\"876\":2,\"885\":1,\"887\":2,\"888\":1,\"896\":2,\"899\":1,\"906\":1,\"912\":1,\"917\":1,\"919\":1,\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":4,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1023\":1,\"1026\":3,\"1027\":3,\"1033\":5,\"1137\":2,\"1330\":2},\"2\":{\"1029\":1}}],[\"httpstatus\",{\"1\":{\"1431\":2}}],[\"httpservletresponse\",{\"1\":{\"876\":3,\"956\":2,\"1092\":4,\"1293\":4}}],[\"httpservletrequest\",{\"1\":{\"876\":3,\"956\":4,\"1092\":4,\"1293\":4}}],[\"https\",{\"1\":{\"4\":5,\"71\":1,\"106\":1,\"109\":1,\"110\":1,\"112\":3,\"116\":1,\"122\":1,\"147\":1,\"152\":1,\"157\":1,\"172\":1,\"177\":1,\"181\":2,\"209\":1,\"212\":1,\"232\":2,\"238\":1,\"241\":2,\"246\":1,\"247\":1,\"251\":6,\"252\":4,\"275\":1,\"336\":1,\"337\":2,\"343\":1,\"385\":1,\"388\":1,\"394\":3,\"405\":2,\"408\":1,\"412\":1,\"413\":1,\"414\":1,\"419\":1,\"425\":1,\"431\":1,\"435\":1,\"457\":1,\"520\":1,\"526\":1,\"527\":3,\"548\":1,\"597\":1,\"605\":1,\"606\":1,\"628\":1,\"633\":1,\"643\":1,\"663\":1,\"664\":1,\"671\":1,\"675\":1,\"681\":1,\"688\":3,\"689\":3,\"690\":1,\"728\":1,\"812\":3,\"832\":2,\"837\":2,\"838\":1,\"844\":2,\"849\":3,\"852\":5,\"856\":1,\"860\":1,\"867\":1,\"871\":1,\"873\":1,\"878\":2,\"884\":1,\"885\":2,\"887\":1,\"888\":1,\"889\":2,\"898\":1,\"903\":1,\"904\":2,\"913\":3,\"917\":1,\"919\":3,\"922\":2,\"924\":2,\"926\":2,\"928\":2,\"930\":2,\"932\":2,\"934\":2,\"936\":2,\"938\":2,\"940\":2,\"942\":2,\"944\":2,\"946\":2,\"948\":2,\"950\":2,\"952\":2,\"954\":2,\"956\":2,\"958\":2,\"960\":2,\"962\":2,\"964\":2,\"966\":2,\"968\":2,\"970\":2,\"972\":2,\"974\":2,\"976\":2,\"978\":2,\"980\":2,\"982\":2,\"988\":2,\"990\":2,\"992\":2,\"994\":2,\"996\":2,\"998\":2,\"1000\":2,\"1002\":2,\"1004\":2,\"1006\":2,\"1008\":2,\"1010\":2,\"1012\":2,\"1016\":2,\"1018\":2,\"1020\":2,\"1023\":2,\"1027\":2,\"1030\":3,\"1062\":1,\"1068\":2,\"1070\":1,\"1072\":1,\"1073\":1,\"1084\":1,\"1088\":2,\"1099\":1,\"1101\":1,\"1104\":4,\"1105\":3,\"1107\":2,\"1184\":1,\"1193\":1,\"1212\":1,\"1219\":1,\"1268\":1,\"1272\":2,\"1274\":1,\"1276\":1,\"1277\":1,\"1285\":1,\"1289\":2,\"1297\":1,\"1299\":1,\"1302\":4,\"1303\":3,\"1305\":2,\"1367\":1,\"1376\":1,\"1389\":1,\"1396\":1,\"1422\":1,\"1431\":1,\"1439\":2,\"1444\":2}}],[\"how\",{\"1\":{\"1073\":1,\"1277\":1}}],[\"hotspot\",{\"1\":{\"692\":2,\"924\":3}}],[\"hold\",{\"1\":{\"562\":1}}],[\"hosts\",{\"1\":{\"406\":1}}],[\"hostaddress\",{\"1\":{\"388\":2}}],[\"hostname\",{\"1\":{\"387\":3}}],[\"host=host\",{\"1\":{\"251\":1}}],[\"host\",{\"1\":{\"106\":5,\"251\":1,\"406\":1,\"824\":1,\"1138\":1,\"1331\":1}}],[\"hope\",{\"1\":{\"44\":1}}],[\"home=\",{\"1\":{\"125\":1}}],[\"homebrew\",{\"1\":{\"109\":2}}],[\"home\",{\"1\":{\"6\":1,\"125\":1,\"154\":1,\"158\":1,\"159\":1,\"701\":1,\"702\":5}}],[\"h1>\",{\"1\":{\"832\":1}}],[\"h1\",{\"1\":{\"43\":2,\"339\":1}}],[\"hkeys\",{\"1\":{\"605\":1}}],[\"hk\",{\"1\":{\"4\":1}}],[\"g1表现良好\",{\"1\":{\"942\":1}}],[\"g1的设计确实非常复杂精巧\",{\"1\":{\"940\":1}}],[\"g1的设计与实现还有其他一些关键点\",{\"1\":{\"940\":1}}],[\"g1的垃圾回收过程可以分为以下几个主要阶段\",{\"1\":{\"940\":1}}],[\"g1收集器的设计与实现还有哪些关键点需要关注\",{\"1\":{\"940\":1}}],[\"g1与cms一脉相承\",{\"1\":{\"940\":1}}],[\"g1是在\",{\"1\":{\"940\":1}}],[\"g1是jdk9默认的垃圾收集器\",{\"1\":{\"940\":1}}],[\"g1引入了remembered\",{\"1\":{\"940\":1}}],[\"g1引入card\",{\"1\":{\"940\":1}}],[\"g1继承了标记\",{\"1\":{\"940\":1}}],[\"g1继承了\",{\"1\":{\"940\":1}}],[\"g1之所以马力十足\",{\"1\":{\"940\":1}}],[\"g1remset\",{\"1\":{\"940\":1}}],[\"g1concurrentmark\",{\"1\":{\"940\":1}}],[\"g1collectedheap\",{\"1\":{\"936\":1,\"940\":2}}],[\"g1可以渐进式回收\",{\"1\":{\"940\":1}}],[\"g1具有以下优点\",{\"1\":{\"940\":1}}],[\"g1到底好在哪儿\",{\"1\":{\"940\":1}}],[\"g1垃圾收集器\",{\"1\":{\"940\":1}}],[\"g1垃圾收集器的工作流程如下\",{\"1\":{\"936\":1}}],[\"g1垃圾回收器\",{\"0\":{\"940\":1}}],[\"g1等收集器\",{\"1\":{\"936\":1}}],[\"g1\",{\"1\":{\"936\":1}}],[\"global\",{\"1\":{\"887\":4,\"952\":1,\"1215\":2,\"1392\":2}}],[\"gt\",{\"1\":{\"800\":1}}],[\"ghz\",{\"1\":{\"591\":1}}],[\"ghcr\",{\"1\":{\"251\":1}}],[\"garbagecollect\",{\"1\":{\"940\":1}}],[\"gauge\",{\"1\":{\"883\":1}}],[\"gakki\",{\"1\":{\"656\":2}}],[\"gap\",{\"1\":{\"440\":1,\"558\":1,\"575\":1}}],[\"gateway\",{\"1\":{\"251\":1}}],[\"gue有\",{\"1\":{\"958\":1}}],[\"guides\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"guide\",{\"1\":{\"419\":1,\"431\":1,\"435\":2,\"457\":1,\"1072\":2,\"1276\":2}}],[\"guava\",{\"1\":{\"342\":1,\"1045\":2,\"1048\":2,\"1254\":2,\"1257\":2}}],[\"gc和full\",{\"1\":{\"938\":1}}],[\"gc来整理空间\",{\"1\":{\"938\":1}}],[\"gc后未死亡进入survivor\",{\"1\":{\"936\":1}}],[\"gc回收这个类的所有实例和空间\",{\"1\":{\"934\":1}}],[\"gc\",{\"1\":{\"286\":1,\"930\":3,\"936\":2,\"938\":1,\"942\":1,\"1150\":2,\"1151\":2,\"1341\":2,\"1342\":2}}],[\"general\",{\"1\":{\"1185\":1,\"1368\":1}}],[\"generated\",{\"1\":{\"1107\":3,\"1305\":3}}],[\"generateid\",{\"1\":{\"388\":2}}],[\"generate\",{\"1\":{\"249\":1,\"252\":1,\"388\":1,\"703\":2,\"704\":2,\"713\":4}}],[\"gen\",{\"1\":{\"940\":1}}],[\"geohash\",{\"1\":{\"660\":2,\"1198\":1,\"1378\":1}}],[\"georadiusbymember\",{\"1\":{\"660\":1}}],[\"georadius\",{\"1\":{\"660\":1}}],[\"geodist\",{\"1\":{\"660\":5}}],[\"geopos\",{\"1\":{\"660\":1}}],[\"geoadd\",{\"1\":{\"660\":2}}],[\"geospatial\",{\"1\":{\"601\":1}}],[\"geo\",{\"0\":{\"660\":1},\"1\":{\"453\":1,\"454\":1,\"660\":1}}],[\"gemma\",{\"1\":{\"245\":1}}],[\"getobject\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"getoutputstream\",{\"1\":{\"876\":2}}],[\"getgeneratedkeys\",{\"1\":{\"1176\":2,\"1361\":2}}],[\"getgenerictype\",{\"1\":{\"1010\":2}}],[\"getwriter\",{\"1\":{\"1092\":1,\"1293\":1}}],[\"getworkid\",{\"1\":{\"388\":2}}],[\"getvalue\",{\"1\":{\"1044\":2,\"1253\":2}}],[\"getfield\",{\"1\":{\"1010\":2}}],[\"getfront\",{\"1\":{\"288\":1}}],[\"getenvironment\",{\"1\":{\"950\":1}}],[\"getentry\",{\"1\":{\"928\":1}}],[\"getkey\",{\"1\":{\"948\":2,\"1044\":2,\"1253\":2}}],[\"getlist\",{\"1\":{\"830\":2,\"831\":1}}],[\"getlocalhost\",{\"1\":{\"388\":1}}],[\"getlogger\",{\"1\":{\"194\":1,\"830\":1,\"831\":1}}],[\"getbytes\",{\"1\":{\"1008\":1,\"1020\":1}}],[\"getbyid\",{\"1\":{\"830\":2,\"831\":1}}],[\"getbean\",{\"1\":{\"950\":1}}],[\"getbook\",{\"1\":{\"828\":1}}],[\"getbirthday\",{\"1\":{\"747\":1}}],[\"getbit\",{\"1\":{\"658\":1}}],[\"getdestroymethodname\",{\"1\":{\"952\":1}}],[\"getdetaillist\",{\"1\":{\"794\":1,\"795\":1}}],[\"getdate\",{\"1\":{\"737\":1}}],[\"getdatacenterid\",{\"1\":{\"388\":2}}],[\"getdata\",{\"1\":{\"289\":2}}],[\"getdatas\",{\"1\":{\"288\":1}}],[\"getpath\",{\"1\":{\"876\":2}}],[\"getparameter\",{\"1\":{\"876\":2}}],[\"getparameterobject\",{\"1\":{\"770\":1}}],[\"getpassword\",{\"1\":{\"747\":1}}],[\"getupdated\",{\"1\":{\"747\":1}}],[\"getuserbyid\",{\"1\":{\"1431\":1}}],[\"getuser\",{\"1\":{\"793\":1,\"794\":1,\"795\":1,\"1431\":1}}],[\"getusername\",{\"1\":{\"747\":1}}],[\"getuserid\",{\"1\":{\"200\":2}}],[\"getall\",{\"1\":{\"1044\":3,\"1253\":3}}],[\"getandincrement\",{\"1\":{\"1018\":1}}],[\"getannotation\",{\"1\":{\"944\":2,\"1092\":1,\"1293\":1}}],[\"getage\",{\"1\":{\"747\":1}}],[\"getargs\",{\"1\":{\"689\":1,\"1092\":1,\"1293\":1}}],[\"getcandidateconfigurations\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"getcode\",{\"1\":{\"1431\":2}}],[\"getcourse\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"getcount\",{\"1\":{\"1022\":2,\"1104\":1,\"1302\":1}}],[\"getconstructor\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"getcontextclassloader\",{\"1\":{\"876\":2}}],[\"getconnection\",{\"1\":{\"737\":1,\"1176\":1,\"1361\":1}}],[\"getconf\",{\"1\":{\"106\":1}}],[\"getchildren\",{\"1\":{\"1008\":1}}],[\"getcreated\",{\"1\":{\"747\":1}}],[\"getclassloader\",{\"1\":{\"1016\":1}}],[\"getclass\",{\"1\":{\"689\":1,\"830\":1,\"831\":1,\"952\":3,\"1016\":2,\"1086\":6,\"1287\":6}}],[\"gettypeparameters\",{\"1\":{\"1010\":2}}],[\"getter和setter方法\",{\"1\":{\"825\":2,\"1431\":1}}],[\"getter\",{\"1\":{\"825\":4}}],[\"gettransaction\",{\"1\":{\"770\":1}}],[\"gettraceid\",{\"1\":{\"201\":1}}],[\"getting\",{\"1\":{\"739\":1}}],[\"gettarget\",{\"1\":{\"689\":1}}],[\"getmessage\",{\"1\":{\"830\":2,\"1431\":2}}],[\"getmethod\",{\"1\":{\"689\":1,\"944\":2,\"952\":2,\"1010\":2,\"1092\":1,\"1293\":1}}],[\"getmapping\",{\"1\":{\"1092\":5,\"1293\":5,\"1431\":1}}],[\"getmapper\",{\"1\":{\"762\":3,\"763\":1,\"790\":1,\"958\":1}}],[\"getmaxsize\",{\"1\":{\"288\":1}}],[\"getsingleton\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"getsignature\",{\"1\":{\"689\":1,\"1092\":1,\"1293\":1}}],[\"getscore\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"getstacktrace\",{\"1\":{\"876\":2}}],[\"getstateinfo\",{\"1\":{\"829\":3}}],[\"getstate\",{\"1\":{\"829\":4,\"932\":1}}],[\"getstring\",{\"1\":{\"737\":2}}],[\"getsex\",{\"1\":{\"747\":1}}],[\"getset\",{\"1\":{\"603\":1}}],[\"getremoteaddress\",{\"1\":{\"1020\":1}}],[\"getresourceasstream\",{\"1\":{\"746\":1,\"747\":1,\"757\":1,\"763\":1}}],[\"getresource\",{\"1\":{\"648\":1,\"876\":2}}],[\"getredis\",{\"1\":{\"648\":1}}],[\"getrear\",{\"1\":{\"288\":1}}],[\"gethandler是handlermapping接口中的唯一方法\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"gethandler\",{\"1\":{\"956\":2}}],[\"gethash\",{\"1\":{\"337\":3}}],[\"gethostname\",{\"1\":{\"388\":1}}],[\"gethostaddress\",{\"1\":{\"388\":1}}],[\"getnode\",{\"1\":{\"286\":4}}],[\"getname\",{\"1\":{\"192\":1,\"193\":1,\"195\":1,\"689\":2,\"747\":1,\"932\":2,\"990\":4,\"1016\":2,\"1086\":6,\"1092\":1,\"1104\":5,\"1287\":6,\"1293\":1,\"1302\":5}}],[\"getinitmethodname\",{\"1\":{\"952\":1}}],[\"getinterfaces\",{\"1\":{\"1016\":1}}],[\"getint\",{\"1\":{\"737\":1,\"1176\":1,\"1361\":1}}],[\"getinstace\",{\"1\":{\"82\":1}}],[\"getinstance\",{\"1\":{\"79\":1,\"80\":1,\"82\":1,\"83\":1,\"84\":1}}],[\"getid\",{\"1\":{\"201\":1,\"747\":1,\"763\":1,\"1177\":2,\"1362\":2}}],[\"get\",{\"1\":{\"104\":1,\"115\":1,\"116\":1,\"152\":1,\"178\":2,\"288\":1,\"337\":1,\"353\":2,\"434\":1,\"436\":2,\"437\":2,\"439\":1,\"597\":1,\"603\":4,\"653\":1,\"831\":2,\"852\":1,\"928\":10,\"960\":5,\"966\":4,\"970\":1,\"998\":1,\"1008\":1,\"1018\":1,\"1023\":2,\"1027\":1,\"1033\":1,\"1044\":2,\"1072\":2,\"1116\":1,\"1216\":3,\"1241\":1,\"1253\":2,\"1276\":2,\"1311\":1,\"1393\":3,\"1414\":1}}],[\"golang\",{\"0\":{\"892\":1}}],[\"goals>\",{\"1\":{\"844\":1}}],[\"goal>\",{\"1\":{\"844\":1}}],[\"go\",{\"1\":{\"112\":1,\"116\":5,\"251\":1,\"950\":1},\"2\":{\"117\":1,\"118\":1}}],[\"go整合etcd\",{\"0\":{\"112\":1}}],[\"google\",{\"1\":{\"4\":1,\"342\":1,\"874\":2}}],[\"groovy\",{\"1\":{\"837\":1}}],[\"grouptid\",{\"1\":{\"715\":1}}],[\"groupid\",{\"1\":{\"705\":2}}],[\"groupid>\",{\"1\":{\"648\":1,\"687\":1,\"708\":2,\"709\":4,\"710\":3,\"715\":9,\"735\":1,\"742\":1,\"756\":1,\"812\":25,\"844\":6,\"862\":3,\"874\":2,\"885\":3,\"1092\":1,\"1293\":1,\"1444\":2}}],[\"group\",{\"1\":{\"451\":2,\"502\":1,\"838\":1,\"839\":1,\"980\":1,\"984\":2,\"990\":2,\"1159\":1,\"1347\":1}}],[\"groups技术\",{\"1\":{\"1064\":1,\"1270\":1}}],[\"groups\",{\"1\":{\"152\":1}}],[\"green\",{\"1\":{\"944\":2}}],[\"grey\",{\"1\":{\"940\":1}}],[\"great\",{\"1\":{\"420\":1}}],[\"greater\",{\"1\":{\"388\":2}}],[\"grep\",{\"1\":{\"90\":1,\"94\":2,\"114\":1,\"852\":1}}],[\"graph\",{\"1\":{\"1177\":1,\"1362\":1}}],[\"gradle\",{\"1\":{\"837\":1}}],[\"gracefully\",{\"1\":{\"112\":1}}],[\"grafana安装\",{\"0\":{\"888\":1}}],[\"grafana安装包\",{\"1\":{\"886\":1}}],[\"grafana\",{\"0\":{\"884\":1},\"1\":{\"109\":7,\"883\":1,\"884\":3,\"888\":1,\"889\":1},\"2\":{\"857\":1,\"858\":1,\"890\":1,\"891\":1}}],[\"give\",{\"1\":{\"954\":1}}],[\"given\",{\"1\":{\"353\":1,\"950\":1,\"1216\":1,\"1393\":1}}],[\"gi\",{\"1\":{\"917\":1}}],[\"gif\",{\"1\":{\"819\":1}}],[\"gif|jpg|jpeg|png|bmp|swf\",{\"1\":{\"106\":1}}],[\"ginobefun\",{\"1\":{\"414\":1}}],[\"git流程图\",{\"1\":{\"919\":1}}],[\"gitstashpop\",{\"1\":{\"916\":1}}],[\"gitstash\",{\"1\":{\"916\":1}}],[\"gitstatus\",{\"1\":{\"916\":1}}],[\"git使用规范\",{\"0\":{\"905\":1}}],[\"git\",{\"0\":{\"916\":1,\"917\":1,\"918\":1,\"919\":1},\"1\":{\"94\":7,\"907\":1,\"913\":7,\"915\":6,\"916\":25,\"917\":13,\"918\":9,\"919\":6}}],[\"git命令\",{\"1\":{\"94\":1}}],[\"gitee\",{\"1\":{\"1\":1,\"49\":1,\"337\":2,\"688\":1,\"689\":1,\"690\":1,\"849\":1,\"922\":2,\"924\":2,\"926\":2,\"928\":2,\"930\":2,\"932\":2,\"934\":2,\"936\":2,\"938\":2,\"940\":2,\"942\":2,\"944\":2,\"946\":2,\"948\":2,\"950\":2,\"952\":2,\"954\":2,\"956\":2,\"958\":2,\"960\":2,\"962\":2,\"964\":2,\"966\":2,\"968\":2,\"970\":2,\"972\":2,\"974\":2,\"976\":2,\"978\":2,\"980\":2,\"982\":2,\"988\":2,\"990\":2,\"992\":2,\"994\":2,\"996\":2,\"998\":2,\"1000\":2,\"1002\":2,\"1004\":2,\"1006\":2,\"1008\":2,\"1010\":2,\"1012\":2,\"1016\":2,\"1018\":2,\"1020\":2,\"1023\":2,\"1030\":1,\"1062\":1,\"1068\":1,\"1070\":1,\"1268\":1,\"1272\":1,\"1274\":1}}],[\"github|gitee\",{\"1\":{\"1080\":1,\"1094\":1,\"1108\":1,\"1123\":1,\"1138\":1,\"1152\":1,\"1168\":1,\"1181\":1,\"1194\":1,\"1207\":1,\"1233\":1,\"1246\":1}}],[\"github<\",{\"1\":{\"812\":1}}],[\"githubusercontent\",{\"1\":{\"109\":1}}],[\"github\",{\"0\":{\"913\":1},\"1\":{\"1\":1,\"2\":1,\"49\":1,\"97\":1,\"106\":1,\"112\":1,\"116\":1,\"209\":4,\"244\":1,\"251\":1,\"252\":1,\"408\":1,\"412\":1,\"413\":1,\"414\":1,\"493\":1,\"552\":1,\"597\":2,\"681\":1,\"688\":1,\"689\":1,\"812\":2,\"815\":2,\"818\":1,\"819\":1,\"825\":2,\"826\":4,\"827\":2,\"828\":7,\"829\":7,\"830\":19,\"831\":8,\"832\":1,\"844\":1,\"849\":1,\"856\":1,\"867\":1,\"878\":1,\"885\":1,\"889\":1,\"903\":1,\"911\":1,\"913\":6,\"922\":2,\"924\":2,\"926\":2,\"928\":2,\"930\":2,\"932\":2,\"934\":2,\"936\":2,\"938\":2,\"940\":2,\"942\":2,\"944\":2,\"946\":2,\"948\":2,\"950\":2,\"952\":2,\"954\":2,\"956\":2,\"958\":2,\"960\":2,\"962\":2,\"964\":2,\"966\":2,\"968\":2,\"970\":2,\"972\":2,\"974\":2,\"976\":2,\"978\":2,\"980\":2,\"982\":2,\"988\":2,\"990\":2,\"992\":2,\"994\":2,\"996\":2,\"998\":2,\"1000\":2,\"1002\":2,\"1004\":2,\"1006\":2,\"1008\":2,\"1010\":2,\"1012\":2,\"1016\":2,\"1018\":2,\"1020\":2,\"1023\":2,\"1104\":2,\"1105\":1,\"1107\":1,\"1302\":2,\"1303\":1,\"1305\":1,\"1444\":1}}],[\"g\",{\"1\":{\"94\":1,\"883\":1,\"909\":1,\"917\":2,\"1068\":1,\"1272\":1}}],[\"gz\",{\"1\":{\"94\":3,\"157\":2,\"405\":2,\"598\":2,\"672\":1}}],[\"gzip压缩比\",{\"1\":{\"106\":1}}],[\"gzip\",{\"1\":{\"90\":1,\"106\":7,\"183\":1}}],[\"谷歌收录\",{\"1\":{\"4\":1}}],[\"cj\",{\"1\":{\"1444\":1}}],[\"cglib字节码生成技术代理\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"cgi\",{\"1\":{\"701\":1}}],[\"c和d了\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"cxqwaittime\",{\"1\":{\"1023\":2}}],[\"cxq\",{\"1\":{\"1023\":2}}],[\"cyclicbarrierdemo\",{\"1\":{\"932\":1,\"1104\":1,\"1302\":1}}],[\"cyclicbarrier\",{\"0\":{\"1104\":1,\"1302\":1},\"1\":{\"932\":14,\"1104\":8,\"1302\":8}}],[\"cc\",{\"1\":{\"924\":2}}],[\"cv2\",{\"0\":{\"895\":1},\"1\":{\"896\":2,\"897\":1},\"2\":{\"901\":1}}],[\"ctrl\",{\"1\":{\"837\":1}}],[\"csrf\",{\"0\":{\"1137\":1,\"1330\":1},\"1\":{\"1137\":4,\"1330\":4}}],[\"css\",{\"1\":{\"819\":1}}],[\"csdn\",{\"1\":{\"2\":1,\"232\":1,\"251\":2,\"275\":1,\"388\":1,\"394\":3,\"425\":1,\"520\":1,\"675\":1,\"688\":1,\"689\":1,\"728\":1,\"849\":1,\"917\":1,\"919\":2,\"1030\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1219\":1,\"1302\":2,\"1303\":1,\"1305\":1,\"1396\":1}}],[\"c3p0连接池的私有属性\",{\"1\":{\"815\":1}}],[\"c3p0\",{\"1\":{\"815\":1}}],[\"c<\",{\"1\":{\"715\":1}}],[\"c++\",{\"1\":{\"589\":1,\"930\":1}}],[\"c语言编写\",{\"1\":{\"589\":1}}],[\"circular\",{\"1\":{\"562\":1,\"954\":1,\"1216\":1,\"1393\":1}}],[\"ciphers\",{\"1\":{\"106\":2}}],[\"cmpxchg8b\",{\"1\":{\"924\":1}}],[\"cmpxchgl\",{\"1\":{\"924\":1}}],[\"cmpxchg\",{\"1\":{\"924\":2}}],[\"cms整个过程比之前的收集器要复杂\",{\"1\":{\"1150\":1,\"1341\":1}}],[\"cms垃圾清理的过程\",{\"0\":{\"1150\":1,\"1341\":1}}],[\"cms垃圾回收器\",{\"0\":{\"938\":1}}],[\"cms也因此成为java垃圾收集史上的里程碑\",{\"1\":{\"938\":1}}],[\"cms仍无法完全解决碎片空间问题\",{\"1\":{\"938\":1}}],[\"cms模式\",{\"1\":{\"938\":1}}],[\"cms做了一些努力\",{\"1\":{\"938\":1}}],[\"cmscollector\",{\"1\":{\"938\":2}}],[\"cms就是为了减少卡顿吧\",{\"1\":{\"938\":1}}],[\"cms全称concurrent\",{\"1\":{\"938\":1}}],[\"cms\",{\"1\":{\"507\":1,\"936\":2,\"938\":8,\"1151\":1,\"1342\":1}}],[\"cmd\",{\"1\":{\"158\":1,\"159\":3,\"597\":3,\"702\":1,\"850\":1,\"1059\":4,\"1265\":4}}],[\"c进行查询\",{\"1\":{\"498\":1}}],[\"c三种组合的查询\",{\"1\":{\"498\":1}}],[\"cù\",{\"1\":{\"495\":1}}],[\"custom\",{\"1\":{\"950\":1}}],[\"customer\",{\"1\":{\"411\":1}}],[\"curd\",{\"0\":{\"752\":1}}],[\"cursor\",{\"1\":{\"605\":1,\"606\":1,\"607\":1}}],[\"currently\",{\"1\":{\"1216\":1,\"1393\":1}}],[\"currentthread\",{\"1\":{\"876\":2,\"932\":3,\"1104\":1,\"1302\":1}}],[\"currenttimemillis\",{\"1\":{\"388\":2,\"689\":2}}],[\"current\",{\"1\":{\"152\":1,\"419\":1,\"435\":1,\"457\":1,\"575\":1,\"800\":6,\"824\":2,\"1072\":1,\"1276\":1}}],[\"curl\",{\"1\":{\"109\":1,\"180\":2,\"247\":1,\"248\":1,\"249\":2,\"412\":1,\"413\":1,\"436\":3,\"462\":2,\"831\":2,\"852\":1}}],[\"center\",{\"1\":{\"1431\":1,\"1439\":1,\"1444\":1}}],[\"centos7\",{\"0\":{\"668\":1},\"1\":{\"669\":1}}],[\"centos\",{\"1\":{\"402\":1,\"852\":1}}],[\"ce\",{\"1\":{\"852\":3}}],[\"cerebro\",{\"0\":{\"408\":1},\"1\":{\"394\":1,\"408\":7,\"460\":1}}],[\"cert\",{\"1\":{\"106\":2}}],[\"certificate\",{\"1\":{\"106\":2}}],[\"c第一个端口用来集群成员的信息交换\",{\"1\":{\"157\":1}}],[\"cfg\",{\"1\":{\"157\":2,\"158\":1}}],[\"c\",{\"1\":{\"109\":1,\"135\":2,\"145\":5,\"146\":5,\"152\":1,\"157\":1,\"288\":2,\"364\":2,\"498\":1,\"589\":3,\"597\":1,\"603\":2,\"619\":3,\"620\":1,\"635\":1,\"707\":3,\"917\":2,\"924\":1,\"964\":2,\"1068\":1,\"1078\":2,\"1104\":2,\"1212\":2,\"1214\":2,\"1218\":1,\"1272\":1,\"1282\":1,\"1302\":2,\"1389\":2,\"1391\":2,\"1395\":1,\"1439\":1}}],[\"cnblogs\",{\"1\":{\"628\":1,\"633\":1,\"919\":1,\"1068\":1,\"1088\":2,\"1212\":1,\"1272\":1,\"1289\":2,\"1389\":1}}],[\"cn\",{\"1\":{\"106\":2,\"157\":1,\"177\":1,\"180\":1,\"181\":2,\"238\":1,\"252\":1,\"364\":1,\"435\":1,\"587\":1,\"659\":1,\"663\":1,\"664\":1,\"668\":1,\"838\":1,\"839\":1,\"852\":3,\"876\":2,\"896\":2,\"906\":1,\"922\":1,\"924\":1,\"926\":1,\"928\":1,\"930\":1,\"932\":1,\"936\":1,\"938\":1,\"940\":1,\"942\":1,\"944\":1,\"946\":1,\"948\":1,\"950\":1,\"952\":1,\"954\":1,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"964\":1,\"966\":1,\"968\":1,\"970\":1,\"972\":1,\"974\":1,\"976\":1,\"978\":1,\"980\":1,\"982\":1,\"988\":1,\"990\":1,\"992\":1,\"994\":1,\"996\":1,\"998\":1,\"1000\":1,\"1002\":1,\"1004\":1,\"1006\":1,\"1008\":1,\"1010\":1,\"1012\":1,\"1016\":1,\"1018\":1,\"1020\":1,\"1023\":1,\"1072\":1,\"1073\":1,\"1276\":1,\"1277\":1,\"1422\":1,\"1431\":1,\"1439\":1,\"1444\":7}}],[\"crc\",{\"1\":{\"1205\":1,\"1385\":1}}],[\"crc32\",{\"1\":{\"106\":1}}],[\"cross\",{\"1\":{\"1136\":1,\"1137\":1,\"1329\":1,\"1330\":1}}],[\"creat\",{\"1\":{\"962\":1}}],[\"creating\",{\"1\":{\"800\":1}}],[\"createznode的方式来实现\",{\"1\":{\"1244\":1,\"1417\":1}}],[\"createmode\",{\"1\":{\"1008\":1}}],[\"createtopics\",{\"1\":{\"982\":1}}],[\"createtime\",{\"1\":{\"817\":2}}],[\"createclient\",{\"1\":{\"964\":1}}],[\"createcommonqrcode\",{\"1\":{\"876\":2}}],[\"createlogoqrcode\",{\"1\":{\"876\":2}}],[\"created=\",{\"1\":{\"759\":1,\"789\":6,\"790\":2}}],[\"created\",{\"1\":{\"736\":3,\"747\":5,\"755\":3,\"759\":2,\"763\":1,\"782\":2,\"789\":3,\"790\":1,\"792\":1,\"793\":2,\"794\":1,\"1216\":2,\"1393\":2}}],[\"create\",{\"0\":{\"542\":1},\"1\":{\"178\":1,\"251\":1,\"505\":3,\"507\":1,\"542\":1,\"577\":1,\"726\":1,\"736\":2,\"792\":2,\"795\":4,\"817\":2,\"824\":2,\"864\":2,\"865\":2,\"950\":1,\"1008\":1,\"1241\":1,\"1414\":1,\"1444\":1}}],[\"crud标签\",{\"0\":{\"774\":1}}],[\"crud\",{\"1\":{\"751\":1}}],[\"crud新闻数据\",{\"1\":{\"394\":1}}],[\"crf\",{\"1\":{\"145\":2}}],[\"crawler\",{\"1\":{\"106\":1}}],[\"crit\",{\"1\":{\"106\":1}}],[\"clear\",{\"1\":{\"916\":1}}],[\"clearcache\",{\"1\":{\"789\":3}}],[\"cleanup\",{\"1\":{\"940\":2}}],[\"clean生命周期一共包含了三个阶段\",{\"1\":{\"712\":1}}],[\"clean生命周期每套生命周期都由一组阶段\",{\"1\":{\"712\":1}}],[\"clean生命周期\",{\"0\":{\"712\":1}}],[\"clean\",{\"1\":{\"284\":1,\"285\":1,\"286\":1,\"705\":2,\"711\":2,\"712\":11,\"850\":1}}],[\"cli\",{\"1\":{\"597\":1,\"601\":1,\"643\":1,\"909\":2}}],[\"clientchannel\",{\"1\":{\"1020\":4}}],[\"clients\",{\"1\":{\"984\":2,\"990\":2}}],[\"clients<\",{\"1\":{\"648\":1,\"812\":1}}],[\"clientport\",{\"1\":{\"157\":1}}],[\"client\",{\"1\":{\"106\":9,\"116\":1,\"692\":1,\"852\":2,\"964\":1,\"1020\":1,\"1075\":1,\"1279\":1}}],[\"clone\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"cloneable\",{\"1\":{\"946\":1}}],[\"closing\",{\"1\":{\"790\":1}}],[\"close=\",{\"1\":{\"724\":1,\"787\":1}}],[\"close\",{\"1\":{\"648\":2,\"737\":3,\"747\":1,\"751\":1,\"770\":1,\"787\":1,\"790\":1,\"876\":2,\"1020\":1,\"1178\":2,\"1363\":2}}],[\"cloud\",{\"1\":{\"524\":1,\"950\":1}}],[\"clock\",{\"1\":{\"388\":1}}],[\"clazz\",{\"1\":{\"1010\":9}}],[\"claim\",{\"1\":{\"487\":1,\"488\":1}}],[\"claimed\",{\"1\":{\"487\":4,\"488\":4}}],[\"class类名对应的值\",{\"1\":{\"1228\":1,\"1403\":1}}],[\"class变为\",{\"1\":{\"1130\":1,\"1323\":1}}],[\"classify\",{\"1\":{\"936\":1}}],[\"classic\",{\"1\":{\"821\":1}}],[\"classic<\",{\"1\":{\"812\":1}}],[\"classnotfoundexception\",{\"1\":{\"934\":1}}],[\"classname\",{\"1\":{\"689\":2}}],[\"class<t>\",{\"1\":{\"934\":1}}],[\"class<\",{\"1\":{\"934\":1,\"1010\":4}}],[\"classloader遵循父类委派模式\",{\"1\":{\"934\":1}}],[\"classloader的加载顺序遵循什么规则\",{\"1\":{\"934\":1}}],[\"classloader是一个很重要的类\",{\"1\":{\"934\":1}}],[\"classloader\",{\"1\":{\"934\":10,\"1143\":1,\"1334\":1}}],[\"class>\",{\"1\":{\"820\":1}}],[\"class>org\",{\"1\":{\"820\":1}}],[\"classpathxmlapplicationcontext\",{\"1\":{\"950\":1}}],[\"classpath和application\",{\"1\":{\"934\":1}}],[\"classpath\",{\"1\":{\"815\":3,\"828\":2,\"934\":3,\"1444\":1}}],[\"class=\",{\"1\":{\"772\":4,\"815\":3,\"818\":1,\"819\":1,\"821\":1,\"832\":1,\"865\":2,\"952\":2,\"1219\":2,\"1396\":2}}],[\"classes\",{\"1\":{\"713\":2}}],[\"classworlds类加载器框架\",{\"1\":{\"701\":1}}],[\"class\",{\"1\":{\"79\":1,\"80\":1,\"83\":2,\"84\":2,\"194\":1,\"285\":1,\"286\":2,\"288\":2,\"289\":3,\"337\":2,\"352\":2,\"353\":1,\"364\":1,\"377\":1,\"388\":1,\"648\":1,\"689\":1,\"692\":2,\"737\":3,\"747\":2,\"754\":1,\"757\":1,\"763\":2,\"770\":4,\"790\":2,\"792\":1,\"793\":2,\"794\":2,\"795\":2,\"825\":2,\"828\":4,\"829\":4,\"830\":3,\"831\":1,\"849\":1,\"864\":1,\"876\":1,\"924\":1,\"928\":3,\"932\":4,\"934\":7,\"944\":7,\"946\":1,\"952\":1,\"956\":1,\"958\":2,\"966\":5,\"984\":1,\"986\":1,\"988\":2,\"990\":9,\"1004\":1,\"1008\":1,\"1010\":13,\"1016\":3,\"1020\":1,\"1022\":1,\"1023\":2,\"1044\":1,\"1084\":2,\"1085\":2,\"1086\":1,\"1089\":1,\"1091\":1,\"1092\":6,\"1093\":3,\"1104\":5,\"1105\":1,\"1107\":4,\"1130\":1,\"1148\":2,\"1253\":1,\"1285\":2,\"1286\":2,\"1287\":1,\"1290\":1,\"1292\":1,\"1293\":6,\"1294\":3,\"1302\":5,\"1303\":1,\"1305\":4,\"1323\":1,\"1339\":2,\"1431\":2,\"1444\":1}}],[\"cluster来管理和监控分片集群\",{\"1\":{\"968\":1}}],[\"cluster\",{\"0\":{\"416\":1},\"1\":{\"112\":1,\"116\":1,\"406\":2,\"601\":1,\"960\":1,\"1048\":1,\"1205\":2,\"1257\":1,\"1385\":2}}],[\"caffeine\",{\"1\":{\"1045\":2,\"1254\":2}}],[\"card\",{\"1\":{\"940\":3}}],[\"cardinality\",{\"1\":{\"506\":1}}],[\"capacity\",{\"1\":{\"928\":1,\"946\":3,\"948\":2}}],[\"capacity的容量会扩大两倍\",{\"1\":{\"922\":1}}],[\"causes\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"cause\",{\"1\":{\"779\":2,\"800\":1,\"829\":6}}],[\"cas使用时\",{\"1\":{\"1018\":1}}],[\"cas是compare\",{\"1\":{\"1018\":1}}],[\"cas\",{\"0\":{\"1018\":1},\"1\":{\"920\":1,\"922\":1,\"1018\":15}}],[\"case\",{\"1\":{\"727\":3}}],[\"cassandra\",{\"1\":{\"588\":1}}],[\"called\",{\"1\":{\"1016\":3}}],[\"callerrunspolicy\",{\"1\":{\"926\":2}}],[\"call\",{\"1\":{\"406\":1}}],[\"cache为了优化读写性能\",{\"1\":{\"1167\":1,\"1355\":1}}],[\"cache中已经存在的对象的引用\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"cache中缓存项目的有效信息\",{\"1\":{\"106\":1}}],[\"cachemap\",{\"1\":{\"1044\":6,\"1253\":6}}],[\"cachesize\",{\"1\":{\"1044\":5,\"1253\":5}}],[\"cacheenabled\",{\"1\":{\"790\":1}}],[\"cache指令无效的参数中一定的时间范围内可以使用的最小文件数\",{\"1\":{\"106\":1}}],[\"cache\",{\"1\":{\"106\":11,\"337\":1,\"614\":1,\"790\":1,\"1048\":1,\"1050\":4,\"1071\":5,\"1085\":6,\"1167\":1,\"1178\":1,\"1257\":1,\"1259\":4,\"1275\":5,\"1286\":6,\"1355\":1,\"1363\":1}}],[\"cannot\",{\"1\":{\"526\":1}}],[\"can\",{\"1\":{\"106\":1,\"112\":1,\"152\":1,\"388\":2,\"487\":1,\"488\":1,\"526\":2,\"865\":2,\"964\":1}}],[\"catalog\",{\"1\":{\"703\":1,\"704\":1}}],[\"catania\",{\"1\":{\"660\":5}}],[\"category\",{\"1\":{\"394\":1}}],[\"catch\",{\"1\":{\"196\":2,\"197\":1,\"285\":1,\"388\":1,\"648\":3,\"689\":1,\"830\":2,\"831\":3,\"876\":2,\"932\":1,\"952\":2,\"988\":2,\"1092\":1,\"1104\":2,\"1105\":2,\"1107\":4,\"1293\":1,\"1302\":2,\"1303\":2,\"1305\":4,\"1431\":1}}],[\"cat\",{\"1\":{\"90\":1,\"94\":4,\"412\":1,\"413\":1,\"462\":2,\"726\":1}}],[\"chroot\",{\"1\":{\"1245\":3,\"1418\":3}}],[\"chroot特性\",{\"0\":{\"1245\":1,\"1418\":1}}],[\"children\",{\"1\":{\"1008\":2}}],[\"child\",{\"1\":{\"962\":2}}],[\"china\",{\"1\":{\"420\":2,\"505\":1}}],[\"cheapobj<mtsynchronizer>\",{\"1\":{\"1023\":1}}],[\"cherry\",{\"0\":{\"917\":1},\"1\":{\"917\":15,\"919\":1}}],[\"check\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"checks=0\",{\"1\":{\"824\":1}}],[\"checkouttimeout\",{\"1\":{\"815\":1}}],[\"checkout\",{\"1\":{\"94\":2,\"913\":1,\"915\":2,\"917\":1}}],[\"ch\",{\"1\":{\"821\":2}}],[\"choose>\",{\"1\":{\"785\":1}}],[\"choose\",{\"0\":{\"785\":1},\"1\":{\"787\":1,\"1177\":1,\"1362\":1}}],[\"chown\",{\"1\":{\"90\":1,\"94\":1}}],[\"chapter\",{\"1\":{\"1072\":1,\"1276\":1}}],[\"chaining\",{\"1\":{\"624\":1}}],[\"channel可以进行读写操作\",{\"1\":{\"1088\":1,\"1289\":1}}],[\"channelpipeline\",{\"1\":{\"1034\":1}}],[\"channelhandler\",{\"1\":{\"1034\":2}}],[\"channel处理io操作\",{\"1\":{\"1034\":1}}],[\"channelfuturelistener\",{\"1\":{\"1034\":1}}],[\"channelfuture\",{\"1\":{\"1034\":2}}],[\"channels\",{\"1\":{\"1020\":4}}],[\"channel\",{\"1\":{\"1020\":14,\"1034\":1}}],[\"chance\",{\"1\":{\"954\":1}}],[\"chan\",{\"1\":{\"439\":1}}],[\"char\",{\"0\":{\"539\":1},\"1\":{\"619\":1,\"736\":1,\"962\":1,\"988\":2}}],[\"charat\",{\"1\":{\"337\":1}}],[\"characterencoding=utf8\",{\"1\":{\"816\":1,\"1444\":1}}],[\"characterencoding=utf\",{\"1\":{\"743\":1,\"864\":1}}],[\"character\",{\"1\":{\"288\":1,\"433\":1,\"1085\":1,\"1286\":1}}],[\"charset=\",{\"1\":{\"832\":1}}],[\"charset=utf\",{\"1\":{\"831\":2,\"832\":1,\"1092\":1,\"1293\":1}}],[\"charset=utf8mb4\",{\"1\":{\"577\":1}}],[\"charset=utf8\",{\"1\":{\"507\":1,\"736\":1,\"792\":1,\"795\":3,\"824\":2}}],[\"charset=latin1\",{\"1\":{\"726\":1}}],[\"charset\",{\"1\":{\"106\":2,\"1020\":4}}],[\"chatroomserver\",{\"1\":{\"1020\":1}}],[\"chat\",{\"1\":{\"249\":1}}],[\"chatgpt\",{\"2\":{\"234\":1,\"240\":1,\"254\":1}}],[\"chmod\",{\"1\":{\"90\":1}}],[\"cpu不是redis的瓶颈\",{\"1\":{\"1200\":1,\"1380\":1}}],[\"cpu相关日志\",{\"1\":{\"942\":1}}],[\"cpu\",{\"1\":{\"924\":2,\"942\":1,\"950\":2,\"960\":1,\"1018\":1,\"1042\":3,\"1088\":1,\"1143\":1,\"1251\":3,\"1289\":1,\"1334\":1}}],[\"cpu等运行情况\",{\"1\":{\"942\":1}}],[\"cpu等\",{\"1\":{\"515\":1}}],[\"cp27m\",{\"1\":{\"898\":1}}],[\"cp27\",{\"1\":{\"898\":1}}],[\"cp\",{\"1\":{\"90\":1,\"91\":2}}],[\"cdb\",{\"1\":{\"864\":1}}],[\"cdata\",{\"1\":{\"801\":7,\"865\":7}}],[\"cd\",{\"1\":{\"90\":1,\"91\":1,\"125\":1,\"408\":1,\"412\":1,\"413\":1,\"597\":1,\"598\":1,\"672\":1}}],[\"cdots\",{\"1\":{\"35\":1}}],[\"code>\",{\"1\":{\"1101\":3,\"1299\":3}}],[\"code\",{\"1\":{\"829\":1,\"832\":1,\"1101\":1,\"1216\":1,\"1299\":1,\"1393\":1,\"1431\":8,\"1439\":1}}],[\"codec\",{\"1\":{\"145\":1}}],[\"codecs\",{\"1\":{\"144\":1}}],[\"colortype\",{\"1\":{\"944\":5}}],[\"color\",{\"1\":{\"944\":4}}],[\"coloreo\",{\"1\":{\"940\":1}}],[\"colors\",{\"1\":{\"144\":1}}],[\"collectyounggengarbage\",{\"1\":{\"940\":1}}],[\"collectonlyyonggen\",{\"1\":{\"940\":2}}],[\"collectgarbage\",{\"1\":{\"940\":3}}],[\"collection包括\",{\"1\":{\"1112\":1,\"1307\":1}}],[\"collection<map\",{\"1\":{\"1044\":1,\"1253\":1}}],[\"collections\",{\"0\":{\"1113\":1,\"1308\":1},\"1\":{\"982\":1,\"984\":2,\"988\":1,\"990\":1,\"1113\":2,\"1308\":2}}],[\"collections<\",{\"1\":{\"812\":2}}],[\"collection>\",{\"1\":{\"794\":1,\"795\":1}}],[\"collection\",{\"0\":{\"1113\":1,\"1308\":1},\"1\":{\"787\":1,\"794\":1,\"1112\":1,\"1113\":1,\"1307\":1,\"1308\":1}}],[\"collection=\",{\"1\":{\"724\":2,\"727\":3,\"787\":1}}],[\"columnnames\",{\"1\":{\"1176\":2,\"1361\":2}}],[\"columnnumber\",{\"1\":{\"800\":1}}],[\"column=\",{\"1\":{\"793\":2,\"794\":3,\"795\":4}}],[\"column`\",{\"1\":{\"726\":1}}],[\"column1\",{\"1\":{\"579\":1}}],[\"columns\",{\"1\":{\"559\":1}}],[\"column\",{\"1\":{\"506\":1,\"526\":3,\"555\":1,\"558\":1,\"559\":2,\"571\":3,\"573\":7,\"578\":1}}],[\"coerce\",{\"1\":{\"440\":1}}],[\"co\",{\"1\":{\"419\":1,\"431\":1,\"435\":1,\"457\":1,\"1072\":1,\"1073\":1,\"1276\":1,\"1277\":1}}],[\"correct\",{\"1\":{\"936\":1}}],[\"core实现了ioc功能\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"core模块是spring的核心类库\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"core模块开始阅读源码\",{\"1\":{\"974\":1}}],[\"core\",{\"1\":{\"821\":1,\"1211\":1,\"1388\":1}}],[\"core<\",{\"1\":{\"710\":1,\"812\":3}}],[\"core的传递依赖\",{\"1\":{\"710\":1}}],[\"core的间接依赖的版本号\",{\"1\":{\"709\":1}}],[\"cors\",{\"1\":{\"406\":3,\"1136\":2,\"1329\":2}}],[\"cork的选项\",{\"1\":{\"106\":1}}],[\"course\",{\"1\":{\"727\":2,\"1177\":4,\"1362\":4}}],[\"coutarray\",{\"1\":{\"360\":4}}],[\"countdown\",{\"1\":{\"932\":1,\"1104\":1,\"1302\":1}}],[\"countdownlatchdemo\",{\"1\":{\"932\":1}}],[\"countdownlatch\",{\"0\":{\"1104\":1,\"1302\":1},\"1\":{\"932\":14,\"1104\":11,\"1302\":11}}],[\"countdownlatch和cyclicbarrier\",{\"0\":{\"932\":1},\"1\":{\"932\":1}}],[\"counter\",{\"1\":{\"603\":4,\"883\":1,\"1022\":1}}],[\"country\",{\"1\":{\"420\":1,\"505\":5}}],[\"count=262144\",{\"1\":{\"403\":1}}],[\"count配置项可实现\",{\"1\":{\"403\":1}}],[\"counting\",{\"0\":{\"357\":1},\"1\":{\"635\":1}}],[\"count++\",{\"1\":{\"285\":2,\"928\":1,\"1022\":1}}],[\"count\",{\"1\":{\"3\":1,\"143\":2,\"285\":2,\"604\":6,\"605\":2,\"606\":3,\"607\":3,\"928\":2,\"1022\":3,\"1023\":2}}],[\"cookie不是很安全\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"cookie数据存放在客户的浏览器上\",{\"1\":{\"1131\":1,\"1324\":1}}],[\"cookies\",{\"1\":{\"1027\":1}}],[\"cookie\",{\"1\":{\"183\":2,\"1131\":3,\"1324\":3}}],[\"coordination\",{\"1\":{\"152\":4}}],[\"cover\",{\"1\":{\"175\":1}}],[\"copyonwritearraylist\",{\"1\":{\"946\":1,\"1022\":1,\"1119\":2,\"1314\":2}}],[\"copyof\",{\"1\":{\"285\":2,\"352\":4,\"364\":1}}],[\"copy到python安装目录下的lib目录当中\",{\"1\":{\"898\":1}}],[\"copy\",{\"0\":{\"436\":1},\"1\":{\"106\":1,\"129\":2,\"132\":1,\"133\":1,\"136\":1,\"146\":4,\"436\":7,\"440\":1,\"850\":1}}],[\"conn\",{\"1\":{\"970\":6,\"1176\":2,\"1361\":2}}],[\"connected\",{\"1\":{\"1020\":1}}],[\"connection\",{\"1\":{\"737\":7,\"789\":6,\"790\":4,\"964\":1,\"1176\":1,\"1361\":1}}],[\"connections\",{\"1\":{\"106\":1}}],[\"connector\",{\"1\":{\"735\":1,\"812\":1,\"862\":1,\"1444\":1}}],[\"connect\",{\"1\":{\"106\":1,\"964\":1}}],[\"concurrency\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"concurrentlinkedqueue\",{\"1\":{\"1018\":1}}],[\"concurrent\",{\"1\":{\"932\":4,\"940\":3,\"1022\":1,\"1104\":2,\"1105\":3,\"1107\":1,\"1150\":2,\"1302\":2,\"1303\":3,\"1305\":1,\"1341\":2}}],[\"concurrenthashmap\",{\"1\":{\"922\":4,\"948\":1,\"988\":2,\"1022\":1,\"1112\":1,\"1115\":1,\"1307\":1,\"1310\":1}}],[\"concurs\",{\"1\":{\"106\":1}}],[\"conditionexpression>\",{\"1\":{\"865\":6}}],[\"condition\",{\"1\":{\"555\":2,\"1101\":1,\"1299\":1}}],[\"conditions\",{\"1\":{\"152\":1}}],[\"context模块提供框架式的bean的访问方式\",{\"1\":{\"1211\":1,\"1388\":1}}],[\"contextconfiguration\",{\"1\":{\"828\":2}}],[\"context\",{\"1\":{\"815\":4,\"818\":4,\"819\":4,\"828\":2,\"950\":1,\"1211\":1,\"1388\":1}}],[\"context=\",{\"1\":{\"815\":1,\"818\":1,\"819\":1}}],[\"context<\",{\"1\":{\"715\":1,\"812\":1}}],[\"contentions\",{\"1\":{\"1023\":2}}],[\"contention\",{\"1\":{\"1023\":1}}],[\"content=\",{\"1\":{\"832\":1}}],[\"contenttype=\",{\"1\":{\"832\":1}}],[\"contenttype\",{\"1\":{\"819\":1}}],[\"contents\",{\"1\":{\"630\":1}}],[\"content\",{\"1\":{\"136\":1,\"249\":1,\"420\":1,\"436\":3,\"507\":3,\"998\":3,\"1431\":1}}],[\"containing\",{\"1\":{\"887\":1}}],[\"containskey\",{\"1\":{\"353\":1}}],[\"contains\",{\"1\":{\"337\":6,\"1004\":1}}],[\"contact\",{\"1\":{\"688\":1,\"689\":1,\"849\":1,\"1104\":2,\"1105\":1,\"1107\":1,\"1302\":2,\"1303\":1,\"1305\":1}}],[\"control的缩写\",{\"1\":{\"1212\":1,\"1389\":1}}],[\"control\",{\"1\":{\"950\":1,\"1213\":1,\"1390\":1}}],[\"control等高级监控与故障排除工具的使用\",{\"1\":{\"942\":1}}],[\"controller会将leader的改变直接通过rpc的方式\",{\"1\":{\"1165\":1,\"1353\":1}}],[\"controller层的bean\",{\"1\":{\"944\":1}}],[\"controller\",{\"1\":{\"686\":1,\"819\":1,\"831\":2,\"849\":1,\"876\":3,\"944\":2,\"950\":1,\"1092\":1,\"1165\":2,\"1166\":5,\"1293\":1,\"1353\":2,\"1354\":5}}],[\"contract\",{\"1\":{\"487\":1,\"488\":1}}],[\"continue\",{\"1\":{\"286\":2,\"352\":1,\"353\":1}}],[\"consequence\",{\"1\":{\"1101\":1,\"1299\":1}}],[\"consistency\",{\"1\":{\"1078\":2,\"1187\":1,\"1240\":1,\"1282\":1,\"1370\":1,\"1413\":1}}],[\"consistent\",{\"1\":{\"112\":1}}],[\"consume\",{\"1\":{\"988\":1,\"992\":3}}],[\"consumer最多只能消费到hw所在的位置上一条信息\",{\"1\":{\"1157\":1,\"1345\":1}}],[\"consumer<string\",{\"1\":{\"990\":1}}],[\"consumerconfig\",{\"1\":{\"990\":4}}],[\"consumerprops\",{\"1\":{\"990\":6}}],[\"consumer从集群中读取消息\",{\"1\":{\"986\":1}}],[\"consumerrecord<string\",{\"1\":{\"984\":1,\"990\":1}}],[\"consumerrecords<string\",{\"1\":{\"984\":1,\"990\":1}}],[\"consumerrecords\",{\"1\":{\"984\":1}}],[\"consumer\",{\"1\":{\"980\":1,\"984\":6,\"986\":1,\"990\":6,\"992\":6,\"1159\":5,\"1347\":5}}],[\"consumers\",{\"1\":{\"159\":1}}],[\"consoleappender\",{\"1\":{\"821\":1}}],[\"construct\",{\"1\":{\"952\":1}}],[\"constructor<employee>\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"constructor类里也有一个newinstance方法可以创建对象\",{\"1\":{\"1093\":1,\"1294\":1}}],[\"constructor\",{\"1\":{\"487\":1,\"488\":1,\"944\":1,\"1093\":2,\"1107\":1,\"1294\":2,\"1305\":1}}],[\"const\",{\"1\":{\"624\":5}}],[\"conf\",{\"1\":{\"125\":1,\"158\":1,\"403\":1,\"597\":1,\"648\":6,\"673\":1,\"674\":2,\"701\":1,\"702\":1}}],[\"configs\",{\"1\":{\"887\":3}}],[\"configlocation\",{\"1\":{\"815\":1}}],[\"configured\",{\"1\":{\"1085\":1,\"1286\":1}}],[\"configureblocking\",{\"1\":{\"1020\":2}}],[\"configure\",{\"1\":{\"125\":1,\"950\":1}}],[\"configuration>\",{\"1\":{\"743\":1,\"745\":1,\"812\":1,\"817\":1,\"821\":1,\"844\":2}}],[\"configuration\",{\"1\":{\"106\":1,\"109\":1,\"152\":1,\"743\":1,\"745\":1,\"762\":2,\"817\":1,\"844\":1,\"887\":2,\"944\":2,\"1092\":1,\"1293\":1,\"1444\":1}}],[\"config\",{\"0\":{\"743\":1,\"745\":1,\"765\":1,\"817\":1},\"1\":{\"109\":1,\"158\":1,\"406\":1,\"743\":2,\"745\":2,\"746\":1,\"747\":1,\"751\":1,\"755\":1,\"757\":2,\"759\":1,\"763\":2,\"765\":1,\"766\":2,\"770\":1,\"772\":1,\"782\":1,\"790\":1,\"815\":2,\"817\":3,\"852\":1,\"887\":2,\"990\":7,\"1127\":1,\"1179\":3,\"1226\":1,\"1320\":1,\"1364\":3,\"1401\":1,\"1444\":1}}],[\"confpasswd\",{\"1\":{\"106\":1}}],[\"conf详解\",{\"0\":{\"106\":1}}],[\"combopooleddatasource\",{\"1\":{\"815\":1}}],[\"command+c\",{\"1\":{\"916\":1}}],[\"common\",{\"1\":{\"852\":1,\"984\":3,\"990\":2}}],[\"commonsql\",{\"1\":{\"782\":10}}],[\"commons\",{\"1\":{\"388\":3}}],[\"comment=\",{\"1\":{\"577\":1,\"824\":2}}],[\"comment\",{\"1\":{\"506\":1,\"577\":1,\"602\":1,\"726\":3,\"795\":1,\"824\":6,\"1444\":4}}],[\"committed\",{\"1\":{\"1220\":1,\"1397\":1}}],[\"committ\",{\"1\":{\"1187\":1,\"1370\":1}}],[\"commit\",{\"1\":{\"94\":1,\"555\":1,\"556\":2,\"558\":2,\"559\":1,\"571\":1,\"573\":2,\"751\":1,\"757\":3,\"770\":1,\"913\":1,\"915\":1,\"917\":1,\"918\":10,\"1178\":1,\"1363\":1}}],[\"compose不再需要使用shell脚本来启动容器\",{\"1\":{\"1060\":1,\"1266\":1}}],[\"compose\",{\"1\":{\"1060\":6,\"1266\":6}}],[\"compose时如何保证容器a先于容器b运行\",{\"0\":{\"1060\":1,\"1266\":1}}],[\"componentscan\",{\"1\":{\"944\":1,\"1227\":1,\"1402\":1}}],[\"component\",{\"1\":{\"689\":2,\"818\":1,\"819\":1,\"944\":1,\"1092\":1,\"1293\":1}}],[\"compareandset\",{\"1\":{\"1018\":1}}],[\"compareandsetstate\",{\"1\":{\"932\":1}}],[\"compareto\",{\"1\":{\"1008\":1}}],[\"compare\",{\"1\":{\"924\":3}}],[\"compiler\",{\"1\":{\"812\":1,\"844\":2}}],[\"compile\",{\"1\":{\"705\":1,\"706\":1,\"713\":2}}],[\"complete>\",{\"1\":{\"865\":1}}],[\"complete\",{\"1\":{\"865\":1,\"934\":1}}],[\"complete=\",{\"1\":{\"820\":1}}],[\"completion\",{\"1\":{\"252\":1}}],[\"complex\",{\"1\":{\"139\":4}}],[\"comp\",{\"1\":{\"106\":1}}],[\"com\",{\"1\":{\"4\":5,\"71\":1,\"79\":1,\"80\":1,\"83\":1,\"84\":1,\"106\":1,\"109\":1,\"110\":1,\"112\":2,\"116\":1,\"136\":1,\"147\":1,\"159\":2,\"172\":1,\"209\":1,\"211\":1,\"212\":1,\"232\":1,\"241\":2,\"246\":1,\"247\":1,\"251\":4,\"252\":2,\"288\":1,\"289\":1,\"336\":1,\"337\":3,\"377\":1,\"388\":1,\"405\":2,\"408\":1,\"412\":1,\"413\":1,\"414\":1,\"526\":1,\"527\":3,\"548\":1,\"597\":1,\"605\":1,\"606\":1,\"628\":1,\"633\":1,\"643\":1,\"671\":1,\"681\":1,\"686\":1,\"688\":3,\"689\":5,\"690\":1,\"705\":1,\"706\":1,\"714\":1,\"716\":1,\"737\":1,\"743\":2,\"744\":1,\"745\":1,\"747\":1,\"753\":1,\"754\":2,\"755\":5,\"757\":3,\"759\":1,\"762\":4,\"763\":9,\"768\":3,\"772\":1,\"779\":7,\"780\":2,\"782\":1,\"784\":1,\"785\":1,\"786\":2,\"787\":1,\"789\":18,\"790\":7,\"793\":4,\"794\":3,\"795\":4,\"812\":3,\"815\":1,\"832\":2,\"837\":1,\"838\":1,\"844\":1,\"849\":3,\"852\":2,\"856\":1,\"860\":1,\"864\":2,\"865\":2,\"867\":1,\"871\":1,\"873\":1,\"878\":2,\"884\":1,\"885\":2,\"888\":1,\"889\":2,\"899\":1,\"903\":1,\"904\":1,\"913\":2,\"917\":1,\"919\":2,\"922\":2,\"924\":2,\"926\":2,\"928\":2,\"930\":2,\"932\":2,\"934\":2,\"936\":2,\"938\":2,\"940\":2,\"942\":2,\"944\":2,\"946\":2,\"948\":2,\"950\":2,\"952\":2,\"954\":2,\"956\":2,\"958\":2,\"960\":2,\"962\":2,\"964\":2,\"966\":2,\"968\":2,\"970\":2,\"972\":2,\"974\":2,\"976\":2,\"978\":2,\"980\":2,\"982\":2,\"988\":2,\"990\":2,\"992\":2,\"994\":2,\"996\":2,\"998\":2,\"1000\":2,\"1002\":2,\"1004\":2,\"1006\":2,\"1008\":2,\"1010\":2,\"1012\":2,\"1016\":2,\"1018\":2,\"1020\":2,\"1023\":2,\"1030\":2,\"1062\":1,\"1068\":2,\"1070\":1,\"1084\":1,\"1088\":2,\"1092\":1,\"1099\":1,\"1101\":1,\"1104\":4,\"1105\":3,\"1107\":2,\"1184\":1,\"1212\":1,\"1268\":1,\"1272\":2,\"1274\":1,\"1285\":1,\"1289\":2,\"1293\":1,\"1297\":1,\"1299\":1,\"1302\":4,\"1303\":3,\"1305\":2,\"1367\":1,\"1389\":1,\"1439\":1,\"1444\":3}}],[\"西瓜视频\",{\"1\":{\"2\":1,\"218\":1}}],[\"哔哩哔哩\",{\"1\":{\"2\":1,\"218\":1}}],[\"腾讯云开发者社区\",{\"1\":{\"2\":1}}],[\"掘金\",{\"1\":{\"2\":1,\"492\":1}}],[\"微服务中如何实现\",{\"0\":{\"1233\":1,\"1408\":1}}],[\"微服务\",{\"1\":{\"950\":1}}],[\"微信朋友圈点赞\",{\"1\":{\"656\":1}}],[\"微信抽奖小程序\",{\"1\":{\"656\":1}}],[\"微信搜\",{\"1\":{\"368\":1,\"425\":1,\"524\":1,\"732\":1}}],[\"微信搜索\",{\"1\":{\"150\":1,\"328\":1,\"347\":1,\"356\":1,\"364\":1,\"377\":1,\"587\":1,\"613\":1,\"648\":1,\"698\":1}}],[\"微信联系站长\",{\"1\":{\"214\":1}}],[\"微信扫描下方二维码加入\",{\"1\":{\"212\":1}}],[\"微信公众号文章索引中查找对应文章\",{\"1\":{\"829\":1}}],[\"微信公众号\",{\"1\":{\"2\":1,\"328\":1,\"698\":1,\"732\":1}}],[\"微博好友关注社交关系\",{\"1\":{\"656\":1}}],[\"微博\",{\"1\":{\"2\":2}}],[\"||\",{\"1\":{\"285\":2,\"286\":3,\"289\":1,\"388\":2,\"831\":1,\"922\":1,\"948\":1,\"952\":1}}],[\"|\",{\"1\":{\"1\":1,\"2\":13,\"49\":1,\"94\":7,\"106\":6,\"114\":1,\"175\":2,\"244\":2,\"247\":1,\"388\":3,\"492\":1,\"527\":2,\"551\":1,\"830\":1,\"852\":2,\"932\":1,\"936\":28,\"1177\":8,\"1362\":8}}],[\"年龄\",{\"1\":{\"1444\":1}}],[\"年t\",{\"1\":{\"388\":1}}],[\"年内蒙古边陲城市\",{\"1\":{\"217\":1,\"223\":1}}],[\"年\",{\"1\":{\"1\":1,\"44\":1,\"217\":1,\"223\":1,\"225\":2,\"387\":1,\"658\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
